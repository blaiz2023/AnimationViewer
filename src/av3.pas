unit av3;
//## ==========================================================================================================================================================================================================================
//##
//## MIT License
//##
//## Copyright 2025 Blaiz Enterprises ( http://www.blaizenterprises.com )
//##
//## Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation
//## files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy,
//## modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
//## is furnished to do so, subject to the following conditions:
//##
//## The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//##
//## THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
//## OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
//## LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
//## CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//##
//## ==========================================================================================================================================================================================================================
//##
//## Please note: This is legacy code and is designed to compile in Borland Delphi 3
//##
//##############################################################################
//## Name......... Internet
//## Desciption... IP communication controls for low-level communication
//## Items........ 62
//## Version...... 3.00.9880 {+906 self - net_encode_str/net_encode_for_html/net_encode_str_full}
//## Date......... 09-MAR-2008
//## Lines........ 40,288
//## Translation.. Confirmed - showerror60/showinfo60/showinfo()/showbasic() as pre-translation usage (translate string before sending to procedure)
//##
//## ======================================================================================
//## | Name                    | Hierarchy       | Version   | Date        | Desciption
//## |-------------------------|-----------------|-----------|-------------|----------------
//## | tmapperip               | trootobject     | 1.00.027  | 15-DEC-2006 | IPv4 to IPv4 mapper
//## | tfonts                  | trootobject     | 1.00.050  | 11-JUN-2006 | Sorted screen/printer fonts list
//## | ttask                   | tthread         | 1.00.070  | 01-FEB-2006 | Safe thread
//## | ttimertask              | ttask           | 1.00.038  | 23-AUG-2006 | TTimer - priority (next)/normal (interval) control
//## | tmt                     | trootobject     | 1.00.273  | 27-NOV-2007 | Synchronised multi-interval-event timer, light weight, low overhead
//## | tlc                     | trootobject     | 1.00.154  | 29-OCT-2007 | License system v3
//## | tass                    | trootobject     | 1.00.015  | 25-SEP-2007 | Audio support system
//## | tmm                     | trootobject     | 1.00.100  | 23-FEB-2008 | Managed multimedia playing
//## | trates                  | tobject         | 1.00.023  | 23-AUG-2006 | Rates generation (x/sec, x/min and x/hr)
//## | ttask                   | tthread         | 1.00.097  | 18-JAN-2005 | Parallel thread with easy to use run/stop/running controls
//## | tlookupthread           | ttask           | 1.00.022  | 03-JUL-2005 | Single channel domain lookup
//## | tlookuphistory          | tobject         | 1.00.030  | 23-AUG-2006 | Fast domain-ip history cache
//## | tlookupmanagement       | trootobject     | 1.00.143  | 10-FEB-2007 | Automated, multi-tasking domain lookup system (with create-threads-on-demand for ultra low resource usage)
//## | tdomains                | trootobject     | 1.00.050  | 06-MAR-2008 | Managed domain name lookup system
//## | tmimes                  | trootobject     | 1.00.035  | 21-OCT-2007 | Mimes list
//## | twebheaders             | trootobject     | 1.00.078  | 10-JUN-2006 | Web Header name-value pair management
//## | tnetsession             | trootobject     | 1.00.115  | 31-DEC-2006 | WSA management system (handles WSAStartup/CleanUp etc)
//## | tnetwork                | trootobject     | 1.00.414  | 16-JAN-2008 | Network layer - 100mbps upload/download, auto. slow down after 10 seconds
//## | tclientbasic            | trootobject     | 1.00.114  | 18-FEB-2008 | Basic downloading client (content range enforcement)
//## | tclientredirect         | tclientbasic    | 1.00.132  | 21-FEB-2007 | Redirecting client
//## | tclients                | tobject         | 1.00.062  | 19-FEB-2008 | Sync.ed list of clients
//## | tclientdownload         | tclientredirect | 1.00.120  | 30-MAY-2006 | Downloading and redirecting client
//## | tclientremote           | trootobject     | 1.00.242  | 10-JAN-2008 | Server client clone (content range enforcement), supports "proxy" tracking (under flow control)
//## | tclientproxy            | tclientremote   | 1.00.110  | 06-DEC-2006 | Server proxy-client control
//## | tserverbasic            | trootobject     | 1.00.215  | 19-FEB-2008 | Basic server
//## | tserverredirection      | tserverbasic    | 1.00.028  | 27-OCT-2007 | Proxy server
//## | tserverudp              | trootobject     | 1.00.118  | 24-APR-2007 | Basic UDP server
//## | tnetworkusers           | trootobject     | 1.00.176  | 07-FEB-2008 | Keeps track of users and their login status - primarily for TBlaizChat
//## | tudppackets             | trootobject     | 1.00.122  | 18-JAN-2008 | Single UDP packet communication system
//## | tudpbasic               | trootobject     | 1.00.377  | 08-MAR-2008 | Reliable/unreliabe single UDP packet communication system of 5-250 messages per second sustained with 5 byte header and 507 byte payload capacity
//## | tudpex                  | trootobject     | 1.00.222  | 27-MAR-2007 | Dual-packet UDP server (upto 1014 bytes)
//## | tmanagedudpex           | trootobject     | 1.00.080  | 05-FEB-2007 | Dual-packet UDP server (upto 1014 bytes) with queue
//## | tsecurityip             | trootobject     | 1.00.083  | 29-SEP-2007 | Multiple IP hit/error/bandwidth monitoring
//## | tsecurityfilter         | tobject         | 1.00.120  | 07-JAN-2007 | IP/IP-range/User-Agent allow/disallow filter
//## | tvirtualsecurityfilter  | tvirtualtext    | 1.00.005  | 03-MAR-2008 | Security filter text box
//## | tvirtualfiltersnippet   | tvirtualtext    | 1.00.010  | 03-MAR-2008 | Snippet filter text box
//## | tmanagedserver          | tvirtualpage    | 1.00.144  | 18-FEB-2008 | Basic server with complete settings/security management
//## | tipfilter               | tobject         | 1.00.065  | 11-OCT-2005 | IP range filter (ip1 and ip1-ip2 formats)
//## | tmanagedconnections     | trootobject     | 1.00.241  | 07-OCT-2007 | Manages multiple internet connections
//## | tcacheredirect          | trootobject     | 1.00.022  | 02-MAR-2007 | Temp cache of urls and their redirects
//## | tnavcacheimages         | trootobject     | 1.00.055  | 19-DEC-2006 | Global image cache for "tnavbase" controls
//## | tnavcacheurls           | trootobject     | 1.00.045  | 19-DEC-2006 | Global url cache for "tnavbase" controls
//## | turldlg                 | trootobject     | 1.00.120  | 16-DEC-2006 | Open dialog box for urls
//## | tcacherobot             | tcachebasic     | 1.00.037  | 22-MAY-2006 | Robots.txt cache
//## | tmanagedrobot           | tobject         | 1.00.073  | 10-MAR-2007 | Robots.txt management (cache and remote fetching)
//## | trawlog                 | trootobject     | 1.00.153  | 28-OCT-2007 | Standardised access log tracking system
//## | tids                    | tobject         | 1.00.030  | 23-AUG-2006 | Timed ids
//## | tbitmapenhanced         | tbitmap         | 1.00.002  | 20-JUN-2006 | Bitmap with extract information for enhanced io support
//## | tfilters                | trootobject     | 1.00.402  | 10-JUN-2007 | Basic filtering of images
//## | taudioswap              | tobject         | 1.00.030  | 15-JUN-2007 | Dual channel gradual switch over
//## | taudio                  | tobject         | 1.00.300  | 15-JUN-2007 | Basic filtering of images
//## | taudiobasic             | trootobject     | 1.00.100  | 14-FEB-2008 | Realtime audio playback and recording, fully managed system
//## | tccs                    | trootobject     | 1.00.1270 | 07-MAR-2008 | Graphics support
//## | tcoloricon              | tgraphic        | 1.00.190  | 09-APR-2005 | Clipboard to Icon Conversion Component
//## | ttextpicture            | tgraphic        | 1.00.135  | 15-OCT-2004 | TEP IO Graphic Object - 8 color/3bit image
//## | txbitmap                | tgraphic        | 1.00.082  | 15-OCT-2004 | XBM IO Graphic Object - Monochrome support only
//## | tportablepixelmap       | tgraphic        | 1.00.192  | 15-OCT-2004 | PPM/PGBM/PBM IO Graphic Object (Note: implements MaxColor only for Loading, defaults to 255 for Saving
//## | toptimisedimage         | tgraphic        | 1.00.075  | 16-NOV-2005 | OMI - Optimised Multiformat Image
//## | ttbt                    | tobject         | 1.00.080  | 21-SEP-2007 | TBT encryption for strings (with TBT3/TBT4 header/variable length key support)
//## | tprogramvars            | tobject         | 1.00.232  | 02-MAR-2007 | High speed, typed variable list
//## | tprogramstack           | tobject         | 1.00.080  | 01-MAR-2007 | High speed, typed variable stack list
//## | tprogram                | tobject         | 1.00.585  | 13-MAR-2007 | Low speed script/binary program language
//## | tprograms               | tobject         | 1.00.082  | 13-MAR-2007 | Multitasking, multi-threaded, "tprogram" threads (upto 2,000 at once =~32Mb of RAM)
//## ====================================================================================
//##
//## Verification: 3.00.8587, 25-SEP-2007
//## Language Enabled
//## Copyright (c) 1997-2007 Blaiz Enterprises
//##############################################################################

interface
{$align on}{$iochecks on}{$O+}{$W-}{$U+}{$V+}{$B-}{$X+}{$T-}{$P+}{$H+}{$J-} { set critical compiler conditionals for proper compilation - 10aug2025 }

Uses
  Windows, Forms, Controls, SysUtils, Classes, Graphics, Messages, ShellApi,
  Registry, clipbrd, printers, jpeg,
  av2;

{winsock session}
type
  u_char = Char;
  u_short = Word;
  u_int = Integer;
  u_long = Longint;
  TSocket = u_int;

{TEP Images}
const
  //dialog images - 32pixels high, variable width
  tepError32       ='anm:t1,c2,d750#T5u00W000yF0)300)3m)028W0000yhm5zBPdiB29(pyqz38W(Zyp(lNV))))(Z8Y()m3(dJE(JAf(NI9(7I8(J4H(luY()pF(NTr(Z4I(FpC(NMP()rN(BX4(p03(314~'+'0000000000000000000000000000111111111111111111111111111100000000000000000000002230001111111111111111111111111111000002222000000000000221130011111111111111111111111111110000222220000000000022211130111111111111111111111111111100002211140000000002211114'+'4311111111111111111111111111110000211114300000002211114433111111111111111111111111111100002111114300000221111443301111111111111111111111111111000002111143000022151144330011111111111111111111111111110000021111433002216714443000111111111111111111111111'+'1111000002111114432218914443300011111111111111111111111111110000002111111221AB11443300001111111111111111111111111111000000211111111CD114433000001111111111111111111111111111000000211111EFCGH11433000000111111111111111111111111111100000002211IJCKJ114430'+
                    '000000111111111111111111111111111100000002211LMCN1144330000000111111111111111111111111111100000000211OPQR1443300000000111111111111111111111111111100000000211SHT114430000000001111111111111111111111111111000000022111111144430000000011111111111111111111'+'1111111100000022111111111143000000001111111111111111111111111111000002211111111111143000000011111111111111111111111111110000221111111111111143000000111111111111111111111111111100022111114441111111143000001111111111111111111111111111002211111144411111'+'1111430000111111111111111111111111111102211111144332111111144430001111111111111111111111111111021111114433002111114443300011111111111111111111111111112211111443300002111444330000111111111111111111111111111121111144430000021114433000001111111111111111'+'111111111111211111433000000021443300000011111111111111111111111111110211144300000000024330000000111111111111111111111111111100214430000000'+
                    '0000330000000011111111111111111111111111110002330000000000000000000000111111111111111111111111111100000000000000'+
                    '000000000000001111111111111111111111111111#';
  tepQuery32       ='anm:t1,c2,d750#T5o00W000yF0)300)3m)028W0000)7LK)Rin)hdU)7Sm)RcP)ln6t300i300t3zvzB8ckZZE)xfh))))yJgf(NuX(tOZ~'+'0000000000000000000000000111111111111111111111111100000000222222222333000001111111111111111111111111000002222111111114443300011111111111111111111111110002222111111111111443300111111111111111111111111100222111111111111111443001111111111111111111111111'+'0222111112222111111114330111111111111111111111111102211111443022111111144331111111111111111111111111222115144330022111111143311111111111111111111111112211671443300022111111443111111111111111111111111122118911443300221111114431111111111111111111111111'+'22111A114433002211111144311111111111111111111111112211111144330221111114433111111111111111111111111102211BC44330021111111433011111111111111111111111110022114433002111111144300111111111111111111111111100044443300211111114433001111111111111111111111111'+
                    '0000443300211111144433000111111111111111111111111100000000021111114443300001111111111111111111111111000000002111111444330000011111111111111111111111110000000221111144433000000111111111111111111111111100000002211114443300000001111111111111111111111111'+'000000002211444330000000011111111111111111111111110000000002144433000000000111111111111111111111111100000000244443300000000001111111111111111111111111000000021144433000000000011111111111111111111111110000002DEF1444300000000001111111111111111111111111'+'0000021GHI114433000000000111111111111111111111111100000211JK1144330000000001111111111111111111111111000002111111443300000000011111111111111111111111110000002111144433000000000111111111111111111111111100000002114443300000000001111111111111111111111111'+'0000000044433300000000000111111111111111111111111100000000003330000000000001111111111111111111111111#';
  tepInfo32        ='anm:t1,c2,d750#T6U00W000yF0)3m)0000028W)300)V2M)JrR)lG3)hXH)BQk)d8a)F8m)piq)F3D)pbk)hjv)FpD)p03)))))3I8)tgs)toC)7tg)Fn6)Jm1))Bt)J1A)ReY))oB)d8k)JsP)RaH))m3~'+'00000111122330044444444444444400011444442233044444444444444400115674444223344444444444444401189A444444223444444444444444011BCD44444422344444444444444411EFGH44444422344444444444444411IIJ444444422344444444444444411KL4444444422344444444444444411MN444444'+'44223444444444444444114O4444444223344444444444444411444444444223044444444444444411444444444223044444444444444411444444442233044444444444444411444444442230044444444444444411444444442230044444444444444401444444422330044444444444444401144444422300044444'+'4444444444001444442233000444444444444444001444442230000444444444444444001144422330000444444444444444000144422300000444444444444444000011223300000444444444444444000011333000000444444444444444011114423300000444444444444444114PQ4422330000444444444444444'+
                    '14IRS44422300004444444444444441TUVW4442230000444444444444444144444442230000444444444444444144444442230000444444444444444114444422330000444444444444444011122223300000444444444444444000132233000000444444444444444#';
  tepSecure32      ='T6W00W00)3001Ie1l3lt))lP)pyClJF8ZfbM)d900yvdpV)dtlVktl)joVVUulVfzx)Utl)kpVFkpV)jwp)bpV)itllkpVlbnR)OtTtTLLLL8W02PQ60vlFepVlfvlVdpVFimNlH4H4H03Cmtl)gtlliY8Y8~'+'000000000000000000000000000000000011111111111111111111111111110001222223232333334343555555555560124477777777777777777777777755861247333333333333333333333333758612739A9BCD5555555555555555551786137EFGFHAC5555555555555555551786127IJKLBLM555NOOOP55555555'+'522Q86137RFST5555NN22222PP555555523Q86127RUBV555N22WWWWWXXP755555QQQ86137RA9Y55N2WWWW2WWWWXP7555551786137I9ZV5N2WWWWWWWWWWWXP555551786137EYV55N2W2WWWWWWW2WXP7555517861373555N2WWWWW222WWWWWXP555517861473555N2WWWW2XXX2PWWWXPQ55517861373555N2W2WW2XXX2Pa'+'2WXPQ55517861473555O2WWWW2XXX2PaWWXPQ55517861373555O2WWWWW222PaWWWXPQ555178615735555O2WWWWPPPaWWWXPQ7555178615735555O2WW2WWaaW2WWXP775551786157355555P2WWWW2WWWWXPQ755522Q861573555555P22WWWWWXXPQ7555523Q8615222222Q55PP2XXXXPPQ755555QQQ8615233333Q5555P'+
                    'PPPPQQ75555555178615QQQQQQQ55555QQQQ77555555551786155155555555555555555555555517861555QQQQQ1Q1Q1Q111111111111175861555577777777777777777777777558601555555555555555555555555555560001111111111111111111111111116000011110000000000000000000011160000011000'+'000000000000000000066000#';
  tepFind32        ='T2U00W000yF0WAu8V7CQ))))~'+'0000000000000000000000KL1000000GfgM000000bwgg50000GggkgQ0000GgwxgQ0000aglhgg1000awkghg1000fglggg6000fwxwgg6000fgkhgg6000fggggg6000fggggg6000aggggg1000aggggg1000GggggQ1000GggggQ50000bgggrL0000KbgMLN10000GL1KT50000000GrL00000000LN10000000KT50000000GrL0'+'0000000LN10000000KT50000000GrL00000000LL00000000K500000000G10000000000#';

  //main tab images
  tepControl       ='T6S00W000yF02nvO6Rin4())r()x4U)x6))vt)lt))lrU)ltZfbMK())S()zE72d)pen))))))(z)Ngp)V)))Rzx)Nhr)xzx)tgr)pfptRzxE73d6d3d4I80l)UAtV)Ql)EX))Vll)UCtV)OtVFZZ1GCUJuvUJvvdNxxltxxlxyzdtwv~'+'00000000000000000000000000000111111111111111200000000000133333333434333312000000000013333333356678961A00000000001333333333BC46651A000000000013333333333353351A00000000000111111111111111AA000000000000AAAAAAAAAAAAAAA0000000000000000000000000000000000000'+'000DDDDDDDDDDDDDDDDDDDD2000000DEEFEEFFEFFEFFEEFEEFED200000DEEGHEIGEIJKLLMNJMMLEDA00000DFFEFFENINEJNNLGEFFEFDA00000DFFEFFEEFEEFEEOGEGOEFDA000000DDDDDPDDDDDDDDPDDQPDAA0000000AAAAAAAAAAAAAAAAAAAA00000000000000000000000000000000000RRRRRRRRRRRRRRRRR200000'+'0000RSSSSSSSSTUVSTSSSSR200000000RSSSSSSSSWXXUUXYUTRA00000000RSSSSSSSSSWWWXUTTSRA00000000RSSSSSSSSSSSSSSSSSRA000000000RRRRRRRRRRRRRRRRRAA0000000000AAAAAAAAAAAAAAAAA00000000000000000000000000000000000000ZZZZZZZZZZZZZZZZZZZZZZZZZ20Zaaaaaaaaaaaaaaaaaabcd'+
                    'cbcaZ2ZaaaaaaaaaaaaaaaaabbecdefaZAZaaaaaaaaaaaaaaaaabffccfbaZAZaaaaaaaaaaaaaaaaaabbccbcaZA0ZZZZZZZZZZZZZZZZZZZZZZZZZAA00AAAAAAAAAAAAAAAAAAAAAAAAA0#';
  tepHistory       ='T6W00W000yF00m9dZfbM0CtSz2mO4I804())xLxz)JenE7pvlVV8tp90x)dns7ujlVVAlVUAS()zv()wpJwkrpPoMpVuMlltjwyvuxiorVRo)pentdVPpFEJXB(RfdlrzwjtzRkpwllgn7laqlzotpenExjtldUR)llop3foO7lmnRzjpFVVlZBmlJepddQirU)xKQyxUJPfSU)zUpOfpVdo4U))dpOfqZvjdl7ddFNfvSUAEZnS~'+'0000000000000000000000000000000000001120033442004455200554420044000161113748444495A5555B4C444494001616637484DD495A5EA5B4C48D494401616637484DD495A5AF5B4C48D49494111GG63444D8D4555EAA54448DC449941H111134I444445E555554J4444499941KLLLM34NOOP945QRSAB54NOOP'+'9499941LTTTU34VVND945WXXQB54YVOZ9499941TTTTa34VYYI945WWWbB54VcOd9499941TTVea34cVYO945XXXbB54cYNd9499941TTTTa34VVYI945XfgRB54cYhi9499941TTeTU34ffYJ945SXSFB54cYhi9499941LLLaM34jfNh945SXSRB54TNOi9499941HkLkl34mfhO945SXbFB54NNIi9499941GGnn734ofhh945SWbRB'+'54YhIp9499941666q734jhfO945SWbFB54fIdi94999416666734mjhh945XXSFB54NIdp94999416666734rjhJ945eXgFB54Nhsp94999416666734jjII945SegFB54IIJD94999416666734rsII945eXbAB54jhZD94999416666734tmhJ945ggQAB54rJIC94999416666734t'+
                    'sZJ945SgQAB54uZP894999416666734uPsD945WgQAB54DZPD94999416666734PD8D945WXQAB54ZPD894999416666734DP88945XWbAB54DCPD949994166667348D8D945XeQAB54CP8D94999416666734D8DD945EgQAB54C8D8949942166667348DDC945AEQAB548DPD94942016666734D8DC945AAAFB5488DC94420'+'0166667348DCD945AFAAB548DCD94200001111120'+'4444420555552vwww4420000#';
  tepUrls          ='T6W00W00)3000m9dZfbMh)luv()w4Mx)4())t)lpts()t)kp))))GKQfxz(zz2mOz2nQmhSqqpfpEdZrtxjpt)NjE7pv)Rzx)JOltxjrt3(ltVkp)NhtMdpv)lNltthnttQlE7pxtpPl)JenE7ZrdpPf63nQYVdrmlOn)pen4I80XZrftVVflVV8)p90t)VjtV)StVFb)RiI)tgnt)Vh)NRASMQC~'+'011100011100011120000000000000001345101365101365120000000000000017781136451016651200000000000000017911646A5116512000000000000000013351A636516651200000000000000001375164B651665120000000000000000137813616516651200000000000000001448B64B65166512000000000'+'000000001881A6165165120000000000000000001A6AC6166665120000000000000000001636C6BC66651220000000000000000013C66CDDD6C5EED200DDD20000000000166C6DFGHD6DIJKD2DLMKD200000000001111DNNHDDOPQRD2DMSKD2000000000000000DPGDDTOULVDDMKD20000000000000000DPIHDWFOXKDM'+'SVD20000000000000000DO9YDJOZJVDMXKD20000000000000000aPObDcWadVDXMVD22000000000000000DUIbDJUEeeeXSKeee200eee2000000000DWbfcZeghieXejhie2eghie000000000DcJGJJekjieejlgie2ehhie000000000DJQcMJDelmeeljhgieehie2000000000DncSMXDejkie9lghiehhie2000000000DSSMS'+
                    'D0ekjieojehiehhie20000000000DDDD00eokpejlehiehhie20000000000000000ehgpellehiehhie200000000000000000ehiqghehiehie2000000000000000000eghghhehhhhie2000000000000000000ehghhhehhhhie2000000000000000000eghhhhehhhhie2000000000000000000ehhhhe0ehhhie2000000000'+'0000000000eeee000eeee200#';
  tepUserManagement='T5W00W00)3004I80ZfbMlVV8))Vft))S))Fd)p90)thK0CtS))Vh))FX4())U)))))FZ4Mx)jwy)tVlGZ1GCE7pxtJOltlNllNhrpXXGtRit)Jen)penUltz)Rzx)JOlEdZt~'+'00000001111200000000000000000000000112013412011200000000000000000013411563311781200009999200000000165AB453338871200009CD920000000001A4A543333812099209DC920992000001EA54333833121FF99DCDC99CC9001113A5A1117383711FCGDCDCDCCCC9001AAAA4100017383879GCCDCDCC'+'CC92001EAAAH10001783871FCGDCDCCCCC9200111AE410001738711FFDCD999FCCC999000143611173871FFCCCD90009FCCCC9000134333333381FFGCDC90009FCCCF9001343633338871FFFGCD90009FCC999001431133871187999CCCC999FCC9200001112018710011209GCCCCCCCCC92000000000178100IIIIFCC'+'CCCCCCCCC9000000000111100IJJIFFFCCCCC99FF900000000000II00IKLIFFII9CC9209900000000000IKMNILOPKIIJJ9FF9200000000000000IMQMKOQPPLKLJ99990000000000000000IOQOQOPRLRPI20000000000000000000IKOPOLPLRPLI200000000000000000IILSKSIIIJPRLPII200000000000000IMKOKSI0'+
                    '00IJPRLTPI00000000000000ILOKOKI000IJRLTPJI000000000000000IIMKON000IJKRLII000000000000000000IMKOIIIJKRPI20000000000000000000IKOLKKKKRPLI2000000000000000000ILMKLKPPRPRLPI000000000000000000ISUNIPPLPIIJJI000000000000000000III20IJPI20III000000000000000000'+'00000IIII200000000000000#';
  tepSettings      ='T5W00W00)3001Ie10yvd)d9042x())wDfYC)(xF0SpD0E3U)T)))0())MQ90))Vi0KTr))Fr))lZwfdUUwfdExip6QeXY9cOo8ZC)20OEJpxa7vzP3cy)Njw)38m)pHZ~'+'00000000111111000002222200000000000000011333111000224442200000000000001355555311024666664200000000000115577785112269AAAB62200000000001C87DD788C12E96DDABBE20000000000158DFF78851269DFFABB6200000000001587DD78851269ADDABB6200000000001C87GG788C12E9AGGABBE'+'2000000000011587788511226BAABB622000000000001388888310024BBBBB4200000000000001C888C100002EBBBE20000000000000011C5C11000022E9E22000000000000000111110000002222200000000000000001HIJ10000002HIJ200000000000000001KLM10000002KLM200000000000022221KIJ10NNNNN2'+'KIJ2111110000002244421111NNOOONN222113331100002466666420NOPQQQPON0135555531002269AAAB62NNPQRRRSPN1155777851002E96DDABBENTRRDDRSST1C87DD788C10269DFFABB6NPRDFFRSSP158DFF788510269ADDABB6NPRRDDRSSP1587DD7885102E9AGGABBENTRRGGRSST1C87GG788C10226BAABB62NNP'+
                    'SRRSSPN115877885110024BBBBB420NOSSSSSON013888883100002EBBBE2000NTSSSTN0001C888C10000022E9E22000NNTPTNN00011C5C110000002222200000NNNNN000001111100000002HIJ200000NHIJN000001HIJ100000002KLM200000NKLMN000001KLM100000002KIJ200000NKIJN000001KIJ100000000222'+'0000000NNN00000001110000#';
  tepSchemes       ='T6W00W00)3002nvOZfbME72d4I80xLxzE7pvtp90dtB4pT(z)twolVkI)RShQRrxtFNlj()xS()z)Jent)Fbl)UAb()z6))xbU)xxtQhlVF6lVltM)lttlMl)xjpd)ltE73d))Vh)Vlr))lnU)lttllPtVlGfU)yr()z))VltJPh4()))Rirt))vd))zE))vC())lpPhE7px)ldntxC2MdJf~'+'0000000120000003200000042000000000000001200000032000000420000000000000012000000320000004200000000000001512000036320000474200000000000015120000363200004742000000000000151200003632000047420000000000015511200366332004474420000000000155512003666320047874'+'200000000015995112336A632044B88442000000001999951233CDE3324BB888420000000155FG95133CHEE6344IJJ884420000001KLLMM513NEHHE634IJJO888420000015MPQLM533RSEHE644JIJO888442000019STTQM5UCSAEHE64BVBJJO8884200015LWXQQMU3ISYCH644QZZBaOJ88442001bPXYPLM3IWXSAH64VI'+'PIIBOJ88742001cPWPQFM3CdWdSe44VQVVIBOJO884201bPWTTQf3BPXPSgD4IdVXVIZJOO877421cPWTQL93CWWXWA64dQdPVVBJJOJ87421bhQTQMf3CXSPSg64IXPVWIBOJOO77421iLWQQM93NSXSdAD4PVWVVZJJJJO87421GhQQLM93CSSdSAD4IPVPVZJOJOJ77421iLPjLG93CASSSAD4XVPVIBJOJJO87421fhLQFkf3RNgSC'+
                    'AD4ZWIIIBOOJJO77421iFTFMf93CAAASl64VZVZBBOJJOO88421fiMGkf93RCACNHm4JIZZBJJOOJO77421cfifff93CHAenHm4IBVJaOOJJO7874201cffff993NenHHm44IJOOJOJ88o7420011cffff93UlHHEHm44VOJOJ8888442000159fff95UllEHHnm44JOJO88744200000119ff951UpRREH6344OJ87744200000001111'+'11123UU33332444444420000#';
  tepHelpInfo      ='T6R00W00)300z2mOpfrOZfbMm3thzdNklRcgbN5fph8hlx7gE7pQnYHSlVvhtJentdQlr62ZqVxhuJPltNRlGBpdtdhnptRjyFiitxTf3ZHc)xzi(sGnCpIVttgnDx2k)VlnxtQi)Vlp63nQ6ZnP))Uj)xTl)VdnqtMl4I80dxTElRjGdNgKKo82)p90lVV8l)UClthISo82))lrtthK)thM~'+'0000000000000000000000000000000000001111111111230000000000001114555467689AB33000000001189C5D5D599CCECFFB300000018CCG95D5D558HEIICJFB300001CGGC911111559HCKKC7FFB30019GGGB1300001449HKKLCJFB30019MNB30000000164CEKKCJFO1319GPHQ111130000R69ESECJTO1319GPUDQ'+'QQQ13000R69DEC47OQ1314VPPWSSDQX3000Y658D97TFQ1314CMZZaIDbQX300R64c447TFQB3018MPNaIDcQB300Y4c467TFQX300148GGGHcQB200144477JJQX3000011969CQB13015c467TOQ13000000011AB1300155557JOQB30000000000000000Y9889AOB130000000000000000deNfghidd30000000000000000djZk'+'lmidd300000000000000000dnjohid3300000000000000000dnjpdid30000000000000000000djpdid300000000000000000000dddddd3000000000000000000000000000000000000000000000000ddddd30000000000000000000ddnjpdidd300000000000000000dnjnjpdid30000000000000000dnjnjjkodid300'+
                    '0000000000000djnjjjjpdid30000000000000000djnjjpdid300000000000000000ddjnpdidd30000000000000000000ddddd300000000000#';

  //window button images
  vimDefaults ='T1D00H00))))0000~'+'W3W8WW0112Y)4(8uGWW0X3YFa)88GGWW0Y0uW#';
  vimMinimise ='T1H00H00))))0000~'+'0000000000000000000000000000000mV0uF0y70000000000#';
  vimNormal   ='T1H00H00))))0000~'+'000000000uF0y7002uF1yd02I01DWW0GG0uF0000000000000#';
  vimMaximise ='T1H00H00))))0000~'+'000000000)VW)Fm)78024012W01GW08G04802y)1000000000#';
  vimClose    ='T1H00H00))))0000~'+'0000000003OW3EWZ3Wx0WF0W30u30k3WZ3uW3CW1000000000#';

  //control images
  simUnticked ='T1900900))))0000~'+'uW82AW1CW2Y8uu#';
  simTicked   ='T1900900))))0000~'+'uW8wglzjlwY8uu#';
  simUp       ='T1900400))))0000~'+'G07ynV#';
  simDown     ='T1900400))))0000~'+'(ZFu02#';
  simRight    ='T1600700))))0000~'+'26EUE62#';
  simLeft     ='T1600700))))0000~'+'GOSUSOG#';
  simDropDown ='T1900400))))0000~'+'(ZFu02#';
  sim90       ='T1900400))))0000~'+'G07ynV#';
  sim270      ='T1900400))))0000~'+'(ZFu02#';
  sim0        ='T1600700))))0000~'+'26EUE62#';
  sim180      ='T1600700))))0000~'+'GOSUSOG#';
  simStop     ='T1700500))))0000~'+'(yvpdl#';
  simDownload ='T1900400))))0000~'+'(ZFu02#';
  simPlus     ='T1500500))))0000~'+'4odGG#';
  simMinus    ='T1500500))))0000~'+'0m700#';
  simTimer    ='T1800900))))0000~'+'(B8He01A49e)#';
  simView     ='T1900800))))0000~'+'U84X84XmFW3u#';
  simAudio    ='T1600800))))0000~'+'WeghhgeW#';
  simFolder   ='T1A00800))))0000~'+'SWu9W(R07W28)z#';
  simFile     ='T1900800))))0000~'+'(HG2Kl2Kl2q)#';
  simRun      ='T1600700))))0000~'+'26EUE62#';
  simSave     ='T1800800))))0000~'+'(5OZ1sVdTwt#';

  //special images - 32 pixels high, variable width
  tepTick32='T2K00W000yF0))))lJF8028W~'+'0000000000000000000000000000000000000000000000000000G000000v00000aE0000Gw00000f30000aE0G00Gw00P00f30aQ0aw0mgQGg30mgQaE00mgQg300mggE000mgw3000mgE0000mw00000iE00000y000000000000000000000000000000000000000000000000000#';
  tepCross32='T3L00W000yF0)3m))3000000028W~'+'0000000000000000000000000000000000000000000000000090009100009I089I30009IQ38IQ4009IQ30HIQ009IQ300HI309IQ3008II39IQ30008II9IQ30000HIIII300000HIIIR000008IIIR000000HIIQ0000009III3000009IIII300009IIIII30009IIIIII3008IIQJIII308HIQ3HIIQ30HIQ30HIQ308IQ300HQ3'+'00HI3008Q3008IR000830000R0000000000000000000000000000000000000000000000000000000000000#';
  tepExclaim32='T3A00W000yF0)(z)00u)42x(000W028W~'+'0000000000000000000000000000000HRi08QRZ5HRRRiHRRRiHRRRiHRRRiHRRZ5HRRZ5HRRZ08QRi08QRi00HZ500HZ500Wi000HZ508QRi0HRRi0HRRi08QZ500Xi00000000000000000000000000000000#';

  //button images - 20 pixels height, variable width
  tepBalloon20        ='T3H00K00)3000fOr04C00OE00yF0~'+'0000000000000000000899900009IIIA100HQRRRI10HRaaaSJ1HZaaaaaJ9QaaaaaSAHZaaaaaJ1HRaaaaJ10HQRaaJ1009IQaJ100089QJ1000008I1000000H1000000HA0000008A0000008A000000890000000000000#';
  tepBalloonNotify20  ='T3P00K00)3000fOr04C00OE00yF0sMirPl()~'+'0000000000000000000000000008999000000009IIIA1000000HQRRRI100000HRaaaSJ10000HZaaaaaJ10008QaaaaaSA0099HZaaaaaJ99fj1HRaaaa99jjsD0HQRa9fjrssk109IQCjsssssD0089Y9fjrssk10008J199jjsD0000H10089fj1000HA00000990008A00000000008A000000000089000000000000000000000'+'#';
  tepWarning20        ='T2K00K00028W)300))F0Bim2~'+'00GL00000K50000Gf50000KQ1000GfQ1000K(M000GflM000Kwh500Gf(g500KglQ10GfwhQ10Kg(gM0GfglgM0Kgwhg5Gfgggg5KgglgQHfgwhgQLgggggMLLLLLLLLLLLLLL#';
  tepLeftSkip20       ='T2N00K00))))4I82fdE4~'+'000000000000000000000000000000000G000G00Gb00Gb0KbA0KbAKfg2KfgMfg2Kfg2fg00fg0Gg50Gg50WgQ1WgQ10gg20gg20eg20eg200g000g000800080000000000000000000000000000000#';
  tepLeft20           ='T2B00K00))))4I82fdE4~'+'00000000000000000G00Gb0KbAKfgMfg2fg0Gg50WgQ10gg20eg200g0008000000000000000#';
  tepRightSkip20      ='T2N00K00))))4I82fdE4~'+'00000000000000000000000000000001000100O500O500gL10gL1WgQ5WgQ50ggL0ggL0Wg60Wg60Kg10Kg1bgA0bgAegA0egAWgA0WgA0e200e200200020000000000000000000000000000000000#';
  tepRight20          ='T2B00K00))))4I82fdE4~'+'000000000000000100O500gL1WgQ50ggL0Wg60Kg1bgAegAWgA0e2002000000000000000000#';
  tepConnect20        ='T2H00K00)))))300MBu0~'+'000000000000L0000KL0000L5000GL1G50G50L50W0GL1080KL0020M10W080008W000WA2000gA00LegA0KLggggLbgg0GLXg20G5WA0000000000#';
  tepUp20             ='T2C00K000yF04I82fdE4~'+'0000000000000G100a600fQ0Ggg1agg6fggQKfQ50fQ00fQ00fQ00fQ00fQ00fQ00fQ00K5000000000#';
  tepUp20a            ='anm:t1,c2,d500#T2O00K000yF0)3004I82fdE4~'+'0000LLLL0000LLLL0000LLLL0W20LLLL0uB0LLLL0(l0LLLLW))2LLLLu))BLLLL())lLLLLe(lALLLL0(l0LLLL0(l0LLLL0(l0LLLL0(l0LLLL0(l0LLLL0(l0LLLL0(l0LLLL0eA0LLLL0000LLLL0000LLLL#';
  tepDown20           ='T2C00K000yF04I82fdE4~'+'0000000000000K500fQ00fQ00fQ00fQ00fQ00fQ00fQ0KfQ5fggQagg6Ggg10fQ00a600G1000000000#';
  tepDown20a          ='anm:t1,c2,d500#T2O00K000yF0)3004I82fdE4~'+'0000LLLL0000LLLL0000LLLL0eA0LLLL0(l0LLLL0(l0LLLL0(l0LLLL0(l0LLLL0(l0LLLL0(l0LLLL0(l0LLLLe(lALLLL())lLLLLu))BLLLLW))2LLLL0(l0LLLL0uB0LLLL0W20LLLL0000LLLL0000LLLL#';
  tepSearch20         ='T2G00K00)3000000WAu8~'+'000000000000L100G1G10G00G0010010100G040001G00040100G0G00G0010010G1Gb00GLW90000O20000c0000W90000800000000000#';
  tepFind20           ='T2G00K0003CmWAu8V7CQ))))~'+'000000000000L100GfQ10GghQ00fkg10flgQ0aggg1Gggg60fggQ0GggQ00fgg50GfQT10GLKN0000r5000GT1000K70000L00000000000#';
  tepView20           ='T2G00K0003CmWAu8V7CQ))))~'+'000000000000L100GfQ10GghQ00fkg10flgQ0aggg1Gggg60fggQ0GggQ00fgg50GfQT10GLKN0000r5000GT1000K70000L00000000000#';
  tepFolder20         ='T3F00K00)300WAu8)xVb))))V7CQ~'+'00000000000000000000000000000000000000000000089000008QA99900PQQQQ108QQQQA00PQA99999QAaaaaCPAaaaaC8AaaaaC09aaaaC009999900000000000000000000000000000000#';
  tepNew20            ='T2B00K00)3000fOrPl()~'+'000000000000000LL1agQ1fgcHggLbggQfggMgggbggQfggMgggbggQfgg6LLL000000000000#';
  tepEdit20           ='T2B00K00)3000fOrPl()~'+'000000000000000LL1agQ1fgcHMfLbggQfggMMLfbggQfggMMLfbggQfgg6LLL000000000000#';
  tepPlay20           ='T2900K00))))hqB08wkP~'+'000000000000K10f60fQ0fg1fg6fgQfgQfg6fg1fQ0f60K10000000000000#';
  tepPlay20a          ='anm:t1,c2,d750#T2I00K00))))hqB08wkP~'+'000000000000000000000000K10000f60000fQ0000fg1000fg6000fgQ000fgQ000fg6000fg1000fQ0000f60000K10000000000000000000000000000#';
  tepStop20           ='T2B00K00))))z2mOlRcg~'+'000000000000000LLLaggQfggMgggbggQfggMgggbggQfggMgggbggQKLL1000000000000000#';
  tepStop20a          ='anm:t1,c2,d750#T2M00K00))))z2mOlRcg~'+'00000000000000000000000000000GLL5000Gggg1000fgg6000aggQ000Gggg1000fgg6000aggQ000Gggg1000fgg6000aggQ000Gggg1000KLL1000000000000000000000000000000000#';
  tepFinish20         ='T2900K00))))z2mOlRcg~'+'000000000000K05fHQfHQfHQfHQfHQfHQfHQfHQfHQfHQK05000000000000#';
  tepPause20          =tepFinish20;
  tepPause20a         ='anm:t1,c2,d750#T2I00K00))))z2mOlRcg~'+'000000000000000000000000K05000fHQ000fHQ000fHQ000fHQ000fHQ000fHQ000fHQ000fHQ000fHQ000fHQ000K05000000000000000000000000000#';
  tepDownload20       ='T4G00K000yF00m9dbhFrv)VkNYD(ejC)Q1itZfbMQfbM4I82fdE4UxD0MRD0ukB1uZ)SvdF6~'+'00000000000000000000000000000000011111111111111012322444445555510643244455566170001444555556600000014555556680000000654556610000000006456180000009999915699999909333ABA11CBACDD90E33EAABCCCCCD90009FEACBBCCDD0000009ACBACCDD800000009CCBCDD8000000000CCCCD'+'9000000000009CD0000000000000099000000000000000000000000000000000000000#';
  tepAdd20            ='T2C00K000yF04I82fdE4~'+'00000000000000000G100a600a600a60KbM5fggQfggQKbM50a600a600a600G100000000000000000#';
  tepMinus20          ='T2C00K000yF04I82fdE4~'+'00000000000000000000000000000000KLL5fggQfggQKLL500000000000000000000000000000000#';
  tepTimer20          ='T2F00K000yF04I80wllg0m9d~'+'0000000000000000GL100bgM0Ggkg1agkg6agkg6fgkgQfgkgQbg))MfgkgQfgkgQaggg6aggg6Gggg10bcM00GL100000000000#';
  tepRun20            ='T2E00K000yF0WAu8)xVb~'+'000000000000005000G6000a6000f600Gg600ag6LLfMHgML1GQ4K1a60K0K00505000a6000f100ag100LL0000000000#';
  tepAudio20          ='T2N00K000yF0FJocY1GCOFOv~'+'000000000000400000e240000eL24G00WML21G00QLL2140eMLbG04gQLLjG0flMQLB4G(hvxz21aLQU(lG0fgcb)B4Gggb()214gQz)lG01WQ))21G0Ws)lG010W()21G00W(BG0100Wg010000004000#';
  tepMute20           ='T2G00K000yF0Y1GCFJocOFOv~'+'0000000000000G5K00KgL00KgQ10KgQ50KfgLGLfgbNzbMMUzNsN(bQPRzNLbPzVLLQz)HLfr)70Lr)70GL)V00K)V00GrV00GHL0000000#';
  tepOpen20           ='T3F00K00)300Kqv2WAu8)xVb))))V7CQ~'+'000000000000000000000000000910000010110000009GI00009HZJIII00YZZZZ20GZZZZJ00YZJIIIIIZJjjjjLYJjjjjLGJjjjjL0IjjjjL00IIIII00000000000000000000000000000000#';
  tepCut20            ='T2900K00)3000fOrWAu8~'+'000000000G01G01G01GH10H00L00400L00YAeYW2YW2YW22Ae00000000000#';
  tepCopy20           ='T2F00K00)3000fOrPl()~'+'000000000000000KL000fQ100fQ600PPLL0fgfQ1PLfQ6fgPPLPLfgQfgPLPPLfgQfgPLPKLfgQ00PLP00fgQ00KL50000000000#';
  tepPaste20          ='T3G00K00)300WAu80fOr)llaPl()~'+'000000000000000000891000899I99109RH9AR90PBRRRPB0PB999PB0PRRRRRB0PRRIIIA0PRRYaaI0PRRYaaY2PRRYIYIIPRRYaaaKPRRYIIIKPRRYaaaK9RRYIIIK899YaaaK000GIII20000000000000000#';
  tepPasteFit20       ='T3G00K00)300WAu80fOr)llaPl()~'+'000000000000000000891000899I99109RH9AR90PBRRRPB0PB999PB0PRRRRRB0PRRIaIaIPRRaaaaaPRRaaaaaPRRYIYaKPRRYaaaKPRRaIIIaPRRaaaaa9RRYIIIK899YaaaK000aIaIa0000000000000000#';
  tepPrint20          ='T5G00K00)300RkvaPl()uEz)kuY9GUv))ztPV)z)hjspmEx))x)bWMw)Kqv28jqVr1u)G3z)tkx)i5tlyztlpTtl~'+'00000000000000000000000000000000000000011100000000000012221100000000013222224400000563322224000005576333224880005799966334989880577AA996649999B857997CC9BDB9BEE857999979F9BEEEE8559999G7BEEEEH8805559999EEEH8E8008FF5599EH8EEHH00088FF5I8EEE8000000088F9EE'+'8800000000008J88000000000000000000000000000000000000000000000000000000#';
  tepSelectAll20      ='T2B00K00)3000fOrPl()~'+'00000000000KL5Ggg5agQ6PLQLMLgbLLQPLLMMLbbLLPPLLMMLbbggQKLL1000000000000000#';
  tepClear20          ='T2B00K00)3000fOrPl()~'+'00000000000KL5Ggg5agQ6fgMLgggbggQfggMgggbggQfggMgggbggQKLL1000000000000000#';
  tepUpper20          ='T1D00K00)3000fOr~'+'000000000)0(1m6WDWx0Z163(FyVCWzn)ZF000000000#';
  tepLower20          ='T1B00K00)3000fOr~'+'0000000000000(Z)3WX)yV7i1t)tl30000000#';
  tepSaveAs20         ='T2E00K00)300hjspiow)))))~'+'00000000000000KLLLHggggb())QfhgkMw))hbkgwQf))lMggggbgggQfLLLMQLrdbMLzPfLLV6LLLL000000000000000#';
  tepEnlarge20        ='T2G00K00)3000fOr))))~'+'0000000000000000KLLLLKLLLLLLLLLLfggggbggggMggbgQfgMggbQLLfMgLLbQfgMggbgQfgMggggQfggggbgggg6LLLL500000000000#';
  tepShrink20         ='T2G00K00)3000fOr))))~'+'0000000000000000KLLLLKLLLLLLLLLLfggggbggggMggggQfggggbQLLfMgLLbQfggggbggggMggggQfggggbgggg6LLLL500000000000#';
  tepSizeTo20         ='T2G00K00)3000fOr))))~'+'0000000000000000KLLLLKLLLLLLLLLLfggggbggggMgfggQfLgggbLbggMgfgfQfcgMgbQLLbMgggbQfggcgbgggg6LLLL500000000000#';
  tepClone20          ='T2F00K00)3000fOrPl()~'+'000000000000000KL000fQ100fQ600PPLL0fgfQ1PLfQ6fgPPLPLfgQfgPLPPLfgQfgPLPKLfgQ00PLP00fgQ00KL50000000000#';
  tepClose20          ='T1B00K00)3000fOr~'+'0000000006m7S77t1V07m7S77t1V030000000#';
  tepHelp20           ='T2I00K00)3000fOr))))~'+'00000000LL000Kgg500fLLQ0GMfQb1aLggL6abQbM6PbMbMPPLLfMPPLLgLPPLbQLPPLbMLPPLbMLPaLLLL6aLbML6GMbMb10fLLQ00Kgg5000LL00000000#';
  tepInfo20           ='T2I00K00)3000fOr))))~'+'00000000LL000Kgg500fLLQ0GMLLb1aLbML6aLbML6PLLLLPPLLLLPPLbMLPPLbMLPPLbMLPPLbMLPaLbML6aLbML6GMLLb10fLLQ00Kgg5000LL00000000#';
  tepPlusSign20       ='T2D00K00)300jm7pPl()~'+'00000000000000000GLLLHgggQfgfgbgcgMgQgQfgfgbMLbMgQgQfgfgbgcgMgQgQfgggHLLL10000000000000#';
  tepMinusSign20      ='T2D00K00)300jm7pPl()~'+'00000000000000000GLLLHgggQfgggbgggMgggQfgggbMLbMgggQfgggbgggMgggQfgggHLLL10000000000000#';
  tepCenter20         ='T2D00K00)300jm7pPl()~'+'00000000000000000GLLLHgggQfgggbgggMgQgQfgfgbQLfMgQgQfgfgbgggMgggQfgggHLLL10000000000000#';
  tepWebPage20        ='T2B00K00)3000fOrPl()~'+'000000000000000LL1agQ1fgcHggLbggQfggMgggbggQfggMgggbggQfgg6LLL000000000000#';
  tepBlaiznet20       ='T4J00K00)30090))Suz)vitzpOy)ADx)ILw)Znv)UHv)hHv)hnu)pvt)xjt)4Et)~'+'001111111213112300001111112232222223001300002322230022200300002202423000223000000220444300044300000444044430044400002442404543454530022324540555533554432300455066663005653300055507773777665300045560787330087630055567888309A888730530673AA3003000BA3030'+'0788A30003000C30000788ABBCCC3DDCD3000733333CCDD33300000630000033DD0000000073000000000000000007300000000000000000300000000000000000#';
  tepRefresh20        ='T1D00K00)300MBu0~'+'00000E0Y0224488(JuZW31274V8)HGWW01141m100000#';
  tepDefaults20       ='T2D00K00)3000fOrPl()~'+'000000000000000000GL10GgQ0Ggg6GgcgHgMfQfMLgbMLbMMLLPfgggHggg1agg10fg10GL100000000000000#';
  tepApply20          ='T2D00K00)3000fOrPl()~'+'000000000000000000GL10GgQ0Ggg6GgggHgggQPLLbbMLbMgLbQfQbgHgcg1agg10fg10GL100000000000000#';
  tepYes20            ='T1D00K00)3000000~'+'0000000000G0O0O0O0O0OWPWp0(0u0m1010000000000#';
  tepNo20             ='T1F00K00)3000000~'+'00000000y1OmW08A0I2GX0C8W12CWW18K0I2WY08Om0y100000#';
  tepCancel20         ='T1B00K00)3000000~'+'0000000006m6C63s0E07m6C63s06000000000#';
  tepUrgent20         ='T1500K00)))))300~'+'0t))))))x00Wx)T00#';
  tepUnlock20         ='T2E00K00)3000fOrPl()~'+'00000KLL1GLLL1500GH100KK00055000G1000KLLL5LLLLHfggQLgggMbgbgLfMbQLgMgMbgbgLfggQLLLLLKLLL100000#';
  tepSizeStep20       ='T2A00K00)3000fOrPl()~'+'000000000000000000GL00f10a60GQ0Lf1ag6GgQ0fgLbgMggQfggLLL50000000000#';
  tepPotFill20        ='T2G00K00)3000fOrPl()~'+'000000000000000000G1000G600KHg50KPgg1KPggQGPggg6bbgggL1fggM5agg6L0fg6K1Gg6050a60K00500100000000000000000000#';
  tepToggleColors20   ='T2F00K00)3000fOr)3m)))F0~'+'000000000000KL100fg600fg600fg600fg600fg600fg600fL1GLV00q)V00q)V00q)V00q)V00q)V00q)V00GL5000000000000#';
  tepTransfer20       ='T2E00K00)3000fOrPl()~'+'000000KL100fQ10Ggc10agL10fgQLLggMgcggbgfgQfQggMgcggbgfgQfQLLHgg60agg10fgQ0Ggg60KLL000000000000#';
  tepTrim20           ='T2D00K00)3000fOrPl()~'+'000000000000000004000K0L5G1aQ0PGg1f1f6aQaQagHgHg1f6a6aQG6Gg1K0L5G1000100000000000000000#';
  tepSL20             ='T4K00K000y))myy))3000yAu))F0dSo900A0)(B00080)3Fy00ml00m)0)80)3B00ynV~'+'000000000000000000000111222222222222222011111222222222222222333332222222222222224444445222222222222244444446666666666666444444466666666666664444444456666666666677777777566666666666555555555566666666665555555555888888888855555555555999999999AAAAAAAAAA'+'A599999999BBBBBBBBBBBB99999999BBBBBBBBBBBB59999999BBBBBBBBBBBBB5CCCCCCBBBBBBBBBBBBBBDDDDDDEEEEEEEEEEEEEE5DDDDD0EEEEEEEEEEEEEEDDDD000000000000000000000#';
  tepHome20           ='T5F00K000yF0EB52V)ztU3004200Eh54ltR88ZCottwOltRAlxySlRiKlxThlRDXlVknlRSElRDZlxTjlVUjlxDbtNgMlRzUttBZtNxU4Y02lVUlt)UhkvcRt)(vtV)x~'+'00000000000000000000000000000000000001120340000000056417340000000589945340000001AB996434000001CDEF9G94420001HEEHICBG645701CHEEHIJKJJ9411BLHHMNKBKKKKK4111O5O5444O444401PEEIJQQJJJG4R01ESTT444QJJJ4R05ESSH43368JK4R01ESEE4438TKT4R01ESST43366K9OR05ESSE433K'+'9694R05155144444444R000000000000000000000000000000#';
  tepWeb20            ='T4F00K00)300E3EscojoyXBUW8fHP1BsnpUwDCNn6xSjbswjbCsFn8LXydV(Ahip6RindB(v~'+'00000000000000000000000000000000000122100000000022333455600000332224477510002432823377491007433322574AA9327338855774AA3B5593382554AAAB35775CD9D94AAA3B27796E9D13AABB3D7B96CC66FBBB3BF5B9CCC6FCEBB9B0D79C6FFF61B3E000D96FFFFC1B900000EDF6CCC9AE0000009DF619'+'A9000000000000000000000000000000000000000000000000#';
  tepEmail20          ='T3K00K00)3000fOr))))WAu8)ypF~'+'00000000000000000000000000000000000000009999999999HIIIIIIIRBHaKIIIIIRBHIIIIIIIRBHaKIIIIIIAHIIIaaaIIAHIIIIIIIIAHIIIYaaIIAHIIIIIIIIAHIIYaaaIIAHIIIIIIIIA99999999990000000000000000000000000000000000000000#';
  tepPhone20          ='T3G00K00)300WAu8)lla0fOrPl()Vyn7))))~'+'00000000000000000000000000000000099999908IIIIII1H999999AH181818AH18PB18A80ZaaS0100ZaaS000Oaiba300Oarka300ZarkaS00ZaibaS0Oaaaaaa3ORRRRRR3000000000000000000000000#';
  tepVoIP20           ='T2B00K00)3000fOr)llaWAu8~'+'0000000G100K000500GLL5fggM()lb))RfggMkkkbhhRfggMkkkbhhRfgg6LLL000000000000#';
  tepMember20         ='T4F00K00)300MBu0yVV0xFV0w3V0ZCo8vtU0))))udU0sRU0rBU0q)T0ppT0oZT0nJT0l3T0~'+'0000000000000000000000000000000000000000000000000111111100000001222222210000013333333331000144554445544101665775657756611885755857558811999559995599911999999999999911AAAAAA5AAAAAA11BBBBB955BBBBB11CC5CCCCCCC5CC101DD5DDDDD5DD10001EE55555EE1000001FFFFFF'+'F1000000011111110000000000000000000000000000000000#';
  tepMemberAdd20      ='T5L00K00)300yVV0MBu000m)xFV0w3V0ZCo8vtU0))))udU0sRU0rBU0q)T0ppT0oZT0nJT0l3T0~'+'0000000000000000000000000000000000000000000000000000000000110000000222222200001331000002111111120001331000024444444442111331110255665556655333333332776886768867333333332996866968669911331112AAA66AAA66AAA21331002AAAAAAAAAAAAA21331002BBBBBB6BBBBBB20110'+'002CCCCCA66CCCCC20000002DD6DDDDDDD6DD200000002EE6EEEEE6EE20000000002FF66666FF2000000000002GGGGGGG2000000000000022222220000000000000000000000000000000000000000000000000000#';

  //fixed images - 16x16 pixels
  tepHome16           ='T5G00G000yF0EB52V)ztU3004200Eh54ltR88ZCottwOltRAlxySlRiKlxThlRDXlVknlRSElRDZlxTjlVUjlxDbtNgMlRzUttBZtNxU4Y02lVUlt)UhkvcRt)(vtV)x~'+'00000001120340000000005641734000000005899453400000001AB9964340000001CDEF9G944200001HEEHICBG6457001CHEEHIJKJJ94121BLHHMNKBKKKKK47111O5O5444O4444701PEEIJQQJJJG4R201ESTT444QJJJ4R005ESSH43368JK4R001ESEE4438TKT4R001ESST43366K9OR005ESSE433K9694R00515514444'+'4444R0#';
  tepSettings16       ='T2G00G00)3000fOrPl()~'+'00000000000GLL00Ggg500fgc10agQL0Gggg10fgg60aggQ0Gggg10fgg60aggQ0Gggg10fgg60GLL50000000#';
  tepLocal16          ='T2G00G00)3000fOrPl()~'+'00000000000GLL00Ggg500fgc10agQL0Gggg10fgg60aggQ0Gggg10fgg60aggQ0Gggg10fgg60GLL50000000#';
  tepUrl16            ='T4G00G00)300E3EscojoyXBUW8fHP1BsnpUwDCNn6xSjbswjbCsFn8LXydV(Ahip6RindB(v~'+'000001221000000000022333455600000033222447751000024328233774910007433322574AA93027338855774AA3B05593382554AAAB305775CD9D94AAA3B027796E9D13AABB30D7B96CC66FBBB3B0F5B9CCC6FCEBB9B00D79C6FFF61B3E0000D96FFFFC1B9000000EDF6CCC9AE00000009DF619A900000000000000'+'000000#';
  //yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy update email
  tepEmail16          ='T4G00G00)300n2ExhbBv7sRjpH8ddO9oU8Q(qHRWGueFP4cFaqMY0qrmcP7YHmJbQL6Ubq5l~'+'000000000012220000002333222445300012333135650140007531117555403007877111355884100687177166889A302B517736668999405B2385666B8999C02626B8A6BA899DE0225BBA88BBD99AE022DBBB89BDDACDC065DDDD9DDDDFDE406CFBDDDDDFFDEE006E0FFFFFFFDEE00065224AEAEEEC00000443443444'+'000000#';
  tepUp16             ='T6G00G000yF00200UxjtCd9DBZvC9RPC))))))VctIu7rAO7p6u6mw76V)zttV)z)VVa)JlZkod5Co8Z)lUX)RUW5BPB0t8Ayc89uM88q6877JvB)3(UZ6t2)JzRuNCOWw62kvcR2)eA)pyPlpxLUoc1jrMRcFhJSg61zgO9)ou9SdAHQYc0wUe8J3wEPUM0hct4eQ74bEN3Cn4J3EuW8ZCoMRjr~'+'000000011200000000000011112000000034511111100000036661111112000036777761189ABCD04EFFFFF11666GH205IJKKKKKKLMNOAACPQK666666666J6RHKS3777777777T7UVWX47EEEEEEEEY7ZaLXK7IIIIIIIIb7cadXe7QQQQQQQQf7gahXN7SSSSSSSSi7jVC9ABGklmRUZcgjno0poaaaaaaaaaaaop00Cqqqqqqq'+'qqqqC0#';
  tepNav16            ='T4G00G00)3006p96)))))pVczNFZSk76dBiLro86)))z)7UW))VfbE72zoPAR)wDyxDU~'+'000000000000000000000000000000000011110000000000012222100000000012333321111110001344444222221500166111111111117011162282222292501114333333336350111A3333333366B01CDA99999999610011E3999E999ED50011AEEEEEEEEECB000BBBBBBBBBBBB00000000000000000000000000000'+'000000#';
  tepFolder16         ='T4G00G00)300AJPB))))))FdwQe7rk76)FFY)VFbjk74)7EUbE72idxJbk62Sk60SE60jE74~'+'000000000000000000000000000000000011110000000000012222100000000012333324445550001366667222228000169111111444555019122222222262A0191333333333B3C01B1376367636B3D0191369696696B3D04B1399999999B7E049539999999913E005558FCCCDDEDE0000000000000000000000000000'+'000000#';
  tepFile16           ='T2G00G00)3000fOrPl()~'+'00000000000GLL00Ggg500fgc10agQL0Gggg10fgg60aggQ0Gggg10fgg60aggQ0Gggg10fgg60GLL50000000#';
  tepInternet16       ='T4G00G00)300n2ExhbBv7sRjpH8ddO9oU8Q(qHRWGueFP4cFaqMY0qrmcP7YHmJbQL6Ubq5l~'+'000000000012220000002333222445300012333135650140007531117555403007877111355884100687177166889A302B517736668999405B2385666B8999C02626B8A6BA899DE0225BBA88BBD99AE022DBBB89BDDACDC065DDDD9DDDDFDE406CFBDDDDDFFDEE006E0FFFFFFFDEE00065224AEAEEEC00000443443444'+'000000#';
  tepBookMark16       ='T3J00E00)300085f))))03Cm00u)028W~'+'09100009189I9008HA9HHIB19JJH9BYShPJaABHHIaBbSIH9AIQRfRJAAPHaQDRYKP9AIZSfaJAAPHIRDRJJP9AYKRfJaAAP9IaDZKAP9YAHQfJ9YA9Xa9DBXa9109999C910#';

  //small images - 14 pixels height, variable width
  tepRefresh14        ='T1D00E00)300Kqv2~'+'W3W8WW01nV2V4S8GuWu3vF2244G4074#';
  tepUpFolder14       ='T1900E00)300Kqv2~'+'000001Cm))))(d1800000#';
  tepOpen14           ='T3E00E00)300Kqv2WAu8)xVb))))V7CQ~'+'000091000080880000009GI00089QSIII00YZZRK00QSSaJ00YZJIIIIQSgjjjLYJjjjj2QgjjjL0Ijjjj20GIIII000000000#';
  tepStop14           ='T2A00E00)300z2mOlRcg~'+'0000000LL5fggbggMggQfggbggMggQfggbgg6LL50000000#';
  tepStop14a          ='anm:t1,c2,d500#T2K00E00)300z2mOlRcg~'+'0000000000000GLL1000fgg100GggQ000agg6000fgg100GggQ000agg6000fgg100GggQ000GLL100000000000000000#';
  tepTime14           ='T1E00E00))))MBu0~'+'mFW01H82154OGW116yR0W10A04188G0)m#';
  tepCopy14           ='T2D00E00)3000fOrPl()~'+'0000GL00Gg500fc10aPL5GgcQ1PLgPagPMLMbgQfQMbHLfg60aLP0Ggg10KLH#';
  tepClear14          ='T2C00E0003Cmz2mOlRcg~'+'00000LL0Ggg1agg6fggQfggQfLLQfLLQfggQfggQagg6Ggg10LL00000#';
  tepMember14         ='T4E00E00)300MBu0yVV0xFV0w3V0ZCo8vtU0))))udU0sRU0rBU0q)T0ppT0oZT0nJT0l3T0~'+'000011111100000001222222100000133333333100014455445544101665775577566118857555755881199955995599911AAAAAAAAAAAA11BBBBB55BBBBB11CC5CCCCCC5CC101DD5DDDD5DD10001EE5555EE1000001FFFFFF100000001111110000#';
  tepUrgent14         ='anm:t1,c2,d500#T1A00E00)))))300~'+'Em7y1Vm7y1VW3u00W3y1VW30#';
  tepPlusSign14       ='T2D00E00)300jm7pPl()~'+'0000GLLLHgggQfgfgbgcgMgQgQfgfgbMLbMgQgQfgfgbgcgMgQgQfgggHLLLH#';
  tepSearch14         ='T2D00E00)3000000WAu8~'+'0K1005G1010G04001400GG00011004G004010G0G1K90G5O2000c000W10008#';
  tepUnlock14         ='T2900E00)3000fOrPl()~'+'000KL1fg6906908900LL5fgQfgQfbQfbQfgQKL5000#';
  tepWebPage14        ='T2A00E00)3000fOrPl()~'+'000GL5GgQ1fgPagMLggQfggbggMggQfggbggMggQKLL0000#';
  tepRoot14           ='T2A00E00)3000fOrPl()~'+'000000000K00a10a10a10a10a10a10a10a10G1000000000#';
  tepVisit14          ='T3J00E00)300085f))))03Cm00u)028W~'+'09100009189I9008HA9HHIB19JJH9BYShPJaABHHIaBbSIH9AIQRfRJAAPHaQDRYKP9AIZSfaJAAPHIRDRJJP9AYKRfJaAAP9IaDZKAP9YAHQfJ9YA9Xa9DBXa9109999C910#';
  tepWeb14            ='T4E00E00)300E3EscojoyXBUW8fHP1BsnpUwDCNn6xSjbswjbCsFn8LXydV(Ahip6RindB(v~'+'000001210000000002233455600000332244775100024328337749100743332574AA93559338554AAAB35775CDD94AAA3B27796ED13AABB3D7B96C66FBBB3BF5B9CC6FCEBB9B0D79C6FF61B3E000D96FFFC1B900000EDFCCC9AE0000009D619A9000#';
  
  //general images
  tepRawGruntSearch20='T3510K00)300rMx)jsw)bMw)KIv)Cou)))))4Iu)~'+'89999999999999999999999999999999998IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIAHRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRJ9QaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaSAHZjjjjjrssjjjjjjjjjjjjjjjkjjjjjjbJ9Qi))))t))t))))))))))))))t))))))lSAHZz))))())())))))))))))))())))))bJ9Qi))))t)'+')))ts()ts()((ts(tt())))lSAHZz))))ts))t))(t))(t(t))(s)())))bJ9Qi))))))t()()t)tss)()())t)t))))lSAHZz)))))))(tss(t))(t)t)))()())))bJ9Qi))))t))t)()))()t)()())t)t))))lSAHZz))))())(t))(t))(t)t))(()())))bJ9Qi)))))ss()ts()ts((()ts(t)t))))lSAHZz))))))))))))))'+')))))))))))))))bJ9QijjjjjjjjjjjjjjjjjjjjjjjjjjjjjjSAHZaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaJ9QRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRAHIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII19999999999999999999999999999999991#';
  tepEnglish='T5O00F000yF0xLdo)300)Z))lV))000e0Smh)Z5K)y3i5NSnV)yt))14VXrlDOWXFY8mFW0el)sRW300)VJBVVtV85KgG01elZoB~'+'011111111111111111111110012345666532716666824910015AB3A66542716682A3CD100166E23A5542716C23456D1001555FE73E427E23AF555D10013333333332G33333333310012222222222222222222H10012222222222222222222H1001G77GGG77G2BGG777GG7I10011111843J32733GECCCCK1001665A3BC5'+'327C84AGL66D10016L33M665327C653A286D100133BC666F327C66683JMD1001HKDDDDDD9HIKDDDDDK9H10011111111111111111111110#';

  //small images - variable width/height
  tepBall             ='T2700700))))1Ie1lJF8~'+'KLagMgQfgbgMgQKLK#';
  tepBullet           ='T1500500)3000000~'+'k))xw#';

{//yyy Old images
  tepClone='T2K00K00)3000fOrPl()~'+'00000000000000KL0000GgM0000agP0000PPLL00GgQgM00aLbgP00fgPPL0GMLgg60agcLb10PLfgQ0GgQML60GLbgg1000PLP000Ggg6000GLL0000000000000000000000#';
  tepClose='T1K00K00)3000fOr~'+'00000000000000000O03W3E0SS0Wx00y10W300V00k30SS0uW3W1C00000000000000#';
  tepEnlarge='T2K00K00)3000fOr))))~'+'00000000000000000000GLLLLL0LLLLLLGLLLLL5aggggg1fggggQGggMgg6aggbgg1fQLLfQGgMLLg6aggbgg1fgQfgQGggggg6aggggg1fggggQ0LLLLL100000000000000#';
  tepShrink='T2K00K00)3000fOr))))~'+'00000000000000000000GLLLLL0LLLLLLGLLLLL5aggggg1fggggQGggggg6aggggg1fQLLfQGgMLLg6aggggg1fggggQGggggg6aggggg1fggggQ0LLLLL100000000000000#';
  tepFind='T2K00K00)3000fOrWAu8~'+'000000000000000K50000K0K000G00G000400400G0004004000100100G00G000400G00G0004004000K0K9000GLW900000W900000W900000W900000W000000000000000#';
  tepText='T2K00K00)3000fOr))))~'+'00000000000000000000GLLLLL0LLLLLLGLLLLL5aggggg1fggggQGQLLfg6aggggg1fggggQGQLLLb6aggggg1fggggQGQLLLb6aggggg1fggggQ0LLLLL100000000000000#';
  tepPlay='T2K00K00)3000fOrPl()~'+'0000000000000000000000400000G600000a600000f60000Gg60000ag60000fg6000Ggg1000ag60000fQ0000Gg10000a600000P0000001000000000000000000000000#';
  tepPlus='T2K00K00)300jm7pPl()~'+'000000000000000000000KLLL00GgggQ00agcg600fgfg10GgQgQ00agcg600fLLf10GgQgQ00agcg600fgfg10GgQgQ00aggg600KLLL00000000000000000000000000000#';
  tepMinus='T2K00K00)300jm7pPl()~'+'000000000000000000000KLLL00GgggQ00aggg600fggg10GgggQ00aggg600fLLf10GgggQ00aggg600fggg10GgggQ00aggg600KLLL00000000000000000000000000000#';
  tepStop='T2K00K00)3000fOrPl()~'+'0000000000000000000000000000KLL100Gggg100aggQ000fgg600Gggg100aggQ000fgg600Gggg100aggQ000fgg600Gggg100GLL500000000000000000000000000000#';
  tepCut='T2K00K00)3000fOrWAu8~'+'00000000000000000000004G00000140000G010000KK000004100000L000000100000K100000YA0000g8800088220002YW000WWW2000W2000000000000000000000000#';
  tepCopy='T2K00K00)3000fOrPl()~'+'00000000000000KL0000GgM0000agP0000PPLL00GgQgM00aLbgP00fgPPL0GMLgg60agcLb10PLfgQ0GgQML60GLbgg1000PLP000Ggg6000GLL0000000000000000000000#';
  tepPaste='T3K00K00)300WAu80fOr)llaPl()~'+'000000000000000000000009900000099HA990008PBAHPB1008RPRRBR1008R9999R1008RRRRRR1008RRJIII1008RRJaaK2008RRJaaKK008RRJKIKI208RRJaaaa208RRJKIIY208RRJaaaa208PRJKIIY20099Haaaa200000IIII0000000000000000000000#';
  tepPasteToFit='T3K00K00)300WAu80fOr)llaPl()~'+'000000000000000000000009900000099HA990008PBAHPB1008RPRRBR1008R9999R1008RRRRRR1008RRJYKYK208RRZaaaa408RRZaaaa408RRJKIaa208RRJaaaa208RRZKIIY408RRZaaaa408PRJKIIY20099Haaaa20000WKYKY4000000000000000000000#';
  tepClear='T2K00K00)3000fOrPl()~'+'000000000000000000000GLL0000fgM000GggP000agQL000fgg600Gggg100aggQ000fgg600Gggg100aggQ000fgg600Gggg100GLL500000000000000000000000000000#';
  tepSelectAll='T2K00K00)3000fOrPl()~'+'000000000000000000000GLL0000fgM000GggP000aLfL000PLf600GMLf100aLLP000PLL600GMLb100aLLP000PLL600Gggg100GLL500000000000000000000000000000#';
  tepUpper='T1K00K00)3000fOr~'+'00000000000000y30mF00i10m60Wx00630OC0m)10)706m0yn7m7V00000000000000#';
  tepLower='T1K00K00)3000fOr~'+'000000000000000000000000uF0m)10060mV0m)1W3606S0u)30)E00000000000000#';
  tepFlip='T2K00K00)300Kqv2OdA9~'+'000000000000000000000000000000000000K10000G050000100000G00000gcggA0Wgfgg2000100000G010000GK00000G500000L10000KL00000000000000000000000#';
  tepMirror='T2K00K00)300OdA9Kqv2~'+'00000000000000000000000K000000500000G100000KW000gA5800WgG1800e2K0200A25W00W0Q120000eA00000500000G100000K000000500000000000000000000000#';
  tepRotate90='T2K00K00)300Kqv2OdA9~'+'0000000000000000001000WgK000W2G500020L100W0KL000200W00W0008008000200200W00W000800GL1W000K508000L0e000GXg000040000000000000000000000000#';
  tepBrushProperties='T2K00K00)3000fOr)lla~'+'0000000000000000000000000K00000G600000P00000a10000G600000P00000a10000G600000P00000L10000a50000LM10000L50000000000000000000000000000000#';
  tepOpenBrush='T3P00K00)300Kqv20fOr)llaWAu8)xVb))))V7CQ~'+'000000000000000000000000000000000000000000091000G20000010110GJ0000000090GJ00Wa000091GJ00Wrbaaa00GJ000qrrrr40GJ000Wrrrrb0GJ0000qrbaaaKJ0000Wrb)))NJ00000qb)))II00000Wb)))QI000000a))IQI2000000aaaII20000000000000000000000000000000000000000000000000000000'+'#';
  tepUndo='T1K00K00)300Kqv2~'+'0000000000000000000000000F0431m2807W0y02m7400G000000000000000000000#';
  tepNew='T2K00K00)3000fOrPl()~'+'000000000000000000000GLL0000fgM000GggP000agQL000fgg600Gggg100aggQ000fgg600Gggg100aggQ000fgg600Gggg100GLL500000000000000000000000000000#';
  tepOpen='T3K00K00)300Kqv2WAu8)xVb))))V7CQ~'+'0000000000000000000000000000000000089000000001011000000008100GI00009100QSIII20000YZZZZ20000QSSSS20000YZJIIII200QSgjjjj200YJjjjjL000Qgjjjj2000IjjjjL0000GIIII20000000000000000000000000000000000000000000#';
  tepSaveAs='T3K00K00)300hjspiow)))))xkx)zrNr~'+'00000000000000000000009999990008IIIIII1008IRRRRI1008IZaaSI1008IRRRRI1008IZaaSI1008IRRRRI1008IIIIII1008IIIIII1008IjjjjL1008IjjjRL1008IjjjRL1008IjjjRL1000999999000000000000000000000000000000000000000000#';
  tepPrint='T5K00K00)300RkvaPl()uEz)kuY9GUv))ztPV)z)hjspmEx))x)bWMw)Kqv28jqVr1u)G3z)tkx)i5tlyztlpTtl~'+'000000000000000000000000000000000000000000000000011100000000000000001222110000000000000132222244000000000563322224000000000557633322488000000057999663349898800000577AA996649999B8000057997CC9BDB9BEE8000057999979F9BEEEE80000559999G7BEEEEH88000005559999'+'EEEH8E80000008FF5599EH8EEHH000000088FF5I8EEE80000000000088F9EE88000000000000008J8800000000000000000000000000000000000000000000000000000000000000000000#';
  tepAdd='T2K00K00)300jm7pPl()~'+'000000000000000000000KLLL00GgggQ00agcg600fgfg10GgQgQ00agcg600fLLf10GgQgQ00agcg600fgfg10GgQgQ00aggg600KLLL00000000000000000000000000000#';
  tepDel='T2K00K00)300jm7pPl()~'+'000000000000000000000KLLL00GgggQ00aggg600fggg10GgggQ00aggg600fLLf10GgggQ00aggg600fggg10GgggQ00aggg600KLLL00000000000000000000000000000#';
  tepOpenN='T3K00K00)300Kqv2WAu8)xVb))))V7CQ~'+'0000000000000000000000000009000000000900000000999000000099900GI00009000QSIII29000YZZZZ20000QSSSS20000YZJIIII200QSgjjjj200YJjjjjL000Qgjjjj2000IjjjjL0000GIIII20000000000000000000000000000000000000000000#';
  tepCenter='T2K00K00)300jm7pPl()~'+'000000000000000000000KLLL00GgggQ00aggg600fggg10GgQgQ00agcg600fMLg10GgQgQ00agcg600fggg10GgggQ00aggg600KLLL00000000000000000000000000000#';
  tepInfo='T2K00K00)3000fOr))))~'+'000000000LL0000bgQ100aMLf10GMLLb10PLfLb1GMLQLP0PLLLLPGMLLLL6aLLQLb1PLbMLPGMLfLL6aLLQLb1aLbML60PLfLb10PLLL600fLLQ000bgQ1000KL1000000000#';
  tepHelp='T2K00K00)3000fOr))))~'+'000000000LL0000bgQ100aMLf10GMfQb10PbgQb1GMgLQP0PbMbMPGMLLgL6aLLfMb1PLbQLPGMLfLL6aLLQLb1aLLLL60PLfLb10PLQL600fLLQ000bgQ1000KL1000000000#';
  tepTextWndColor='T3K00K00)3000fOr))))RlV)14Sq~'+'0000000000000000000000000000000999999990899999999189999999918IIIIIIII18IIIIIIII18I9999II918IIIIIIAB98IIIIII9998I999999998IIIIIAB918IIIIIPB918I9999RCI18IIIIPZHI18IIIARCII10999PZ99900000XC00000000910000#';
  tepWndColor='T3K00K00)3000fOr)xVb))))RlV)14Sq~'+'000000000000000000000000000000099999999089IIIIII9189999999918RRRRRRRR18RRRRRRRR18RRRRRRR918RRRRRRBC98RRRRRR9998RRRRRR9998RRRRRBC918RRRRRXC918RRRRBaDR18RRRRXiPR18RRRBaDRR10999Xi99900000fD00000000910000#';
  tepListColor='T3K00K00)3000fOr))))WAu8Kqv2RlV)14Sq~'+'000000000000000000000000000000000000000009999999908IIIIIIII18QYaaaaaK18IIIIIIII18QYaaaaK918IIIIIIAD98QYaaaK9998IIIIII9998QYaaKAD918IIIIIfD918QYaaAjEI18IIIIfrHI18IIIAjEII10999fr99900000nE00000000910000#';
  tepLinkColor='T2K00K00)3000fOrRlV)14Sq~'+'000000000000000000000000000G1K0500G0G04004040100101G00G040H504G00P50140KL1G010LL0L05aL1000GQ50KLLfN00LLbU5000Gw10000f70000GV00000K1000#';
{}//yyyy

{thashtable}
  HashKeyBits		= 13;			//Max number of bits per Hash Key
  HashSize		= 8009;			//Size of hash table, must be prime, must be > than HashMaxCode, must be < than HashMaxKey
  HashKeyMax		= (1 SHL HashKeyBits)-1;//Max hash key value, 13 bits = 8191
  HashKeyMask		= HashKeyMax;		//$1FFF
  GIFCodeBits		= 12;			//Max number of bits per GIF token code
  GIFCodeMax		= (1 SHL GIFCodeBits)-1;//Max GIF token code
  GIFCodeMask		= GIFCodeMax;		//$0FFF
  HashEmpty		= $000FFFFF;		//20 bits
  GIFTableMaxMaxCode	= (1 SHL GIFCodeBits);
  GIFTableMaxFill	= GIFTableMaxMaxCode-1;	//Clear table when it fills to

  //Windows Sockets
  winsocket = 'wsock32.dll';
  winsocketVersion=$0101;//windows 95 compatiable
  CM_SOCKETMESSAGE = WM_USER + $0001;
  CM_SYSTRAYMESSAGE= WM_USER + $0002;
  SOL_SOCKET       = $ffff;          {options for socket level }
  SOMAXCONN        = 5;
  //Option for opening sockets for synchronous access
  SO_OPENTYPE     = $7008;
  SO_SYNCHRONOUS_ALERT    = $10;
  SO_SYNCHRONOUS_NONALERT = $20;
  SO_ACCEPTCONN   = $0002;          { socket has had listen() }
  SO_KEEPALIVE    = $0008;          { keep connections alive }
  SO_LINGER       = $0080;          { linger on close if data present }
  SO_DONTLINGER  =   $ff7f;

  INADDR_ANY       = $00000000;
  INADDR_LOOPBACK  = $7F000001;
  INADDR_BROADCAST = $FFFFFFFF;
  INADDR_NONE      = $FFFFFFFF;

  WSADESCRIPTION_LEN     =   256;
  WSASYS_STATUS_LEN      =   128;

  //This is used instead of -1, since the TSocket type is unsigned
  INVALID_SOCKET		= TSocket(NOT(0));
  SOCKET_ERROR			= -1;

  //Address families
  AF_UNSPEC       = 0;               { unspecified }
  AF_UNIX         = 1;               { local to host (pipes, portals) }
  AF_INET         = 2;               { internetwork: UDP, TCP, etc. }

  //Protocol families - same as address families for now. }
  PF_UNSPEC       = AF_UNSPEC;
  PF_UNIX         = AF_UNIX;
  PF_INET         = AF_INET;

  //Types
  SOCK_STREAM     = 1;               { stream socket }
  SOCK_DGRAM      = 2;               { datagram socket }
  SOCK_RAW        = 3;               { raw-protocol interface }
  SOCK_RDM        = 4;               { reliably-delivered message }
  SOCK_SEQPACKET  = 5;               { sequenced packet stream }

  //Protocols
  IPPROTO_IP     =   0;             { dummy for IP }
  IPPROTO_ICMP   =   1;             { control message protocol }
  IPPROTO_IGMP   =   2;             { group management protocol }
  IPPROTO_GGP    =   3;             { gateway^2 (deprecated) }
  IPPROTO_TCP    =   6;             { tcp }
  IPPROTO_PUP    =  12;             { pup }
  IPPROTO_UDP    =  17;             { user datagram protocol }
  IPPROTO_IDP    =  22;             { xns idp }
  IPPROTO_ND     =  77;             { UNOFFICIAL net disk proto }
  IPPROTO_RAW    =  255;            { raw IP packet }
  IPPROTO_MAX    =  256;

  //Define flags to be used with the WSAAsyncSelect
  FD_READ         = $01;
  FD_WRITE        = $02;
  FD_OOB          = $04;
  FD_ACCEPT       = $08;
  FD_CONNECT      = $10;{=16}
  FD_CLOSE        = $20;{=32}

  IOCPARM_MASK = $7f;
  IOC_VOID     = $20000000;
  IOC_OUT      = $40000000;
  IOC_IN       = $80000000;
  IOC_INOUT    = (IOC_IN or IOC_OUT);

  FIONREAD     = IOC_OUT or { get # bytes to read }
    ((Longint(SizeOf(Longint)) and IOCPARM_MASK) shl 16) or
    (Longint(Byte('f')) shl 8) or 127;
  FIONBIO      = IOC_IN or { set/clear non-blocking i/o }
    ((Longint(SizeOf(Longint)) and IOCPARM_MASK) shl 16) or
    (Longint(Byte('f')) shl 8) or 126;
  FIOASYNC     = IOC_IN or { set/clear async i/o }
    ((Longint(SizeOf(Longint)) and IOCPARM_MASK) shl 16) or
    (Longint(Byte('f')) shl 8) or 125;

{ All Windows Sockets error constants are biased by WSABASEERR from the "normal" }

  WSABASEERR              = 10000;

{ Windows Sockets definitions of regular Microsoft C error constants }

  WSAEINTR                = (WSABASEERR+4);
  WSAEBADF                = (WSABASEERR+9);
  WSAEACCES               = (WSABASEERR+13);
  WSAEFAULT               = (WSABASEERR+14);
  WSAEINVAL               = (WSABASEERR+22);
  WSAEMFILE               = (WSABASEERR+24);

{ Windows Sockets definitions of regular Berkeley error constants }

  WSAEWOULDBLOCK          = (WSABASEERR+35);
  WSAEINPROGRESS          = (WSABASEERR+36);
  WSAEALREADY             = (WSABASEERR+37);
  WSAENOTSOCK             = (WSABASEERR+38);
  WSAEDESTADDRREQ         = (WSABASEERR+39);
  WSAEMSGSIZE             = (WSABASEERR+40);
  WSAEPROTOTYPE           = (WSABASEERR+41);
  WSAENOPROTOOPT          = (WSABASEERR+42);
  WSAEPROTONOSUPPORT      = (WSABASEERR+43);
  WSAESOCKTNOSUPPORT      = (WSABASEERR+44);
  WSAEOPNOTSUPP           = (WSABASEERR+45);
  WSAEPFNOSUPPORT         = (WSABASEERR+46);
  WSAEAFNOSUPPORT         = (WSABASEERR+47);
  WSAEADDRINUSE           = (WSABASEERR+48);
  WSAEADDRNOTAVAIL        = (WSABASEERR+49);
  WSAENETDOWN             = (WSABASEERR+50);
  WSAENETUNREACH          = (WSABASEERR+51);
  WSAENETRESET            = (WSABASEERR+52);
  WSAECONNABORTED         = (WSABASEERR+53);
  WSAECONNRESET           = (WSABASEERR+54);
  WSAENOBUFS              = (WSABASEERR+55);
  WSAEISCONN              = (WSABASEERR+56);
  WSAENOTCONN             = (WSABASEERR+57);
  WSAESHUTDOWN            = (WSABASEERR+58);
  WSAETOOMANYREFS         = (WSABASEERR+59);
  WSAETIMEDOUT            = (WSABASEERR+60);
  WSAECONNREFUSED         = (WSABASEERR+61);
  WSAELOOP                = (WSABASEERR+62);
  WSAENAMETOOLONG         = (WSABASEERR+63);
  WSAEHOSTDOWN            = (WSABASEERR+64);
  WSAEHOSTUNREACH         = (WSABASEERR+65);
  WSAENOTEMPTY            = (WSABASEERR+66);
  WSAEPROCLIM             = (WSABASEERR+67);
  WSAEUSERS               = (WSABASEERR+68);
  WSAEDQUOT               = (WSABASEERR+69);
  WSAESTALE               = (WSABASEERR+70);
  WSAEREMOTE              = (WSABASEERR+71);

  WSAEDISCON              = (WSABASEERR+101);

{ Extended Windows Sockets error constant definitions }

  WSASYSNOTREADY          = (WSABASEERR+91);
  WSAVERNOTSUPPORTED      = (WSABASEERR+92);
  WSANOTINITIALISED       = (WSABASEERR+93);

{ Error return codes from gethostbyname() and gethostbyaddr() => "WSABASEERR+1001"}

  WSAHOST_NOT_FOUND       = (WSABASEERR+1001);
  WSATRY_AGAIN            = (WSABASEERR+1002);
  WSANO_RECOVERY          = (WSABASEERR+1003);
  WSANO_DATA              = (WSABASEERR+1004);

{multi-media}
  //general
  MM_MCINOTIFY        = $3B9;
  //flags for wParam of MM_MCINOTIFY message
  MCI_NOTIFY_SUCCESSFUL           =$0001;
  MCI_NOTIFY_SUPERSEDED           =$0002;
  MCI_NOTIFY_ABORTED              =$0004;
  MCI_NOTIFY_FAILURE              =$0008;
  //common flags for dwFlags parameter of MCI command messages
  MCI_NOTIFY                      =$00000001;
  MCI_WAIT                        =$00000002;
  MCI_FROM                        =$00000004;
  MCI_TO                          =$00000008;
  MCI_TRACK                       =$00000010;
  //flags for dwFlags parameter of MCI_OPEN command message
  MCI_OPEN_SHAREABLE              =$00000100;
  MCI_OPEN_ELEMENT                =$00000200;
  MCI_OPEN_ALIAS                  =$00000400;
  MCI_OPEN_ELEMENT_ID             =$00000800;
  MCI_OPEN_TYPE_ID                =$00001000;
  MCI_OPEN_TYPE                   =$00002000;
  //MCI command message identifiers
  MCI_OPEN                        =$0803;
  MCI_CLOSE                       =$0804;
  MCI_ESCAPE                      =$0805;
  MCI_PLAY                        =$0806;
  MCI_SEEK                        =$0807;
  MCI_STOP                        =$0808;
  MCI_PAUSE                       =$0809;
  MCI_INFO                        =$080A;
  MCI_GETDEVCAPs                  =$080B;
  MCI_SPIN                        =$080C;
  MCI_SET                         =$080D;
  MCI_STEP                        =$080E;
  MCI_RECORD                      =$080F;
  MCI_SYSINFO                     =$0810;
  MCI_BREAK                       =$0811;
  MCI_SOUND                       =$0812;
  MCI_SAVE                        =$0813;
  MCI_STATUS                      =$0814;
  MCI_CUE                         =$0830;
  MCI_REALIZE                     =$0840;
  MCI_WINDOW                      =$0841;
  MCI_PUT                         =$0842;
  MCI_WHERE                       =$0843;
  MCI_FREEZE                      =$0844;
  MCI_UNFREEZE                    =$0845;
  MCI_LOAD                        =$0850;
  MCI_CUT                         =$0851;
  MCI_COPY                        =$0852;
  MCI_PASTE                       =$0853;
  MCI_UPDATE                      =$0854;
  MCI_RESUME                      =$0855;
  MCI_DELETE                      =$0856;
  //flags for dwFlags parameter of MCI_STATUS command message
  MCI_STATUS_ITEM                 =$00000100;
  MCI_STATUS_START                =$00000200;
  //flags for dwItem field of the MCI_STATUS_PARMS parameter block
  MCI_STATUS_LENGTH               =$00000001;
  MCI_STATUS_POSITION             =$00000002;
  MCI_STATUS_NUMBER_OF_TRACKS     =$00000003;
  MCI_STATUS_MODE                 =$00000004;
  MCI_STATUS_MEDIA_PRESENT        =$00000005;
  MCI_STATUS_TIME_FORMAT          =$00000006;
  MCI_STATUS_READY                =$00000007;
  MCI_STATUS_CURRENT_TRACK        =$00000008;

{managed states}
  msFree      =0;
  msHold      =1;
  msQueued    =2;
  msWorking   =3;
  msFinished  =4;

{tmt}
  mtNilTimer  =0;

{TWebHeaders}
  //core
  wbhcMax=49;
  //clear style
  wbcsExcludeTEMP=0;
  wbcsExcludeSYSTEM=1;
  //names - standard
  // .system
  wbnSystem='__';{all names begining with "wbnSystem" are not included in "GetText"}
  wbnMethod=wbnSystem+'method';//methode ie. GET/POST or HEAD
  wbnURL=wbnSystem+'url';
  wbnProxyURL=wbnSystem+'proxyurl';
  wbnFilename=wbnSystem+'filename';//filename
  wbnHTTPv=wbnSystem+'httpv';//http version being used
  wbnMUV=wbnSystem+'muv';//first line of header
  // .system.internal
  wbnIdletime=wbnSystem+'idletime';
  wbnState=wbnSystem+'state';
  // .mode
  wbnProxyConnection='proxy-connection';
  wbnConnection='connection';
  wbnAcceptEncoding='accept-encoding';
  // .sender
  wbnOriginalSender='original-sender';
  wbnReferer='referer';
  wbnUserAgent='user-agent';
  wbnAcceptLanguage='accept-language';
  // .content
  wbnContentType='content-type';
  wbnContentLength='content-length';
  wbnContent='content';
  // .other
  wbnHost='host';

{TLookupName}
  //Modes
  lnimFree=0;
  lnimHold=1;
  lnimOpen=2;
  //Other
  lnccMax=1999;

{TTextPicture TEP}
  tpccSOF=29;{Encoded Value - Start of File}
  tpccEOF=35;{End of File}
  tpccEOP=126;{End of Palette}
  tpccStartComment=123;// '{'
  tpccEndComment=125;// '}'
  tpccMaxInt=16777216;
  {Styles - Save Only}
  tpscPlain=0;{Single String}
  tpscBlocks=1;{Blocks of no more than 255 char's separated by "'+'"}
  tpscLines=2;{Lines, each terminated by RCode}
  tpscMax=2;
  {Colors}
  tpsbMinBPP=1;
  tpsbMaxBPP=6;
  tpsbDefault=tpsbMaxBPP;
  tpsbBPPAsPixels:Array[0..6] of Byte=(0,6,3,2,1,1,1);

{TByteBuffer}
  bbccMax=2047;
  bbccMaxSize=bbccMax+1;

{TByteStream}
  bssmSeekForward=0;
  bssmSeekBackward=1;
  bssmSeekMiddle=2;
  bssmSeekMax=2;

{TRGBPalette - upto 256 colors}
  rpccMax=255;
  rpccPal8:Array[0..7] of Integer=(clBlack,clRed,clYellow,clLime,clBlue,clSilver,clGray,clWhite);
  rpccBPPS:Array[0..8] of Integer=(0,2,4,8,16,32,64,128,256);{bbp:colors}

{TIconHeader}
  ihInfoSize=22;
  ihInfoDataSize=40;
  ihSize=ihInfoSize+ihInfoDataSize;
  ihMax=ihSize-1;
  ihMinSize=1;{Width/Height}
  ihMaxSize=127;{MaxDimension}

{TXBitmap}
  //core
  xblcDefine='#DEFINE';
  xblcDefineLen=Length(xblcDefine);
  xblcWidth='_WIDTH';
  xblcWidthLen=Length(xblcWidth);
  xblcHeight='_HEIGHT';
  xblcHeightLen=Length(xblcHeight);
  xblcStatic='STATIC';
  xblcStaticLen=Length(xblcStatic);
  xblcDataStart=123;// '{'
  xblcDataFinish=125;// '}'

{TPortablePixelmap PPM/PGB/PBM}
  //core
  ppccComment=Ord('#');
  //styles
  pphsMonoA=1;
  pphsMonoB=pphsMonoA+3;
  pphsGreyA=2;
  pphsGreyB=pphsGreyA+3;
  pphsRGBA=3;
  pphsRGBB=pphsRGBA+3;
  pphsAscii=pphsRGBA;
  pphsMin=pphsMonoA;
  pphsMax=pphsRGBB;
  pphsNewLine=#10;

{TOptimisedImage OMI}
  //core
  omicOMIV1='OMIV1.0';
  //style
  omicJPG='JPG';
  omicBMP='BMP';
  omicNil='';

{tnetwork}
  ip1=1;
  ip2=256;
  ip3=256*256;
  ip4=256*256*256;
  ip127_0_0_1=(127*ip1)+(0*ip2)+(0*ip3)+(1*ip4);
  //header size limit - 32Kb
  nwHeaderLimit=32*1024;
  nwMinThrottle=256;
  nwMaxThrottle=20480000;//20Mb/sec

{ttbt}
  tbtFeedback =0;
  tbtEncode   =1;
  tbtDecode   =2;

{taudio}
  //core
  aoeMaxFilter                        =49;//50 user definable filter panels (5 filters per channel)
  aoeByte0                            =0;
  aoeByte1                            =1;
  aoeMaxTrack                         =9;//10 tracks (2 are master left/right)
  aoeMasterLeft                       =0;
  aoeMasterRight                      =5;
  aoeLeft                             =(aoeMaxTrack div 2);//0..4

{programvars}
  //var types
  pvtBol=0;
  pvtInt=1;
  pvtCur=2;
  pvtStr=3;
  pvtLab=4;//label
  //code sep
  pvcSep=#32;//separator

{tmanagedserver}//22 vars "0..21"
  msrPort                  =0;
  msrLogs                  =1;
  msrRequireAuthorisation  =2;
  msrUserName              =3;
  msrPassword              =4;
  msrSecurityIP3           =5;//5..7
  msrMimeTypes             =8;
  msrForceClose            =9;
  msrIPlimit               =10;//max concurrent connections
  msrTransferRate          =11;
  msrTimeout               =12;
  msrFilterA2              =13;//13..14
  msrFilterB2              =15;//15..16
  msrFilterC2              =17;//17..18
  msrFilterD2              =19;//19..20
  msrIncludeInheaders      =21;//21..21

{tudpex}
  //limits
  udlHead                  =5;//id(4)+status(1)
  udlPacket                =512;
  udlData                  =udlPacket-udlHead;//507
  udlDataLimit             =udlData*2;//1014
  udlIDLimit               =2147483640;
  //id types
  udiNil                   =0;
  udiClient                =1;//1..N
  udiServer                =-1;//-1..-N

{tnavbase etc}
  //sep
  nsSep                    ='-';
  //types
  ntInternal               ='*'+nsSep;//safe, can't be used as an address, so ok for use as internal referencing
  ntFull                   ='f'+nsSep;
  ntPartial                ='p'+nsSep;
  //actions
  //.internal
  naHome                   =ntInternal+'home';//*
  naSettings               =ntInternal+'settings';//*
  naBookmarks              =ntInternal+'bookmarks';//*
  //.full
  naLocal                  =ntFull+'local';//*
  naUrl                    =ntFull+'url';//*
  naEmail                  =ntFull+'email';
  //.partial
  naHost                   =ntPartial+'host';
  naUp                     =ntPartial+'up';
  naNav                    =ntPartial+'nav';
  naFolder                 =ntPartial+'folder';
  naFile                   =ntPartial+'file';
  //Note: * indicates name has extra purpose, to describe nav panels so as to know which
  //      to switch to etc.

{tudpbasic}
    //styles - tudpbasic
    ubsServer                      ='s';//server
    ubsReliable                    ='r';//client - reliable
    ubsUnreliable                  ='u';//client - unreliable
    ubsRaw                         ='$';//client - raw packet

{taudiobasic}
    //other
    mmsyst='winmm.dll';
    CALLBACK_TYPEMASK   = $00070000;    { callback type mask }
    CALLBACK_NULL       = $00000000;    { no callback }
    CALLBACK_WINDOW     = $00010000;    { dwCallback is a HWND }
    CALLBACK_TASK       = $00020000;    { dwCallback is a HTASK }
    CALLBACK_FUNCTION   = $00030000;    { dwCallback is a FARPROC }
    CALLBACK_THREAD     = CALLBACK_TASK;{ thread ID replaces 16 bit task }
    CALLBACK_EVENT      = $00050000;    { dwCallback is an EVENT Handle }
{ flags for dwFlags field of WAVEHDR }
    WHDR_DONE       = $00000001;  { done bit }
    WHDR_PREPARED   = $00000002;  { set if this header has been prepared }
    WHDR_BEGINLOOP  = $00000004;  { loop start block }
    WHDR_ENDLOOP    = $00000008;  { loop end block }
    WHDR_INQUEUE    = $00000010;  { reserved for driver }
    MM_WOM_OPEN         = $3BB;
    MM_WOM_CLOSE        = $3BC;
    MM_WOM_DONE         = $3BD;
    WAVE_FORMAT_QUERY     = $0001;
    WAVE_ALLOWSYNC        = $0002;
    WAVE_MAPPED           = $0004;

type
  {forward declarations}
  tudppackets=class;
  twebheaders=class;
  tbitmapenhanced=class;
  tipfilter=class;
  tmanagedserver=class;
  tserverbasic=class;

  PServEnt = ^TServEnt;
  TServEnt = packed record
    s_name: PChar;
    s_aliases: ^PChar;
    s_port: Smallint;
    s_proto: PChar;
    end;//end of record

  PHostEnt = ^THostEnt;
  THostEnt = packed record
    h_name: PChar;
    h_aliases: ^PChar;
    h_addrtype: Smallint;
    h_length: Smallint;
    case Byte of
      0: (h_addr_list: ^PChar);
      1: (h_addr: ^PChar)
    end;//end of record

  PWSAData = ^TWSAData;
  TWSAData = packed record
    wVersion: Word;
    wHighVersion: Word;
    szDescription: array[0..WSADESCRIPTION_LEN] of Char;
    szSystemStatus: array[0..WSASYS_STATUS_LEN] of Char;
    iMaxSockets: Word;
    iMaxUdpDg: Word;
    lpVendorInfo: PChar;
    end;//end of record

  SunB = packed record
    s_b1, s_b2, s_b3, s_b4: u_char;
    end;

  SunW = packed record
    s_w1, s_w2: u_short;
    end;

  PInAddr = ^TInAddr;
  TInAddr = packed record
    case integer of
      0: (S_un_b: SunB);
      1: (S_un_w: SunW);
      2: (S_addr: u_long);
    end;//end of record

  PSockAddrIn = ^TSockAddrIn;
  TSockAddrIn = packed record
    case Integer of
      0: (sin_family: u_short;
          sin_port: u_short;
          sin_addr: TInAddr;
          sin_zero: array[0..7] of Char);
      1: (sa_family: u_short;
          sa_data: array[0..13] of Char)
    end;//end of record

  PSockAddr = ^TSockAddr;
  TSockAddr = TSockAddrIn;

{tass}
    tass=class(trootobject)//audio support system
    private

    public
     //create
     constructor create; override;
     destructor destroy; override;
     //workers
     function findformat(var x,format:string;var binary:boolean):boolean;
     function findformatb(var x:string):string;
     function supportformat(filenameorext:string):boolean;
     function extlabel(extorfilename:string;var z:string):boolean;
     //formats
     procedure playpcs(x:string);
     procedure playssd(x:string);
    end;

{tmm}
    MCIERROR = DWORD;     { error return code, 0 means no error }
    MCIDEVICEID = UINT;   { MCI device ID type }
    PMCI_Generic_Parms=^TMCI_Generic_Parms;
    TMCI_Generic_Parms=record
      dwCallback:DWORD;
      end;
    PMCI_Open_ParmsA=^TMCI_Open_ParmsA;
    PMCI_Open_Parms=PMCI_Open_ParmsA;
    TMCI_Open_ParmsA=record
      dwCallback:DWORD;
      wDeviceID:MCIDEVICEID;
      lpstrDeviceType:PAnsiChar;
      lpstrElementName:PAnsiChar;
      lpstrAlias:PAnsiChar;
      end;
    TMCI_Open_Parms=TMCI_Open_ParmsA;
    PMCI_Play_Parms=^TMCI_Play_Parms;
    TMCI_Play_Parms=record
      dwCallback:DWORD;
      dwFrom:DWORD;
      dwTo:DWORD;
      end;
    PMCI_Status_Parms=^TMCI_Status_Parms;
    TMCI_Status_Parms=record
      dwCallback:DWORD;
      dwReturn:DWORD;
      dwItem:DWORD;
      dwTrack:DWORD;
      end;
    PMCI_Seek_Parms=^TMCI_Seek_Parms;
    TMCI_Seek_Parms=record
      dwCallback:DWORD;
      dwTo:DWORD;
      end;
    tmmodes=(mmNotReady,mmStopped,mmPlaying,mmRecording,mmSeeking,mmPaused,mmOpen);
    tmm=class(trootobject)
    private
     istate:byte;
     ideviceid:word;
     ihandle:hwnd;
     ifilename:string;
     istoplock,istopwait,ivalid:boolean;
     function getplaying:boolean;
     procedure _stop;
     function _open(var e:string):boolean;
     function _play(var e:string):boolean;
     function gethandle:hwnd;
     procedure wndproc(var message:tmessage);
     function getmode:tmmodes;
     function getposition:longint;
     procedure setposition(x:longint);
     function getlength:longint;
    public
     //events
     onnotify:tnotifyevent;
     //create
     constructor create; override;
     destructor destroy; override;
     //workers
     //.play
     function canplay:boolean;
     function play(x:string;var e:string):boolean;
     property playing:boolean read getplaying;
     //.stop
     function canstop:boolean;
     procedure stop;
     //.information
     property position:integer read getposition write setposition;
     property length:integer read getlength;
     property mode:tmmodes read getmode;
     property filename:string read ifilename;
     property state:byte read istate;
     //.handle
     property handle:hwnd read gethandle;
    end;

{tmapperip}
    tmapperip=class(trootobject)
    private
     imax:integer;
     iips:array[0..1] of tdynamicinteger;
     function gettext:string;
     procedure settext(x:string);
    public
     //create
     constructor create; override;
     destructor destroy; override;
     //workers
     procedure clear;
     function add(s,d:integer):boolean;
     property text:string read gettext write settext;//format <source IPv4>=<dest. IPv4>, eg. 10.0.0.20=44.77.21.36
     //find  - sIP -> dIP
     function ip(sip:integer):integer;
     function find(sip:integer;var dip:integer):boolean;
     function findex(sip:integer;var dip,index:integer):boolean;
     //reverse find - dIP -> sIP
     function rip(dip:integer):integer;
     function rfind(dip:integer;var sip:integer):boolean;//reverse lookup
     function rfindex(dip:integer;var sip,index:integer):boolean;
     //information
     function count:integer;
    end;

{tfonts}
    tfontsstyle=(fnsNil,fnsScreen,fnsPrinter,fnsBoth);
    tfonts=class(trootobject)
    private
     inames:tdynamicname;
     istyles:tdynamicbyte;
     istyle:tfontsstyle;
     icount:integer;
     procedure setstyle(x:tfontsstyle);
     function getname(x:integer):string;
     function getstyle(x:integer):tfontsstyle;
     function getscreen(x:integer):boolean;
     function getprinter(x:integer):boolean;
     function gettext:string;
    public
     //create
     constructor create; override;
     constructor createsys(sysVar:prootobject); override;
     destructor destroy; override;
     //style
     property style:tfontsstyle read istyle write setstyle;
     //names
     property count:integer read icount;
     property names[x:integer]:string read getname;
     property styles[x:integer]:tfontsstyle read getstyle;
     function stylelabel(x:tfontsstyle;sep,s,p:string):string;
     property isScreen[x:integer]:boolean read getscreen;
     property isPrinter[x:integer]:boolean read getprinter;
     property text:string read gettext;
     //find
     function find(x:string):integer;
     procedure refresh;
     //internal
     property _names:tdynamicname read inames;
     property _styles:tdynamicbyte read istyles;
    end;

{tmt - multitimer}
    ttimertask=class;
    tmt=class(trootobject)//now uses priority control (ie. only fire event when needed)
    private
     ishutdown,ihooked:boolean;
     iminutesindex,iminutes:currency;
     itask:ttimertask;
     istate:tdynamicbyte;
     ievent:tdynamicnotifyevent;
     iref,iinterval:tdynamiccurrency;
     ienabled:tdynamicboolean;
     procedure _ontimer(sender:tobject);
     function getsize:integer;
     procedure setsize(x:integer);
     property size:integer read getsize write setsize;
     function getevent(x:integer):tnotifyevent;
     procedure setevent(x:integer;y:tnotifyevent);
     function getinterval(x:integer):currency;
     procedure setinterval(x:integer;y:currency);
     function getenabled(x:integer):boolean;
     procedure setenabled(x:integer;y:boolean);
     function onappmsg(var Message: TMessage):boolean;
     function valid(x:integer):boolean;
     function canvalue(x:integer):boolean;
    public
     //create
     constructor create; override;
     destructor destroy; override;
     procedure closing;//system closing
     //minutes
     property minutes:currency read iminutes write iminutes;
     procedure minutesreset;
     function minutespartial:currency;
     //slow
     procedure slowoff(var secref:currency);
     procedure slowon(var secref:currency);
     function slowauto(var secref:currency;_interval:currency):currency;
     //other
     function new(_event:tnotifyevent;_interval:currency;_enabled:boolean):integer;
     procedure del(var _instance:integer);
     property event[x:integer]:tnotifyevent read getevent write setevent;
     property interval[x:integer]:currency read getinterval write setinterval;
     property enabled[x:integer]:boolean read getenabled write setenabled;
     property count:integer read getsize;
     procedure clear;
    end;

{trates}
    tratestyle=(rtesTotal,rtesGood,rtesBad,rtesOther);
    trateunits=(rteuDay,rteuHour,rteuMin,rteuSec,rteuPercentage);
    trates=class(tobject)
    private
     iclearongo,igoing:boolean;
     istarttime,ifinishtime:currency;
     icounts:array[0..3] of currency;
     iunits:array[0..3] of integer;
     function gettimeperiod:currency;
     procedure setgoing(x:boolean);
     procedure sync;
    public
     //create
     constructor create;
     //go-stop
     property going:boolean read igoing write setgoing;
     property clearongo:boolean read iclearongo write iclearongo;
     procedure go;
     procedure stop;
     procedure clear;
     //rates
     function rate(_s:tratestyle;_u:trateunits):currency;
     function ratestr(_s:tratestyle;_u:trateunits):string;
     property timeperiod:currency read gettimeperiod;
     function value(_s:tratestyle):currency;
     procedure incby(_s:tratestyle;_by:currency);
     procedure incone(_s:tratestyle);
    end;

{ttask}
    ttaskmode=(tkmFree,tkmInUse,tkmStopping,tkmCreate,tkmDestroy);
    ttask=class(tthread)//Warning: do not create a "tthread" object when system is shuting down otherwise Delphi can crash
    private
     imode:ttaskmode;
     ivalid:boolean;
     procedure _ontask; virtual;
     function getrunning:boolean;
     procedure _suspend;
     procedure _stop;
     procedure _run;
    protected
     procedure execute; override;
     procedure dotask; virtual;
     procedure doontask;
     procedure _ondestroy; virtual;
     procedure resume;
     procedure suspend;
     procedure terminate;
    public
     //events
     ontask:tnotifyevent;
     //create
     constructor create;
     destructor destroy; override;
     procedure free;
     //workers
     property running:boolean read getrunning;
     procedure run;
     procedure stop;
     function quit:boolean;
    end;

{ttimertask}
    ttimertask=class(ttask)
    public
     //vars
     interval:currency;
     next:currency;
     //other
     procedure dotask; override;
    end;

{tnetworkptr}
    tnetworkptr=record
       case integer of
       0:(c:currency);
       1:(index:integer;id:integer);
       end;

{tlookupthread}
    tlookupthread=class(ttask)
     host:string;
     ip:integer;
     ptr:tnetworkptr;
     procedure _netstart;
     procedure _general;
     procedure dotask; override;
    end;

{tlookuphistory}
    tlookuphistory=class(tobject)
    private//defaults: size=256, timeout=10,000 (10sec)
     itimeout:currency;
     iindex,imax,isize:integer;
     ihost:tdynamicname;
     itime:tdynamiccurrency;
     iip:tdynamicinteger;
     ihold:tdynamicboolean;
     function _find(host:string;var index,ip:integer):boolean;
     procedure setsize(x:integer);
     procedure settimeout(x:currency);
    public
     //create
     constructor create;
     destructor destroy; override;
     //find
     function find(host:string;var ip:integer):boolean;
     function add(host:string;ip:integer):boolean;
     //size
     property size:integer read isize write setsize;
     property timeout:currency read itimeout write settimeout;
    end;

    tlookupstate=(lusFree,lusOpen,lusFind,lusDead);
    tlookupevent=procedure(sender:tobject;tag:currency;ptr:tnetworkptr) of object;
    tlookupmanagement=class(trootobject)
    private//defaults: maxthread=1, size=256
     ihistory:tlookuphistory;
     ihits:currency;
     islowref,itime:currency;
     iactivethreads,iindex,itimer,iid,isize,imax,imaxthread:integer;
     ithreads:array[0..99] of tlookupthread;
     istate:tdynamicbyte;
     itag,iptr:tdynamiccurrency;
     iurl,ihost:tdynamicstring;
     iip:tdynamicinteger;
     iport:tdynamicword;
     ihold:tdynamicboolean;
     ionclose:tdynamicnotifyevent;
     ilink:tnotifylist;
     procedure createthread(x:integer);
     procedure freethread(x:integer);
     procedure setmaxthread(x:integer);
     procedure _ontask(sender:tobject);
     function new(var x:integer):boolean;
     function newthread(var x:integer):boolean;
     function getinuse(x:tnetworkptr):boolean;
     procedure setsize(x:integer);
     function getstate(x:tnetworkptr):tlookupstate;
     function geturl(x:tnetworkptr):string;
     function gethost(x:tnetworkptr):string;
     function getip(x:tnetworkptr):integer;
     function getport(x:tnetworkptr):word;
     function gettag(x:tnetworkptr):currency;
     function getonclose(x:tnetworkptr):tlookupevent;
     function getptr(x:integer):tnetworkptr;
     function getactive:integer;
     function getpending:integer;
     function getdead(x:tnetworkptr):boolean;
     procedure _ontimer(sender:tobject);
     procedure syncthreads;
    public
     //vars
     ipmapping:boolean;//FALSE=default, TRUE=ips are converted to mapped version "mip.find(ip,mappedip)"
     //create
     constructor create; override;
     destructor destroy; override;
     function empty:boolean; override;
     //history
     property history:tlookuphistory read ihistory;
     //threads
     property maxthread:integer read imaxthread write setmaxthread;//1..40
     property activethreads:integer read iactivethreads;
     //open
     function open(url:string;tag:currency;autoclose:tlookupevent):tnetworkptr;
     //close
     procedure close(x:tnetworkptr);
     procedure closeall;
     //info
     property inuse[x:tnetworkptr]:boolean read getinuse;
     property dead[x:tnetworkptr]:boolean read getdead;
     property state[x:tnetworkptr]:tlookupstate read getstate;
     function statestr(x:tlookupstate):string;
     property url[x:tnetworkptr]:string read geturl;
     property host[x:tnetworkptr]:string read gethost;
     property ip[x:tnetworkptr]:integer read getip;
     property port[x:tnetworkptr]:word read getport;
     property tag[x:tnetworkptr]:currency read gettag;
     property onclose[x:tnetworkptr]:tlookupevent read getonclose;
     property ptr[x:integer]:tnetworkptr read getptr;//special
     //size
     property max:integer read imax;
     property size:integer read isize write setsize;
     //link
     function link(_event:tnotifyevent):integer;
     procedure unlink(var _instance:integer);
     //stats
     property active:integer read getactive;
     property pending:integer read getpending;
     property id:integer read iid;
     property hits:currency read ihits;
    end;

{tdomains}
    tdomains=class(trootobject)
    private
     istate:array  [1..201] of byte;//0=free, 1=hold, 2=inuse
     idomain:array [1..201] of string;
     iip:array     [1..201] of integer;
     ims:array     [1..201] of currency;
     iitag:array   [1..201] of integer;
     ictag:array   [1..201] of currency;
     icount:array   [1..201] of integer;//number of times lookup attempts (good or bad)
     //lookup info
     ilookupitem:integer;//points to item that's waiting for domain lookup
     ilookupdomain:string;//stores domain, to ensure item is same when lookup is done
     ilookupptr:tnetworkptr;
     //other
     imin,imax,iactive,ilookpos,itimer:integer;
     function valid(x:integer):boolean;
     function getitag(x:integer):integer;
     procedure setitag(x:integer;y:integer);
     function getctag(x:integer):currency;
     procedure setctag(x:integer;y:currency);
     function getinuse(x:integer):boolean;
     function getip(x:integer):integer;
     function getdomain(x:integer):string;
     procedure setdomain(x:integer;y:string);
     procedure _ontimer(sender:tobject);
     procedure _onlookup(sender:tobject;tag:currency;ptr:tnetworkptr);
     function gettext:string;
     function gettextex(sep:string):string;//list of domains in use in no particular order
     function getstate(x:integer):byte;
     procedure sethold(x:integer;y:boolean);
     function gethold(x:integer):boolean;
     function getcount(x:integer):integer;
    public
     //vars
     attemptlimit:integer;//default=5, maximum number of trys to look a domain up before giving up
     //create
     constructor create; override;
     destructor destroy; override;
     //information
     property min:integer read imin;
     property max:integer read imax;
     property domain[x:integer]:string read getdomain write setdomain;
     property ip[x:integer]:integer read getip;
     property count[x:integer]:integer read getcount;//lookup count for each item
     property inuse[x:integer]:boolean read getinuse;
     property state[x:integer]:byte read getstate;//0=free, 1=hold, 2=inuse
     property hold[x:integer]:boolean read gethold write sethold;
     property active:integer read iactive;
     property text:string read gettext;
     property textex[sep:string]:string read gettextex;
     property itag[x:integer]:integer read getitag write setitag;
     property ctag[x:integer]:currency read getctag write setctag;
     //special
     procedure refreshIPS;
     //support
     function new:integer;
     function newex(p:integer):boolean;
     procedure del(var x:integer);
     function asdomain(x:string):string;
    end;

{tmimes}
    tmimes=class(trootobject)
    private
     ie,im:tdynamicvars;
     function getdefaults:string;
    public
     //create
     constructor create; override;
     destructor destroy; override;
     //other
     procedure clear;
     procedure add(e,m:string);
     procedure addall(em:string);
     function em(e:string):string;
     function emb(e,def:string):string;//extension to mime type
     function me(m:string):string;
     //defaults
     property defaults:string read getdefaults;
     procedure flush;
    end;

{twebheaders}
    TWebHeaderClear=set of 0..1;
    PWebHeader=^TWebHeader;
    TWebHeader=record
       n:array[0..wbhcMax] of string;//name (lowercase)
       nRef:array[0..wbhcMax] of integer;
       v:array[0..wbhcMax] of string;//value
       {internal}
       tmpN:string;//name of tmp
       tmpL:integer;//max length
       tmp:string;//used for large "push" operations
       init:boolean;
       end;//end of record

{tnetwork}
    tnetworkstyle=(nwsUnknown,nwsClient,nwsClientRemote,nwsServer,nwsServerUDP);
    tnetworkstate=(nwsFree,nwsOpen,nwsIO,nwsDead);
    tnetworkerror=(nweOK,nweOpenAddress,nweOpenTimeout,nweIOTimeout,nweInvalidPtr);
    tserveracceptevent=procedure(sender:tobject;var caller:tsocket;var accepted:boolean) of object;
    tnetwork=class(trootobject)
    private
     ilastsocket:tsocket;
     isessioninfo:twsadata;
     isession:boolean;
     ilink:tnotifylist;
     itimeout,islowref,ifastdelay:currency;
     isendbuffer,isendfactor,ithrottle,itimer20,itimer1000,isize,imax,iid:integer;
     istyle,ierror,istate:tdynamicbyte;
     itime,itimeoutb:tdynamiccurrency;
     ichoke,iip,iipproxy,isocket:tdynamicinteger;
     isent,irecv,ilook,iserverptr,iptr,ifromsocket:tdynamiccurrency;
     ionaccept,ionread,ionwrite:tdynamicnotifyevent;
     iport:tdynamicword;
     iproxy,iurl:tdynamicstring;
     idisableto,iisserver,irecvnil,ihold:tdynamicboolean;
     iua:string;
     procedure setsize(x:integer);
     function new(var x:integer):boolean;
     function getstate(x:tnetworkptr):tnetworkstate;
     function getstyle(x:tnetworkptr):tnetworkstyle;
     function gettime(x:tnetworkptr):currency;
     procedure settime(x:tnetworkptr;y:currency);
     function gettimeoutb(x:tnetworkptr):currency;
     procedure settimeoutb(x:tnetworkptr;y:currency);
     function getdisableto(x:tnetworkptr):boolean;
     procedure setdisableto(x:tnetworkptr;y:boolean);
     function geterror(x:tnetworkptr):tnetworkerror;
     function geterrorcode(x:tnetworkptr):integer;
     function getsocket(x:tnetworkptr):tsocket;
     function geturl(x:tnetworkptr):string;
     procedure seturl(x:tnetworkptr;y:string);
     function getonaccept(x:tnetworkptr):tnotifyevent;
     procedure setonaccept(x:tnetworkptr;y:tnotifyevent);
     function getonread(x:tnetworkptr):tnotifyevent;
     procedure setonread(x:tnetworkptr;y:tnotifyevent);
     function getonwrite(x:tnetworkptr):tnotifyevent;
     procedure setonwrite(x:tnetworkptr;y:tnotifyevent);
     function getproxy(x:tnetworkptr):string;
     function getip(x:tnetworkptr):integer;
     function getipb(x:integer):integer;
     function getipproxy(x:tnetworkptr):integer;
     procedure setipproxy(x:tnetworkptr;y:integer);
     function getipproxyb(x:integer):integer;
     function getport(x:tnetworkptr):word;
     function getsentbytes(x:tnetworkptr):currency;
     function getrecvbytes(x:tnetworkptr):currency;
     function getisserver(x:tnetworkptr):boolean;
     procedure dodead(x:integer);
     function getinuse(x:tnetworkptr):boolean;
     function getdead(x:tnetworkptr):boolean;
     function getlook(x:tnetworkptr):tnetworkptr;
     function getserverptr(x:tnetworkptr):tnetworkptr;
     function getptr(x:integer):tnetworkptr;
     function getactive:integer;
     function getstatecount(x:tnetworkstate):integer;
     procedure settimeout(x:currency);
     procedure setthrottle(x:integer);
     function timedout(x:integer):boolean;
     function gettimeop(x:tnetworkptr):string;
     procedure setua(x:string);
     procedure _ontimer20(sender:tobject);
     procedure _ontimer1000(sender:tobject);
     procedure _onlookup(sender:tobject;tag:currency;ptr:tnetworkptr);
    public
     //vars
     recvall:currency;
     sentall:currency;
     //create
     constructor create; override;
     destructor destroy; override;
     //utilities
     function htons(x:word):word;
     //workers
     //.core
     property throttle:integer read ithrottle write setthrottle;//1..X (unlimited is not allowed)
     property buffersize:integer read isendbuffer;
     property ua:string read iua write setua;
     property timeout:currency read itimeout write settimeout;
     //.link - 20ms timer link
     function link(_event:tnotifyevent):integer;
     procedure unlink(var _instance:integer);
     //.open
     function open(url,proxy:string;var requesturl,host:string):tnetworkptr;//client
     function openserver(_port,_maxconn:integer;_onaccept:tnotifyevent):tnetworkptr;
     function openserverUDP(_port:integer):tnetworkptr;
     function acceptclient(_serverptr:tnetworkptr;_serverport:word;_socket:tsocket):tnetworkptr;
     //.send
     function cansend(x:tnetworkptr;var y:string;linger:boolean):boolean;
     function send(x:tnetworkptr;var y:string):integer;
     property sendfactor:integer read isendfactor;
     //.sendto - special (for UDP)
     function cansendto(x:tnetworkptr):boolean;
     function sendto(x:tnetworkptr;var ca:tsockaddrin;var y:string):integer;
     //.recv
     function canrecv(x:tnetworkptr):boolean;
     function recv(x:tnetworkptr;var y:string):integer;
     //.recvfrom - special (for UDP)
     function canrecvfrom(x:tnetworkptr):boolean;
     function recvfrom(x:tnetworkptr;var ca:tsockaddrin;var y:string):integer;
     //..info
     property sentbytes[x:tnetworkptr]:currency read getsentbytes;
     property recvbytes[x:tnetworkptr]:currency read getrecvbytes;
     function stats(showheader:boolean;colsep,linesep:string):string;
     //.close
     procedure close(x:tnetworkptr);
     procedure closeall;
     //.check
     function ehl(var x:string):boolean;//exceeds header limit
     //.other
     property inuse[x:tnetworkptr]:boolean read getinuse;
     property dead[x:tnetworkptr]:boolean read getdead;
     procedure ffc(x:tnetworkptr;var header:string);//find and force closure - only if reply in header is "403"
     //info
     property lastsocket:tsocket read ilastsocket;
     property error[x:tnetworkptr]:tnetworkerror read geterror;
     property errorcode[x:tnetworkptr]:integer read geterrorcode;
     property state[x:tnetworkptr]:tnetworkstate read getstate;
     function statestr(x:tnetworkstate):string;
     property style[x:tnetworkptr]:tnetworkstyle read getstyle;
     property time[x:tnetworkptr]:currency read gettime write settime;
     property timeoutb[x:tnetworkptr]:currency read gettimeoutb write settimeoutb;//overrides system "timeout" when 1..X
     property timeop[x:tnetworkptr]:string read gettimeop;//timeout progress
     property disableto[x:tnetworkptr]:boolean read getdisableto write setdisableto;
     property socket[x:tnetworkptr]:integer read getsocket;
     property url[x:tnetworkptr]:string read geturl write seturl;//not to be set by "nwsClient"
     property proxy[x:tnetworkptr]:string read getproxy;
     property ip[x:tnetworkptr]:integer read getip;
     property ipb[x:integer]:integer read getipb;//special
     property ipproxy[x:tnetworkptr]:integer read getipproxy write setipproxy;
     property ipproxyb[x:integer]:integer read getipproxyb;//special
     property port[x:tnetworkptr]:word read getport;
     property look[x:tnetworkptr]:tnetworkptr read getlook;
     property serverptr[x:tnetworkptr]:tnetworkptr read getserverptr;
     property ptr[x:integer]:tnetworkptr read getptr;//special
     property isserver[x:tnetworkptr]:boolean read getisserver;
     property onaccept[x:tnetworkptr]:tnotifyevent read getonaccept write setonaccept;
     property onread[x:tnetworkptr]:tnotifyevent read getonread write setonread;
     property onwrite[x:tnetworkptr]:tnotifyevent read getonwrite write setonwrite;
     //size - default is 1024
     property max:integer read imax;
     property size:integer read isize write setsize;
     //stats
     property active:integer read getactive;
     property statecount[x:tnetworkstate]:integer read getstatecount;
     property id:integer read iid;
     //stats incrementors - for external bandwidth coordination
     procedure recvinc(x:tnetworkptr;by:currency);
     procedure sentinc(x:tnetworkptr;by:currency);
     //internal
     function internalwndproc(hWnd:hwnd;msg:uint;wparam:wparam;lparam:lparam):lresult;
    end;

{tclientbasic}
    topenevent=procedure(sender:tobject;requesturl,host:string;var header:string) of object;
    trecvevent=procedure(sender:tobject;var header,content:string;first:boolean) of object;
    tsendevent=procedure(sender:tobject;var content:string;var linger:boolean) of object;
    tclientbasic=class(trootobject)
    private
     fonopen:topenevent;
     fonrecv:trecvevent;
     fonclose:tnotifyevent;
     iclosecode,icode,ilockcount:integer;
     iptr:tnetworkptr;
     iip,itag,ilink:integer;
     irecvlimit,imaxbytes,icontentbytes:currency;
     iua,iurl,iproxy,irequesturl,ihost,iheadersendtmp,iheadersend,icontent,iheader:string;
     iipset,icloselocked,ibusy,imustclose,ihok,iopendone:boolean;
     procedure _ontimer(sender:tobject);
     procedure _onopen(sender:tobject;_requesturl,_host:string;var _header:string);
     procedure doclose;
     function getua:string;
     procedure setrecvlimit(x:currency);
    public
     //vars
     sendbytes:currency;
     recvbytes:currency;
     sendbytesp:pcurrency;
     recvbytesp:pcurrency;
     banprivate:boolean;//ban private ip addresses (127.x.x.x, 10.x.x.x etc)
     //create
     constructor create; override;
     destructor destroy; override;
     //open
     function canopen:boolean; virtual;
     function open(_url,_proxy:string):boolean; virtual;
     //close
     function canclose:boolean; virtual;
     procedure close; virtual;
     procedure closecode(errcode:integer); virtual;
     //send
     property ua:string read getua write iua;
     property ip:integer read iip;
     property url:string read iurl;
     property proxy:string read iproxy;
     property requesturl:string read irequesturl;
     property host:string read ihost;
     property headersend:string read iheadersend;
     //recv
     property recvlimit:currency read irecvlimit write setrecvlimit;
     property maxbytes:currency read imaxbytes;//-1=unknown, 0..X=specified range
     property contentbytes:currency read icontentbytes;//0..X
     property header:string read iheader;
     property content:string read icontent write icontent;//18FEB2008 - allows other procs to flush/clear large content's when required
     property code:integer read icode;
     //events
     property onopen:topenevent read fonopen write fonopen;
     property onrecv:trecvevent read fonrecv write fonrecv;
     property onclose:tnotifyevent read fonclose write fonclose;
     //other
     property tag:integer read itag write itag;
     //internal
     property ptr:tnetworkptr read iptr;
     procedure _onfinish(sender:tobject); virtual;
    end;

{tclientredirect}
    tclientredirect=class(tclientbasic)
    private
     imaxbytes,icontentbytes:currency;
     ilastheader,iurl,ifinalurl,iredirecturl:string;
     imustclose,ibusy:boolean;
     iredirectcount,imaxredirect:integer;
     procedure __onopen(sender:tobject;requesturl,host:string;var header:string); virtual;
     procedure __onrecv(sender:tobject;var header,content:string;first:boolean); virtual;
     procedure __onclose(sender:tobject); virtual;
     procedure setmaxredirect(x:integer);
     function openb(_url,_proxy:string):boolean;
    public
     //events
     onopen:topenevent;
     onrecv:trecvevent;
     onclose:tnotifyevent;
     //create
     constructor create; override;
     destructor destroy; override;
     //open
     function canopen:boolean;
     function open(_url,_proxy:string):boolean;
     //close
     function canclose:boolean;
     procedure close;
     procedure closecode(errcode:integer);
     //redirect
     property maxredirect:integer read imaxredirect write setmaxredirect;
     property redirectcount:integer read iredirectcount;
     //send
     property url:string read iurl;
     property finalurl:string read ifinalurl;
     property redirecturl:string read iredirecturl;//non-empty only if redirect-count exceeds set limit
     //recv
     property maxbytes:currency read imaxbytes;//-1=unknown, 0..X=specified range
     property contentbytes:currency read icontentbytes;//0..X
     //internal
     procedure _onfinish(sender:tobject); override;
    end;

{tclients}
    tclients=class(tobject)
    private
     fonopen:topenevent;
     fonclose:tnotifyevent;
     imax:integer;
     iinuse:   array[0..99] of boolean;
     iclients: array[0..99] of tclientredirect;
     ipost:    array[0..99] of string;
     ivars:    array[0..99] of tdynamictext;
     iref:     array[0..99] of integer;
     istr:     array[0..99] of string;//18FEB2008
     istr2:    array[0..99] of string;//18FEB2008
     ival:     array[0..99] of integer;
     ival2:    array[0..99] of integer;
     icount:integer;
     function getclient(x:integer):tclientredirect;
     function getinuse(x:integer):boolean;
     function getvars(x:integer):tdynamictext;
     function getref(x:integer):integer;
     function getstr(x:integer):string;
     function getstr2(x:integer):string;
     procedure setstr(x:integer;y:string);
     procedure setstr2(x:integer;y:string);
     function getval(x:integer):integer;
     function getval2(x:integer):integer;
     procedure setval(x:integer;y:integer);
     procedure setval2(x:integer;y:integer);
     procedure _onopen(sender:tobject;_requesturl,_host:string;var _header:string);
     procedure _onclose(sender:tobject);
     function getactive:integer;
     function getrecvlimit:currency;
     procedure setrecvlimit(x:currency);
    public
     //create
     constructor create;
     destructor destroy; override;
     //workers
     function new(var x:integer):boolean;
     function open(_url,_proxy,_post:string;_index,_ref:integer):integer;
     //info
     function valid(x:integer):boolean;
     property clients[x:integer]:tclientredirect read getclient;
     property inuse[x:integer]:boolean read getinuse;
     property vars[x:integer]:tdynamictext read getvars;
     property ref[x:integer]:integer read getref;
     property active:integer read getactive;
     property count:integer read icount;
     property recvlimit:currency read getrecvlimit write setrecvlimit;
     //user tags
     property str[x:integer]:string read getstr write setstr;
     property str2[x:integer]:string read getstr2 write setstr2;
     property val[x:integer]:integer read getval write setval;
     property val2[x:integer]:integer read getval2 write setval2;
     //events
     property onopen:topenevent read fonopen write fonopen;
     property onclose:tnotifyevent read fonclose write fonclose;
    end;

{tclientdownload}
    tclientdownload=class(tclientredirect)
    private
     ifile:tfilepush;
     idestfilename,irealfilename,ifilename,irootpath:string;
     istyle:turlfilestyle;
     procedure __onrecv(sender:tobject;var header,content:string;first:boolean); override;
     procedure __onclose(sender:tobject); override;
     function getrootpath:string;
     procedure setstyle(x:turlfilestyle);
     function getprogress:single;
    public
     //vars
     replaceexisting:boolean;
     decodeurl:boolean;
     //events
     onstart,onfinish:tnotifyevent;
     //create
     constructor create; override;
     destructor destroy; override;
     //workers
     property rootpath:string read getrootpath write irootpath;
     property style:turlfilestyle read istyle write setstyle;
     property filename:string read ifilename;
     property realfilename:string read irealfilename;
     property destfilename:string read idestfilename write idestfilename;//use this to specifiy local filename to save to, overriding ALL other settings
     property progress:single read getprogress;
    end;

{tclientremote}
    trequestevent=function(sender:tobject;var header,content:string;var wait:boolean):boolean of object;
    tclientremote=class(trootobject)
    private
     itransactionstart:currency;
     ilogHI,ilogHO:string;
     fonrecv:trecvevent;
     fonrequest:trequestevent;
     fonsend:tsendevent;
     fonclose:tnotifyevent;
     iclosecode,icode,ilockcount:integer;
     iptr:tnetworkptr;
     iip,itag,ilink:integer;
     irecvlimit,imaxbytes,icontentbytes:integer;
     itagstr,isn:string;
     icontent,iheader:pstring;
     iwaiting,icansend,icloselocked,ibusy,imustclose,ihok,iopendone:boolean;
     procedure doclose;
     function getsn:string;
     procedure setrecvlimit(x:integer);
     procedure syncLOGHI;
    public
     //vars
     host:tserverbasic;
     raw:boolean;//TRUE=non-http communications (no HTTP headers)
     ffc:boolean;
     sendbytes:currency;
     recvbytes:currency;
     sendbytesp:pcurrency;
     recvbytesp:pcurrency;
     log:boolean;//default=FALSE (no)
     logextra:string;
     logextralines:string;
     tagpos:integer;//user
     tagmode:byte;//user
     tagobj:tobject;//controlled by user
     oContentLength:boolean;//automatically inserts content-length if not present
     //internal
     property ptr:tnetworkptr read iptr;
     procedure _onfinish(sender:tobject); virtual;
     procedure _ontimer(sender:tobject); virtual;
     procedure _onheader;
     //create
     constructor create; override;
     destructor destroy; override;
     //open
     function canopen:boolean;
     function open(_ptr:tnetworkptr):boolean; virtual;
     //close
     function canclose:boolean; virtual;
     procedure close; virtual;
     procedure closecode(errcode:integer); virtual;
     //info
     property sn:string read getsn write isn;//server name
     property ip:integer read iip;//set by host server
     property recvlimit:integer read irecvlimit write setrecvlimit;
     property maxbytes:integer read imaxbytes;//-1=unknown, 0..X=specified range
     property contentbytes:integer read icontentbytes;//0..X
     property header:pstring read iheader;
     property content:pstring read icontent;
     property code:integer read icode write icode;//can be override (should only be set when using mode RAW, else it fully automatic)
     function limitpassed(_ip:integer;_bytes:currency;var header:string):boolean;
     //wait
     property waiting:boolean read iwaiting;
     procedure unwait; virtual;
     //events
     property onrecv:trecvevent read fonrecv write fonrecv;
     property onrequest:trequestevent read fonrequest write fonrequest;
     property onsend:tsendevent read fonsend write fonsend;
     property onclose:tnotifyevent read fonclose write fonclose;
     //other
     property tag:integer read itag write itag;
     property tagstr:string read itagstr write itagstr;
    end;

{tclientproxy}
    turlevent=procedure(sender:tobject;var header,content,url:string) of object;
    tclientproxy=class(tclientremote)
    private
     iid:string;
     iout:tnetworkptr;
     ioutonce:boolean;
    public
     //events
     onurl:turlevent;
     //internal
     procedure _ontimer(sender:tobject); override;
     procedure _onfinish(sender:tobject); override;
     //create
     constructor create; override;
     destructor destroy; override;
     //workers
     procedure unwait; override;
     function security(ip:integer;var header,content,url:string):boolean;
    end;

{tserverbasic}
    tserverbasic=class(trootobject)
    private
     fonrequest:trequestevent;
     fonsend:tsendevent;
     fonclose:tnotifyevent;
     iclients:array[0..1023] of tclientremote;
     iptr:tnetworkptr;
     iport:word;
     iportbusy:boolean;//19FEB2008
     iports:string;
     iopentime:currency;
     iiplimit,iconnactive,iconnactivepeak,itimer,imaxconn:integer;
     function getclient(x:integer):tclientremote;
     procedure internalonaccept(sender:tobject);
     procedure setmaxconn(x:integer);
     procedure _ontimer(sender:tobject);
     function getonline:boolean;
     procedure _open;
     procedure _close;
     function _onrequest(sender:tobject;var header,content:string;var wait:boolean):boolean;
     procedure _onsend(sender:tobject;var content:string;var _linger:boolean);
     procedure _onclose(sender:tobject);
     function getlog:boolean;
     procedure setlog(x:boolean);
     function getrecvlimit:integer;
     procedure setrecvlimit(x:integer);
     function getffc:boolean;
     procedure setffc(x:boolean);
     procedure syncall; virtual;
     function getaddress:string;
     procedure setports(x:string);
     procedure setiplimit(x:integer);
     function getraw:boolean;
     procedure setraw(x:boolean);
    public
     //vars
     sendbytes:currency;
     recvbytes:currency;
     hits:currency;
     tag:integer;//09JAN2008
     tagstr:string;//09JAN2008
     //internal
     procedure initclient(x:tclientremote); virtual;
     function createclient:tclientremote; virtual;
     procedure _onaccept(sender:tobject;var caller:tsocket;var accepted:boolean); virtual;
     function accept(var _socket:tsocket):integer; virtual;
     property ptr:tnetworkptr read iptr;
     function passed(_ip:integer;_bytes:currency;var header:string):boolean;
     //create
     constructor create; override;
     destructor destroy; override;
     //events
     property onrequest:trequestevent read fonrequest write fonrequest;
     property onsend:tsendevent read fonsend write fonsend;
     property onclose:tnotifyevent read fonclose write fonclose;
     //connections 0..1023 (max. of 1024 connections)
     property maxconn:integer read imaxconn write setmaxconn;
     property connactive:integer read iconnactive;
     function connactivepeak(reset:boolean):integer;
     //port
     property portbusy:boolean read iportbusy;
     property port:word read iport;
     property ports:string read iports write setports;
     function portrange(_from,_to:integer):string;
     property online:boolean read getonline;
     property address:string read getaddress;
     //other
     property raw:boolean read getraw write setraw;//non-http communications
     property log:boolean read getlog write setlog;
     property recvlimit:integer read getrecvlimit write setrecvlimit;
     //clients
     property clients[x:integer]:tclientremote read getclient;
     //other
     property ffc:boolean read getffc write setffc;
     property iplimit:integer read iiplimit write setiplimit;//0=no limit
    end;

{tserverredirection}
    tserverredirection=class(tserverbasic)
    private
     iitems:tdynamictext;
     procedure seturls(x:string);
    public
     //vars
     allowinternet:boolean;
     //internal
     procedure initclient(x:tclientremote); override;
     function createclient:tclientremote; override;
     //create
     constructor create; override;
     destructor destroy; override;
     //onurl
     procedure _onurl(sender:tobject;var header,content,url:string);
     //urls
     property urls:string write seturls;
    end;

{tserverudp}
    trequesteventudp=procedure(sender:tobject;socket:tsocket;var clientaddress:tsockaddrin;clientip:integer;clientport:word;var data,extra:string;var code:integer) of object;
    tserverudp=class(trootobject)
    private
     fonrequest:trequesteventudp;
     isocket:tsocket;
     iptr:tnetworkptr;
     iport:word;
     iports:string;
     islowref,iopentime:currency;
     iiplimit,irecvlimit,itimer,itimerfast:integer;
     procedure _ontimer(sender:tobject);
     procedure _ontimerfast(sender:tobject); virtual;
     function getonline:boolean;
     procedure _open;
     procedure _close;
     procedure setrecvlimit(x:integer);
     procedure setports(x:string);
     procedure unwait(ca:tsockaddrin;caIP:integer;caPort:word;recv,time:currency;code:integer;data,extra:string);
    public
     //vars
     recvbytes:currency;
     sendbytes:currency;
     hits:currency;
     connections:integer;//in connections (server)
     sconnections:integer;//used in higher version (send connections, client)
     log:boolean;
     //internal
     property ptr:tnetworkptr read iptr;
     //create
     constructor create; override;
     destructor destroy; override;
     //port
     property port:word read iport;
     property ports:string read iports write setports;
     function portrange(_from,_to:integer):string;
     property online:boolean read getonline;
     //recvlimit
     property recvlimit:integer read irecvlimit write setrecvlimit;
     //events
     property onrequest:trequesteventudp read fonrequest write fonrequest;
    end;

{tnetworkusers}
    tnetworkusersevent=procedure(sender:tobject;index:integer) of object;
    tnetworkusers=class(trootobject)
    private
     tsWaiting,tsFinding,tsDisabled,tsIP,tsGroup,tsSignal,tsNoSignal,tsPermanent,tsVisitor:string;
     ilooking:boolean;
     ilookpos,ilimit,idelpos,ionline,iactive,itimer:integer;
     irefOnline,irefDelete,itimeout:currency;
     iimgname,idomain,igroupname,iusername:tdynamicstring;
     iint1,iint2,iip,imsgid:tdynamicinteger;
     iport:tdynamicword;
     ifromuser,ionce,istatic:tdynamicboolean;//hard coded - user specified, these we persist on trying!
     ilookms,iuref,iid,ialive:tdynamiccurrency;
     iawake,ilookcount:tdynamicbyte;
     //events
     fonnew,fononline,fonoffline:tnetworkusersevent;
     procedure _ontimer(sender:tobject);
     procedure settimeout(x:currency);
     function getactiveuser(x:integer):boolean;
     function getonlineuser(x:integer):boolean;
     function getint1(x:integer):integer;
     function getint2(x:integer):integer;
     function getawake(x:integer):byte;
     function getip(x:integer):integer;
     function getmsgid(x:integer):integer;
     function getport(x:integer):word;
     function getusername(x:integer):string;
     function getgroupname(x:integer):string;
     function getdomain(x:integer):string;
     function getimgname(x:integer):string;
     function getaddress(x:integer):string;
     function getstatic(x:integer):boolean;
     function getvalid(x:integer):boolean;
     function getinuse(x:integer):boolean;
     function getonlinecount:integer;
     function getcount:integer;
     procedure setlimit(x:integer);//restrict the number of users that can be cached - prevents memory overflow
     function new(_username,_groupname:string;var p:integer;var _new:boolean):boolean;
     procedure _onlookup(sender:tobject;tag:currency;ptr:tnetworkptr);
     function _privateerror(ip:integer):boolean;//for stats only
    public
     //vars
     attemptlimit:integer;//default=5, maximum number of trys to look a domain up before giving up
     //create
     constructor create; override;
     destructor destroy; override;
     //add
     function addstatic(_addresses:string):boolean;
     function adduser(_ip:integer;_port:word;_awake:byte;_username,_groupname,_domain,_imgname:string;_int1,_int2:integer;_fromuser,_updateexisting:boolean):boolean;
     function adduserex(_ip,_msgid:integer;_port:word;_awake:byte;_username,_groupname,_domain,_imgname:string;_int1,_int2:integer;_fromuser,_updateexisting:boolean;var _msgidOK:boolean):boolean;
     //delete
     procedure del(x:integer);
     procedure deleteofflineusers;//27NOV2007
     //find
     function findnext(_start:integer;var _index:integer):boolean;
     function findnextex(_start:integer;var _index:integer;includestatic:boolean):boolean;
     function findu(_username:string;var i:integer):boolean;
     function findug(_username,_groupname:string;var i:integer):boolean;
     property activeuser[_index:integer]:boolean read getactiveuser;//"online...warning"=TRUE and "offline"=FALSE
     property onlineuser[_index:integer]:boolean read getonlineuser;//"online...warning"=TRUE and "offline"=FALSE and direct communication has been had from that client
     //information
     property timeout:currency read itimeout write settimeout;//milli-seconds
     property valid[x:integer]:boolean read getvalid;
     property inuse[x:integer]:boolean read getinuse;
     property limit:integer read ilimit write setlimit;//restrict the number of users that can be cached - prevents memory overflow
     property active:integer read iactive;
     property count:integer read getcount;
     property online:integer read ionline;
     function onlineusers(_sep:string;_sort:boolean;var _users:string;var _indexref:tdynamicinteger;var _count:integer):boolean;
     function stats(showheader,showgroup,showonline,privateIPsonly:boolean;colsep,linesep:string):string;
     function statsex(showheader,showgroup,showonline,privateIPsonly:boolean;colsep,linesep:string;itemlimit:integer):string;
     property ip[x:integer]:integer read getip;
     property msgid[x:integer]:integer read getmsgid;
     property port[x:integer]:word read getport;
     property username[x:integer]:string read getusername;
     property groupname[x:integer]:string read getgroupname;
     property domain[x:integer]:string read getdomain;
     property imgname[x:integer]:string read getimgname;
     property address[x:integer]:string read getaddress;
     property int1[x:integer]:integer read getint1;//for host use, e.g. fontcolor
     property int2[x:integer]:integer read getint2;//for host use, e.g. bgcolor
     property awake[x:integer]:byte read getawake;//awake status of client
     property static[x:integer]:boolean read getstatic;
     //special
     procedure refreshIPS;
     //events
     property onnew:tnetworkusersevent read fonnew write fonnew;
     property ononline:tnetworkusersevent read fononline write fononline;
     property onoffline:tnetworkusersevent read fonoffline write fonoffline;
    end;

{tudppackets}
    tudppacketsevent=procedure(sender:tobject;ip:integer;port:word;data:string) of object;
    tudppackets=class(trootobject)
    private
     tsInboundQueue,tsOutboundQueue,tsThrottle,tsPacketsPerSecond:string;
     isocket:tsocket;
     iptr:tnetworkptr;
     istatustime,iopentime:currency;
     ipushrate,ipushcount,ipullrate,ipullcount,isafelevel,ilimit,itimer:integer;
     iport:word;
     istatus,iports:string;
     fonrequest:tudppacketsevent;
     iinqueue,ioutqueue:tqueuestring;
     procedure setports(x:string);
     function getonline:boolean;
     procedure _ontimer(sender:tobject);
     procedure _open;
     procedure _close;
     procedure _onread(sender:tobject);
     procedure _onwrite(sender:tobject);
     procedure setlimit(x:integer);//maximum number of packets to cache for each of inbound and outbound caches
     function getsafelevel:boolean;
     procedure setpushrate(x:integer);
     procedure setpullrate(x:integer);
     procedure setUDPavedatalen(x:word);
     function getinboundactive:integer;
     function getoutboundactive:integer;
     //io
     function canpull:boolean;
     function pull:boolean;
     function canpush:boolean;
     function push:boolean;
    public
     //vars
     recvbytes:currency;
     sendbytes:currency;
     inhits:currency;//21DEC2007
     outhits:currency;//21DEC2007
     hits:currency;
     log:boolean;//FALSE=default - no logs are recorded, TRUE=basic logs are automatically recorded
     //other
     tag:integer;//09JAN2008
     tagstr:string;//09JAN2008
     //create
     constructor create; override;
     destructor destroy; override;
     //port
     property port:word read iport;
     property ports:string read iports write setports;
     function portrange(_from,_to:integer):string;
     property online:boolean read getonline;
     //io
     property onrequest:tudppacketsevent read fonrequest write fonrequest;
     function cansend:boolean;
     function send(ip:integer;port:word;data:string):boolean;
     //information
     property limit:integer read ilimit write setlimit;//maximum number of packets to cache for each of inbound and outbound caches
     property status:string read istatus;
     property pushrate:integer read ipushrate write setpushrate;
     property pullrate:integer read ipullrate write setpullrate;
     //other
     property inboundactive:integer read getinboundactive;
     procedure inflush;
     property outboundactive:integer read getoutboundactive;
     procedure outflush;
     //.level
     property safelevel:boolean read getsafelevel;
    end;

{tudpbasic}
    tudpbasicServerevent=procedure(sender:tobject;ip:integer;port:word;data:string;reliable,error:boolean) of object;
    tudpbasicClientevent=procedure(sender:tobject;ip:integer;port:word;usertag:integer;data:string) of object;
    tudpbasic=class(trootobject)
    private
     //Important Note: Server always trys to use as many connections has it has,
     //for maximum reliability, where as client is restricted to using a user specified
     //number of connections at any one time, which also sets the "rate" at which the
     //current connection may be used at - for instance a large proxy server running
     //over a small "dial-up" internet connection should only use say about 100 connections
     //or about 5K/sec transfer rate.

     //client
     icstate:tdynamicbyte;//0=free, 1=hold, 2=inuse
     iccount:tdynamicbyte;//try count
     ictime:tdynamiccurrency;//time reference before retrying
     icip,icid,icsn,icusertag:tdynamicinteger;
     icport:tdynamicword;
     icdata:tdynamicstring;
     icqueue,irqueue,iuqueue,iwqueue:tqueuestring;//temp storage of inbound packets - keep buffer clear
     icdone:tdynamicboolean;
     icspeed:trates;
     irsafelevel,iusafelevel,iwsafelevel,icpos,icactive,icactivelast,icpushcount:integer;
     //server
     isqueue:tqueuestring;//temp storage of inbound packets - keep buffer clear
     isid,issn,isip:tdynamicinteger;
     isport:tdynamicword;
     istime:tdynamiccurrency;//time reference before retrying
     isspeed:trates;
     ispos,ispushcount:integer;
     iraw:boolean;
     //other
     tsMsgsec,tsMsgmin,tsTasks,tsInboundLoad,tsOutboundLoad,tsLoad,tsThrottle,tsPKperMSG,tsInbound,tsMessages,tsOverhead,tsPackets,tsBytes,tsOutbound,tsQueue,tsFailed,tsFailedmessages:string;
     isocket:tsocket;
     iptr:tnetworkptr;
     islowref,ispeedtime,istatustime,iopentime:currency;
     isn,ithrottle,icoreid,irate,ilimit,itimer,itimerfast:integer;
     irclimit,ihdrsize:byte;
     idatalimit:integer;//19JAN2008
     iport:word;
     isnSTR,istatus,iports:string;
     fonserver:tudpbasicServerevent;
     fonclient:tudpbasicClientevent;
     ilimitmodified:boolean;
     procedure setports(x:string);
     function getonline:boolean;
     procedure _ontimerfast(sender:tobject);
     procedure _ontimer(sender:tobject);
     procedure _open;
     procedure _close;
     procedure _onread(sender:tobject);//09FEB2008
     procedure _onwrite(sender:tobject);
     //support
     function ctime(rightaway:boolean):currency;
     function stime:currency;
     function newid:integer;//1..maxint
     function valid(x:integer):boolean;
     procedure ceventclose(x:integer;ok:boolean);
     function cfind(id,sn,ip:integer;port:word;var index:integer):boolean;
     function cdo:boolean;//process client based items
     function sdo:boolean;//process server based items
     function sevent(id,sn,ip:integer;port:word;raw:boolean;var data:string):boolean;
     function cansendnow:boolean;
     function sendnow(ip:integer;port:word;usertag:integer;data:string):boolean;//reliable only
     function isserver(style:char):boolean;
     function isclient(style:char):boolean;
     procedure setthrottle(x:integer);
     function getmsgsec:integer;
     procedure setmsgsec(x:integer);
     function getrlimit:integer;
     procedure setrlimit(x:integer);
     function getulimit:integer;
     procedure setulimit(x:integer);
     function getwlimit:integer;
     procedure setwlimit(x:integer);
     function sendpacket(ip:integer;port:word;data:string):boolean;
     function getsactive:integer;
     procedure setinlimit(x:integer);
     function getinlimit:integer;
     procedure setlimits(x:integer);
    public
     //vars
     log:boolean;//FALSE=default - no logs are recorded, TRUE=basic logs are automatically recorded
     advancedstatus:boolean;//FALSE=default=short status, TRUE=full and detailed status
     //information
     messagesRecv:currency;
     messagesSent:currency;
     messagesFail:currency;
     overheadRecv:currency;
     overheadSent:currency;
     packetsRecv:currency;
     packetsSent:currency;
     bytesRecv:currency;
     bytesSent:currency;
     bandwidth:currency;
     statuscomments:string;//optional information to be displayed within "virtualserverpanel"
     //internal
     __packetsClient:currency;
     __packetsServer:currency;
     //other
     tag:integer;//09JAN2008
     tagstr:string;//09JAN2008
     //create
     constructor create; override;
     destructor destroy; override;
     //port
     property port:word read iport;
     property ports:string read iports write setports;
     function portrange(_from,_to:integer):string;
     property online:boolean read getonline;
     //events
     property onserver:tudpbasicServerevent read fonserver write fonserver;
     property onclient:tudpbasicClientevent read fonclient write fonclient;
     //information
     property throttle:integer read ithrottle write setthrottle;
     property msgsec:integer read getmsgsec write setmsgsec;//set throttle using "messages/second"
     property sactive:integer read getsactive;//physical server connections inuse
     property cactive:integer read icactive;//physical client connections inuse
     property status:string read istatus;
     property datalimit:integer read idatalimit;//max host data that can be sent/recv.ed
     property sn:integer read isn;//serial number of "c" drive
     //common
     property raw:boolean read iraw write iraw;//allow raw packets in ('$...'), bypassing "reliable and unreliable" methods, supporting 3 formats at once - 21FEB2008
     property limits:integer write setlimits;//set all 4 limits at once (inlimit,rlimit,ulimit and wlimit)
     property inlimit:integer read getinlimit write setinlimit;//used to cache inbound packets that can't be processed right away, default is 20,000 - 20FEB2008
     //send reliable
     property rlimit:integer read getrlimit write setrlimit;
     function rsafelevel:boolean;
     function rfree:integer;
     function rcansend:boolean;
     function rsend(ip:integer;port,usertag:word;data503:string):boolean;
     //send unreliable
     property ulimit:integer read getulimit write setulimit;
     function usafelevel:boolean;
     function ufree:integer;
     function ucansend:boolean;
     function usend(ip:integer;port,usertag:word;data503:string):boolean;
     //send raw
     property wlimit:integer read getwlimit write setwlimit;
     function wsafelevel:boolean;
     function wfree:integer;
     function wcansend:boolean;
     function wsend(ip:integer;port,usertag:word;data511:string):boolean;
     //other
     procedure flush;
    end;

{tudpex}
    teventudpex=procedure(sender:tobject;index,id:integer;var data,extra:string) of object;
    tudpexitem=record//~36 bytes
      //core
      inuse:boolean;
      id:integer;//0=nil,1..N=client,-1..-N=server
      pushing:boolean;
      ip:integer;
      port:word;
      ca:tsockaddrin;
      //data control
      aok:boolean;
      adata:string;
      bok:boolean;
      bdata:string;
      //event
      onclose:teventudpex;
      //support
      _adata:string;
      _bdata:string;
      timeout:currency;//timedout if "ms64>=timeout"
      rcount:byte;//retry count, counts down if 0=no retries, set when opened for "client"
      extra:string;//for logs
      //user
      tag:integer;
      end;
    pudpexitems=^tudpexitems;
    tudpexitems=array[0..99] of tudpexitem;//~36Kb
    tudpex=class(trootobject)
    private
     isocket:tsocket;
     iptr:tnetworkptr;
     fonserver:teventudpex;
     iport:word;
     iports:string;
     iretrys,islowref,iopentime:currency;
     iid,ircount,ipos,imax,itimer,itimerfast:integer;
     iactive,iactiveclient,iactiveserver:integer;
     iitems:tudpexitems;
     ipitems:pudpexitems;
     itimeout:currency;
     procedure _ontimer(sender:tobject);
     procedure _ontimerfast(sender:tobject); virtual;
     function getonline:boolean;
     procedure _open;
     procedure _close;
     procedure setports(x:string);
     function getvalid(x:integer):boolean;
     function getinuse(x:integer):boolean;
     procedure setpushing(x:integer;_pushing:boolean);
     procedure activeinc(x:integer;_inc:boolean);
     procedure encode(x:integer;y:string;orgsync:boolean);
     procedure settimeout(x:currency);
     procedure closeitem(x:integer;force:boolean);
     function pull:boolean;
     function push(p:integer):boolean;
     function new(id,ip:integer;port:word;var r:integer):boolean;
     function newid(_type:integer):integer;
     procedure decode(x:integer;orgsync:boolean);
     procedure _onread(sender:tobject);
     procedure _onwrite(sender:tobject);
     procedure dolog(x:integer);
    public
     //vars
     recvbytes:currency;
     sendbytes:currency;
     hits:currency;
     connections:integer;//in connections (server)
     sconnections:integer;//used in higher version (send connections, client)
     log:boolean;
     linearflow:boolean;//process one packet at a time in linear order (for linear critical servers/clients)
     //internal
     property ptr:tnetworkptr read iptr;
     //create
     constructor create; override;
     destructor destroy; override;
     //port
     property port:word read iport;
     property ports:string read iports write setports;
     function portrange(_from,_to:integer):string;
     property online:boolean read getonline;
     //items
     property valid[x:integer]:boolean read getvalid;
     property inuse[x:integer]:boolean read getinuse;
     property items:pudpexitems read ipitems;
     //information
     property active:integer read iactive;
     property activeclient:integer read iactiveclient;
     property activeserver:integer read iactiveserver;
     property retrys:currency read iretrys;
     property timeout:currency read itimeout write settimeout;
     //client (use to send data)
     function safelevel:boolean;
     function safelevelex(safezone:integer):boolean;
     function client(ip:integer;port:word;data:string;_onclose:teventudpex;var rid:integer):boolean;
     function clientex(ip:integer;port:word;data:string;tag:integer;_onclose:teventudpex;var rid:integer):boolean;
     //events
     property onserver:teventudpex read fonserver write fonserver;
    end;

{tmanagedudpex}
    tmanagedudpexcloseevent=procedure(sender:tobject;index,ip:integer;port:word;var send,recv,extra:string;tag:integer;str:string;obj:tobject) of object;
    tmanagedudpexroll=(musNew,musQueue);
    tmanagedudpex=class(trootobject)
    private
     ispeed:trates;
     irate,iratecount,inew,iqueue,iactiveidle,iactive:integer;
     ispeedtimer,iratetimer:currency;
     iserver:tudpex;
     iid,iip,itag:tdynamicinteger;
     iport:tdynamicword;
     istr,isend,irecv:tdynamicstring;
     iobj:tdynamicobject;
     ionclose:tdynamicnotifyevent;
     iinuse:tdynamicboolean;
     itimer:integer;
     function getsize:integer;
     procedure setsize(x:integer);
     function getsafelevel:boolean;
     function getvalid(x:integer):boolean;
     function getinuse(x:integer):boolean;
     procedure clearitem(x:integer);
     procedure doclose(x:integer;var extra:string);
     procedure _onclose(sender:tobject;index,id:integer;var data,extra:string);
     function cannext:boolean;
     function next(var r:integer;range:integer):boolean;
     procedure _ontimer(sender:tobject);
     procedure _onserver(sender:tobject;index,id:integer;var data,extra:string);
     function roll(var index:integer;style:tmanagedudpexroll;range:integer):boolean;
     function canpull:boolean;
     procedure setrate(x:integer);//urls per min
     function getstatus(sep:char):string;
    public
     //events
     onserver:teventudpex;
     //create
     constructor create; override;
     destructor destroy; override;
     //information
     property server:tudpex read iserver;
     property safelevel:boolean read getsafelevel;
     property active:integer read iactive;
     property activeidle:integer read iactiveidle;
     property size:integer read getsize write setsize;
     property rate:integer read irate write setrate;//urls per minute
     property speed:trates read ispeed;
     property status[sep:char]:string read getstatus;
     //items
     property valid[x:integer]:boolean read getvalid;
     property inuse[x:integer]:boolean read getinuse;
     //workers
     function open(_ip:integer;_port:word;_sendtext:string;_onclose:tmanagedudpexcloseevent;var _rid:integer):boolean;
     function openex(_ip:integer;_port:word;_sendtext:string;_onclose:tmanagedudpexcloseevent;_tag:integer;_str:string;_obj:tobject;var _rid:integer):boolean;
     function pull:boolean;
     function pullex(range:integer):boolean;
    end;

{tsecurityip}
    tsecurityip=class(trootobject)
    private
     //last info
     ilastn,ilastp:integer;
     //counters
     ihitlimit,ierrorlimit:integer;
     ibytelimit:currency;
     ihit,ierror:tdynamicinteger;
     ibyte:tdynamiccurrency;
     //misc
     iname:tdynamicinteger;
     itimeout:currency;
     itime:tdynamiccurrency;
     function getsize:integer;
     procedure setsize(x:integer);
     function getname(x:integer):integer;
     function gethit(x:integer):integer;
     function geterror(x:integer):integer;
     function getbyte(x:integer):currency;
     procedure sethitlimit(x:integer);
     procedure seterrorlimit(x:integer);
     procedure setbytelimit(x:currency);
     procedure settimeout(x:currency);
     function _passed(x:integer):boolean;
     function statsadd(p:integer;var x:string;var xlen:integer;var tindex:currency;var colsep,linesep:string;b:tdynamicboolean):boolean;
    public
     //create
     constructor create; override;
     destructor destroy; override;
     //workers
     function find(n:integer):integer;
     function findb(n:integer;new:boolean):integer;
     procedure clear;
     property size:integer read getsize write setsize;
     //passed
     function passed(n:integer;_bytes:currency;_error:integer;_hit,log:boolean):boolean;
     //hit
     property hit[x:integer]:integer read gethit;
     property hitlimit:integer read ihitlimit write sethitlimit;//set to 0 for no-limit
     //error
     property error[x:integer]:integer read geterror;
     property errorlimit:integer read ierrorlimit write seterrorlimit;//set to 0 for no-limit
     //byte
     property byte[x:integer]:currency read getbyte;
     property bytelimit:currency read ibytelimit write setbytelimit;//set to 0 for no-limit
     //information
     property name[x:integer]:integer read getname;
     property timeout:currency read itimeout write settimeout;
     function stats(showheader:boolean;colsep,linesep:string):string;
     function iwe(x:integer):boolean;//is wec error
     procedure readsettings(_sysptr:integer);
    end;

{tsecurityfilter}
    tsecurityfilter=class(tobject)
    private
     istyle:byte;//0=off, 1=disallow, 2=allow
     itext:string;//Note: "itext" stores cleaned input data as reference only
     icount:integer;//reference only
     //ip
     iipfrom,iipto:tdynamiccurrency;
     iipmask:tdynamicstring;
     //ua
     iua,iuamask:tdynamicstring;
     //referer
     iref,irefmask:tdynamicstring;
     function isip(x:string):boolean;
     function ip8(ip4:integer):currency;
     function asfilter(x:string;var _from,_to:currency;var _fromIP,_toIP:integer):boolean;
     procedure settext(x:string);
    public
     //create
     constructor create;
     destructor destroy; override;
     //support
     function ipfind(_ip:integer):integer;
     function uafind(_ua:string):integer;
     function reffind(_ref:string):integer;
     //workers
     procedure clear;
     property text:string read itext write settext;
     procedure readsettings(_sysptr:integer);
     //passed
     function passed(_ip:integer;var _header:string):boolean;
     function passedb(_ip,_ipproxy:integer;_ua,_ref,_pfd:string):boolean;
     //information
     property count:integer read icount;
    end;

{tvirtualsecurityfilter}
   tvirtualsecurityfilter=class(tvirtualtext)
   public
    //internal
    function _filter(x:string):string; override;
   end;

{tvirtualfiltersnippet}
   tvirtualfiltersnippet=class(tvirtualtext)
   public
    //internal
    function _filter(x:string):string; override;
   end;

{tmanagedserver}
    tmanagedserver=class(tmanaged)
    private
     iserver:tserverbasic;
     ilist:tvirtuallist;
     ifilters:array[0..3] of tsecurityfilter;
     irecordlogs,iinheaders:tvirtualcontrol;
     ipages:tvirtualpages;
     ibupAccess,ibanua:string;
     ibasicshow,imimesshow:boolean;
     function _onrequest(sender:tobject;var header,content:string;var wait:boolean):boolean;
    public
     //vars
     filter:boolean;
     security:boolean;
     //events
     onrequest:trequestevent;
     //internal
     function createserver:tserverbasic; virtual;
     procedure readwrite(mode:tvirtualstoragemode); override;
     property pages:tvirtualpages read ipages;//18FEB2008
     //create
     constructor create(_gui:tvirtualform;_sysptr:integer;_vars:string); override;
     constructor createfrom(_gui:tvirtualform;_sysptr:integer;_vars:string;_server:tserverbasic);
     destructor destroy; override;
     //filters
     function passedfilter(ip:integer;var header,content:string):boolean;
     function passedsecurity(ip:integer;var header,content:string):boolean;
     function passedall(ip:integer;var header,content:string):boolean;
     property bup:string read ibupAccess;
     //server
     property server:tserverbasic read iserver;
    end;

{tmanagedconnections}
    tmanagedconnectionban=set of (mcbBANPRIVATE,mcbBANREDIRECT);
    tmanagedcloseevent=procedure(_url,_urlfinal,_urlredirect,_outtext:string;_tag,_id,_ip,_code:integer;_header,_content:string;sendbytes,recvbytes:currency) of object;
    tmanagedconnections=class(trootobject)
    private
     ispeed:trates;
     iagent,iua:string;
     ispeedtimer,itimethread,itime,islowref,idelay:currency;
     iactivethreads,ipullindex,itimer,iactive,ithreadlimit,irate:integer;
     ithreads:array[1..40] of tclientredirect;
     iurl,iouttext:tdynamicstring;
     itag,ithreadid:tdynamicinteger;
     irecvlimit:tdynamiccurrency;
     ionclose:tdynamicnotifyevent;
     istate,iban:tdynamicbyte;//0=free, 1=queued, 2=working, 3=finished
     function getstate(x:integer):byte;
     procedure setsize(x:integer);
     function getsize:integer;
     procedure _onopen(sender:tobject;_requesturl,_host:string;var _header:string);
     procedure _onclose(sender:tobject);
     procedure _closeid(_url,_urlfinal,_urlredirect,_outtext:string;_tag,_id:integer;_ip,_code:integer;_header,_content:string;sendbytes,recvbytes:currency);
     procedure setua(x:string);
     procedure _ontimer(sender:tobject);
     function pull(var _id:integer):boolean;
     function getactivethreads:integer;
     procedure setrate(x:integer);
     function getsafelevel:boolean;
     function getstatus(sep:char):string;
    public
     //create
     constructor create; override;
     destructor destroy; override;
     function empty:boolean; override;
     //open
     procedure open(_url,_outtext:string;_tag:integer;_recvlimit:currency;_ban:tmanagedconnectionban;_onclose:tmanagedcloseevent;var _id:integer);
     property state[_id:integer]:byte read getstate;
     //close
     procedure closeall;
     procedure closeid(var _id:integer);
     //size
     property size:integer read getsize write setsize;
     property active:integer read iactive write iactive;
     property activethreads:integer read iactivethreads;
     property rate:integer read irate write setrate;//1..2000 urls/minute
     property threadlimit:integer read ithreadlimit;//1..40
     property safelevel:boolean read getsafelevel;
     property speed:trates read ispeed;
     property status[sep:char]:string read getstatus;
     //useragent
     property ua:string read iua write setua;
     property agent:string read iagent;
     //misc
     function valid(x:integer):boolean;
    end;


{tnavcacheimages = "navimgs"}
//yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy//44444444444444444
    tnavcacheimages=class(trootobject)
    private
     inilimage:tvirtualbitmap;
     iname:tdynamicnamelist;
     iimage:tdynamicobject;
     function getimg(x:integer):tvirtualbitmap;
     procedure setimg(x:integer;y:tvirtualbitmap);
     function getimgn(x:string):tvirtualbitmap;
     procedure setimgn(x:string;y:tvirtualbitmap);
     procedure settep(x:integer;tep:string);
     procedure settepn(_name,tep:string);
     function getvalid(x:integer):boolean;
     function getvalidex(x:integer;_upperlimit:boolean):boolean;
     function getcount:integer;
     function getactive:integer;
    public
     //create
     constructor create; override;
     destructor destroy; override;
     //valid
     property valid[x:integer]:boolean read getvalid;
     property validex[x:integer;_upperlimit:boolean]:boolean read getvalidex;
     //img
     property img[x:integer]:tvirtualbitmap read getimg write setimg;//get image by index
     property imgn[x:string]:tvirtualbitmap read getimgn write setimgn;//get image by name
     //tep - use this to create new images from tep's
     property tep[x:integer]:string write settep;
     property tepn[x:string]:string write settepn;
     //edit
     function find(_name:string):integer;
     procedure clear;
     //information
     property count:integer read getcount;
     property active:integer read getactive;
    end;

{tnavcacheurls = "navurls"}
//yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy//55555555555555555555555555555
    tnavcacheurlitem=record
      inuse:boolean;
      //note: urls are not encoded versions
      ua:string;
      ub:string;
      folders:string;
      files:string;
      code:integer;
      end;
    pnavcacheurlitems=^tnavcacheurlitems;
    tnavcacheurlitems=record
      items:array[0..199] of tnavcacheurlitem;
      index:integer;
      end;//end of if
    tnavcacheurls=class(trootobject)
    private
     imax:integer;
     icache:tnavcacheurlitems;
     ipcache:pnavcacheurlitems;
     function getvalid(x:integer):boolean;
     function getinuse(x:integer):boolean;
     function getcount:integer;
     function getactive:integer;
     function getfolders(x:integer):string;
     function getfiles(x:integer):string;
     function getcode(x:integer):integer;
     function getua(x:integer):string;
     function getub(x:integer):string;
    public
     //create
     constructor create; override;
     destructor destroy; override;
     //valid
     property valid[x:integer]:boolean read getvalid;
     property inuse[x:integer]:boolean read getinuse;
     //workers
     function pull(ua,ub:string;var index:integer):boolean;
     function push(ua,ub:string;code:integer;folders,files:string;var index:integer):boolean;
     procedure clear;
     procedure clearex(_prompt:boolean);
     //information
     property ua[x:integer]:string read getua;
     property ub[x:integer]:string read getub;
     property folders[x:integer]:string read getfolders;
     property files[x:integer]:string read getfiles;
     property code[x:integer]:integer read getcode;
     property count:integer read getcount;
     property active:integer read getactive;
     //common - support (used by other controls such as tnavbase and tnavurl)
     procedure pu(x:string;var ui:tparseurl;_encode:boolean);
     //_cache - pointer to internal structure, readonly, do not write
     property _cache:pnavcacheurlitems read ipcache;
    end;

    tnavview=class;
{tnavbase}
//yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy//333333
    tnavshow=set of (nsHideFiles,nsHideInternet,nsHideLocal);//yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy
    tnavbase=class(tvirtualpage)
    private
     ilist:tvirtualbaselist;
     //core
     imask,iaddress:string;
     //reading
     icanbookmark,ifromhost,ionce,imustread,irefreshing,ireading:boolean;
     ireadcount,inavcount:integer;//temporary only
     //listing information
     iimage,ilabel,ides,iname:tdynamicstring;
     isize:tdynamiccurrency;
     idate:tdynamicdatetime;
     idateshow:tdynamicboolean;
     iindent:tdynamicword;
     //core listing data
     iurl:string;
     ihost:string;//host+port - \\god1 or c: or www.blaiz.net:72, no trailing slashes
     ipath:string;//always a trailing slash
     ifile:string;//no slashes
     inavs:tdynamicstring;// path=a/b/c/d => [0=a/, 1=a/b/, 2=a/b/c/, 3=a/b/c/d/]
     procedure setreading(x:boolean);
     procedure _onkey(sender:tobject;var key:byte);
     procedure _ondblclick(sender:tobject);
     procedure _onimage(sender:tobject;index:integer;var image:tvirtualbitmap);
     procedure _getitemtext(sender:tobject;index:integer;var value:string);
     procedure _getindent(sender:tobject;index:integer;var value:word);
     function getaction(x:integer):string;
     function canasname(action:string):boolean;
     function getprogress:single;
     procedure setprogress(x:single);
     function getlabel(x:integer):string;
     function getname(x:integer):string;
     function getimage(x:integer):string;
     //read
     property reading:boolean read ireading write setreading;
     function readcount:integer;
     function readone(_label,_des,_name,_image:string;_size:currency;_date:tdatetime;_dateshow:boolean;_indent:word):integer;//add item to list
     //support
     function filtername(x:string):string;
     function filtervalue(x:string):string;
    public
     //vars
     id:integer;//for setparams
     host:tnavview;
     naStyle:string;//style of panel
     //internal
     function getvalid(x:integer):boolean;//TRUE=if item is valid
     function getaddress:string; virtual;
     procedure _ontimer(sender:tobject); override;
     procedure _onaction(sender:tobject); virtual;
     procedure _onreadstart(sender:tobject); virtual;//for intetnet/network of other downloading style controls
     procedure _onreadend(sender:tobject); virtual;//fill list and update display
     //create
     constructor create(_gui:tvirtualform); override;
     destructor destroy; override;
     //action
     property action[x:integer]:string read getaction;
     function _actionsupported(x:string):boolean; virtual;
     function actionsupported(x:integer):boolean;
     //setparams
     procedure setparams(_address,_mask:string); virtual;
     //filters
     function aalocal(x,xdefault:string):string;//address as local
     function aaurl(x,xdefault:string):string;//address as url
     function aastyle(x,xdefault:string):string;//address as current "nastyle"
     function aastyleex(x,xdefault,_nastyle:string):string;
     function addressfilter(x:string):string; virtual;
     //common
     property progress:single read getprogress write setprogress;
     property refreshing:boolean read irefreshing;
     function canrefresh:boolean; virtual;
     procedure refresh; virtual;
     function canstop:boolean; virtual;
     procedure stop; virtual;
     function canclear:boolean; virtual;
     procedure clear; virtual;
     function canbookmark:boolean; virtual;
     procedure bookmark; virtual;
     //information
     property valid[x:integer]:boolean read getvalid;
     property labels[x:integer]:string read getlabel;
     property names[x:integer]:string read getname;
     property images[x:integer]:string read getimage;
     property address:string read getaddress;//yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy
    end;

{tnavurl}
//yyyyyyyyyyyyyyyyyyyyyyyyy//222222
    tnavurl=class(tnavbase)
    private
     iclient:tclientredirect;
     procedure fill(index:integer);
     procedure _onrecv(sender:tobject;var header,content:string;first:boolean);
     procedure _onclose(sender:tobject);
    public
     //internal
     procedure _onreadstart(sender:tobject); override;
     //create
     constructor create(_gui:tvirtualform); override;
     destructor destroy; override;
     //common
     function canstop:boolean; override;
     procedure stop; override;
     function canclear:boolean; override;
     procedure clear; override;
    end;

{tnavlocal}
//yyyyyyyyyyyyyyyyyyyyyyyyy//999999999999999
    tnavlocal=class(tnavbase)
    private

    public
     //internal
     procedure _onreadstart(sender:tobject); override;
     //create
     constructor create(_gui:tvirtualform); override;
     destructor destroy; override;
    end;

{tnavbookmarks}
//yyyyyyyyyyyyyyyyyyyyyyyyy//aaaaaaaaaaaaaaaaaaaa
    tnavbookmarks=class(tnavbase)
    private
     procedure pull;
    public
     //internal
     procedure _onreadstart(sender:tobject); override;
     //create
     constructor create(_gui:tvirtualform); override;
     destructor destroy; override;
     //workers
     procedure add(_name,_address:string);
    end;

{tnavhome}
//yyyyyyyyyyyyyyyyyyyyyyyyy//888888888888
    tnavhome=class(tnavbase)
    private
     ionce:boolean;
    public
     //internal
     procedure _onreadstart(sender:tobject); override;
     //create
     constructor create(_gui:tvirtualform); override;
     destructor destroy; override;
    end;

{tnavview}
//yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy//66666666666666666666666
    tnavview=class(tvirtualpage)
    private
     ioaddress,iomask,imustpanel,imustaddress,imustmask:string;
     iroot:tnavbase;
     ibookmarks:tnavbookmarks;//pointer only
     idisableonpage:boolean;
     ipages:tvirtualpages;
     iadd,iclear,istop,irefresh:tvirtuallink;
     iprogress:tvirtualprogress;
     function getnavs(x:integer):tnavbase;
     function getnavscount:integer;
     function getnav:tnavbase;
     procedure _onclick(sender:tobject);
     procedure _onpage(sender:tobject);
     procedure updatebuttons;
     function new(nastyle:string):tnavbase;
     function getreading:boolean;
     procedure setreading(x:boolean);
     property reading:boolean read getreading write setreading;
     function getprogress:single;
     procedure setprogress(x:single);
     procedure setpanel(x:string);
     function getpanel:string;
    public
     //vars
     id:integer;//id for init
     //internal
     procedure _ontimer(sender:tobject); override;
     //create
     constructor create(_gui:tvirtualform); override;
     destructor destroy; override;
     //workers
     procedure sync;
     //setparams
     procedure init(_address,_mask:string);
     procedure setparams(_address,_mask:string);
     //bookmark
     function canbookmark:boolean;
     procedure bookmark(_address,_mask:string);
     //information
     property navs[x:integer]:tnavbase read getnavs;
     property navscount:integer read getnavscount;
     property nav:tnavbase read getnav;
     property panel:string read getpanel write setpanel;
     property progress:single read getprogress write setprogress;
    end;

{tnavdlg}
    tnavdlg=class(trootobject)
//yyyyyyyyyyyyyyyyyyyyyyyyy
    private
     inav:tnavview;
     iopenfile,ihideonclose,idownloading,imustreload,imustrefresh,iopening:boolean;
     idata:string;
     idlg:tvirtualdlg;
     iopen,icancel:tvirtualbutton;
     iroot,iallfiles,istop,iload,iclearcache:tvirtuallink;
     iurls:tvirtualdroplist;
//yyyyyyyyyyyyyyyyyy     iclient:tclientredirect;
     procedure __onclick(sender:tobject);
    public
     //create
     constructor create; override;
     destructor destroy; override;
     //workers
     function canopen:boolean;
     function open(var _address,_mask,_data,e:string;_prompt:boolean):boolean;
    end;

{tcacherobot}
    //.bot - robots.txt "filters"
    pbot=^tbot;
    tbot=array[0..511] of char;//512

    tcacherobotREC=packed record
      ip:integer;
      dim:integer;
      wec:integer;//web error code
      value:tbot;
      end;

    tcacherobot=class(tcachebasic)
    private
     iip,idim,iwec:tdynamicinteger;
    public
     //internal
     function getinuse(x:integer):boolean; override;
     procedure setinuse(x:integer;y:boolean); override;
     function sizeRAM(x:integer):boolean; override;
     function fromRAM(x:integer;var rec):boolean; override;
     function toRAM(x:integer;var rec):boolean; override;
     function getactive:integer; override;
     function bpiRAM:integer; override;
     //create
     constructor create;
     procedure _createsupport; override;
     procedure _destroysupport; override;
     //workers
     function find(_ip:integer;var x:integer):boolean;
     function findvalue(_ip:integer;var _wec,_dim,_index:integer;var x:string):boolean;
     function new(_ip:integer;var x,xcomment:integer):boolean;
     function addonce(_ip,_wec:integer;var _index,_indexcomment:integer;_value:string):boolean;
     //null
     function pull(var x:string):boolean;
     function push(x:string):boolean;
    end;

{tmanagedrobot}
    trobotevent=procedure(_ip,_wec,_dim,_index:integer;_value:string;_cached:boolean;sendbytes,recvbytes:currency) of object;
    tmanagedrobot=class(trootobject)
    private
     icache:tcacherobot;
     iiplist:tdynamicinteger;
    public
     //create
     constructor create; override;
     destructor destroy; override;
     //control
     function lockip(_ip:integer;var _wec,_dim,_index:integer;var _value:string;var _cached:boolean):byte;
     procedure unlockip(_ip:integer);
     procedure pushcontent(_ip,_code:integer;_content:string);
     //cache
     property cache:tcacherobot read icache;
    end;

{tcacheredirect}
    tcacheredirect=class(trootobject)
    private
     iu,iur:tdynamicstring;
     iuref:tdynamiccurrency;
     ipos:integer;
     function getsize:integer;
     procedure setsize(x:integer);
    public
     //create
     constructor create; override;
     destructor destroy; override;
     //workers
     property size:integer read getsize write setsize;
     function find(url:string;var redirecturl:string):boolean;
     procedure add(url,redirecturl:string);
    end;

{tipfilter}
    tipfilter=class(tobject)
    private
     ienabled:boolean;
     ifilter:string;
     ipos:integer;
     ifrom,ito:tdynamiccurrency;
     procedure setfilter(x:string);
     function getcount:integer;
    public
     //create
     constructor create;
     destructor destroy; override;
     //filter
     property enabled:boolean read ienabled write ienabled;
     property filter:string read ifilter write setfilter;
     function asfilter(x:string;var _from,_to:currency;var _fromIP,_toIP:integer):boolean;
     function ip8(ip4:integer):currency;
     //workers
     function find(ip:integer):integer;
     function found(ip:integer):boolean;
     //other
     property pos:integer read ipos write ipos;
     property count:integer read getcount;
    end;

{trawlog}
    trawlogstyle=set of (rlsDisk,rlsList);
    trawlog=class(trootobject)
    private
     istyle:trawlogstyle;
     itimeout,ilastcanviewtime,ilastcanviewbantime,ilastcanviewtraffictime,itimeindex:currency;
     itmplen,ibanlen,itimer:integer;
     ilist:trolltext;
     itrafficfn,ibanfn,icurrentfn,itmp,iban:string;
     ilastcanview,ilastcanviewban,ilastcanviewtraffic:boolean;
     procedure _ontimer(sender:tobject);
     procedure disk;
    public
     //var
     includeInheaders:boolean;//TRUE=input headers included within standard rawlogs if (code<>200)
     //create
     constructor create; override;
     destructor destroy; override;
     //add
     procedure addstr(x:string);
     procedure addentry(cip:integer;dt:tdatetime;rl:string;ec:integer;bytes:currency;rf,ua,extra,extralines,inputheader:string);
     procedure addheader(i,o:pstring;code:integer;ip:integer;bytes,tst:currency;extra,extralines:string);
     procedure addheaderb(i,o:pstring;code:integer;ip:integer;bytes,tst:currency;extra,extralines:string;raw:boolean);
     procedure addbanned(ip,hitcount,errorcount:integer;bytecount:currency);
     //view
     function canview:boolean;
     procedure view;
     //ban
     function canviewban:boolean;
     procedure viewban;
     //traffic
     function canviewtraffic:boolean;
     procedure viewtraffic;
     //folder
     procedure viewfolder;
     //list
     property list:trolltext read ilist;
     function listtext32k(up:boolean):string;
     //other
     property style:trawlogstyle read istyle write istyle;
     property timeout:currency read itimeout;
     procedure addlogextra(x:string;var z:string);
     //internal
     function fp:string;
     function fnLOG:string;
     function fnBAN:string;
     function fnREQ:string;
     function fnTRA:string;
    end;

{tids}
    tids=class(tobject)
    private
     iid:tdynamicname;
     itime:tdynamiccurrency;
     itimeout:currency;
     iactive,itimer:integer;
     procedure _del(index:integer);
     function getsize:integer;
     procedure setsize(x:integer);
     procedure _ontimer(sender:tobject);
     procedure settimeout(x:currency);
     procedure check;
    public
     //create
     constructor create;
     destructor destroy; override;
     //other
     function valid(_id:string):boolean;
     function new:string;
     procedure del(_id:string);
     procedure clear;
     //size - automatically enlargens
     property size:integer read getsize write setsize;
     property active:integer read iactive;
     property timeout:currency read itimeout write settimeout;
    end;

{tnetsession}   
    tnetsession=class(trootobject)
    private
     iIdleMS:integer;
     ilockcount:integer;
     irunning:boolean;
     iinfo:TWSAData;
     ipinfo:PWSAData;
     function getmsghandle:hwnd;
     procedure _stop;
     procedure SetIdleMS(x:integer);
     function getuseragents(sep:string):string;
    public
     //create
     constructor create; override;
     constructor createsys(sysVar:prootobject); override;
     destructor destroy; override;
     //info
     function remoteip(_socket:integer;var _ip:integer):boolean;
     function remoteipb(_socket:integer):integer;
     function hlen(var x:string;var len:integer):boolean;
     function hlenb(var x:string;xlen:integer;var len:integer):boolean;
     function findservice(def,http:integer;const service:string):integer;
     //header
     function ahRLb(var h:string;var hlen:integer;m:char;t,u,p,v:string):boolean;//adjust header request-line
     function ahRL(var h:string;var hlen:integer;m:char;var t,u,p,v:string):boolean;//adjust header request-line
     function rlINFO(var h:string;var hlen:integer;var tPOS,uPOS,pPOS,vPOS:tpoint):boolean;//request-line information
     function multipart(var header:string;var boundary:string):boolean;
     //authorization
     function bup(username,password:string):string;//basic: username & password for "http 401"
     function bupENABLED(sysBUP:string):boolean;
     function bupCREATE(enabled,restrict:boolean;username,password:string):string;
     function bupACCESS(brwBUP,sysBUP:string):boolean;
     function bupDUALENABLED(sysBUP,sysBUP2:string):boolean;
     function bupRESTRICTED(sysBUP:string):boolean;
     //other
     function start:boolean;
     procedure stop;
     property running:boolean read irunning;
     property info:PWSAData read ipinfo;
     property lockcount:integer read ilockcount;
     //time
     property IdleMS:integer read iIdleMS write SetIdleMS;
     function WithinTime(var x:TWebHeader):boolean;
     //strings
     function safeua(x:string):string;
     function agentname(x:string):string;
     property useragents[sep:string]:string read getuseragents;
     //accept-encoding
     function gzipsafeext(ext:string):boolean;
     function canGZIP(var header:string):boolean;//13-OCT-2006
     procedure GZIP(var header,content:string;autodecide:boolean);//browser controlled
     procedure GZIPheader(var header,content,pregzippedcontent:string;autodecide:boolean);//browser controlled
     //resume
     procedure supportRESUME(var header:string);
     function canRESUME(var header:string):boolean;//19-OCT-2006
     function readRESUMEi(var header:string;var start,len:integer):boolean;
     function readRESUME(var header:string;var start,len:currency):boolean;//26-DEC-2006
    end;

{TWebHeaders}
  TWebHeaders=class(trootobject)
  private
   function new(var x:TWebHeader;n:string;var xnew:boolean):integer;
   function GetFind(var x:TWebHeader;n:string):integer;
   procedure SetValue(var x:TWebHeader;n,v:string);
   function GetValue(var x:TWebHeader;n:string):string;
   function GetLen(var x:TWebHeader;n:string):integer;
   function GetInt(var x:TWebHeader;n:string):integer;
   procedure SetInt(var x:TWebHeader;n:string;v:integer);
   function emfi(var x:TWebHeader;y:string):boolean;{extract method and filename info}
   procedure SetText(var x:TWebHeader;y:string);
   function GetText(var x:TWebHeader):string;
   function GetCount(var x:TWebHeader):integer;
   procedure flushtmp(var x:TWebHeader;clr:boolean);
   function GetOutput(var x:TWebHeader):string;
  public
   //create
   constructor create; override;
   destructor destroy; override;
   //host
   function hostnameb(x:string;var h:string):boolean;
   function hostname(x:string):string;
   function hostb(x:string;var h,etc:string):boolean;
   function host(x:string):string;
   //other
   function removehash(x:string):string;
   function alwslash(x:string):string;
   function echv(var _data,_muv,_getcontent,_httpv,_method,_filename:string):boolean;//extract critical header values
   function env(var x:string;var pos,ep:integer;var n,v:string):boolean;{extract name value}
   property find[var x:TWebHeader;n:string]:integer read GetFind;
   property value[var x:TWebHeader;n:string]:string read GetValue write SetValue;
   procedure PushValue(var x:TWebHeader;n:string;var v:string;vmax:integer);
   property len[var x:TWebHeader;n:string]:integer read GetInt;
   property int[var x:TWebHeader;n:string]:integer read GetInt write SetInt;
   property text[var x:TWebHeader]:string read GetText write SetText;
   property output[var x:TWebHeader]:string read GetOutput;
   property count[var x:TWebHeader]:integer read GetCount;
   procedure clear(var x:TWebHeader;y:TWebHeaderClear);
   procedure del(var x:TWebHeader;s,f:integer;y:TWebHeaderClear);
   {workers}
   //header
   function rwh(var x:TWebHeader;var y:string):boolean;{read web header}
   //header.boundaries
   function ehb(var x:string;var eohp,hlen:integer):boolean;{extract header boundaries}
   function sn(x:string):string;{system name}
   //content
   function crc(var x:TWebHeader):boolean;{can read content - i.e. content not at "content-length" size}
   function rc(var x:TWebHeader;y:string):boolean;{read content}
  end;

{TByteStream}
    TByteBuffer=Record
      Items:Array[0..bbccMax] of Byte;
      OffSet:Integer;
      Count:Integer;
      Modified:Boolean;
      end;//end of record

    TWordBuffer=Record
      Items:Array[0..bbccMax] of Word;
      OffSet:Integer;
      Count:Integer;
      Modified:Boolean;
      end;//end of record

    TByteStream=class(tobject)
    Private
     iStream:TStream;
     iBuffer:TByteBuffer;
     iSize:Integer;
     iSeekMode:Integer;
     Procedure Clear;
     Procedure SetStream(X:TStream);
     Procedure SetSeekMode(X:Integer);
    Public
     {create}
     constructor create;
     destructor destroy; override;
     {Properties}
     Property Stream:TStream Read iStream Write SetStream;
     Function Get(X:Integer;Var Y:Byte):Boolean;
     Function Put(X:Integer;Y:Byte):Boolean;
     Function Finalise:Boolean;
     Property Size:Integer Read iSize;
     Property SeekMode:Integer Read iSeekMode Write SetSeekMode;
     {Special}
     Function ReadLine(Var sS:Integer;sF:Integer;Var S,F:Integer;FindByte:Byte;Var FindP:Integer):Boolean;
     Function FindByte(X:Byte;S,F:Integer):Integer;
     Function SwapByte(X,Y:Byte;S,F:Integer):Boolean;
     Function AsciiDecimalToBinary(S,F,MaxV:Integer;Var X:TWordBuffer):Boolean;
     Function XHexToBinary(S,F,MaxV:Integer;Var X:TByteBuffer):Boolean;
     Function ByteToXHex(X:Byte;Var Y:TByteBuffer):Boolean;
     Function Str(S,F:Integer):String;
     Function ReadWordValue(Var X:TWordBuffer;Var Y:Integer):Boolean;
     Function PushStr(Var X:Integer;Y:String):Boolean;
    end;

{TByteImage}
    TByteImage=class(tobject)
    Private
     iRow:PRGBColorRow;
     iRowY:Integer;
     iImage:TBitmap;
     iX,iY,iZeroWidth,iZeroHeight,iWidth,iHeight:Integer;
     Function ReadRow(Y:Integer):Boolean;
     Procedure SetImage(X:TBitmap);
     Function GetPixels(X,Y:Integer):TRGBColor;
     Procedure SetPixels(X,Y:Integer;Z:TRGBColor);
     Function GetRow(Y:Integer):PRGBColorRow;
    Public
     {create}
     constructor create;
     {Properties}
     Property Image:TBitmap Read iImage Write SetImage;
     Property Pixels[X,Y:Integer]:TRGBColor Read GetPixels Write SetPixels;
     Property X:Integer Read iX Write iX;
     Property Y:Integer Read iY Write iY;
     Property ZeroWidth:Integer Read iZeroWidth;
     Property ZeroHeight:Integer Read iZeroHeight;
     Property Width:Integer Read iWidth;
     Property Height:Integer Read iHeight;
     Function MoveTo(X,Y:Integer):Boolean;
     Function PushPixel(Var X:TRGBColor):Boolean;
     Function PullPixel(Var X:TRGBColor):Boolean;
     Procedure ExpandBits(X:Byte;Var Y:TByteBuffer);
     Property Row[Y:Integer]:PRGBColorRow Read GetRow;
    end;

{TColorIcon}
    TIconHeader=Array[0..ihMax] of Byte;
    TIconStyle=Record
    {Dimensions}
    Width:Integer;
    Height:Integer;
    {Transparency}
    Transparent:Boolean;
    TransparentX:Integer;
    TransparentY:Integer;
    TransparentColor:TRGBColor;
    {Colors}
    Colors:Integer;
    {BPP}
    BPP:Byte;
    end;
    TImageInfo=Record
    BPP:Byte;
    WIDTH:Integer;
    HEIGHT:Integer;
    ZeroWidth:Integer;
    ZeroHeight:Integer;
    WIDTHbytes:Integer;
    BMPbytes:Integer;
    MONObytes:Integer;
    PALbytes:Integer;
    {Icon Related}
    DATAbytes:Integer;
    IMAGESbytes:Integer;
    {Other}
    TransColor:TRGBColor;
    end;

    PRGBPalette=^TRGBPalette;
    TRGBPalette=Array[0..rpccMax] of TRGBColor;

    PIntPalette=^TIntPalette;
    TIntPalette=Array[0..rpccMax] of Integer;

    PColorPalette=^TColorPalette;
    TColorPalette=Record
      Items:PRGBPalette;
      IntItems:PIntPalette;
      Count:Integer;
      end;//end of record

    TColorIcon=class(tgraphic)
    Private
     itransparent:boolean;
     ilockcount,itransparentcolor,ibpp,icolors,isize:integer;
     itransparentxy:tpoint;
     iimage:tbitmap;
     ierrormessage:string;
     FOnChange:TNotifyEvent;
     FOnProgress:TProgressEvent;
     Function FillImageInfo(Var X:TImageInfo):Boolean;
     Procedure Progress(Sender: TObject;Stage:TProgressStage;PercentDone:Byte;RedrawNow:Boolean;const R:TRect;const Msg:string);
     Procedure Progressing(PercentDone:Byte;const Msg:string);
     Function WriteHeader(X:TStream;Var Y:TImageInfo;Var E:String):Boolean;
     Function WritePalette(X:TStream;Var Y:TColorPalette;Var E:String):Boolean;
     Function WriteBMP(X:TStream;Var Y:TBitmap;Var Z:TColorPalette;Var Info:TImageInfo;Var E:String):Boolean;
     Function _BuildPalette(Var X:TBitmap;Var Pal:TColorPalette;Var Info:TImageInfo;Var E:String):Boolean;
     Function WidthBytes(rBPP,W:Integer):Integer;
     Function OffSet4(X:Integer):Integer;
     Function RoundRow(Var X:TByteStream;Var Pos:Integer;Y:Integer):Boolean;
     procedure setsize(x:integer);
     procedure setimage(x:tbitmap);
     function getcolors:integer;
     procedure settransparent(x:boolean);
     procedure settransparentxy(x:tpoint);
     procedure _update;
    protected
     function getheight:integer; override;
     function getwidth:integer; override;
     procedure setwidth(x:integer); override;
     procedure setheight(x:integer); override;
     function getempty:boolean; override;
     procedure draw(acanvas:tcanvas;const srect:trect); override;
     procedure LoadFromClipboardFormat(AFormat: Word; AData: THandle; APalette: HPALETTE); override;
     procedure SaveToClipboardFormat(var Format: Word; var Data: THandle; var APalette: HPALETTE); override;
    Public
     //create
     constructor create; override;
     destructor destroy; override;
     {Events}
     Property OnProgress:TProgressEvent Read FOnProgress Write FOnProgress;
     Property OnChange:TNotifyEvent Read FOnChange Write FOnChange;
     //other
     property image:tbitmap read iimage write setimage;
     procedure readimage(x:tbitmap);
     property size:integer read isize write setsize;
     property bpp:integer read ibpp;
     property colors:integer read getcolors;
     property transparentcolor:integer read itransparentcolor;
     property transparentxy:tpoint read itransparentxy write settransparentxy;
     property transparent:boolean read itransparent write settransparent;
     procedure assign(source:tpersistent); override;
     procedure paintto(darea:trect;i:tbitmap);
     procedure freeimage;
     procedure dormant;
     //io
     procedure savetostream(x:tstream); override;
     function savetofile(x:string):boolean;
     //errors
     property errormessage:string read ierrormessage write ierrormessage;
    end;

{TTextPicture}
    TTextPicture=class(TGraphic)
    Private
     FOnProgress:TProgressEvent;
     iImage:TBitmap;
     iLastTimerIndex:Integer;
     iStyle:Byte;
     iBPP:Byte;
     iErrorMessage:String;
     Procedure FromRGB(X:Integer;Var Y:TByteBuffer;Z:Integer);
     Function AsByte(Var X:Byte):Boolean;
     Function AsNum(Var X:Byte):Boolean;
     Function AsInteger(Var X:TByteBuffer;Y:Integer):Integer;
     Procedure Update;
     Procedure Progress(Sender: TObject;Stage:TProgressStage;PercentDone:Byte;RedrawNow:Boolean;const R:TRect;const Msg:string);
     Procedure Progressing(PercentDone:Byte;const Msg:string);
     Function ReadHeader(X:TStream;Var rBPP:Byte;Var W,H:Integer;Var Pal:TColorPalette):Boolean;
     Function WriteHeader(X:TStream;Var Y:TBitmap;rBPP,W,H:Integer;Var Pal:TColorPalette):Boolean;
     Function AsciiReader(X:TStream;rBPP:Integer;Var Y:TBitmap;Var Pal:TColorPalette):Boolean;
     Function AsciiWriter(X:TStream;S,rBPP:Integer;Var Y:TBitmap;Var Pal:TColorPalette):Boolean;
     Function StdPalette(Var Pal:TColorPalette):Boolean;
     Procedure SetStyle(X:Byte);
     Function WriteSep(X:TByteStream;Var Pos:Integer;Style:Integer;EOL:Boolean):Boolean;
     Procedure SetBPP(X:Byte);
     Function CondensePixels(Var X:TByteBuffer;bpp:Byte;Var Z:Byte):Boolean;
     Function ExpandPixels(X,bpp:Byte;Var Y:TByteBuffer;Z:Integer):Boolean;
    Protected
     procedure Draw(ACanvas: TCanvas; const Rect: TRect); override;
     function GetEmpty: Boolean; override;
     function GetHeight: Integer; override;
     function GetWidth: Integer; override;
     procedure SetHeight(Value: Integer); override;
     procedure SetWidth(Value: Integer); override;
     procedure LoadFromClipboardFormat(AFormat: Word; AData: THandle; APalette: HPALETTE); override;
     procedure SaveToClipboardFormat(var Format: Word; var Data: THandle; var APalette: HPALETTE); override;
    Public
     {create}
     constructor create; override;
     destructor destroy; override;
     {Assign}
     Procedure Assign(Source: TPersistent); override;
     {Properties}
     Procedure CopyFrom(X:TGraphic);
     Property OnProgress:TProgressEvent Read FOnProgress Write FOnProgress;
     Property Image:TBitmap Read iImage;
     Procedure FreeImage;
     Procedure Dormant;
     {Styles}
     Property Style:Byte Read iStyle Write SetStyle;
     Property BPP:Byte Read iBPP Write SetBPP;
     Function CountBPP:Byte;{Actual Realtime BPP}
     {IO}
     Procedure LoadFromStream(X:TStream);Override;
     Function LoadFromFile(X:String):Boolean;
     Function LoadFromStr(Var X:String):Boolean;
     Procedure SaveToStream(X:TStream);Override;
     Function SaveToFile(X:String):Boolean;
     Function SaveToStr(Var X:String):Boolean;
     Function Glyph(X:String):TBitmap;
     {Errors}
     Property ErrorMessage:String Read iErrorMessage Write iErrorMessage;
     Procedure ShowError;
    end;

{TXBitmap}
    TXBitmap=class(TGraphic)
    Private
     FOnProgress:TProgressEvent;
     iImage:TBitmap;
     iLastTimerIndex:Integer;
     iErrorMessage:String;
     Procedure Update;
     Procedure Progress(Sender: TObject;Stage:TProgressStage;PercentDone:Byte;RedrawNow:Boolean;const R:TRect;const Msg:string);
     Procedure Progressing(PercentDone:Byte;const Msg:string);
     Function ReadHeader(X:TStream;Var W,H:Integer):Boolean;
     Function WriteHeader(X:TStream;W,H:Integer):Boolean;
     Function Within(X:String;Var Y:String):Integer;
     Function AsciiReader(X:TStream;Var Y:TBitmap):Boolean;
     Function AsciiWriter(X:TStream;Var Y:TBitmap):Boolean;
    Protected
     procedure Draw(ACanvas: TCanvas; const Rect: TRect); override;
     function GetEmpty: Boolean; override;
     function GetHeight: Integer; override;
     function GetWidth: Integer; override;
     procedure SetHeight(Value: Integer); override;
     procedure SetWidth(Value: Integer); override;
     procedure LoadFromClipboardFormat(AFormat: Word; AData: THandle; APalette: HPALETTE); override;
     procedure SaveToClipboardFormat(var Format: Word; var Data: THandle; var APalette: HPALETTE); override;
    Public
     {create}
     constructor create; override;
     destructor destroy; override;
     {Assign}
     Procedure Assign(Source: TPersistent); override;
     {Properties}
     Procedure CopyFrom(X:TGraphic);
     Property OnProgress:TProgressEvent Read FOnProgress Write FOnProgress;
     Property Image:TBitmap Read iImage;
     Procedure FreeImage;
     Procedure Dormant;
     {IO}
     Procedure LoadFromStream(X:TStream);Override;
     Function LoadFromFile(X:String):Boolean;
     Procedure SaveToStream(X:TStream);Override;
     Function SaveToFile(X:String):Boolean;
     {Errors}
     Property ErrorMessage:String Read iErrorMessage Write iErrorMessage;
     Procedure ShowError;
    end;

{TPortablePixelmap PPM/PGB/PBM}
    TPortablePixelmapHeader=Record
      //style
      style:integer;
      //max color depth usually 255
      maxcolor:integer;
      //dimensions}
      width:integer;
      height:integer;
      end;//end of record

    TPortablePixelmap=class(TGraphic)
    Private
     FOnProgress:TProgressEvent;
     iImage:TBitmap;
     iStyle:Integer;
     iLastTimerIndex:Integer;
     iErrorMessage:String;
     Function ReadHeader(X:TStream;Var Y:TPortablePixelmapHeader):Boolean;
     Function WriteHeader(X:TStream;Var Y:TPortablePixelmapHeader):Boolean;
     Function SafeStyle(X:Integer):Integer;
     Function IsAscii(X:Integer):Boolean;
     Procedure SetStyle(X:Integer);
     Function GetAscii:Boolean;
     Procedure SetAscii(X:Boolean);
     Function AsciiReader(X:TStream;Var Y:TBitmap;MaxColor:Integer):Boolean;
     Function BinaryReader(X:TStream;Var Y:TBitmap;MaxColor:Integer):Boolean;
     Function AsciiWriter(X:TStream;Var Y:TBitmap):Boolean;
     Function BinaryWriter(X:TStream;Var Y:TBitmap):Boolean;
     Procedure Update;
     Procedure Progress(Sender: TObject;Stage:TProgressStage;PercentDone:Byte;RedrawNow:Boolean;const R:TRect;const Msg:string);
     Procedure Progressing(PercentDone:Byte;const Msg:string);
    Protected
     procedure Draw(ACanvas: TCanvas; const Rect: TRect); override;
     function GetEmpty: Boolean; override;
     function GetHeight: Integer; override;
     function GetWidth: Integer; override;
     procedure SetHeight(Value: Integer); override;
     procedure SetWidth(Value: Integer); override;
     procedure LoadFromClipboardFormat(AFormat: Word; AData: THandle; APalette: HPALETTE); override;
     procedure SaveToClipboardFormat(var Format: Word; var Data: THandle; var APalette: HPALETTE); override;
    Public
     {create}
     constructor create; override;
     destructor destroy; override;
     {assign}
     Procedure Assign(Source: TPersistent); override;
     {Properties}
     Procedure CopyFrom(X:TGraphic);
     Property Style:Integer Read iStyle Write SetStyle;
     Property Ascii:Boolean Read GetAscii Write SetAscii;
     Property OnProgress:TProgressEvent Read FOnProgress Write FOnProgress;
     Property Image:TBitmap Read iImage;
     Procedure FreeImage;
     Procedure Dormant;
     {IO}
     Procedure LoadFromStream(X:TStream);Override;
     Function LoadFromFile(X:String):Boolean;
     Procedure SaveToStream(X:TStream);Override;
     Function SaveToFile(X:String):Boolean;
     {Errors}
     Property ErrorMessage:String Read iErrorMessage Write iErrorMessage;
     Procedure ShowError;
    end;

{TOptimisedImage OMI}
  TOptimisedImage=class(TGraphic)
  Private
    FOnProgress:TProgressEvent;
    iImage:TBitmap;
    iLastTimerIndex:Integer;
    iStyle:String;
    iComment,iExtraInfo1,iExtraInfo2:String;
    iErrorMessage:String;
    Procedure Progress(Sender: TObject;Stage:TProgressStage;PercentDone:Byte;RedrawNow:Boolean;const R:TRect;const Msg:string);
    Procedure Progressing(PercentDone:Byte;const Msg:string);
    Function _SmallestImageStr(X:TBitmap;Var Y,Ztype:String):Boolean;
    Function WriteStrVal(Var X,Val:String):Boolean;
    Function ReadStrVal(Var Pos:Integer;Var X,Val:String):Boolean;
  Protected
    procedure Draw(ACanvas: TCanvas; const Rect: TRect); override;
    function GetEmpty: Boolean; override;
    function GetHeight: Integer; override;
    function GetWidth: Integer; override;
    procedure SetHeight(Value: Integer); override;
    procedure SetWidth(Value: Integer); override;
    procedure LoadFromClipboardFormat(AFormat: Word; AData: THandle; APalette: HPALETTE); override;
    procedure SaveToClipboardFormat(var Format: Word; var Data: THandle; var APalette: HPALETTE); override;
    Procedure Update;
    Procedure SetData(X:String);
    Function GetData:String;
  Public
    //create
    constructor create; override;
    destructor destroy; override;
    //assign
    procedure assign(Source: TPersistent); override;
    //properties
    Procedure CopyFrom(X:TGraphic);
    Property OnProgress:TProgressEvent Read FOnProgress Write FOnProgress;
    Property Image:TBitmap Read iImage;
    Procedure FreeImage;
    Procedure Dormant;
    //style
    Procedure Clear;
    Property Style:String Read iStyle;
    Property Comment:String Read iComment Write iComment;
    Property ExtraInfo1:String Read iExtraInfo1 Write iExtraInfo1;
    Property ExtraInfo2:String Read iExtraInfo2 Write iExtraInfo2;
    //data
    Function _GetData(Var X:String):Boolean;
    Function _SetData(X:String):Boolean;
    Property Data:String Read GetData Write SetData;
    //io
    Procedure LoadFromStream(X:TStream);Override;
    Function LoadFromFile(X:String):Boolean;
    Procedure SaveToStream(X:TStream);Override;
    Function SaveToFile(X:String):Boolean;
    //special - saves "x" automatically with best quality&compression
    function SaveJPG(x:tbitmap;y:string;var e:string):boolean;
    //errors
    Property ErrorMessage:String Read iErrorMessage Write iErrorMessage;
    Procedure ShowError;
  end;

{tbitmapenhanced}
    tbitmapenhanced=class(tbitmap)
    public
     ai:tanimationinformation;
     dtransparent:boolean;
    end;

{tfilters}
    //.rgb
    pfilterbasic=^tfilterbasic;
    tfilterbasic=procedure(var r,g,b:byte);
    //.action
    pfilteraction=^tfilteraction;
    tfilteraction=function(d:tbitmap;v1,v2:integer;var rtc:integer;var tc,stc:trgbcolor;var e:string):boolean;
    //.matrix
    pfiltermatrixinfo=^tfiltermatrixinfo;
    tfiltermatrixinfo=record
      inuse:boolean;
      v:array[0..24] of integer;
      vdiv:integer;//never zero
      vbias:integer;
      count:integer;//9=3x3 and 25=5x5
      rows:byte;//3x3=3, 5x5=5
      radius:byte;//3x3=1, 5x5=2
      end;
    pfiltermatrixvals=^tfiltermatrixvals;
    tfiltermatrixvals=array[0..24] of array[0..255] of integer;//3x3 and 5x5 filter matrixs fast lookup
    pfiltermatrix=^tfiltermatrix;
    tfiltermatrix=procedure(var r,g,b:byte;var f:tfiltermatrixinfo;var fv:tfiltermatrixvals;var x:integer;pr:array of pdlRGB);
    //.reference
    pfilterreference=^tfilterreference;
    tfilterreference=function(d:tbitmap;var ref:tbitmap;var refmode:byte;var e:string):boolean;
    //.items
    tfilteritem=record
      rawname:string;
      name:string;
      //events
      basic:tfilterbasic;
      action:tfilteraction;
      matrix:tfiltermatrix;
      reference:tfilterreference;
      //support
      mi:tfiltermatrixinfo;
      v1:integer;
      v2:integer;
      end;
    tfilteritems=array[0..199] of tfilteritem;
    tfilters=class(trootobject)
    private
     iitems:tfilteritems;
     ilastcount,icount:integer;
     ilastrawname:string;
     function valid(x:integer):boolean;
     function getrawname(x:integer):string;
     function getitem(x:integer):tfilteritem;
     function range(var _rawname,_name:string):boolean;
     procedure clear(x:integer);
     procedure addbasic(_rawname,_name:string;_event:tfilterbasic);
     procedure addaction(_rawname,_name:string;_v1,_v2:integer;_event:tfilteraction);
     procedure addreference(_rawname,_name:string;_event:tfilterreference);
     procedure addmatrix(_rawname,_name,_mi:string);
    public
     //create
     constructor create; override;
     destructor destroy; override;
     //information
     property items[x:integer]:tfilteritem read getitem;
     property count:integer read icount;
     function find(_rawname:string;var _index:integer):boolean;
     property rawname[x:integer]:string read getrawname;
     function names(sol,eol:string;rawname:boolean):string;
     //support
     function readmatrix(x:string;var y:tfiltermatrixinfo;var e:string):boolean;
     procedure rti(x:tbitmap;xy:tpoint;var tc:integer;var rgbTC,rgbsafeTC:trgbcolor);//read transparent information
     //workers
     function filter(d:tbitmap;var rtc:integer;filterlist:string;var e:string):boolean;
    end;

{taudioswap}
    taudioswap=class(tobject)
    private
     ivallimit,iswitch,ilength,ipos,ival1,ival2:integer;
     ivalref1,ivalref2,iswitchstep:extended;
     idown:boolean;
    public
     //create
     constructor create;
     //workers
     procedure init(_length,_switch,_vallimit:integer);
     procedure next;
     property length:integer read ilength;
     property switch:integer read iswitch;
     property val1:integer read ival1;
     property val2:integer read ival2;
     property vallimit:integer read ivallimit;
    end;

{taudio}
    //.basic
    taudiobasicevent=procedure(var val:smallint);
    //.action
    paudioaction=^taudioaction;
    taudioaction=function(var pos:integer;v1,v2:integer;var dl,dr:tdynamicsmallint;l,r:tdynamicsmallint;var e:string):boolean;
    //.matrix
    paudiomatrixinfo=^taudiomatrixinfo;
    taudiomatrixinfo=record
      v:array[0..9] of integer;//range -500..500 [100x500x32767=>1,638,350,000 "within 32bit-integer"]
      vdiv:integer;
      vbias:integer;
      count:integer;
      end;
    taudiomatrix=procedure(var val:smallint;pos,ysize:integer;y:pdlSMINT;var m:taudiomatrixinfo);
    //.items
    paudioitem=^taudioitem;
    taudioitem=record
      rawname:string;
      name:string;
      //events
      action:taudioaction;
      matrix:taudiomatrix;
      basic:taudiobasicevent;
      //support
      mi:taudiomatrixinfo;
      v1:integer;
      v2:integer;
      end;
    paudioitems=^taudioitems;
    taudioitems=array[0..199] of taudioitem;
    //.pullinfo
    paudiopullinfo=^taudiopullinfo;
    taudiopullinfo=record
      //action
      a:array[0..99] of taudioaction;
      ac:byte;
      aon:boolean;
      //filters
      b:array[0..99] of taudiobasicevent;
      m:array[0..99] of taudiomatrix;
      mi:array[0..99] of paudiomatrixinfo;//pointers only
      v1:array[0..99] of integer;
      v2:array[0..99] of integer;
      fc:byte;
      fon:boolean;
      bon:array[0..99] of boolean;
      mon:array[0..99] of boolean;
      //pointers
      left:tdynamicsmallint;
      right:tdynamicsmallint;
      packetcount:integer;
      end;
    taudioprogressevent=procedure(sender:tobject;pertint:integer;pertext:extended;finished:boolean) of object;
    taudio=class(tobject)
    private
     //data
     ipos:array[0..aoeMaxTrack] of integer;
     iinfo:array[0..aoeMaxTrack] of taudiopullinfo;
     iuse:array[0..aoeMaxTrack] of boolean;
     imaster:array[0..aoeMaxTrack] of boolean;
     ifilters:array[0..aoeMaxTrack] of string;
     ienabled:array[0..aoeMaxTrack] of boolean;
     ireading:boolean;
     ipacketlimit,ibytes,ileftcount,irightcount:integer;
     idata:string;
     itemp:array [0..aoeMaxTrack] of tdynamicsmallint;
     itempleft,itempright:tdynamicsmallint;
     ileftratio,irightratio:extended;
     //filters
     inormalise:boolean;
     iswap:taudioswap;
     itrailer,iswaplength,iswapswitch,iautoboost:integer;
     ileft,iright:tdynamicsmallint;
     iitems:taudioitems;
     ilastcount,icount:integer;
     ilastrawname:string;
     function valid(x:integer):boolean;
     function getrawname(x:integer):string;
     function getitem(x:integer):taudioitem;
     function range(var _rawname,_name:string):boolean;
     procedure clear(x:integer);
     procedure addbasic(_rawname,_name:string;_event:taudiobasicevent);
     procedure addaction(_rawname,_name:string;_v1,_v2:integer;_event:taudioaction);
     procedure addmatrix(_rawname,_name,_mi:string);
     function getfiltercount:integer;
     function getfilter(x:integer):string;
     procedure setfilter(x:integer;y:string);
     function getenabled(x:integer):boolean;
     procedure setenabled(x:integer;y:boolean);
     procedure settrailer(x:integer);
     procedure setautoboost(x:integer);
     procedure setswaplength(x:integer);
     procedure setswapswitch(x:integer);
     procedure readclear;
     procedure doprogress(pert:extended;finished:boolean);
     function getpackets:integer;
    public
     //events
     onprogress:taudioprogressevent;
     //create
     constructor create;
     destructor destroy; override;
     //information
     property items[x:integer]:taudioitem read getitem;
     property count:integer read icount;
     function find(_rawname:string;var _index:integer):boolean;
     property rawname[x:integer]:string read getrawname;
     function names(sol,eol:string;rawname:boolean):string;
     function bytesleft:integer;
     function bytesright:integer;
     property packets:integer read getpackets;
     //support
     function readmatrix(x:string;var y:taudiomatrixinfo;var yevent:taudiomatrix;var e:string):boolean;
     //pull
     function pullinit(var pos:integer;var info:taudiopullinfo;filterlist:string;right:boolean):boolean;
     procedure pull(var pos:integer;var info:taudiopullinfo;var data:tdynamicsmallint;var count:integer);
     //read
     property normalise:boolean read inormalise write inormalise;
     property trailer:integer read itrailer write settrailer;//add Xms of trailing silence
     property autoboost:integer read iautoboost write setautoboost;//restrict number of TIMES volume may be multiplied automatically (ie 0=off, 1=x1(none), 2=x2, 3=x3)
     property swaplength:integer read iswaplength write setswaplength;//swap: 0ms=OFF
     property swapswitch:integer read iswapswitch write setswapswitch;
     property enabled[x:integer]:boolean read getenabled write setenabled;
     property filters[x:integer]:string read getfilter write setfilter;
     property filtercount:integer read getfiltercount;
     property reading:boolean read ireading;
     function readstart(var data,e:string):boolean;
     function readpull(var data,e:string):boolean;
     procedure readfinish;
     //io
     function fromfile(x:string;var e:string):boolean;
     function tofile(x:string;var e:string):boolean;
    end;

{thashtable}
    // A Hash Key is 20 bits wide.
    // - The lower 8 bits are the postfix character (the new pixel).
    // - The upper 12 bits are the prefix code (the GIF token).
    // A KeyInt must be able to represent the integer values -1..(2^20)-1
    //KeyInt = longInt;	// 32 bits
    //CodeInt = SmallInt;	// 16 bits
    thasharray=array[0..hashsize-1] of longint;
    phasharray=^thasharray;
    thashtable=class(tobject)//hash table for GIF compressor
    private
     hashtable:phasharray;
    public
     constructor create;
     destructor destroy; override;
     procedure clear;
     procedure insert(key:longint;code:smallint);
     function lookup(key:longint):smallint;
    end;

{tccs}
    //.count colors
    //note: "timagemap" requires "max stack size" to be atleast "$00500000" 15-SEP-2004 else program crashes
    trectalign=(rtaCenterVertical,rtaCenterHorizontal);
    pgifpal=^tgifpal;
    tgifpal=record
     c:array[0..255] of trgbcolor;
     count:integer;
     init:boolean;
     end;
    tgifscreen=packed record//7
     w:word;
     h:word;
     pf:byte;//packed flags
     bgi:byte;//background color index that points to a color in "global color palette"
     ar:byte;//aspectratio => actual ratio = (AspectRatio + 15) / 64
     end;
    tgifimgdes=packed record
     sep:byte;
     dx:word;
     dy:word;
     w:word;
     h:word;
     pf:byte;//bit fields
     end;
    tccs=class(trootobject)//color conversions
    private
     ipatch_rrw,ipatch_rrh:boolean;//patch indicators for "createroundrectrgn" for Windows
     icanprinttimeref:currency;
     ilastcanprint:boolean;
     function getpixel(i:tbitmap;x,y:integer):integer;
     procedure setpixel(i:tbitmap;x,y,c:integer);
     procedure patchsinit;
    public
     print_usingoldimp:boolean;//backward compatible with "v2.00.772" image printer
     //create
     constructor create; override;
     destructor destroy; override;
     //regions
     function newrgn(x,y,x2,y2:integer;rounded:boolean):hrgn;
     procedure delrgn(var x:hrgn);
     //filters
     function sV(v:integer):integer;//safe value
     procedure sRGB(var r,g,b:integer);//safe R,G,B
     //low-high
     function rgbMIN(r,g,b:integer):integer;
     function rgbMAX(r,g,b:integer):integer;
     //special
     function toLUMb(x:integer):integer;
     function toLUM(r,g,b:integer):integer;//luminosity 13-SEP-2004
     //to
     procedure toYUV(r,g,b:integer;var y,u,v:integer);//"PAL"
     procedure toYIQ(r,g,b:integer;var y,i,q:integer);//"NTSC"
     procedure toCYM(r,g,b:integer;var c,y,m:integer);//"Cyan,Yellow,Magenta"
     //from
     procedure fromYUV(var r,g,b:integer;y,u,v:integer);//"PAL"
     procedure fromYIQ(var r,g,b:integer;y,i,q:integer);//"NTSC"
     procedure fromCYM(var r,g,b:integer;c,y,m:integer);//"Cyan,Yellow,Magenta"
     //color count
     function bpp(i:tbitmap;_colors:integer):byte;//bits per pixel
     function lcc(i:tbitmap;_limit:integer):integer;//limited color count 21-SEP-2004
     function countcolors(i:tbitmap):integer;//full color count
     function reducecolors(x:tbitmap;colorlimit:integer;fast:boolean;var colorsused:integer;var e:string):boolean;//15SEP2007
     function reducecolorsex(x:tbitmap;colorlimit:integer;fast:boolean;var a:array of trgbcolor;var acount:integer;var e:string):boolean;//15SEP2007
     function palfind(var a:array of trgbcolor;acount:integer;var z:trgbcolor):byte;
     //pixels
     property pixels[i:tbitmap;x,y:integer]:integer read getpixel write setpixel;
     function safetransinfo(tc:integer;var rgbTC,rgbsafeTC:trgbcolor):boolean;//safe transparency information
     function transparentcolor(i:tbitmap;x,y:integer;_transparent:boolean):integer;
     function edgecolor(i:tbitmap):integer;
     //rgb
     procedure swaprgb(var a,b:trgbcolor);
     //read rows
     function rr8(var a:trows8;i:tbitmap):boolean;//read rows 8bit
     function rr24(var a:trgbcolorrows;i:tbitmap):boolean;//read rows 24bit
     procedure fpe(_pal:PLogPalette;_index,_color:integer);//fill palette entry
     //rgb
     function intrgb(x:integer):trgbcolor;
     function rgbint(x:trgbcolor):integer;
     Function ColorsAsBPP(X:Integer):Byte;
     Function BuildPalette(Var X:TBitmap;Var Pal:TColorPalette;MaxCount:Integer):Boolean;
     function rgbequal(Var X,Y:TRGBColor):Boolean;
     Function FindPaletteColor(Var X:TColorPalette;Y:Integer):Integer;
     Function FindPaletteRGB(Var X:TColorPalette;Y:TRGBColor):Integer;
     Function AddRGBToPalette(Var X:TColorPalette;Y:TRGBColor):Integer;
     //tep
     function istep(var x:string):boolean;
     function asanimationb(cells,delay:integer;tep:string):string;
     function asanimation(cells,delay:integer;var tep:string):string;
     function glyph(x:string):tbitmap;
     function astep(x:tobject;maxw,maxh:integer):string;
     //ai - animation information (general structure for all images and animations)
     procedure aiClear(var x:tanimationinformation);
     function aiRead(var x:string;var y:tanimationinformation):boolean;
     function aiWrite(var x:string;var y:tanimationinformation):boolean;
     function aiRewrite(var x:string;var y:tanimationinformation):boolean;
     //icon
     function iconstr(x:ticon):string;
     function icon(x:tbitmap;txy:tpoint):ticon;
     function iconex(x:string;txy:tpoint):ticon;
     //screen/cursor
     function screencapture(d:tbitmap):boolean;//17-JAN-2007
     function screencaptureex(dx,dy,dw,dh,sx,sy,sw,sh:integer;d:tbitmap):boolean;//17-JAN-2007
     function screencolor(x,y:integer):integer;//17-JAN-2007
     function cursorcolor:integer;
     //safe colors
     function ccv(x,y:byte;by:integer):boolean;//color channel visible
     function cv(col,bgcolor:integer;by:integer):boolean;//color visible
     function ecv(col,bgcolor:integer;by:integer):integer;//ensure color visible
     //region
     procedure srr(x:twincontrol;rounded,redraw:boolean);//set rounded region, stable, 06-MAY-2005
     procedure sir(a:twincontrol;img:tbitmap;redraw:boolean);//set image region
     //area & size
     function rectgrow(x:trect;by:integer):trect;
     function fittext(a:tcanvas;_maxwidth:integer;_text,_marker:string;_right:boolean):string;
     function saferect(x:tbitmap;xrect:trect):trect;//26SEP2007
     //draw
     procedure drect(x:tcanvas;y:trect;fc,bc:integer;_rounded:boolean);//draw rect
     procedure drectb(x:tcanvas;y:trect;fc,bc:integer;_rounded:boolean;_size:integer);//draw rect
     function rectrotate90(x:trect):trect;
     function rectalign(source,base:trect;align:trectalign):trect;
     //.rotatable
     procedure dtri(x:tcanvas;y:trect;fc,bc,_rotate:integer);//draw triangle
     procedure drectangle(x:tcanvas;y:trect;fc,bc,_rotate:integer);//draw rectangle
     //.symbol
     function dsymbolsize(x:tcanvas):integer;
     procedure dsymbol(x:tcanvas;y:trect;fc,bc:integer;_symbol:string);//draw symbol
     //text
     procedure inverttext(a:tcanvas;x,y,w,h:integer;s:string);
     //adjustment
     function findtop(a:tbitmap;c,emax:integer;up:boolean):integer;
     function findleft(a:tbitmap;c,emax:integer;right:boolean):integer;
     function autotrim(a:tbitmap;c:integer;var e:string):boolean;
     function autotrimAB(a:tbitmap;c1,c2:integer;var e:string):boolean;
     function edgetrim(a:tbitmap;limit:integer;var e:string):boolean;
     function gridtest(d:tbitmap;dpi:integer;vert:boolean;var e:string):boolean;//17JUN2007
     function gridlines(d:tbitmap;jump:integer;vertcolor,horzcolor:integer;var e:string):boolean;//13JUL2007
     function gridlinesex(d:tbitmap;drect:trect;vjump,hjump:integer;vertcolor,horzcolor:integer;var e:string):boolean;//07MAR2008
     function gridspaces(d:tbitmap;vspacecount,hspacecount:integer;vertcolor,horzcolor:integer;var e:string):boolean;//07MAR2008
     function gridspacesex(d:tbitmap;drect:trect;vspacecount,hspacecount:integer;vertcolor,horzcolor:integer;var e:string):boolean;//07MAR2008
     function tile(dr:trect;d,s:tbitmap;deg:integer;var e:string):boolean;//29MAY2007
     function zoom(x:tbitmap;by:integer;var e:string):boolean;
     function zoomex(x:tbitmap;wby,hby:integer;var e:string):boolean;
     function mirror(x:tbitmap;var e:string):boolean;
     function mirrorex(x:tbitmap;xrect:trect;var e:string):boolean;//mirror horizontally
     function flip(x:tbitmap;var e:string):boolean;
     function flipex(x:tbitmap;xrect:trect;var e:string):boolean;//flip vertical
     function cellsflipmirror(x:tbitmap;_flip,_mirror:boolean;var e:string):boolean;//prepare a multi-cell imagestrip, ensuring all [0,0] pixel corners are "black" if transparent and all black must be [1,1,1] or higher
     function rotateby(x:tbitmap;deg:integer;var e:string):boolean;
     function rotate90(x:tbitmap;left:boolean;var e:string):boolean;
     function rotate90ex(dest,source:tbitmap;left:boolean;var e:string):boolean;
     //image
     procedure scaledown(maxw,maxh,w,h:integer;var dw,dh:integer);
     procedure scaleup(maxw,maxh,w,h:integer;var dw,dh:integer);
     procedure scale(pw,ph,w,h:integer;var dw,dh:integer);
     function tojpgt(s:tbitmap;var y,e:string):boolean;//to transparent jpeg
     function fromjpgt(x:tbitmap;var y,e:string):boolean;//from transparent jpeg - 17SEP2007
     function fromgif(x:tbitmap;var y,e:string):boolean;//20SEP2007
     function togif(x:tbitmap;var y,e:string):boolean;//11SEP2007
     function toppm(x:tbitmap;var y,e:string):boolean;//14SEP2007
     function topgm(x:tbitmap;var y,e:string):boolean;//14SEP2007
     function topbm(x:tbitmap;var y,e:string):boolean;//14SEP2007
     function totep(x:tbitmap;var y,e:string):boolean;//15SEP2007
     function toico(x:tbitmap;var y,e:string):boolean;//15SEP2007
     function fromico(x:tbitmap;var y,e:string):boolean;
     function aszip(x:tbitmap;var y,e:string):boolean;
     function asbmp(x:tbitmap;var y:string):boolean;//Updated: 20-JUN-2006
     function bmpstr(x:tbitmap;var y,e:string):boolean;
     function asimage(rawdata:string;var image:string;var imagewidth,imageheight:integer;ignorebad:boolean):boolean;
     function asthumb(rawdata:string;var thumb:string;var thumbwidth,thumbheight:integer;ignorebad:boolean):boolean;
     function jpgstr(x:tbitmap;var y:string;z:byte;var e:string):boolean;
     function asjpg(x:tbitmap;var jpg,e:string):boolean;
     function asgrey(x:tbitmap;shadelimit:integer;var e:string):boolean;//greyscale
     function edgefill(x:tbitmap;replacecolor:integer):boolean;
     function edgefillex(x:tbitmap;replacecolor:integer;sc:byte):boolean;
     function potfill(x:tbitmap;sx,sy:integer;c:trgbcolor;tol:byte;var e:string):boolean;
     function potfillex(x:tbitmap;xarea:trect;sx,sy:integer;c:trgbcolor;tol:byte;var e:string):boolean;
     //support - GIF
     procedure gifpalinit(var x:tgifpal);
     function gifpalfill(x:tbitmap;var y:tgifpal;var e:string):boolean;//12SEP2007
     function gifpalfind(var y:tgifpal;var z:trgbcolor):byte;
     function transwhite(x:tbitmap;var e:string):boolean;//all cells are forces to have transparent color of WHITE(255,255,255)
     function transpotfill(x:tbitmap;tol:byte;var e:string):boolean;//20SEP2007
     function transtrim(x:tbitmap;var e:string):boolean;//03OCT2007 - Automatically trims all cells
     function trimscan(x:tbitmap;xarea:trect;var spL,spT,spR,spB:integer;var e:string):boolean;
     function nonwhite(x:trgbcolor):trgbcolor;//make sure color is never white
     //.compress
     function compress(var x,e:string):boolean;//12SEP2007
     function compressex(var x,imgdata,e:string):boolean;//12SEP2007
     //.decompress
     procedure decompress(var x:string);//11SEP2007
     procedure decompressex(var xlenpos:integer;var x,imgdata:string;_width,_height:integer;interlaced:boolean);//11SEP2007
     //other
     function newbmp(w,h:integer):tbitmap;
     function newbmpeh(w,h:integer):tbitmapenhanced;
     function size(x:tbitmap;w,h:integer):boolean;
     function valid8(i:tbitmap):boolean;
     function valid24(i:tbitmap):boolean;
     function nonempty24(x:tbitmap):boolean;
     function cls(i:tbitmap;c:integer;fsd:string):boolean;
     function draw(dx,dy:integer;dest,source:tbitmap;_omitcolor:integer):boolean;//15-SEP-2004
     function copybmp(dest,source:tbitmap):boolean;
     function copygraphic(dest:tbitmap;source:tgraphic):boolean;
     function copygraphicex(dest:tbitmap;source:tgraphic;color:integer):boolean;//13SEP2007
     function stretchdraw(darea:trect;dest,source:tbitmap;_omitcolor:integer):boolean;//19-MAY-2007
     function stretchdrawex(darea,allowarea:trect;dest,source:tbitmap;_omitcolor:integer):boolean;//19-MAY-2007
     //INFO
     function isgraphic(var x:string):boolean;
     function supportformat(filenameorext:string):boolean;
     function supportformatstr(filenameorext:string):boolean;//some formats only work with a filename, this one is with strings
     function supportcells(filenameorext:string):boolean;
     function supportflip(filenameorext:string):boolean;
     function supportmirror(filenameorext:string):boolean;
     function supporttransparency(filenameorext:string):boolean;
     function findformat(var x,format:string;var binary:boolean):boolean;
     //READ
     function fromdata(a:tbitmap;var data,e:string):boolean;
     function fromfile(a:tbitmap;x:string;var e:string):boolean;//20SEP2007
     //WRITE
     function savetoBEC(a:tbitmapenhanced;var e:string):boolean;
     function copytoclipboard(s:tobject;allcells,syncwithBEC:boolean;var e:string):boolean;
     function copyfiletoclipboard(f:string;allcells,syncwithBEC:boolean;var e:string):boolean;
     function tobmp(dest:tbitmap;source:tobject;allcells:boolean;var e:string):boolean;
     function tobmpex(dest:tbitmap;source:tobject;allcells,convertvirtuals:boolean;var e:string):boolean;
     function todata(x:tbitmap;var data,e:string):boolean;
     function todataex(x:tbitmap;checkcells:boolean;var data,e:string):boolean;
     function tofile(a:tbitmap;x:string;var e:string):boolean;//20SEP2007
     //CONVERT
     function convertdata(var data:string;dformat,dsubformat:string;var e:string):boolean;
     //print
     function printexe(var f:string):boolean;
     function canprint:boolean;
     procedure printfile(x,y:string);
     procedure print(x:tobject;y:string);
     //object
     function fromobject(a:tbitmap;x:tobject;var e:string):boolean;
     //video motion
     function dvmb(dest:tbitmapenhanced;img:string;var grey,greylast,e:string;s,t:integer;showthumb,showgraph,cycle,toggle:boolean;datetime:string;var tcount:integer):boolean;//detect video motion
     function dvm(dest:tbitmapenhanced;var img,grey,greylast,e:string;s,t:integer;showthumb,showgraph,cycle,toggle:boolean;datetime:string;var tcount:integer):boolean;//detect video motion
     //effects
     //.shade block
     function sc(sc,dc,pert:integer):integer;//shift color
     function shadev(x:tobject;c1,c2:integer;var e:string):boolean;//shade color vertically
     function shadevex(x:tobject;c,up,dn:integer;flip:boolean;var e:string):boolean;//shade color vertically
     //.shade text
     function shadetexth(x:tbitmap;t:string;c1,c2,depth,dx,dy,xstep,ystep:integer;var e:string):boolean;//shade text horizontally
     function shadetexthb(x:tbitmap;t:string;c,up,dn,depth,dx,dy,xstep,ystep:integer;var e:string):boolean;//shade text horizontally
     function shadetextextenth(x:tbitmap;t:string;c1,c2,depth,dx,dy,xstep,ystep:integer;var w,h:integer;calcwh:boolean;var e:string):boolean;//shade text horizontally
    end;

{ttbt}
    ttbt=class(tobject)
    private
     ipassword,ikeyrandom,ikey:string;//fixed length string of 1000 chars
     ikeymodified:boolean;
     ipower:integer;
     function keyinit:boolean;
     function keyid(var x:string;var id:integer):boolean;
     procedure setpassword(x:string);
     procedure setpower(x:integer);
    public
     //create
     constructor create;
     destructor destroy; override;
     //workers
     property power:integer read ipower write setpower;
     property password:string read ipassword write setpassword;
     function encode(var s,d,e:string):boolean;
     function encode4(var s,d,e:string):boolean;
     function decode(var s,d,e:string):boolean;
     //internal
     function frs(var s,d:string;m:byte):boolean;//feedback randomisation of string
    end;

    tprogram=class;
    tprogramvars=class;
    tprogramstack=class;

{tprogramvars}
    tprogramfunction=procedure(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
    //Note: "piAny" and "piLocked" are also stored in external permanent lists "iva" and "ivl".
    tprograminfo=set of (piOnlylabel,piConst,piLabel,piAny,piLocked);
    tprogramvars=class(tobject)
    private
     //.references
     iconstcount,iid,iresult,iresult2,inil,icount:integer;
     //.helpers
     ivn:tdynamicnamelist;
     ivinfo:tdynamicbyte;//list of "tprograminfo"
     //.core
     ivb:tdynamicboolean;
     ivi:tdynamicinteger;
     ivc:tdynamiccurrency;
     ivs,ivdef:tdynamicstring;//string and default value
     //.support
     iva:tdynamicboolean;
     ivl:tdynamicboolean;//locked or not
     ivt:tdynamicbyte;//var type (integer, currency etc)
     function new(n:string;var i:integer):boolean;
     function valid(x:integer):boolean;
     function validok(x:integer):boolean;
     function canset(x:integer):boolean;
     procedure setb(x:integer;y:boolean);
     function getb(x:integer):boolean;
     procedure seti(x:integer;y:integer);
     function geti(x:integer):integer;
     procedure setc(x:integer;y:currency);
     function getc(x:integer):currency;
     procedure sets(x:integer;y:string);
     function gets(x:integer):string;
     function getinfo(x:integer):tprograminfo;
     procedure setinfo(x:integer;y:tprograminfo);
     function getl(x:integer):boolean;
     function gett(x:integer):byte;
     function geta(x:integer):boolean;
     procedure typechange(x:integer;newt:byte);
    public
     //system vars (5 input, 5 output)
     vin:array[0..4] of integer;
     vout:array[0..4] of integer;
     //create
     constructor create;
     destructor destroy; override;
     //workers
     procedure clear;
     procedure flush;//restore all vars to their "defaults"
     procedure reduce;
     function find(n:string):integer;
     function findex(n:string;var i:integer):boolean;
     function copyvar(_s,_d:integer):boolean;
     procedure null(x:integer);
     function newid:integer;
     //define
     function besttype(x:string):byte;
     function define(n,v:string;t:byte;var i:integer):boolean;
     function defineconst(var n:string;v:string;t:byte;var i:integer):boolean;
     function defineex(n,v:string;t:byte;pi:tprograminfo;var i:integer):boolean;
     //information
     property b[x:integer]:boolean read getb write setb;
     property i[x:integer]:integer read geti write seti;
     property c[x:integer]:currency read getc write setc;
     property s[x:integer]:string read gets write sets;
     property l[x:integer]:boolean read getl;//locked
     property t[x:integer]:byte read gett;//type
     property a[x:integer]:boolean read geta;//any (true=can be any type, false=fixed type)
     property info[x:integer]:tprograminfo read getinfo write setinfo;//temp only
     //special reserved var pointers
     property vnil:integer read inil;
     property vresult:integer read iresult;
     property vresult2:integer read iresult2;
     property vid:integer read iid;
     //internal
     property vn:tdynamicnamelist read ivn;//temp only
     property vb:tdynamicboolean read ivb;
     property va:tdynamicboolean read iva;
     property vi:tdynamicinteger read ivi;
     property vc:tdynamiccurrency read ivc;
     property vs:tdynamicstring read ivs;
     property vdef:tdynamicstring read ivdef;
     property vl:tdynamicboolean read ivl;
     property vt:tdynamicbyte read ivt;
     property constcount:integer read iconstcount write iconstcount;
     property count:integer read icount write icount;
     //.helpers
     property vinfo:tdynamicbyte read ivinfo;
    end;

{tprogramstack}
    tprogramstack=class(tobject)
    private
     ivb:tdynamicboolean;
     ivi:tdynamicinteger;
     ivc:tdynamiccurrency;
     ivs:tdynamicstring;//string and default value
     ivt:tdynamicbyte;
     icount:integer;
     procedure enlarge;
     procedure shrink;
    public
     //create
     constructor create;
     destructor destroy; override;
     //workers
     procedure clear;
     //information
     property count:integer read icount;
     //push
     procedure pushbol(x:boolean);
     procedure pushint(x:integer);
     procedure pushcur(x:currency);
     procedure pushstr(x:string);
     //pull
     procedure pullbol(var x:boolean);
     procedure pullint(var x:integer);
     procedure pullcur(var x:currency);
     procedure pullstr(var x:string);
     function pulltype:byte;
    end;

{tprogram}
    tprogramcrawlerevent=procedure(com:string;sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer) of object;
    tprogramexternalevent=function(sender:tprogram;var v1,v2,v3,v4,v5:string):boolean of object;
    tprogramioinfo=record
      x:string;
      xlen:integer;
      pos:integer;
      end;//end of record
    tprogram=class(tobject)
    private
     //core
     ivars:tprogramvars;
     istack:tprogramstack;
     igo:string;
     iid,iposfinish,iposstart,ipos,icount:integer;
     isleep:currency;
     ic,iv,inl:tdynamicword;
     finternalonrunend,fonrunend:tnotifyevent;
     //other
     istepbusy,istepexit,ilocked,iwaiting,irunning,iloading:boolean;
     procedure clear;
     function getvn(var x,n:string;var pos:integer):boolean;
     function getvv(var x,v:string;var pos:integer;var isvalue:boolean):boolean;
     function defc(a:tdynamicstring;p:integer;var c,n,ecomment:string):boolean;
     function _readtext(x:tdynamicstring;var lineerr:integer;var e:string):boolean;
     procedure _removeindent(var x:string);
     procedure gopush(p:integer);
     function gopull(var p:integer):boolean;
     procedure runend;
     //io
     function pushend(var a:tprogramioinfo):boolean;
     function pushbol(var a:tprogramioinfo;y:boolean;s:byte):boolean;
     function pushint(var a:tprogramioinfo;y:integer;s:byte):boolean;
     function pushlab(var a:tprogramioinfo;y:integer;s:byte):boolean;
     function pushcur(var a:tprogramioinfo;y:currency;s:byte):boolean;
     function pushstr(var a:tprogramioinfo;y:string;s:byte):boolean;
     function pullbol(var a:tprogramioinfo;var y:boolean;var s:byte):boolean;
     function pullint(var a:tprogramioinfo;var y:integer;var s:byte):boolean;
     function pullcur(var a:tprogramioinfo;var y:currency;var s:byte):boolean;
     function pullstr(var a:tprogramioinfo;var y:string;var s:byte):boolean;
    public
     //vars
     tag:integer;
     host:tobject;
     //.user vars - nothing to do with program
     tagstr:string;
     tagerr:string;
     //syste vars
     quitstatus:byte;//0=not in use, 1=waiting to quit, 2=quit allowed, 3=quit started
     screentext:string;
     msstart:currency;//time reference program started
     //create
     constructor create;
     destructor destroy; override;
     //run
     property running:boolean read irunning;
     function canrun:boolean;
     function run(_onrunend:tnotifyevent):boolean;
     procedure quit;
     //step
     function canstep:boolean;
     function step:integer;
     function stepex(numberofcommands:integer):integer;
     //information
     property id:integer read iid;//id for this program, changes every time a program is "run"
     //bin
     //.write
     function canwrite:boolean;
     function writebin(var x,e:string):boolean;
     //.read
     function canread:boolean;
     function readbin(x:string;var e:string):boolean;
     function readtext(x:string;var e:string):boolean;
     function readtextex(x:string;var lineerr:integer;var e:string):boolean;
     //internal
     property waiting:boolean read iwaiting write iwaiting;
     property internalonrunend:tnotifyevent read finternalonrunend write finternalonrunend;
     procedure _ondns(sender:tobject;tag:currency;ptr:tnetworkptr);
     procedure _onpullcontent(_url,_urlfinal,_urlredirect,_outtext:string;_tag,_id,_ip,_code:integer;_header,_content:string;_sendbytes,_recvbytes:currency);
     property vars:tprogramvars read ivars;
     property pos:integer read ipos write ipos;//for internal use only
     property stepexit:boolean read istepexit write istepexit;
     property sleep:currency read isleep write isleep;
     property posstart:integer read iposstart;
     property posfinish:integer read iposfinish;
     property count:integer read icount;
     property c:tdynamicword read ic;
     property v:tdynamicword read iv;
     property nl:tdynamicword read inl;
    end;

{tprograms}
    tprograms=class(tobject)
    private
     iitems:array[0..1999] of tprogram;
     ifast:array[0..1999] of word;
     ifastcount,itimer,ipos,iactive,icount,ilastcount:integer;
     islowtime,islowref:currency;
     idatabin:string;
     procedure setcount(x:integer);
     function getprogram(x:integer):tprogram;
     procedure _internalonrunend(sender:tobject);
     procedure _ontimer(sender:tobject);
    public
     //create
     constructor create;
     destructor destroy; override;
     //information
     property count:integer read icount write setcount;
     property active:integer read iactive;
     property items[x:integer]:tprogram read getprogram;
     //workers
     function valid(x:integer):boolean;
     function read(x:string;var lineerr:integer;var e:string):boolean;
     function dataok:boolean;
     function canrun:boolean;
     function run(_onexternal:tprogramexternalevent;_onrun,_onrunend:tnotifyevent):boolean;
     function runex(_host:tobject;_onexternal:tprogramexternalevent;_onrun,_onrunend:tnotifyevent):boolean;
     procedure quitall;
     property databin:string read idatabin;
    end;

{taudiobasic}
    PHWAVE = ^HWAVE;
    HWAVE = Integer;
    PHWAVEIN = ^HWAVEIN;
    HWAVEIN = Integer;
    PHWAVEOUT = ^HWAVEOUT;
    HWAVEOUT = Integer;
    VERSION = UINT;               { major (high byte), minor (low byte) }
    MMVERSION = UINT;             { major (high byte), minor (low byte) }
    MMRESULT = UINT;              { error return code, 0 means no error }
    PWaveFormatEx = ^TWaveFormatEx;
    TWaveFormatEx = packed record
     wFormatTag: Word;         { format type }
     nChannels: Word;          { number of channels (i.e. mono, stereo, etc.) }
     nSamplesPerSec: DWORD;  { sample rate }
     nAvgBytesPerSec: DWORD; { for buffer estimation }
     nBlockAlign: Word;      { block size of data }
     wBitsPerSample: Word;   { number of bits per sample of mono data }
     cbSize: Word;           { the count in bytes of the size of }
     end;
    PWaveHdr = ^TWaveHdr;
    TWaveHdr = record
     lpData: PChar;              { pointer to locked data buffer }
     dwBufferLength: DWORD;      { length of data buffer }
     dwBytesRecorded: DWORD;     { used for input only }
     dwUser: DWORD;              { for client's use }
     dwFlags: DWORD;             { assorted flags (see defines) }
     dwLoops: DWORD;             { loop control counter }
     lpNext: PWaveHdr;           { reserved for driver }
     reserved: DWORD;            { reserved for driver }
     end;
//yyyyyyyyyyy Note: Object not yet completed, works for playback over multiple formats,
//yyyyyyyyyyy       however, recording system is in place but not yet fully built or
//yyyyyyyyyyy       operational - 18FEB2008
    paudiobasicbuffer=^taudiobasicbuffer;
    taudiobasicbuffer=array[0..35279] of byte;
    taudiobasic=class(trootobject)
    private
     //common
     iformat:twaveformatex;
     iformatstr:string;
     isecsize,iblocksize:integer;//bytes required to fill buffer (10 of these per second)
     ihandle:hwnd;
     iformatmodified:boolean;
     //push - play
     iptime:currency;
     iphandle:HWAVEOUT;
     ipH:array [0..1] of twavehdr;
     ipB:array [0..1] of taudiobasicbuffer;
     ippos:byte;
     ipcount:integer;
     ipdata:string;
     ipplaying:boolean;
     //pull - record
     irtime:currency;
     irhandle:HWAVEIN;
     irH:array [0..1] of twavehdr;
     irB:array [0..1] of taudiobasicbuffer;
     irpos:byte;
     ircount:integer;
     irdata:string;
     irrecording:boolean;
     //core
     ilocked:boolean;
     itimer:integer;
     procedure _ontimer(sender:tobject);
     procedure pdo;
     procedure rdo;
     procedure paoc;//automatic open/close
     procedure raoc;//automatic open/close
     function handle:hwnd;
     procedure wndproc(var message:tmessage);
     procedure setformat(x:string);
    public
     //create
     constructor create; override;
     destructor destroy; override;
     //information
     property blocksize:integer read iblocksize;
     property secsize:integer read isecsize;
     property format:string read iformatstr write setformat;
     //push
     function pushonline:boolean;
     function pushlen:integer;//amount of data length in push buffer for playback
     function canpush:boolean;
     function canpushex(seconds:integer):boolean;
     function push(var data:string):boolean;
     //pull
     function pullonline:boolean;//hardware is running
     function canpull:boolean;
     function pull(var data:string;var count:integer):boolean;
    end;

//## Audio ##
function sndPlaySound(lpszSoundName: PChar; uFlags: UINT): BOOL;                                          stdcall;external 'winmm.dll' name 'sndPlaySoundA';
//## WinWock API's ##
//session
function WSAStartup(wVersionRequired: word; var WSData: TWSAData): Integer;                               stdcall;external winsocket name 'WSAStartup';
function WSAAsyncSelect(s: TSocket; HWindow: HWND; wMsg: u_int; lEvent: Longint): Integer;                stdcall;external winsocket name 'WSAAsyncSelect';
function WSACleanup: Integer;                                                                             stdcall;external winsocket name 'WSACleanup';
function WSAGetLastError: Integer;                                                                        stdcall;external winsocket name 'WSAGetLastError';
function WSAAsyncGetHostByName(HWindow: HWND; wMsg: u_int; name, buf: PChar; buflen: Integer): THandle;   stdcall;external winsocket name 'WSAAsyncGetHostByName';
//sockets
function n_socket(af, struct, protocol: Integer): TSocket;                                                stdcall;external winsocket name 'socket'
function n_htons(hostshort: u_short): u_short;                                                            stdcall;external winsocket name 'htons';
function n_ntohs(netshort: u_short): u_short;                                                             stdcall;external winsocket name 'ntohs';
function n_htonl(hostlong: u_long): u_long;                                                                 stdcall;external winsocket name 'htonl';
function n_bind(s: TSocket; var addr: TSockAddr; namelen: Integer): Integer;                              stdcall;external winsocket name 'bind';
function n_accept(s: TSocket; addr: PSockAddr; addrlen: PInteger): TSocket;                               stdcall;external winsocket name 'accept';
function n_listen(s: TSocket; backlog: Integer): Integer;                                                 stdcall;external winsocket name 'listen';
function n_recv(s: TSocket; var Buf; len, flags: Integer): Integer;                                       stdcall;external winsocket name 'recv';
function n_recvfrom(s: TSocket; var Buf; len, flags: Integer;  var from: TSockAddr; var fromlen: Integer): Integer;stdcall;external winsocket name 'recvfrom';
function n_send(s: TSocket; var Buf; len, flags: Integer): Integer;                                       stdcall;external winsocket name 'send';
function n_sendto(s: TSocket; var Buf; len, flags: Integer; var addrto:TSockAddr;tolen:Integer):Integer;  stdcall;external winsocket name 'sendto';
function n_gethostname(name: PChar; len: Integer): Integer;                                               stdcall;external winsocket name 'gethostname';
function n_getsockname(s: TSocket; var name: TSockAddr; var namelen: Integer): Integer;                   stdcall;external winsocket name 'getsockname';
function n_getpeername(s: TSocket; var name: TSockAddr; var namelen: Integer): Integer;                   stdcall;external winsocket name 'getpeername';
function n_getservbyname(name, proto: PChar): PServEnt;                                                   stdcall;external winsocket name 'getservbyname';
function n_ioctlsocket(s: TSocket; cmd: Longint; var arg: u_long): Integer;                               stdcall;external winsocket name 'ioctlsocket';
function n_gethostbyname(name: PChar): PHostEnt;                                                          stdcall;external winsocket name 'gethostbyname';
function n_getsockopt(s: TSocket; level, optname: Integer; optval: PChar; var optlen: Integer): Integer;  stdcall;external winsocket name 'getsockopt';
function n_setsockopt(s: TSocket; level, optname: Integer; optval: PChar; optlen: Integer): Integer;      stdcall;external winsocket name 'setsockopt';
function n_inet_addr(cp: PChar): u_long;                                                                  stdcall;external winsocket name 'inet_addr';
function n_inet_ntoa(inaddr: TInAddr): PChar;                                                             stdcall;external winsocket name 'inet_ntoa';
function n_closesocket(s: TSocket): Integer;                                                              stdcall;external winsocket name 'closesocket';
function n_connect(s: TSocket; var name: TSockAddr; namelen: Integer): Integer;                           stdcall;external winsocket name 'connect';

//### General Support Routines ###
function freeportb(_from,_to:integer;_udp:boolean):integer;//27-OCT-2006
function freeport(x:string;_udp:boolean):integer;//27-OCT-2006
Function nid(var x:integer):integer;{new id}
Function vpn(x:integer):integer;{valid port number}
Function cupn(x:string;y:integer):string;{change url port number}
Procedure inc_int(Var X:Integer);
Procedure SplitAddr(X:String;Var Addr:String;Var Port:Integer);
Function ID_str(macID,macPort:Integer):String;
//Other
Function strs_IDs(X:String;Var Y:Array of String):Integer;
Procedure dosunix_paths(Var X:string;dos:boolean);{07-07-03}
Function int_hex_char(X:byte):char;
function col_hex(x:integer):string;
Function int_hex(X:byte):string;
Function hex_char_int(X:char):byte;//updated 18-JAN-2006
Function hex_int(X:string):byte;
Procedure net_unix_split_pf(Var pf,p,f:string);
Function net_IsHTMLext(X:String):Boolean;
Function net_mozilla_ver(x:string):byte;
procedure net_encode_str(Var X:String);{v2 16-07-03 - Rapid}
procedure net_encode_url(var x:string);//18-DEC-2006 v008
function net_encode_url_b(x:string):string;//23FEB2008
function net_encode_urlSHOULD(var x:string):boolean;//28FEB2008
function net_encode_str_slash_b(x:string;leaveslash:boolean):string;//20DEC2007
procedure net_encode_str_slash(var x:string;leaveslash:boolean);//12-JUN-2006
procedure net_encode_str_full(var x:string);//12-JUN-2006
function net_encode_str_fullb(x:string):string;
procedure net_decode_str(var x:string);//12-JUN-2006
procedure net_encode_for_html(var x:string);//faster, date: 12-JUN-2006
function net_read_nameval(Var X,name,data:String;Var P,MaxP:Integer):boolean;//updated: 15-APR-2004
Function net_decode_str_b(X:String):String;
Function net_encode_str_b(X:String):String;
Function net_encode_for_html_b(X:String):String;

var
   //rgb
   rgbBlack:TRGBColor=(b:0; g:0; r:0);
   gettickcountSEC:currency;//approx. "ms64" - nearest second +/- 500ms
   getDIM:integer;//approx. "dim"
   //other
   ffs:tfilters=nil;
   fccs:tccs=nil;
   fmimes:tmimes=nil;
   ffonts:tfonts=nil;
   fmt:tmt=nil;
   fmm:tmm=nil;
   fass:tass=nil;
   flm:tlookupmanagement=nil;
   fdm:tdomains=nil;
   fwebheaders:twebheaders=nil;
   fnetsession:tnetsession=nil;
   fnw:tnetwork=nil;
   frawlog:trawlog=nil;
   fmc:tmanagedconnections=nil;
   fmr:tmanagedrobot=nil;
   fcr:tcacheredirect=nil;
   fmip:tmapperip=nil;
   fsecip:tsecurityip=nil;
   fnavdlg:tnavdlg=nil;
   fnavimgs:tnavcacheimages=nil;
   fnavurls:tnavcacheurls=nil;
   machine_ip:longint=0;
   machine_host:string='';
   //translated strings
   tsBanned,tsAllowed,tsDefault,tsDate,tsType,tsSent,tsIdle,tsRecv,tsResource,tsState,tsUrl:string;
   tsUrlPerMin,tsUrlPerHour,tsUrlPerDay:string;
   //64bit system timer
   ms64init:boolean=false;
   ms64LAST:currency=0;
   ms64OFFSET:currency=0;
   //system information
   timerload:integer=0;
   timerloadactive:integer=0;
   threadcount:integer=0;
   programcount:integer=0;//tprogram
   programactive:integer=0;//tprogram
   programinstructioncount:currency=0;//tprogram
   networkhitsin:currency=0;
   networkhitsout:currency=0;
   networklookup:currency=0;

   //tprogram function list
   programf_init     :boolean=false;
   programf_count    :word=0;
   programf_ptr      :array[0..255] of pointer;
   programf_banconst :array[0..255] of boolean;
   programf_banvar   :array[0..255] of boolean;
   programf_onlylabel:array[0..255] of boolean;
   programf_name     :array[0..255] of string;
   programf_nameref  :array[0..255] of integer;
   //.quick reference ptrs for if/ifnot...endif statements (since reverse lookup is required during compile)
   programf_ifptr    :word;
   programf_ifnotptr :word;
   programf_elseptr  :word;
   programf_endifptr :word;
   programf_notsupp  :string='Command not supported';
   //.core support
   programf_recvlimit:currency=maxcur;
   programf_ban      :tmanagedconnectionban=[];
   programf_screen   :tvirtuallist=nil;//program output screen
   programf_external :tprogramexternalevent=nil;
   programf_crawler  :tprogramcrawlerevent=nil;//program crawler support "cw-" based commands, use "cw-support" to detect if crawler support is present
   virtualprogramid:integer=0;//used by tprogram for handle instance
   //tfilters
   fbinited:boolean=false;
   fb255:array[-1024..1024] of byte;
   fbwrap255:array[-1024..1024] of byte;
   
function fs:tfilters;
function ccs:tccs;
function mimes:tmimes;
function fonts:tfonts;
function mt:tmt;
function mm:tmm;
function ass:tass;
function lm:tlookupmanagement;
function dm:tdomains;
function whs:twebheaders;{whs -> WebHeaders}
function WebHeaders:twebheaders;
function netsession:tnetsession;
function nw:tnetwork;
function ns:tnetsession;
function rawlog:trawlog;
function mc:tmanagedconnections;
function cr:tcacheredirect;
function mr:tmanagedrobot;
function mip:tmapperip;
function secip:tsecurityip;//security ip
function navdlg:tnavdlg;//nav dialog
function navimgs:tnavcacheimages;//tnavbase images cache
function navurls:tnavcacheurls;//tnavbase urls cache

//critical support routines
function newb3(self:tvirtualform;_type:string;var _caption:string;_tep:string;_align:tvirtualalign;_newparent:tvirtualcontrol;_onclick:tnotifyevent;var _sysptr:integer;_style:tstoragestyle;_default,_range:string;var _result:tvirtualcontrol):boolean;//03MAR2008
function ms64:currency;//64bit millisecond system timer, 01-SEP-2006
function ms32:currency;//32bit millisecond system timer (reference only)
function mn32:integer;//32bit minute system timer (0..MAXINT ~ 4,000 years), 27-SEP-2006

//general support routines
function _strIP(x:integer):string;
function _strIPpad(x:integer):string;//convert integer IP to padded string (dot notation) 05JAN2008
function _intIP(x:string):longint;
function _intIPb(x:string;var ip:integer):boolean;//convert "string IP" (dot notation) to integer version
function _intIPc(x:string;reverse:boolean):string;//10.0.0.1 => #10#0#0#1 or #1#0#0#10 - 28-OCT-2006
function _revIP(x:longint):longint;
function _ip8(ip4:integer):currency;
function _ip4(ip8:currency):integer;
function fromstruc(a:pointer;asize:integer):string;
procedure tostrucb(a:pointer;asize:integer;x:string);
procedure tostruc(a:pointer;asize:integer;var x:string);
function fromnullstr(a:pointer;asize:integer):string;
procedure tonullstrb(a:pointer;asize:integer;z:string);
procedure tonullstr(a:pointer;asize:integer;var z:string);
procedure getmachineinfob(var ip:integer;var host:string);//local ip and local host
procedure getmachineinfo(var ip,host:string);//local ip and local host
function clientUDP(ip:integer;port:word;data:string;var rdata:string):boolean;//27-OCT-2006
function netGET(url,proxy:string;var hdr:string;var content:string;var cancelled:boolean):tnetworkerror;
function netHEAD(url,proxy:string;var hdr:string;var content:string;var cancelled:boolean):tnetworkerror;
function netXXX(url,proxy:string;ohdr:string;var hdr:string;var content:string;var cancelled:boolean;mode:string;raw:boolean):tnetworkerror;
function mciSendCommand(mciId:MCIDEVICEID;uMessage:UINT;dwParam1,dwParam2:DWORD):MCIERROR; stdcall; external 'winmm.dll' name 'mciSendCommandA';
function mciGetErrorString(mcierr: MCIERROR; pszText: PChar; uLength: UINT): BOOL; stdcall; external 'winmm.dll' name 'mciGetErrorStringA';

//tbt - related
function ted(p:string;var s,d,e:string;_encode:boolean):boolean;
function tedb(p:string;var x,e:string;_encode:boolean):boolean;
//.tbt version 4 - supports variable length key
function tedb4(p:string;var x,e:string;_power:integer;_encode:boolean):boolean;//21SEP2007
function ted4(p:string;var s,d,e:string;_power:integer;_encode:boolean):boolean;//21SEP2007

//## tprogram support functions ################################################
//support
procedure programf_create;
function programf_find(n:string;var i:integer):boolean;
procedure programf_definefunc(n:string;v:tprogramfunction;banconst,banvar,onlylabel:boolean);
//functions
procedure program_nil(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
procedure program_test(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
procedure program_vidadd(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
procedure program_vidpull(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
procedure program_vidpush(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
procedure program_vidcls(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
procedure program_label(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
procedure program_msg(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
procedure program_msg60(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
procedure program_msgvar(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
procedure program_pull(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
procedure program_push(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
procedure program_pull2(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
procedure program_push2(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
procedure program_g(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);//>
procedure program_ge(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);//>=
procedure program_e(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);//=
procedure program_ne(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);//<>
procedure program_le(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);//<=
procedure program_l(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);//<
procedure program_p(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
procedure program_m(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
procedure program_t(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
procedure program_d(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
procedure program_pp(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
procedure program_mm(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
procedure program_rnd(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
procedure program_null(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
procedure program_beep(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
procedure program_sleep(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
procedure program_breath(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
procedure program_loop(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
procedure program_ifloop(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
procedure program_ifnotloop(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
procedure program_goto(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
procedure program_ifgoto(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
procedure program_ifnotgoto(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
procedure program_go(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
procedure program_ifgo(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
procedure program_ifnotgo(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
procedure program_ret(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
procedure program_ifret(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
procedure program_ifnotret(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
procedure program_if(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
procedure program_ifnot(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
procedure program_else(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
procedure program_endif(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
procedure program_end(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
procedure program_quit(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
procedure program_stack(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
procedure program_unstack(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
procedure program_unstackp(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
procedure program_stackcount(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
procedure program_asbol(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
procedure program_asint(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
procedure program_ascur(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
procedure program_asstr(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
procedure program_not(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
procedure program_and(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
procedure program_or(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
procedure program_cmp(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
procedure program_ms64(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
procedure program_pasttime(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
procedure program_uptime(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
procedure program_msstart(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
procedure program_mselapsed(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
procedure program_yes(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
procedure program_len(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
procedure program_thousands(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
procedure program_wecd(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
procedure program_timedate(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
procedure program_indent(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);

//INTERNET
procedure program_dns(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
procedure program_redirectfind(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
procedure program_redirectadd(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
procedure program_strip(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
procedure program_intip(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
procedure program_pullcontent(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
//.robots
procedure program_urlrobot(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
procedure program_lockrobot(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
procedure program_pushrobot(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
procedure program_unlockrobot(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
//EXTERNAL
procedure program_exsupport(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
procedure program_ex(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
//CRAWLER (cw-XXX)
procedure program_cwsupport(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
procedure program_cwpullurl(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
procedure program_cwfinaliseurl(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
procedure program_cwallowurl(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
procedure program_cwallowip(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
procedure program_cwipurlonce(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
procedure program_cwrobotsok(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
procedure program_cwpushcrawl(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
//TAUDIO
function abMspk(ms:integer):integer;//convert "milliseconds" to "number-of-sound-packets"
function abPkms(x:integer):integer;//convert "milliseconds" to "number-of-sound-packets"
//TNetworkUsers
function writeuseraddress(_username,_domain:string;var _address:string):boolean;
function readuseraddress(_address:string;var _username,_domain:string):boolean;
//wave - out
function waveOutOpen(lphWaveOut: PHWaveOut; uDeviceID: UINT; lpFormat: PWaveFormatEx; dwCallback, dwInstance, dwFlags: DWORD): MMRESULT; stdcall; external mmsyst name 'waveOutOpen';
function waveOutClose(hWaveOut: HWAVEOUT): MMRESULT; stdcall; external mmsyst name 'waveOutClose';
function waveOutPrepareHeader(hWaveOut: HWAVEOUT; lpWaveOutHdr: PWaveHdr; uSize: UINT): MMRESULT; stdcall; external mmsyst name 'waveOutPrepareHeader';
function waveOutUnprepareHeader(hWaveOut: HWAVEOUT; lpWaveOutHdr: PWaveHdr; uSize: UINT): MMRESULT; stdcall; external mmsyst name 'waveOutUnprepareHeader';
function waveOutWrite(hWaveOut: HWAVEOUT; lpWaveOutHdr: PWaveHdr; uSize: UINT): MMRESULT; stdcall; external mmsyst name 'waveOutWrite';
//wave - in
function waveInOpen(lphWaveIn: PHWAVEIN; uDeviceID: UINT; lpFormatEx: PWaveFormatEx; dwCallback, dwInstance, dwFlags: DWORD): MMRESULT; stdcall; external mmsyst name 'waveInOpen';
function waveInClose(hWaveIn: HWAVEIN): MMRESULT; stdcall; external mmsyst name 'waveInClose';
function waveInPrepareHeader(hWaveIn: HWAVEIN; lpWaveInHdr: PWaveHdr; uSize: UINT): MMRESULT; stdcall; external mmsyst name 'waveInPrepareHeader';
function waveInUnprepareHeader(hWaveIn: HWAVEIN; lpWaveInHdr: PWaveHdr; uSize: UINT): MMRESULT; stdcall; external mmsyst name 'waveInUnprepareHeader';
function waveInAddBuffer(hWaveIn: HWAVEIN; lpWaveInHdr: PWaveHdr; uSize: UINT): MMRESULT; stdcall; external mmsyst name 'waveInAddBuffer';

implementation

uses av1; {app critical data}

//-- Critical Support Routines --------------------------------------------------
//## newb3 ##
function newb3(self:tvirtualform;_type:string;var _caption:string;_tep:string;_align:tvirtualalign;_newparent:tvirtualcontrol;_onclick:tnotifyevent;var _sysptr:integer;_style:tstoragestyle;_default,_range:string;var _result:tvirtualcontrol):boolean;//03MAR2008
label
   skipend;
const
   sp=5;
begin
try
//defaults
result:=false;
//check
if (self=nil) then exit;
//process
//.control
if (_type='MANAGEDSERVER22') then//22 vars
   begin
   _result:=tmanagedserver.create(self,_sysptr,_tep);
   _caption:='';//*
   _sysptr:=vsNil;
   end
else if (_type='SECURITYFILTER') then
   begin
   self.new('*',_caption,'','',valTop,_newparent,nil);
   _result:=tvirtualsecurityfilter.create(self);
   end
else if (_type='FILTERSNIPPET') then//03MAR2008
   begin
   self.new('*',_caption,'','',valTop,_newparent,nil);
   _result:=tvirtualfiltersnippet.create(self);
   end
else goto skipend;//end of if
//succcesful
result:=true;
skipend:
except;end;
end;
//## ms64 ##
function ms64:currency;//64bit millisecond system timer, 01-SEP-2006
var//64bit system timer, replaces "gettickcount" with range of 49.7 days,
   //now with new range of 29,247 years.
   //Note: must be called atleast once every 49.7 days, or it will loose track so
   //      system timer should call this routine regularly.
   i4:tint4;
   tmp:currency;
begin
try
//defaults
result:=0;
//process
//.get
i4.val:=gettickcount;
//INTEGER -> CURRENCY (0..4billion)
//#1
result:=i4.bytes[0];
//#2
tmp:=i4.bytes[1];
result:=result+(tmp*256);
//#3
tmp:=i4.bytes[2];
result:=result+(tmp*256*256);
//#4
tmp:=i4.bytes[3];
result:=result+(tmp*256*256*256);
//#5
if (not ms64init) then
   begin
   if programtesting then
      begin
      ms64OFFSET:=maxint;
      ms64OFFSET:=ms64OFFSET*4;
      end
   else ms64OFFSET:=0;
   ms64LAST:=result;
   ms64init:=true;
   end;//end of if
//# thread safe - allow a large difference margin (10 minutes) so close calling
//# threads won't corrupt (increment falsely) the offset var.
if ((result+600000)<ms64LAST) then ms64OFFSET:=ms64OFFSET+ms64LAST;
//lastv
ms64LAST:=result;
//#6
result:=result+ms64OFFSET;
except;end;
end;
//## ms32 ##
function ms32:currency;//32bit millisecond system timer (0..4-billion)
var//To be used only as reference, no-longer as core.
   i4:tint4;
   tmp:currency;
begin
try
//defaults
result:=0;
//process
//.get
i4.val:=gettickcount;

//INTEGER -> CURRENCY (0..4billion)
//#1
result:=i4.bytes[0];
//#2
tmp:=i4.bytes[1];
result:=result+(tmp*256);
//#3
tmp:=i4.bytes[2];
result:=result+(tmp*256*256);
//#4
tmp:=i4.bytes[3];
result:=result+(tmp*256*256*256);
except;end;
end;
//## mn32 ##
function mn32:integer;//32bit minute system timer (0..MAXINT ~ 4,000 years), 27-SEP-2006
begin//Range:
try
//defaults
result:=0;
//get
result:=round(ms64/60000);
except;end;
end;

//-- General Support Routines --------------------------------------------------
//## clientUDP ##
function clientUDP(ip:integer;port:word;data:string;var rdata:string):boolean;
label
   skipend;
const//Timeout occurs after 5send/10recv seconds
   bufsize=4096;
var
   buf:array[0..(bufsize-1)] of char;
   a:tsockaddrin;
   s:tsocket;
   sent,aLEN,v,len,p:integer;
   t:currency;
begin
try
//defaults
result:=false;
rdata:='';
s:=invalid_socket;
//session
netsession.start;
//range
if (ip=0) or (port<=0) then exit;
//process
//.socket
s:=n_socket(PF_INET,SOCK_DGRAM,IPPROTO_UDP);
if (s=invalid_socket) then goto skipend;
//.non-blocking (program runs while waiting for data)
wsaasyncselect(s,pg.handle,cm_socketmessage,longint(FD_READ or FD_WRITE or FD_ACCEPT or FD_CONNECT or FD_CLOSE));
//.init
fillchar(a,sizeof(a),0);
a.sin_family:=PF_INET;
a.sin_port:=n_htons(port);
a.sin_addr.s_addr:=ip;
aLEN:=sizeof(a);
//.fill
len:=frcmax(length(data),bufsize);
tonullstr(@buf,bufsize,data);
//.send
t:=ms64;
sent:=0;
repeat
v:=n_sendto(s,buf,len,0,a,aLEN);
if (v>=1) then
   begin
   t:=ms64;
   inc(sent,v);
   break;
   end;//end of if
//.breath
if general.pause then application.processmessages;
until ((ms64-t)>=5000);
//.recv
if (sent<len) then goto skipend;
aLEN:=sizeof(a);
t:=ms64;
repeat
len:=n_recvfrom(s,buf,sizeof(buf),0,a,aLEN);
if (len>=1) then
   begin
   //.get
   setstring(rdata,buf,len);
   //successful
   result:=true;
   end;//end of if
//.breath
if general.pause then application.processmessages;
until ((ms64-t)>=10000) or result;
skipend:
except;end;
try
if (s<>invalid_socket) then n_closesocket(s);
netsession.stop;
except;end;
end;
//## netGET ##
function netGET(url,proxy:string;var hdr:string;var content:string;var cancelled:boolean):tnetworkerror;
begin
try;result:=netXXX(url,proxy,'',hdr,content,cancelled,'GET',false);except;end;
end;
//## netHEAD ##
function netHEAD(url,proxy:string;var hdr:string;var content:string;var cancelled:boolean):tnetworkerror;
begin
try;result:=netXXX(url,proxy,'',hdr,content,cancelled,'HEAD',false);except;end;
end;
//## netXXX ##
function netXXX(url,proxy:string;ohdr:string;var hdr:string;var content:string;var cancelled:boolean;mode:string;raw:boolean):tnetworkerror;
var
   ptr:tnetworkptr;
   host,requesturl,tmp,s,e,z:string;
   hlen,len,p:integer;
   hok:boolean;
begin
try
//defaults
result:=nweOpenAddress;
s:=ohdr;
hdr:='';
content:='';
cancelled:=false;
if (mode='') then mode:='GET';
mode:=uppercase(mode);
//process
//.set
ptr:=nw.open(url,proxy,requesturl,host);
//.start
if (ptr.c<>0) then
   begin
   //.prepare
   if (s='') then
      begin
      s:=
      mode+#32+requesturl+' HTTP/1.0'+rcode+
      'Accept: */*'+rcode+
      'Accept-Language: en-us'+rcode+
      'User-Agent: '+nw.ua+rcode+
      'Host: '+host+rcode+
      rcode;
      end;//end of if
   //..other
   hok:=false;
   len:=0;
   hlen:=0;
   //..enforce header
   if raw then insert(misc.writeunix16(length(s)),s,1);
   repeat
   //.send
   if (s<>'') then nw.send(ptr,s)
   //.recv
   else nw.recv(ptr,z);
   //..add
   if (z<>'') then
      begin
      if hok or raw then
         begin
         content:=content+z;
         if raw then
            begin
            result:=nweOK;
            delete(content,1,2);//remove "leading 2 byte length header"
            break;
            end;//end of if
         end
      else
         begin
         hdr:=hdr+z;
         if ns.hlen(hdr,hlen) then
            begin
            hok:=true;
            content:=copy(hdr,hlen+1,length(hdr));
            hdr:=copy(hdr,1,hlen);
            end;//end of if
         end;//end of if
      z:='';
      end;//end of if
   //.status
   sleep(1);
   application.processmessages;
   until cancelled or ((not nw.cansend(ptr,s,false)) and (not nw.canrecv(ptr)));
   //.cancelled
   if cancelled then result:=nweInvalidPtr
   else result:=nw.error[ptr];
   //.close
   nw.close(ptr);
   end;//end of if
except;end;
end;
//## _strIP ##
function _strIP(x:integer):string;//convert integer IP to string (dot notation)
var
   a:tint4;
begin
try
a.val:=x;
result:=inttostr(a.bytes[0])+'.'+inttostr(a.bytes[1])+'.'+inttostr(a.bytes[2])+'.'+inttostr(a.bytes[3]);
except;end;
end;
//## _strIPpad ##
function _strIPpad(x:integer):string;//convert integer IP to padded string (dot notation) 05JAN2008
var
   a:tint4;
begin
try
a.val:=x;
result:=
 general.digpad(a.bytes[0],3)+'.'+
 general.digpad(a.bytes[1],3)+'.'+
 general.digpad(a.bytes[2],3)+'.'+
 general.digpad(a.bytes[3],3);
except;end;
end;
//## _intIP ##
function _intIP(x:string):longint;//convert "string IP" (dot notation) to integer version
begin
try;_intIPb(x,result);except;end;
end;
//## _intIPc ##
function _intIPc(x:string;reverse:boolean):string;//10.0.0.1 => #10#0#0#1 or #1#0#0#10
var
   a:tint4;
begin
try
//defaults
result:=#0#0#0#0;
//get
a.val:=_intip(x);
//set
case reverse of
false:begin
   result[1]:=a.chars[0];
   result[2]:=a.chars[1];
   result[3]:=a.chars[2];
   result[4]:=a.chars[3];
   end;//end of begin
true:begin
   result[1]:=a.chars[3];
   result[2]:=a.chars[2];
   result[3]:=a.chars[1];
   result[4]:=a.chars[0];
   end;//end of begin
end;//end of case
except;end;
end;
//## _intIPb ##
function _intIPb(x:string;var ip:integer):boolean;//convert "string IP" (dot notation) to integer version
var
   a:tint4;
   s,c,p,maxp:integer;
   z:string;
begin
try
//defaults
result:=false;
ip:=0;
//setup
fillchar(a,sizeof(a),0);
x:=x+'.';
maxp:=length(x);
c:=0;
s:=1;
//process
for p:=1 to maxp do if (x[p]='.') then
    begin
    z:=copy(x,s,p-s);
    a.bytes[c]:=frcrange(strint(copy(x,s,p-s)),0,255);
    s:=p+1;
    inc(c);
    if (c>=4) then
       begin
       result:=true;
       break;
       end;//end of if
    end;//end of if
//return result
ip:=a.val;
except;end;
end;
//## _revIP ##
function _revIP(x:longint):longint;
var
   a,b:tint4;
begin
try
a.val:=x;
b.bytes[0]:=a.bytes[3];
b.bytes[1]:=a.bytes[2];
b.bytes[2]:=a.bytes[1];
b.bytes[3]:=a.bytes[0];
result:=b.val;
except;end;
end;
//## _ip8 ##
function _ip8(ip4:integer):currency;
var
   a:tint4;
   tmp:currency;
begin
try
//defaults
result:=0;
//process
//.get
a.val:=ip4;
//.set
result:=a.bytes[3]+a.bytes[2]*256+a.bytes[1]*65536;
//.math workaround
tmp:=16777216;
result:=result+(tmp*a.bytes[0]);
except;end;
end;
//## _ip4 ##
function _ip4(ip8:currency):integer;
var
   a:tcur8;
   b:tint4;
begin
try
//defaults
result:=0;
//process
a.val:=ip8;
a.val:=a.val/10000;
b.val:=0;
b.bytes[3]:=a.bytes[0];
b.bytes[2]:=a.bytes[1];
b.bytes[1]:=a.bytes[2];
b.bytes[0]:=a.bytes[3];
result:=b.val;
except;end;
end;
//## fromstruc ##
function fromstruc(a:pointer;asize:integer):string;
var
   p:integer;
   b:pdlBYTE;
begin
try
//prepare
b:=a;
setlength(result,asize);
//process
for p:=0 to (asize-1) do result[p+1]:=chr(b[p]);
except;end;
end;
//## tostrucb ##
procedure tostrucb(a:pointer;asize:integer;x:string);
begin
try;tostruc(a,asize,x);except;end;
end;
//## tostruc ##
procedure tostruc(a:pointer;asize:integer;var x:string);
var
   maxp,p:integer;
   b:pdlBYTE;
begin
try
//prepare
fillchar(a^,asize,0);
b:=a;
maxp:=frcmax(length(x),asize);
//process
for p:=1 to maxp do b[p-1]:=ord(x[p]);
except;end;
end;
//## fromnullstr ##
function fromnullstr(a:pointer;asize:integer):string;
var
   p:integer;
   b:pdlBYTE;
begin
try
//prepare
setlength(result,asize);
b:=a;
//process
for p:=0 to (asize-1) do
    begin
    result[p+1]:=chr(b[p]);
    if (b[p]=0) then
       begin
       setlength(result,p);
       break;
       end;//end of if
    end;//end of loop
except;end;
end;
//## tonullstrb ##
procedure tonullstrb(a:pointer;asize:integer;z:string);
begin
try;tonullstr(a,asize,z);except;end;
end;
//## tonullstr ##
procedure tonullstr(a:pointer;asize:integer;var z:string);
var//Note: this proc used to stop when it detected the first #0 in z, but this
   //      has now been removed, since it caused data transmission failure for
   //      higher level system using "binary data" instead of ascii 30-OCT-2006.
   maxp,p:integer;
   b:pdlBYTE;
begin
try
//prepare
maxp:=frcmax(length(z)-1,asize-1);
fillchar(a^,asize,0);
b:=a;
//process
for p:=0 to maxp do b[p]:=ord(z[p+1]);
except;end;
end;
//## getmachineinfob ##
procedure getmachineinfob(var ip:integer;var host:string);//local ip and local host
var
   tmp:string;
begin
try
getmachineinfo(tmp,host);
ip:=_intip(tmp);
except;end;
end;
//## getmachineinfo ##
procedure getmachineinfo(var ip,host:string);//local ip and local host
var
   wVersionRequested:word;
   wsaData:twsadata;
   p:phostent;
   s:array[0..128] of char;
   p2:pchar;
begin
try
//defaults
ip:='';
host:='';
//process
//.start
wsastartup(winsocketVersion,wsaData);
//.host
n_gethostname(@s,128);
p:=n_gethostbyname(@s);
host:=p^.h_Name;
//.ip
p2:=n_inet_ntoa(pinaddr(p^.h_addr_list^)^);
ip:=p2;
//.stop
wsacleanup;
except;end;
end;
//## freeportb ##
function freeportb(_from,_to:integer;_udp:boolean):integer;//27-OCT-2006
begin
try;result:=freeport(misc.numbers(_from,_to,','),_udp);except;end;
end;
//## freeport ##
function freeport(x:string;_udp:boolean):integer;//27-OCT-2006
label
     skipend;
var
   s,z,r,maxp,xLen,dp,lp,p:integer;
   sai:TSockAddrIn;
begin
try
{error}
result:=-1;
{start session}
NetSession.start;
{prepare}
//xLen
xLen:=length(x);
//s
case _udp of
false:s:=n_socket(PF_INET,SOCK_STREAM,IPPROTO_TCP);
true:s:=n_socket(PF_INET,SOCK_DGRAM,IPPROTO_UDP);
end;//end of case
if (s=INVALID_SOCKET) then goto skipend;
//sai
sai.sin_family:=PF_INET;
sai.sin_addr.s_addr:=INADDR_ANY;
{process}
lp:=1;
dp:=0;
//scan
for p:=1 to xLen do if (x[p]=',') or (p=xLen) then
    begin
    //get
    if (x[p]<>',') then dp:=1 else dp:=0;
    z:=-1;
    try;z:=strint(copy(x,lp,p-lp+dp));except;end;
    //enforce min-range only (error for max range on Win95v1)
    //.init
    if (z>=0) then
       begin
       sai.sin_port:=n_htons(z);
       //.bind
       if (0=n_bind(s,sai,sizeOf(sai))) then
          begin
          //successful
          result:=z;
          break;
          end;//end of if
       end;//end of if
    //lp
    lp:=p+1;
    end;//end of if
skipend:
except;end;
try
if (s<>INVALID_SOCKET) then n_closesocket(s);
{stop}
NetSession.stop;
except;end;
end;
//## nid ##
Function nid(var x:integer):integer;{new id}
begin
try
{process}
case (x>=high(integer)) of
true:x:=0;
false:x:=x+1;
end;//end of case
{return result}
result:=x;
except;end;
end;
//## vpn ##
Function vpn(x:integer):integer;{valid port number}
var
   p:integer;
begin
try
//get
case netsession.running of
true:p:=netsession.info.iMaxSockets-1;
false:p:=65535;
end;//end of case
//set
result:=frcrange(x,1,p);
except;end;
end;
//## cupn ##
Function cupn(x:string;y:integer):string;{change url port number | date: 13-OCT-2003}
var
   z:string;
   d,s,p,xlen:integer;
begin{supports: IP=10.0.0.9, URL=http://www.blaiz.net, FULL=http://www.blaiz.net:10754/HOME.HTM}
try
{prepare}
xlen:=length(x);
s:=0;
z:=':';
{process}
for p:=1 to xlen do
begin
//start
if (s=0) then
   begin
   if (x[p]=':') and (copy(x,p,3)<>'://') then
      begin
      s:=p;
      z:='';
      end
   else if (x[p]='/') and ((copy(x,p-1,1)<>'/') and (copy(x,p+1,1)<>'/')) then s:=p-1
   else if (p=xlen) then s:=p;
   end;//end of if
//finish
if (s<>0) and ((x[p]='/') or (p=xlen)) then
   begin
   if (x[p]='/') then d:=1 else d:=0;
   x:=copy(x,1,s)+z+inttostr(vpn(y))+copy(x,p,xlen-p+d);
   break;
   end;//end of if
end;//end of loop
{return result}
result:=x;
except;end;
end;
//## inc_int ##
Procedure inc_int(Var X:Integer);
begin
try;If (X<High(Integer)) then X:=X+1;except;end;
end;
//## SplitAddr ##
Procedure SplitAddr(X:String;Var Addr:String;Var Port:Integer);
Var
   P,MaxP:Integer;
begin
try
{Defaults}
Addr:=X;
Port:=0;
MaxP:=Length(X);
For P:=MaxP downTo 1 Do If (X[P]=':') and (Copy(X,P,3)<>'://') then
    begin
    Addr:=Copy(X,1,P-1);
    Port:=FrcRange(strint(Copy(X,P+1,MaxP)),0,High(Word));
    break;
    end;//end of if
except;end;
end;
//## ID_str ##
Function ID_str(macID,macPort:Integer):String;
begin
try;Result:=From32Bit(macID)+From32Bit(macPort);except;end;
end;
//## strs_IDs ##
Function strs_IDs(X:String;Var Y:Array of String):Integer;
Label
     ReDo,SkipEnd;
Var
   MaxP,P:Integer;
begin
try
{Default}
Result:=0;
{Prepare}
MaxP:=FrcRange(Length(X) Div 8,1,High(Y)+1);
If (MaxP<=0) then Goto SkipEnd;
{Process}
P:=1;
ReDo:
{Set}
Y[P-1]:=Copy(X,(P-1)*8+1,8);
{Count}
Result:=P;
{Loop}
If (P<MaxP) then
   begin
   P:=P+1;
   Goto ReDo;
   end;//end of if
SkipEnd:
except;end;
end;
//## dosunix_paths ##
Procedure dosunix_paths(Var X:string;dos:boolean);
Var
   P,MaxP:Integer;
begin
try
{Prepare}
MaxP:=Length(X);
{Process}
case dos of
true:For P:=1 to MaxP Do if (X[P]='/') then X[P]:='\';
false:For P:=1 to MaxP Do if (X[P]='\') then X[P]:='/';
end;//end of case
except;end;
end;
//## int_hex_char ##
Function int_hex_char(X:byte):char;
begin
try
If (X>15) then X:=15;
Case X of
0..9:Result:=Chr(48+X);
10..15:Result:=Chr(55+X);
else
 Result:='?';
end;//end of case
except;end;
end;
//## hex_char_int ##
Function hex_char_int(X:char):byte;//updated 18-JAN-2006
Var
   v:byte;
begin
try
V:=Ord(X);
Case V of
48..57:Result:=V-48;//0-9
65..70:Result:=V-55;//A-F
97..102:Result:=V-87;//a-f
else
 Result:=0;
end;//end of case
except;end;
end;
//## col_hex ##
function col_hex(x:integer):string;
var
   a,b:byte;
   c:tint4;
begin
try
{prepare}
c.val:=x;
{process}
result:='#'+int_hex(c.r)+int_hex(c.g)+int_hex(c.b);
except;end;
end;
//## int_hex ##
Function int_hex(X:byte):string;
Var
   a,b:byte;
begin
try
a:=X div 16;
b:=X-(a*16);
Result:=int_hex_char(a)+int_hex_char(b);
except;end;
end;
//## hex_int ##
Function hex_int(X:string):byte;
begin
try
Case Length(X) of
1:Result:=hex_char_int(X[1]);
2:Result:=16*hex_char_int(X[1])+hex_char_int(X[2]);
else
 Result:=0;
end;//end of case
except;end;
end;
//## net_unix_split_pf ##
Procedure net_unix_split_pf(Var pf,p,f:string);
var
   i,maxi:integer;
begin
try
{enforce root path}
case (pf='') of
true:pf:='/';
false:if (pf[1]<>'/') then pf:='/'+pf;
end;//end of case
{default}
f:=pf;
p:='';
maxi:=length(pf);
{process}
for i:=maxi downto 1 do if (pf[i]='/') then
    begin
    f:=copy(pf,i+1,maxi);
    p:=copy(pf,1,i);
    break;
    end;//end of if
except;end;
end;
//## net_IsHTMLext ##
Function net_IsHTMLext(X:string):Boolean;
begin
try
{No}
Result:=False;
X:=ExtractFileExt(LowerCase(X));
{Yes}
Result:=(X='htm') or (X='html');
except;end;
end;
//## net_mozilla_ver ##
Function net_mozilla_ver(x:string):byte;
begin
try
{not valid}
result:=0;
x:=lowercase(x);
if (Copy(x,1,8)='mozilla/') then result:=strint(copy(x,9,1))*10+strint(copy(x,11,1));{3.1->31}
except;end;
end;
//## net_encode_str ##
procedure net_encode_str(Var X:String);
begin
try;net_encode_str_slash(x,false);except;end;
end;
//## net_encode_url ##
procedure net_encode_url(var x:string);//18-DEC-2006 v008
var//Note: Range 33..126 are raw and not encoded for URL's
   v,xlen,p:integer;
begin
try
//defaults
xlen:=length(x);
//check
if (xlen=0) then exit;
//process
p:=1;
repeat
v:=byte(x[p]);
if (v<=32) or (v>=127) or (v=35) or (v=43) then//hash and "+" must be encoded (special cases)
   begin
   x:=copy(x,1,p-1)+'%'+int_hex(v)+copy(x,p+1,xlen);
   xlen:=xlen+2;{always "%XY" = 3-1 = enlarged by 2c's}
   //.inc
   inc(p,2);
   end;//end of if
//.inc
inc(p);
until (p>xlen);
except;end;
end;
//## net_encode_url_b ##
function net_encode_url_b(x:string):string;//23FEB2008
begin
try
result:=x;
net_encode_url(result);
except;end;
end;
//## net_encode_urlSHOULD ##
function net_encode_urlSHOULD(var x:string):boolean;//28FEB2008
var//Note: skip over "+" as these are ok within a url
   p:integer;
   v:byte;
begin
try
//defaults
result:=false;
//scan
for p:=1 to length(x) do
begin
v:=byte(x[p]);
if (v=63) then break//?
else if (v<=32) or (v=35) or (v>=127) then
    begin
    result:=true;
    break;
    end;//end of if
end;//end of loop
except;end;
end;
//## net_encode_str_slash_b ##
function net_encode_str_slash_b(x:string;leaveslash:boolean):string;//20DEC2007
begin
try;result:=x;net_encode_str_slash(result,leaveslash);except;end;
end;
//## net_encode_str_slash ##
procedure net_encode_str_slash(var x:string;leaveslash:boolean);//12-JUN-2006
var
   v,xlen,p:integer;
begin
try
//defaults
xlen:=length(x);
//check
if (xlen=0) then exit;
//process
p:=1;
repeat
v:=byte(x[p]);
case v of
42,45..46,48..57,64..90,95,97..122:{don't encode these |*|-|.|0..9|@..Z|_|a..z|};
32:x[p]:='+';{special case: <space> -> <+>}
else{encode using IBM encoding ("%"+"0..F"+"0..F")}
if not ((x[p]='/') and leaveslash) then
   begin
   x:=copy(x,1,p-1)+'%'+int_hex(v)+copy(x,p+1,xlen);
   xlen:=xlen+2;{always "%XY" = 3-1 = enlarged by 2c's}
   //.inc
   inc(p,2);
   end;//end of if
end;//end of case
//.inc
inc(p);
until (p>xlen);
except;end;
end;
//## net_encode_str_full ##
procedure net_encode_str_full(var x:string);//12-JUN-2006
var
   v,xlen,p:integer;
begin
try
//defaults
xlen:=length(x);
//check
if (xlen=0) then exit;
//process
p:=1;
repeat
v:=byte(x[p]);
case v of
42,45..46,48..57,64..90,95,97..122://don't encode these |*|-|.|0..9|@..Z|_|a..z|;
else//encode using IBM encoding ("%"+"0..F"+"0..F")
x:=copy(x,1,p-1)+'%'+int_hex(v)+copy(x,p+1,xlen);
//.inc
inc(xlen,2);//always "%XY" = 3-1 = enlarged by 2c's
inc(p,2);
end;//end of case
until (p>xlen);
except;end;
end;
//## net_encode_str_fullb ##
function net_encode_str_fullb(x:string):string;
begin
try;result:=x;net_encode_str_full(result);except;end;
end;
//## net_decode_str ##
procedure net_decode_str(var x:string);//12-JUN-2006
var
   xp,xlen,p:integer;
begin
try
//defaults
xlen:=length(x);
//check
if (xlen=0) then exit;
//process
xp:=0;
p:=1;
repeat
if (x[p]='%') then
   begin
   x[p+xp]:=chr(hex_int(copy(x,p+1,2)));
   xp:=xp-2;
   p:=p+2;
   end
else if (x[p]='+') then x[p+xp]:=#32
else x[p+xp]:=x[p];
//.inc
inc(p);
until (p>xlen);
//.size
x:=copy(x,1,xlen+xp);
except;end;
end;
//## net_decode_str_b ##
Function net_decode_str_b(X:String):String;
begin
try;net_decode_str(X);Result:=X;except;end;
end;
//## net_encode_str_b ##
Function net_encode_str_b(X:String):String;
begin
try;net_encode_str(X);Result:=X;except;end;
end;
//## net_encode_for_html ##
Function net_encode_for_html_b(X:String):String;
begin
try;net_encode_for_html(X);Result:=X;except;end;
end;
//## net_encode_for_html ##
procedure net_encode_for_html(var x:string);//faster, date: 12-JUN-2006
var
   v:byte;
   lsp,len,xlen,p:integer;
   z:string;
begin
try
//defaults
z:=x;
x:='';
xlen:=length(z);
len:=0;
p:=1;
lsp:=0;
//check
if (xlen=0) then exit;
//process
repeat
//get
v:=ord(z[p]);
//scan  <=60, >=62, "=34, '=39 &=38, space=32, rcode=10/13, tab=9
case v of
60:pushb(len,x,'&lt;');//<
62:pushb(len,x,'&gt;');//>
38:pushb(len,x,'&amp;');//&
34:pushb(len,x,'&quot;');//"
32:begin
   if (lsp=(p-1)) then pushb(len,x,'&nbsp;')
   else pushb(len,x,#32);
   lsp:=p;
   end;//end of begin
9,39:pushb(len,x,'&#'+inttostr(v)+';');
else pushb(len,x,z[p]);
end;//end of case
//.inc
inc(p);
until (p>xlen);
//finalise
pushb(len,x,'');
except;end;
end;
//## net_read_nameval ##
function net_read_nameval(Var X,name,data:String;Var P,MaxP:Integer):boolean;//updated: 15-APR-2004
var
   minP,m,f,i,i2:Integer;
begin
try
{Finished}
Result:=False;
{Prepare}
If (P<1) then P:=1;
If (P>MaxP) then exit;
m:=1;
f:=1;
minP:=P;
{process}
for i:=minp to maxp Do
begin
//split
if (X[i]='=') then m:=i;
//get
if (X[i]='&') or (i=maxp) then
   begin
   {f}
   case (i=maxP) of
   True:f:=i;
   False:f:=i-1;
   end;//end of case
   {decode & set}
   name:=Copy(X,P,m-P);
   net_decode_str(name);
   data:=Copy(X,m+1,f-m);
   net_decode_str(data);
   P:=i+1;
   {Successful}
   Result:=True;
   break;
   end;//end of if
end;//end of loop
except;end;
end;

//## tprogramf #################################################################
//## programf_create ##
procedure programf_create;
var
   c:word;
begin
try
//defaults
randomize;
c:=0;
//check
if programf_init then exit else programf_init:=true;
//process
//.get                            //banconst,banvar
programf_definefunc('nil',program_nil,false,true,false);
programf_definefunc('test',program_test,false,false,false);
programf_definefunc('vidadd',program_vidadd,false,false,false);
programf_definefunc('vidpull',program_vidpull,false,true,false);
programf_definefunc('vidpush',program_vidpush,false,true,false);
programf_definefunc('vidcls',program_vidcls,false,true,false);
programf_definefunc('label',program_label,false,false,false);
programf_definefunc('msg',program_msg,false,false,false);
programf_definefunc('msg60',program_msg60,false,false,false);
programf_definefunc('msgvar',program_msgvar,false,false,false);
programf_definefunc('pull',program_pull,false,false,false);
programf_definefunc('push',program_push,true,false,false);
programf_definefunc('pull2',program_pull2,false,false,false);
programf_definefunc('push2',program_push2,true,false,false);
programf_definefunc('>',program_g,false,false,false);
programf_definefunc('>=',program_ge,false,false,false);
programf_definefunc('=',program_e,false,false,false);
programf_definefunc('<>',program_ne,false,false,false);
programf_definefunc('<=',program_le,false,false,false);
programf_definefunc('<',program_l,false,false,false);
programf_definefunc('+',program_p,false,false,false);
programf_definefunc('-',program_m,false,false,false);
programf_definefunc('*',program_t,false,false,false);
programf_definefunc('/',program_d,false,false,false);
programf_definefunc('++',program_pp,true,false,false);//inc specified var +1 (int)
programf_definefunc('--',program_mm,true,false,false);//dec specified var -1 (int)
programf_definefunc('rnd',program_rnd,false,false,false);
programf_definefunc('null',program_null,true,false,false);
programf_definefunc('beep',program_beep,false,false,false);
programf_definefunc('sleep',program_sleep,false,false,false);
programf_definefunc('breath',program_breath,false,true,false);
programf_definefunc('loop',program_loop,true,false,false);
programf_definefunc('ifloop',program_ifloop,true,false,false);
programf_definefunc('ifnotloop',program_ifnotloop,true,false,false);
programf_definefunc('goto',program_goto,true,false,true);
programf_definefunc('ifgoto',program_ifgoto,true,false,true);
programf_definefunc('ifnotgoto',program_ifnotgoto,true,false,true);
programf_definefunc('go',program_go,true,false,true);
programf_definefunc('ifgo',program_ifgo,true,false,true);
programf_definefunc('ifnotgo',program_ifnotgo,true,false,true);
programf_definefunc('ret',program_ret,false,true,false);//return from a go
programf_definefunc('ifret',program_ifret,true,false,false);//return from a go
programf_definefunc('ifnotret',program_ifnotret,true,false,false);//return from a go
programf_definefunc('if',program_if,false,false,false);
programf_definefunc('ifnot',program_ifnot,false,false,false);
programf_definefunc('else',program_else,false,true,false);
programf_definefunc('endif',program_endif,false,true,false);
programf_definefunc('end',program_end,false,true,false);
programf_definefunc('quit',program_quit,false,true,false);
programf_definefunc('stack',program_stack,false,false,false);
programf_definefunc('unstack',program_unstack,true,false,false);
programf_definefunc('unstack+',program_unstackp,true,false,false);
programf_definefunc('stackcount',program_stackcount,true,false,false);
programf_definefunc('asbol',program_asbol,true,false,false);
programf_definefunc('asint',program_asint,true,false,false);
programf_definefunc('ascur',program_ascur,true,false,false);
programf_definefunc('asstr',program_asstr,true,false,false);
programf_definefunc('not',program_not,false,false,false);
programf_definefunc('and',program_and,false,false,false);
programf_definefunc('or',program_or,false,false,false);
programf_definefunc('cmp',program_cmp,false,false,false);
programf_definefunc('ms64',program_ms64,true,false,false);
programf_definefunc('pasttime',program_pasttime,false,false,false);
programf_definefunc('uptime',program_uptime,false,false,false);
programf_definefunc('msstart',program_msstart,false,false,false);
programf_definefunc('mselapsed',program_mselapsed,false,false,false);
programf_definefunc('yes',program_yes,false,false,false);
programf_definefunc('len',program_len,false,false,false);
programf_definefunc('thousands',program_thousands,false,false,false);
programf_definefunc('wecd',program_wecd,false,false,false);
programf_definefunc('timedate',program_timedate,false,false,false);
programf_definefunc('indent',program_indent,false,true,false);
//.internet
programf_definefunc('dns',program_dns,false,false,false);
programf_definefunc('redirectfind',program_redirectfind,false,false,false);
programf_definefunc('redirectadd',program_redirectadd,false,true,false);
programf_definefunc('strip',program_strip,false,false,false);
programf_definefunc('intip',program_intip,false,false,false);
programf_definefunc('urlrobot',program_urlrobot,false,false,false);
programf_definefunc('pullcontent',program_pullcontent,false,true,false);
//.robots
programf_definefunc('lockrobot',program_lockrobot,false,false,false);
programf_definefunc('pushrobot',program_pushrobot,false,true,false);
programf_definefunc('unlockrobot',program_unlockrobot,false,false,false);
//EXTERNAL
programf_definefunc('ex-support',program_exsupport,false,true,false);
programf_definefunc('ex',program_ex,false,true,false);
//CRAWLER
programf_definefunc('cw-support',program_cwsupport,false,false,false);
programf_definefunc('cw-pullurl',program_cwpullurl,false,true,false);
programf_definefunc('cw-finaliseurl',program_cwfinaliseurl,false,false,false);
programf_definefunc('cw-allowurl',program_cwallowurl,false,false,false);
programf_definefunc('cw-allowip',program_cwallowip,false,false,false);
programf_definefunc('cw-ipurlonce',program_cwipurlonce,false,true,false);
programf_definefunc('cw-robotsok',program_cwrobotsok,false,true,false);
programf_definefunc('cw-pushcrawl',program_cwpushcrawl,false,true,false);
except;end;
end;
//## programf_find ##
function programf_find(n:string;var i:integer):boolean;
var
   nref,p:integer;
begin
try
//defaults
result:=false;
i:=-1;
//init
nref:=general.ref32U(n);
//scan
for p:=0 to (programf_count-1) do if (programf_nameref[p]=nref) and (0=comparetext(n,programf_name[p])) then
   begin
   //found
   i:=p;
   result:=true;
   break;
   end;//end of if
except;end;
end;
//## programf_definefunc ##
procedure programf_definefunc(n:string;v:tprogramfunction;banconst,banvar,onlylabel:boolean);
begin
try
//process
if (n<>'') and assigned(v) and (programf_count<=high(programf_name)) then
   begin
   //set
   programf_name[programf_count]:=lowercase(n);
   programf_nameref[programf_count]:=general.ref32U(n);
   programf_ptr[programf_count]:=@v;
   programf_banconst[programf_count]:=banconst;
   programf_banvar[programf_count]:=banvar;
   programf_onlylabel[programf_count]:=onlylabel;
   //reference
   if      (programf_ifptr   =0) and (comparetext(n,'if'   )=0) then programf_ifptr:=programf_count
   else if (programf_ifnotptr=0) and (comparetext(n,'ifnot')=0) then programf_ifnotptr:=programf_count
   else if (programf_elseptr =0) and (comparetext(n,'else' )=0) then programf_elseptr:=programf_count
   else if (programf_endifptr=0) and (comparetext(n,'endif')=0) then programf_endifptr:=programf_count;
   //inc
   inc(programf_count);
   end;//end of if
except;end;
end;

//## tprogramvars ##############################################################
//## create ##
constructor tprogramvars.create;
begin
//self
inherited create;
//controls
//.helpers
ivn:=tdynamicnamelist.create;
ivinfo:=tdynamicbyte.create;
//.core
ivb:=tdynamicboolean.create;
iva:=tdynamicboolean.create;
ivi:=tdynamicinteger.create;
ivc:=tdynamiccurrency.create;
ivs:=tdynamicstring.create;
ivdef:=tdynamicstring.create;
ivl:=tdynamicboolean.create;
ivt:=tdynamicbyte.create;
//defaults
clear;
end;
//## destroy ##
destructor tprogramvars.destroy;
begin
try
//controls
freeobj(@ivn);
freeobj(@ivinfo);
freeobj(@ivb);
freeobj(@iva);
freeobj(@ivi);
freeobj(@ivc);
freeobj(@ivs);
freeobj(@ivdef);
freeobj(@ivl);
freeobj(@ivt);
//self
inherited;
except;end;
end;
//## newid ##
function tprogramvars.newid:integer;
begin
try
//inc
general.iroll(virtualprogramid,1);
//get
virtualprogramid:=frcmin(virtualprogramid,1);
//set
result:=virtualprogramid;
except;end;
end;
//## reduce ##
procedure tprogramvars.reduce;
begin
try
//trim
ivb.setparams(icount,icount,0);
iva.setparams(icount,icount,0);
ivi.setparams(icount,icount,0);
ivc.setparams(icount,icount,0);
ivs.setparams(icount,icount,0);
ivdef.setparams(icount,icount,0);
ivl.setparams(icount,icount,0);
ivt.setparams(icount,icount,0);
//names only required during setup, all other times they can be removed
ivn.clear;
ivinfo.clear;
except;end;
end;
//## clear ##
procedure tprogramvars.clear;
var
   p:integer;
begin
try
//clear
iconstcount:=0;
icount:=0;
//.helpers
ivn.clear;
ivinfo.clear;
//.core
ivb.setparams(0,0,0);
iva.setparams(0,0,0);
ivi.setparams(0,0,0);
ivc.setparams(0,0,0);
ivs.setparams(0,0,0);
ivdef.setparams(0,0,0);
ivl.setparams(0,0,0);
ivt.setparams(0,0,0);
//reserved vars
//.core
defineex('nil','',pvtStr,[piLocked],inil);
defineex('result','',pvtStr,[piAny],iresult);
defineex('result2','',pvtStr,[piAny],iresult2);//used as a temporariy version (for user only)
defineex('id','',pvtInt,[piLocked],iid);//locked int, for internal storage of "id" of "tprogram.instance"
//.system input/output vars
for p:=0 to high(vin) do defineex('in'+inttostr(p+1),'',pvtStr,[piAny],vin[p]);
for p:=0 to high(vout) do defineex('out'+inttostr(p+1),'',pvtStr,[piAny],vout[p]);
except;end;
end;
//## flush ##
procedure tprogramvars.flush;
var
   p:integer;
begin
try;for p:=0 to (icount-1) do if (not ivl.items[p]) then s[p]:=ivdef.items[p]^;except;end;
end;
//## find ##
function tprogramvars.find(n:string):integer;
begin
try;findex(n,result);except;end;
end;
//## findex ##
function tprogramvars.findex(n:string;var i:integer):boolean;
var
   tmp:integer;
begin
try
//defaults
result:=false;
i:=-1;
//scan
if (n<>'') then
   begin
   tmp:=ivn.findfast(0,n);
   if (tmp>=0) then
      begin
      i:=tmp;
      result:=true;
      end;//end of if
   end;//end of if
except;end;
end;
//## new ##
function tprogramvars.new(n:string;var i:integer):boolean;
begin//Note: creates var only once, repeats generate an error
try
//defaults
result:=false;
i:=-1;
//get
if (n<>'') and ivn.addonce(n) then
   begin
   //.helpers
   icount:=ivn.count;
   ivinfo.atleast(icount);
   //.core
   ivb.atleast(icount);
   iva.atleast(icount);
   ivi.atleast(icount);
   ivc.atleast(icount);
   ivs.atleast(icount);
   ivdef.atleast(icount);
   ivl.atleast(icount);
   ivt.atleast(icount);
   //successful
   i:=icount-1;
   result:=true;
   end;//end of if
except;end;
end;
//## besttype ##
function tprogramvars.besttype(x:string):byte;
begin
try
//defaults
result:=pvtStr;
//scan
if misc.isnumber(x) then
   begin
   if misc.isint(x) then result:=pvtInt
   else if misc.iscur(x) then result:=pvtCur;
   end;//end of if
except;end;
end;
//## define ##
function tprogramvars.define(n,v:string;t:byte;var i:integer):boolean;
begin
try;result:=defineex(n,v,t,[],i);except;end;
end;
//## defineconst ##
function tprogramvars.defineconst(var n:string;v:string;t:byte;var i:integer):boolean;
begin
try
//defaults
result:=false;
i:=-1;
//init
general.iroll(iconstcount,1);
n:='const'+inttostr(iconstcount);
//get
result:=defineex(n,v,t,[piConst,piLocked],i);
except;end;
end;
//## defineex ##
function tprogramvars.defineex(n,v:string;t:byte;pi:tprograminfo;var i:integer):boolean;
var//Note: creates new var only once, repeats generate an error
   //n=name, v=default value (as a string), t=type, a=auto-type, l=lock, i=position within var array
   tmp:integer;
begin
try
//defaults
result:=false;
i:=-1;
//new
if new(n,tmp) then
   begin
   //core
   ivdef.items[tmp]^:=v;
   ivt.items[tmp]:=t;
   ivinfo.items[tmp]:=byte(pi);
   s[tmp]:=v;
   if (piAny in pi) then iva.items[tmp]:=true;
   if (piLocked in pi) then ivl.items[tmp]:=true;
   //successful
   i:=tmp;
   result:=true;
   end;//end of if
except;end;
end;
//## valid ##
function tprogramvars.valid(x:integer):boolean;
begin
try;result:=(x>=0) and (x<icount);except;end;
end;
//## validok ##
function tprogramvars.validok(x:integer):boolean;
begin
try;result:=(x<>inil) and ((x>=0) and (x<icount));except;end;
end;
//## canset ##
function tprogramvars.canset(x:integer):boolean;
begin
try;result:=validok(x) and (not ivl.items[x]);except;end;
end;
//## copyvar ##
function tprogramvars.copyvar(_s,_d:integer):boolean;
begin
try
if valid(_s) and canset(_d) then
   begin
   //typechange
   typechange(_d,ivt.items[_s]);
   //set
   if (ivt.items[_d]=ivt.items[_s]) then
      begin
      case ivt.items[_d] of
      pvtBol:ivb.items[_d]:=ivb.items[_s];
      pvtInt,pvtLab:ivi.items[_d]:=ivi.items[_s];
      pvtCur:ivc.items[_d]:=ivc.items[_s];
      pvtStr:ivs.items[_d]^:=ivs.items[_s]^;
      end;//end of case
      end
   else s[_d]:=s[_s];
   end;//end of if
except;end;
end;
//## null ##
procedure tprogramvars.null(x:integer);
begin
try
if canset(x) then
   begin
   case ivt.items[x] of
   pvtBol:ivb.items[x]:=false;
   pvtInt,pvtLab:ivi.items[x]:=0;
   pvtCur:ivc.items[x]:=0;
   pvtStr:ivs.items[x]^:='';
   end;//end of case
   end;//end of if
except;end;
end;
//## setb ##
procedure tprogramvars.setb(x:integer;y:boolean);
begin
try
if canset(x) then
   begin
   //typechange
   typechange(x,pvtBol);
   //set
   case ivt.items[x] of
   pvtBol:ivb.items[x]:=y;
   pvtInt,pvtLab:ivi.items[x]:=integer(y);
   pvtCur:ivc.items[x]:=integer(y);
   pvtStr:ivs.items[x]^:=general.bn(y);
   end;//end of case
   end;//end of if
except;end;
end;
//## getb ##
function tprogramvars.getb(x:integer):boolean;
begin
try
//defaults
result:=false;
//get
if validok(x) then
   begin
   case ivt.items[x] of
   pvtBol:result:=ivb.items[x];
   pvtInt,pvtLab:result:=(ivi.items[x]<>0);
   pvtCur:result:=(ivc.items[x]<>0);
   pvtStr:result:=(ivs.items[x]^<>'') and (ivs.items[x]^<>'0');
   end;//end of case
   end;//end of if
except;end;
end;
//## seti ##
procedure tprogramvars.seti(x:integer;y:integer);
begin
try
if canset(x) then
   begin
   //typechange
   typechange(x,pvtInt);
   //set
   case ivt.items[x] of
   pvtBol:ivb.items[x]:=(y<>0);
   pvtInt,pvtLab:ivi.items[x]:=y;
   pvtCur:ivc.items[x]:=y;
   pvtStr:ivs.items[x]^:=inttostr(y);
   end;//end of case
   end;//end of if
except;end;
end;
//## geti ##
function tprogramvars.geti(x:integer):integer;
begin
try
//defaults
result:=0;
//get
if validok(x) then
   begin
   case ivt.items[x] of
   pvtBol:result:=integer(ivb.items[x]);
   pvtInt,pvtLab:result:=ivi.items[x];
   pvtCur:result:=round(ivc.items[x]);
   pvtStr:result:=strint(ivs.items[x]^);
   end;//end of case
   end;//end of if
except;end;
end;
//## setc ##
procedure tprogramvars.setc(x:integer;y:currency);
begin
try
if canset(x) then
   begin
   //typechange
   typechange(x,pvtCur);
   //set
   case ivt.items[x] of
   pvtBol:ivb.items[x]:=(y<>0);
   pvtInt,pvtLab:ivi.items[x]:=round(y);
   pvtCur:ivc.items[x]:=y;
   pvtStr:ivs.items[x]^:=floattostrex2(y);
   end;//end of case
   end;//end of if
except;end;
end;
//## getc ##
function tprogramvars.getc(x:integer):currency;
begin
try
//defaults
result:=0;
//get
if validok(x) then
   begin
   case ivt.items[x] of
   pvtBol:result:=integer(ivb.items[x]);
   pvtInt,pvtLab:result:=ivi.items[x];
   pvtCur:result:=ivc.items[x];
   pvtStr:result:=strtofloatex(ivs.items[x]^);
   end;//end of case
   end;//end of if
except;end;
end;
//## sets ##
procedure tprogramvars.sets(x:integer;y:string);
begin
try
if canset(x) then
   begin
   //typechange
   typechange(x,pvtStr);
   //set
   case ivt.items[x] of
   pvtBol:ivb.items[x]:=(y<>'') and (y<>'0');
   pvtInt,pvtLab:ivi.items[x]:=strint(y);
   pvtCur:ivc.items[x]:=strtofloatex(y);
   pvtStr:ivs.items[x]^:=y;
   end;//end of case
   end;//end of if
except;end;
end;
//## gets ##
function tprogramvars.gets(x:integer):string;
begin
try
//defaults
result:='';
//get
if validok(x) then
   begin
   case ivt.items[x] of
   pvtBol:result:=general.bn(ivb.items[x]);
   pvtInt,pvtLab:result:=inttostr(ivi.items[x]);
   pvtCur:result:=floattostrex2(ivc.items[x]);
   pvtStr:result:=ivs.items[x]^;
   end;//end of case
   end;//end of if
except;end;
end;
//## getinfo ##
function tprogramvars.getinfo(x:integer):tprograminfo;
begin
try;if (icount>=1) then result:=tprograminfo(ivinfo.items[x]) else result:=[];except;end;
end;
//## setinfo ##
procedure tprogramvars.setinfo(x:integer;y:tprograminfo);
begin
try;if (icount>=1) then ivinfo.items[x]:=byte(y);except;end;
end;
//## getl ##
function tprogramvars.getl(x:integer):boolean;
begin
try;if validok(x) then result:=ivl.items[x] else result:=false;except;end;
end;
//## gett ##
function tprogramvars.gett(x:integer):byte;
begin
try;if validok(x) then result:=ivt.items[x] else result:=pvtBol;except;end;
end;
//## geta ##
function tprogramvars.geta(x:integer):boolean;
begin
try;if validok(x) then result:=iva.items[x] else result:=false;except;end;
end;
//## typechange ##
procedure tprogramvars.typechange(x:integer;newt:byte);
begin//Warning: no range check is performed
try
if iva.items[x] and (ivt.items[x]<>newt) then
   begin
   //cleanup
   if (ivt.items[x]=pvtStr) then ivs.items[x]^:='';
   //set
   ivt.items[x]:=newt;
   end;//end of if
except;end;
end;

//## tprogramstack #############################################################
//## create ##
constructor tprogramstack.create;
begin
//self
inherited create;
//controls
ivt:=tdynamicbyte.create;
ivb:=tdynamicboolean.create;
ivi:=tdynamicinteger.create;
ivc:=tdynamiccurrency.create;
ivs:=tdynamicstring.create;
end;
//## destroy ##
destructor tprogramstack.destroy;
begin
try
//controls
freeobj(@ivt);
freeobj(@ivb);
freeobj(@ivi);
freeobj(@ivc);
freeobj(@ivs);
//self
inherited;
except;end;
end;
//## clear ##
procedure tprogramstack.clear;
begin
try
icount:=0;
ivt.clear;
ivb.clear;
ivi.clear;
ivc.clear;
ivs.clear;
except;end;
end;
//## enlarge ##
procedure tprogramstack.enlarge;
var
   tmp:integer;
begin
try
//inc
inc(icount);
//set
if (icount>=ivt.size) then
   begin
   tmp:=icount+100;
   ivt.setparams(tmp,tmp,0);
   ivb.setparams(tmp,tmp,0);
   ivi.setparams(tmp,tmp,0);
   ivc.setparams(tmp,tmp,0);
   ivs.setparams(tmp,tmp,0);
   end;//end of if
except;end;
end;
//## shrink ##
procedure tprogramstack.shrink;
var
   tmp:integer;
begin
try
//inc
dec(icount);
if (icount<=0) then tmp:=0 else tmp:=icount+100;
//set
if (tmp<ivt.size) then
   begin
   ivt.setparams(icount,icount,0);
   ivb.setparams(icount,icount,0);
   ivi.setparams(icount,icount,0);
   ivc.setparams(icount,icount,0);
   ivs.setparams(icount,icount,0);
   end;//end of if
except;end;
end;
//## pushbol ##
procedure tprogramstack.pushbol(x:boolean);
begin
try
enlarge;
ivt.items[icount-1]:=pvtBol;
ivb.items[icount-1]:=x;
except;end;
end;
//## pushint ##
procedure tprogramstack.pushint(x:integer);
begin
try
enlarge;
ivt.items[icount-1]:=pvtInt;
ivi.items[icount-1]:=x;
except;end;
end;
//## pushcur ##
procedure tprogramstack.pushcur(x:currency);
begin
try
enlarge;
ivt.items[icount-1]:=pvtCur;
ivc.items[icount-1]:=x;
except;end;
end;
//## pushstr ##
procedure tprogramstack.pushstr(x:string);
begin
try
enlarge;
ivt.items[icount-1]:=pvtStr;
ivs.items[icount-1]^:=x;
except;end;
end;
//## pullbol ##
procedure tprogramstack.pullbol(var x:boolean);
begin
try
if (icount>=1) then
   begin
   case ivt.items[icount-1] of
   pvtBol:x:=ivb.items[icount-1];
   pvtInt:x:=(ivi.items[icount-1]<>0);
   pvtCur:x:=(ivc.items[icount-1]<>0);
   pvtStr:x:=(ivs.items[icount-1]^<>'') and (ivs.items[icount-1]^<>'0');
   end;//end of case
   shrink;
   end
else x:=false;
except;end;
end;
//## pullint ##
procedure tprogramstack.pullint(var x:integer);
begin
try
if (icount>=1) then
   begin
   case ivt.items[icount-1] of
   pvtBol:x:=integer(ivb.items[icount-1]);
   pvtInt:x:=ivi.items[icount-1];
   pvtCur:x:=round(ivc.items[icount-1]);
   pvtStr:x:=strint(ivs.items[icount-1]^);
   end;//end of case
   shrink;
   end
else x:=0;
except;end;
end;
//## pullcur ##
procedure tprogramstack.pullcur(var x:currency);
begin
try
if (icount>=1) then
   begin
   case ivt.items[icount-1] of
   pvtBol:x:=integer(ivb.items[icount-1]);
   pvtInt:x:=ivi.items[icount-1];
   pvtCur:x:=ivc.items[icount-1];
   pvtStr:x:=strtofloatex(ivs.items[icount-1]^);
   end;//end of case
   shrink;
   end
else x:=0;
except;end;
end;
//## pullstr ##
procedure tprogramstack.pullstr(var x:string);
begin
try
if (icount>=1) then
   begin
   case ivt.items[icount-1] of
   pvtBol:x:=general.bn(ivb.items[icount-1]);
   pvtInt:x:=inttostr(ivi.items[icount-1]);
   pvtCur:x:=floattostrex2(ivc.items[icount-1]);
   pvtStr:x:=ivs.items[icount-1]^;
   end;//end of case
   shrink;
   end
else x:='';
except;end;
end;
//## pulltype ##
function tprogramstack.pulltype:byte;
begin
try;if (icount>=1) then result:=ivt.items[icount-1] else result:=0;except;end;
end;

//## tprogram ##################################################################
//## _nil ##
procedure program_nil(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
begin
//ignore
end;
//## _test ##
procedure program_test(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
begin
try;if (sysstate<ssClosed) and (forma<>nil) then forma.caption:=vars.s[x]+'<<'+floattostrex2(ms64);except;end;
end;
//## _vidadd ##
procedure program_vidadd(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
begin
try;if (sender<>nil) then sender.screentext:=sender.screentext+vars.s[x];except;end;
end;
//## _vidpull ##
procedure program_vidpull(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
begin
try;vars.s[vars.vresult]:=sender.screentext;except;end;
end;
//## _vidpush ##
procedure program_vidpush(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
begin
try
if (sender<>nil) and (programf_screen<>nil) then
   begin
   programf_screen.lock;
   programf_screen.text:=sender.screentext;
   programf_screen.itemindex:=programf_screen.count;
   programf_screen.unlock;
   end;//end of if
except;end;
end;
//## _vidcls ##
procedure program_vidcls(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
begin
try;if (sender<>nil) then sender.screentext:='';except;end;
end;
//## _label ##
procedure program_label(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
begin
try;if (sender.pos=sender.posfinish) then sender.quitstatus:=3;except;end;
end;
//## _msg ##
procedure program_msg(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
begin
try;showbasic(general.udv(vars.s[x],#32));except;end;
end;
//## _msg60 ##
procedure program_msg60(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
begin
try;showinfo60(vars.s[x]);except;end;
end;
//## _msgvar ##
procedure program_msgvar(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
var
   tmp:string;
begin
try
//get
tmp:=vars.s[x];
//set
showbasic(
'tag: '+inttostr(sender.tag)+rcode+
'var-index: '+inttostr(x)+rcode+
'var-type: '+inttostr(vars.t[x])+rcode+
'var-locked: '+bn(vars.l[x])+rcode+
'var-length: '+general.thousands(length(tmp))+rcode+
'var-value: '+rcode+
'>>'+vars.s[x]+'<<');
except;end;
end;
//## _pull ##
procedure program_pull(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
begin
try;vars.copyvar(x,vars.vresult);except;end;
end;
//## _push ##
procedure program_push(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
begin
try;vars.copyvar(vars.vresult,x);except;end;
end;
//## _pull2 ##
procedure program_pull2(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
begin
try;vars.copyvar(x,vars.vresult2);except;end;
end;
//## _push2 ##
procedure program_push2(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
begin
try;vars.copyvar(vars.vresult2,x);except;end;
end;
//## _g ##
procedure program_g(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
var
   a,b:byte;
   r:boolean;
begin
try
//get
a:=vars.vt.items[vars.vresult];
b:=vars.vt.items[x];
r:=false;
//set
if (a=pvtStr) or (b=pvtStr) then r:=(vars.s[vars.vresult]>vars.s[x])
else if (a=pvtCur) or (b=pvtCur) then r:=(vars.c[vars.vresult]>vars.c[x])
else if (a=pvtInt) or (b=pvtInt) then r:=(vars.i[vars.vresult]>vars.i[x])
else if (a=pvtLab) or (b=pvtLab) then r:=(vars.i[vars.vresult]>vars.i[x])
else r:=(vars.b[vars.vresult]>vars.b[x]);
vars.b[vars.vresult]:=r;
except;end;
end;
//## _ge ##
procedure program_ge(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
var
   a,b:byte;
   r:boolean;
begin
try
//get
a:=vars.vt.items[vars.vresult];
b:=vars.vt.items[x];
r:=false;
//set
if (a=pvtStr) or (b=pvtStr) then r:=(vars.s[vars.vresult]>=vars.s[x])
else if (a=pvtCur) or (b=pvtCur) then r:=(vars.c[vars.vresult]>=vars.c[x])
else if (a=pvtInt) or (b=pvtInt) then r:=(vars.i[vars.vresult]>=vars.i[x])
else if (a=pvtLab) or (b=pvtLab) then r:=(vars.i[vars.vresult]>=vars.i[x])
else r:=(vars.b[vars.vresult]>=vars.b[x]);
vars.b[vars.vresult]:=r;
except;end;
end;
//## _e ##
procedure program_e(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
var
   a,b:byte;
   r:boolean;
begin
try
//get
a:=vars.vt.items[vars.vresult];
b:=vars.vt.items[x];
r:=false;
//set
if (a=pvtStr) or (b=pvtStr) then r:=(vars.s[vars.vresult]=vars.s[x])
else if (a=pvtCur) or (b=pvtCur) then r:=(vars.c[vars.vresult]=vars.c[x])
else if (a=pvtInt) or (b=pvtInt) then r:=(vars.i[vars.vresult]=vars.i[x])
else if (a=pvtLab) or (b=pvtLab) then r:=(vars.i[vars.vresult]=vars.i[x])
else r:=(vars.b[vars.vresult]=vars.b[x]);
vars.b[vars.vresult]:=r;
except;end;
end;
//## _ne ##
procedure program_ne(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
var
   a,b:byte;
   r:boolean;
begin
try
//get
a:=vars.vt.items[vars.vresult];
b:=vars.vt.items[x];
r:=false;
//set
if (a=pvtStr) or (b=pvtStr) then r:=(vars.s[vars.vresult]<>vars.s[x])
else if (a=pvtCur) or (b=pvtCur) then r:=(vars.c[vars.vresult]<>vars.c[x])
else if (a=pvtInt) or (b=pvtInt) then r:=(vars.i[vars.vresult]<>vars.i[x])
else if (a=pvtLab) or (b=pvtLab) then r:=(vars.i[vars.vresult]<>vars.i[x])
else r:=(vars.b[vars.vresult]<>vars.b[x]);
vars.b[vars.vresult]:=r;
except;end;
end;
//## _le ##
procedure program_le(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
var
   a,b:byte;
   r:boolean;
begin
try
//get
a:=vars.vt.items[vars.vresult];
b:=vars.vt.items[x];
r:=false;
//set
if (a=pvtStr) or (b=pvtStr) then r:=(vars.s[vars.vresult]<=vars.s[x])
else if (a=pvtCur) or (b=pvtCur) then r:=(vars.c[vars.vresult]<=vars.c[x])
else if (a=pvtInt) or (b=pvtInt) then r:=(vars.i[vars.vresult]<=vars.i[x])
else if (a=pvtLab) or (b=pvtLab) then r:=(vars.i[vars.vresult]<=vars.i[x])
else r:=(vars.b[vars.vresult]<=vars.b[x]);
vars.b[vars.vresult]:=r;
except;end;
end;
//## _l ##
procedure program_l(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
var
   a,b:byte;
   r:boolean;
begin
try
//get
a:=vars.vt.items[vars.vresult];
b:=vars.vt.items[x];
r:=false;
//set
if (a=pvtStr) or (b=pvtStr) then r:=(vars.s[vars.vresult]<vars.s[x])
else if (a=pvtCur) or (b=pvtCur) then r:=(vars.c[vars.vresult]<vars.c[x])
else if (a=pvtInt) or (b=pvtInt) then r:=(vars.i[vars.vresult]<vars.i[x])
else if (a=pvtLab) or (b=pvtLab) then r:=(vars.i[vars.vresult]<vars.i[x])
else r:=(vars.b[vars.vresult]<vars.b[x]);
vars.b[vars.vresult]:=r;
except;end;
end;
//## _p ##
procedure program_p(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
var
   a,b:byte;
begin
try
//get
a:=vars.vt.items[vars.vresult];
b:=vars.vt.items[x];
//set
if (a=pvtStr) or (b=pvtStr) then vars.s[vars.vresult]:=(vars.s[vars.vresult]+vars.s[x])
else if (a=pvtCur) or (b=pvtCur) then vars.c[vars.vresult]:=(vars.c[vars.vresult]+vars.c[x])
else if (a=pvtInt) or (b=pvtInt) then vars.i[vars.vresult]:=(vars.i[vars.vresult]+vars.i[x])
else if (a=pvtLab) or (b=pvtLab) then vars.i[vars.vresult]:=(vars.i[vars.vresult]+vars.i[x])
else vars.b[vars.vresult]:=(vars.b[vars.vresult] or vars.b[x]);
except;end;
end;
//## _m ##
procedure program_m(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
var
   a,b:byte;
   r:boolean;
begin
try
//get
a:=vars.vt.items[vars.vresult];
b:=vars.vt.items[x];
//set
if (a=pvtStr) or (b=pvtStr) then vars.s[vars.vresult]:=''
else if (a=pvtCur) or (b=pvtCur) then vars.c[vars.vresult]:=(vars.c[vars.vresult]-vars.c[x])
else if (a=pvtInt) or (b=pvtInt) then vars.i[vars.vresult]:=(vars.i[vars.vresult]-vars.i[x])
else if (a=pvtLab) or (b=pvtLab) then vars.i[vars.vresult]:=(vars.i[vars.vresult]-vars.i[x])
else
   begin
   r:=vars.b[vars.vresult];
   if vars.b[x] then r:=false;
   vars.b[vars.vresult]:=r;
   end;//end of if
except;end;
end;
//## _t ##
procedure program_t(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
var
   a,b:byte;
begin
try
//get
a:=vars.vt.items[vars.vresult];
b:=vars.vt.items[x];
//set
if (a=pvtStr) or (b=pvtStr) then vars.s[vars.vresult]:=''
else if (a=pvtCur) or (b=pvtCur) then vars.c[vars.vresult]:=(vars.c[vars.vresult]*vars.c[x])
else if (a=pvtInt) or (b=pvtInt) then vars.i[vars.vresult]:=(vars.i[vars.vresult]*vars.i[x])
else if (a=pvtLab) or (b=pvtLab) then vars.i[vars.vresult]:=(vars.i[vars.vresult]*vars.i[x])
else vars.b[vars.vresult]:=(vars.b[vars.vresult] and vars.b[x]);
except;end;
end;
//## _d ##
procedure program_d(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
var
   a,b:byte;
   _c:currency;
   _i:integer;
begin
try
//get
a:=vars.vt.items[vars.vresult];
b:=vars.vt.items[x];
//set
if (a=pvtStr) or (b=pvtStr) then vars.s[vars.vresult]:=''
else if (a=pvtCur) or (b=pvtCur) then
   begin
   _c:=vars.c[x];
   if (_c=0) then vars.c[vars.vresult]:=0//prevent division by zero
   else vars.c[vars.vresult]:=vars.c[vars.vresult]/_c;
   end
else if (a=pvtInt) or (b=pvtInt) then
   begin
   _i:=vars.i[x];
   if (_i=0) then vars.i[vars.vresult]:=0//prevent division by zero
   else vars.i[vars.vresult]:=vars.i[vars.vresult] div _i;
   end
else if (a=pvtLab) or (b=pvtLab) then
   begin
   _i:=vars.i[x];
   if (_i=0) then vars.i[vars.vresult]:=0//prevent division by zero
   else vars.i[vars.vresult]:=vars.i[vars.vresult] div _i;
   end
else vars.b[vars.vresult]:=false;
except;end;
end;
//## _pp ##
procedure program_pp(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
var
   a:byte;
begin
try
//get
a:=vars.vt.items[x];
//set
if (a=pvtStr) then vars.vs.items[x]^:=''
else if (a=pvtCur) then vars.vc.items[x]:=vars.vi.items[x]+1
else if (a=pvtInt) then vars.vi.items[x]:=vars.vi.items[x]+1
else if (a=pvtLab) then vars.vi.items[x]:=vars.vi.items[x]+1
else vars.vb.items[x]:=true;
except;end;
end;
//## _mm ##
procedure program_mm(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
var
   a:byte;
begin
try
//get
a:=vars.vt.items[x];
//set
if (a=pvtStr) then vars.vs.items[x]^:=''
else if (a=pvtCur) then vars.vc.items[x]:=vars.vi.items[x]-1
else if (a=pvtInt) then vars.vi.items[x]:=vars.vi.items[x]-1
else if (a=pvtLab) then vars.vi.items[x]:=vars.vi.items[x]-1
else vars.vb.items[x]:=false;
except;end;
end;
//## _rnd ##
procedure program_rnd(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
begin
try;vars.i[vars.vresult]:=random(vars.i[x]);except;end;
end;
//## _null ##
procedure program_null(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
begin
try;vars.null(x);except;end;
end;
//## _beep ##
procedure program_beep(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
begin
try;general.shortbeep(frcrange(vars.i[x],1,1000));except;end;
end;
//## _sleep ##
procedure program_sleep(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
var
   tmp:currency;
begin
try
tmp:=vars.c[x];
if (tmp>=1) then
   begin
   sender.sleep:=ms64+tmp;
   sender.stepexit:=true;
   end;//end of if
except;end;
end;
//## program_breath ##
procedure program_breath(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
begin
try
application.processmessages;
sender.stepexit:=true;
except;end;
end;
//## _loop ##
procedure program_loop(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
var
   tmp:integer;
begin
try
tmp:=vars.i[x]-1;
if (tmp>=1) then
   begin
   vars.i[x]:=tmp;
   sender.pos:=sender.nl.items[sender.pos];
   end;//end of if
except;end;
end;
//## _ifloop ##
procedure program_ifloop(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
var
   tmp:integer;
begin
try
if vars.b[vars.vresult] then
   begin
   tmp:=vars.i[x]-1;
   if (tmp>=1) then
      begin
      vars.i[x]:=tmp;
      sender.pos:=sender.nl.items[sender.pos];
      end;//end of if
   end;//end of if
except;end;
end;
//## _ifnotloop ##
procedure program_ifnotloop(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
var
   tmp:integer;
begin
try
if not vars.b[vars.vresult] then
   begin
   tmp:=vars.i[x]-1;
   if (tmp>=1) then
      begin
      vars.i[x]:=tmp;
      sender.pos:=sender.nl.items[sender.pos];
      end;//end of if
   end;//end of if
except;end;
end;
//## _goto ##
procedure program_goto(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
begin
try;if (vars.t[x]=pvtLab) then sender.pos:=vars.i[x];except;end;
end;
//## _ifgoto ##
procedure program_ifgoto(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
begin
try;if vars.b[vars.vresult] then program_goto(sender,stack,vars,x);except;end;
end;
//## _ifnotgoto ##
procedure program_ifnotgoto(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
begin
try;if not vars.b[vars.vresult] then program_goto(sender,stack,vars,x);except;end;
end;
//## _go ##
procedure program_go(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
begin
try
if (vars.t[x]=pvtLab) then
   begin
   sender.gopush(sender.pos+1);
   sender.pos:=vars.i[x];
   end;//end of if
except;end;
end;
//## _ifgo ##
procedure program_ifgo(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
begin
try
if (vars.t[x]=pvtLab) and vars.b[vars.vresult] then
   begin
   sender.gopush(sender.pos+1);
   sender.pos:=vars.i[x];
   end;//end of if
except;end;
end;
//## _ifnotgo ##
procedure program_ifnotgo(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
begin
try
if (vars.t[x]=pvtLab) and (not vars.b[vars.vresult]) then
   begin
   sender.gopush(sender.pos+1);
   sender.pos:=vars.i[x];
   end;//end of if
except;end;
end;
//## _ret ##
procedure program_ret(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
begin
try;if sender.gopull(x) then sender.pos:=x;except;end;
end;
//## _ifret ##
procedure program_ifret(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
begin
try;if vars.b[x] and sender.gopull(x) then sender.pos:=x;except;end;
end;
//## _ifnotret ##
procedure program_ifnotret(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
begin
try;if not vars.b[x] and sender.gopull(x) then sender.pos:=x;except;end;
end;
//## program_if ##
procedure program_if(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
begin//Note: inl.items[sender.pos] = address of "endif" which acts as a special destination label
try;if not vars.b[x] then sender.pos:=sender.nl.items[sender.pos];except;end;
end;
//## program_ifnot ##
procedure program_ifnot(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
begin//Note: inl.items[sender.pos] = address of "endif" which acts as a special destination label
try;if vars.b[x] then sender.pos:=sender.nl.items[sender.pos];except;end;
end;
//## program_else ##
procedure program_else(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
begin//Note: Jump straight to "endif"
try;sender.pos:=sender.nl.items[sender.pos];except;end;
end;
//## program_endif ##
procedure program_endif(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
begin
//nil
end;
//## _end ##
procedure program_end(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
begin
try
sender.stepexit:=true;
if (sender.quitstatus<=1) then sender.quitstatus:=2
else sender.runend;
except;end;
end;
//## _quit ##
procedure program_quit(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
begin//0=not in use, 1=waiting to quit, 2=quit allowed, 3=quit started
try;if (sender.quitstatus=1) then sender.quitstatus:=sender.quitstatus+1;except;end;
end;
//## program_stack ##
procedure program_stack(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
begin
try
case vars.vt.items[x] of
pvtBol:stack.pushbol(vars.vb.items[x]);
pvtInt,pvtLab:stack.pushint(vars.vi.items[x]);
pvtCur:stack.pushcur(vars.vc.items[x]);
pvtStr:stack.pushstr(vars.vs.items[x]^);
end;//end of case
except;end;
end;
//## program_unstack ##
procedure program_unstack(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
begin
try
case vars.vt.items[x] of
pvtBol:stack.pullbol(vars.vb.items[x]);
pvtInt,pvtLab:stack.pullint(vars.vi.items[x]);
pvtCur:stack.pullcur(vars.vc.items[x]);
pvtStr:stack.pullstr(vars.vs.items[x]^);
end;//end of case
except;end;
end;
//## program_unstackp ##
procedure program_unstackp(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
var
   a,b:byte;
   _bol:boolean;
   _int:integer;
   _cur:currency;
   _str:string;
begin
try
//get
a:=stack.pulltype;
b:=vars.vt.items[x];
//decide
if (a=pvtStr) or (b=pvtStr) then
   begin
   stack.pullstr(_str);
   vars.s[vars.vresult]:=vars.s[vars.vresult]+_str;
   end
else if (a=pvtCur) or (b=pvtCur) then
   begin
   stack.pullcur(_cur);
   vars.c[vars.vresult]:=vars.c[vars.vresult]+_cur;
   end
else if (a=pvtInt) or (b=pvtInt) then
   begin
   stack.pullint(_int);
   vars.i[vars.vresult]:=vars.i[vars.vresult]+_int;
   end
else
   begin
   stack.pullbol(_bol);
   vars.b[vars.vresult]:=vars.b[vars.vresult] or _bol;
   end;//end of if
except;end;
end;
//## program_stackcount ##
procedure program_stackcount(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
begin
try;vars.i[x]:=stack.count;except;end;
end;
//## program_asbol ##
procedure program_asbol(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
begin
try;if (vars.vt.items[x]<>pvtBol) then vars.b[x]:=vars.b[x];except;end;
end;
//## program_asint ##
procedure program_asint(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
begin
try;if (vars.vt.items[x]<>pvtInt) then vars.i[x]:=vars.i[x];except;end;
end;
//## program_ascur ##
procedure program_ascur(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
begin
try;if (vars.vt.items[x]<>pvtCur) then vars.c[x]:=vars.c[x];except;end;
end;
//## program_asstr ##
procedure program_asstr(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
begin
try;if (vars.vt.items[x]<>pvtStr) then vars.s[x]:=vars.s[x];except;end;
end;
//## program_not ##
procedure program_not(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
begin
try;vars.b[vars.vresult]:=not vars.b[x];except;end;
end;
//## program_and ##
procedure program_and(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
begin
try;vars.b[vars.vresult]:=vars.b[vars.vresult] and vars.b[x];except;end;
end;
//## program_or ##
procedure program_or(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
begin
try;vars.b[vars.vresult]:=vars.b[vars.vresult] or vars.b[x];except;end;
end;
//## program_cmp ##
procedure program_cmp(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
begin
try;vars.b[vars.vresult]:=(0=comparetext(vars.s[vars.vresult],vars.s[x]));except;end;
end;
//## program_ms64 ##
procedure program_ms64(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
begin
try;vars.c[x]:=ms64;except;end;
end;
//## program_pasttime ##
procedure program_pasttime(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
begin
try;vars.b[vars.vresult]:=(ms64>vars.c[x]);except;end;
end;
//## program_uptime ##
procedure program_uptime(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
begin
try;vars.s[x]:=dates.uptimeb(ms64-sender.msstart,false,true,#32);except;end;
end;
//## program_msstart ##
procedure program_msstart(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
begin
try;vars.c[x]:=sender.msstart;except;end;
end;
//## program_mselapsed ##
procedure program_mselapsed(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
begin
try;vars.c[x]:=(ms64-sender.msstart);except;end;
end;
//## program_yes ##
procedure program_yes(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
begin
try;vars.s[vars.vresult]:=misc.yes(vars.b[x]);except;end;
end;
//## program_len ##
procedure program_len(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
begin
try;vars.i[vars.vresult]:=length(vars.s[x]);except;end;
end;
//## program_thousands ##
procedure program_thousands(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
var
   r:string;
begin
try
//defaults
r:='0';
//get
if (vars.vt.items[x]=pvtStr) then r:=general.thousands(length(vars.s[x]))
else if (vars.vt.items[x]=pvtCur) then r:=general.curcomma(vars.c[x])
else r:=general.thousands(vars.i[x]);
//set
vars.s[vars.vresult]:=r;
except;end;
end;
//## program_wecd ##
procedure program_wecd(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
begin
try;vars.s[vars.vresult]:=general.ecdb(vars.i[x],true);except;end;
end;
//## program_timedate ##
procedure program_timedate(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
begin
try;vars.s[vars.vresult]:=dates.shortdatetimeb(now,false,true);except;end;
end;
//## program_indent ##
procedure program_indent(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
var
   a:tdynamicstring;
   v:string;
   p:integer;
begin
try
//defaults
a:=nil;
v:=vars.s[vars.vin[1]];
//process
if (v<>'') then
   begin
   //init
   a:=tdynamicstring.create;
   //get
   a.text:=vars.s[vars.vin[0]];
   for p:=0 to (a.count-1) do a.items[p]^:=v+a.items[p]^;
   //set
   vars.s[vars.vresult]:=a.text;
   end;//end of if
except;end;
try;freeobj(@a);except;end;
end;
//## _dns ##
procedure program_dns(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
begin
try
//lock
sender.waiting:=true;
//move to next command
sender.pos:=sender.pos+1;
//call remote function
if (lm.open(vars.s[x],sender.id,sender._ondns).c=0) then
   begin
   //error
   vars.b[vars.vresult]:=false;
   vars.i[vars.vout[0]]:=0;
   vars.i[vars.vout[1]]:=0;
   sender.waiting:=false;
   end;//end of if
except;end;
end;
//## program_redirectfind ##
procedure program_redirectfind(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
var
   r:boolean;
   u:string;
begin
try
//get
r:=cr.find(vars.s[x],u);
//set
vars.b[vars.vresult]:=r;
if r then
   begin
   vars.s[vars.vout[0]]:=u;
   vars.s[vars.vout[4]]:=u;//second copy for ease of use (lines up with other command values)
   end;//end of if
except;end;
end;
//## program_redirectadd ##
procedure program_redirectadd(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
begin
try;cr.add(vars.s[vars.vin[0]],vars.s[vars.vin[1]]);except;end;
end;
//## _strip ##
procedure program_strip(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
begin
try;vars.s[vars.vresult]:=_strip(vars.i[x]);except;end;
end;
//## _intip ##
procedure program_intip(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
begin
try;vars.i[vars.vresult]:=_intip(vars.s[x]);except;end;
end;
//## program_urlrobot ##
procedure program_urlrobot(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
var
   ui:tparseurl;
begin
try
general.pu('http://'+vars.s[x],'',ui,[pusExcludeMark]);
vars.s[vars.vresult]:=ui.ca+'/robots.txt';
except;end;
end;
//## program_pullcontent ##
procedure program_pullcontent(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
var
   ui:tparseurl;
   ua,u:string;
   rl:currency;
   junkid:integer;
begin
try
//lock
sender.waiting:=true;
//move to next command
sender.pos:=sender.pos+1;
//call remote function
general.pu('http://'+vars.s[vars.vin[0]],'',ui,[pusExcludeMark]);
ua:=general.udv(vars.s[vars.vin[1]],mc.ua);//in2
rl:=vars.c[vars.vin[2]];//in3
if (rl<=0) then rl:=programf_recvlimit;
//set
mc.open(ui.cu,
//ui.p+ui.f+ui.d;//"/<path>/<file>?<data>" - for bfilter
'GET '+ui.p+ui.f+ui.d+' HTTP/1.0'+rcode+//start header
'Accept: */*'+rcode+
'Accept-Language: en-us'+rcode+
'User-Agent: '+ua+rcode+
'Host: '+ui.h+rcode+
rcode,                           //finish header
0,rl,programf_ban+[mcbBANREDIRECT],sender._onpullcontent,junkid);
except;end;
end;
//## program_lockrobot ##
procedure program_lockrobot(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
var//0=no data in cache (up to program to use "pushrobot" to fill content (must finish with "unlockrobot")
   //1=must retry, since IP is currently being worked on by another thread
   //2=entry is cached and thus we can read values in out1...out5
   _wec,_dim,_index:integer;
   _value:string;
   _cached:boolean;
   r:byte;
begin
try
//get
r:=mr.lockip(vars.i[x],_wec,_dim,_index,_value,_cached);
//set
vars.i[vars.vresult]:=r;
if (r=2) then
   begin
   vars.s[vars.vout[0]]:=_value;
   vars.i[vars.vout[1]]:=_wec;
   vars.i[vars.vout[2]]:=_dim;
   vars.i[vars.vout[3]]:=_index;
   vars.b[vars.vout[4]]:=_cached;
   end;//end of if
except;end;
end;
//## program_pushrobot ##
procedure program_pushrobot(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
begin
try;mr.pushcontent(vars.i[vars.vin[0]],vars.i[vars.vin[1]],vars.s[vars.vin[2]]);except;end;
end;
//## program_unlockrobot ##
procedure program_unlockrobot(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
begin
try;mr.unlockip(vars.i[x]);except;end;
end;
//EXTERNAL
//## program_exsupport ##
procedure program_exsupport(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
var
   tmp:boolean;
begin
try
tmp:=assigned(programf_external);
vars.b[vars.vresult]:=tmp;
vars.s[vars.vout[0]]:=misc.yes(tmp);//out1
if (not tmp) and (sender<>nil) and (sender.tagerr='') then sender.tagerr:='No External Support';
except;end;
end;
//## program_ex ##
procedure program_ex(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
var
   r:boolean;
   o1,o2,o3,o4,o5:string;
begin
try
//defaults
r:=false;
o1:=vars.s[vars.vin[0]];//in1
o2:=vars.s[vars.vin[1]];//in2
o3:=vars.s[vars.vin[2]];//in3
o4:=vars.s[vars.vin[3]];//in4
o5:=vars.s[vars.vin[4]];//in5
//get
if assigned(programf_external) then r:=programf_external(sender,o1,o2,o3,o4,o5);
//set
vars.b[vars.vresult]:=r;
vars.s[vars.vout[0]]:=o1;
vars.s[vars.vout[1]]:=o2;
vars.s[vars.vout[2]]:=o3;
vars.s[vars.vout[3]]:=o4;
vars.s[vars.vout[4]]:=o5;
except;end;
end;
//CRAWLER
//## program_cwsupport ##
procedure program_cwsupport(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
var
   tmp:boolean;
begin
try
tmp:=assigned(programf_crawler);
vars.b[vars.vresult]:=tmp;
vars.s[vars.vout[0]]:=misc.yes(tmp);//out1
if (not tmp) and (sender<>nil) and (sender.tagerr='') then sender.tagerr:='No Crawler Support';
except;end;
end;
//## program_cwpullurl ##
procedure program_cwpullurl(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
begin
try;if assigned(programf_crawler) then programf_crawler('pullurl',sender,stack,vars,x);except;end;
end;
//## program_cwfinaliseurl ##
procedure program_cwfinaliseurl(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
begin
try;if assigned(programf_crawler) then programf_crawler('finaliseurl',sender,stack,vars,x);except;end;
end;
//## program_cwallowurl ##
procedure program_cwallowurl(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
begin
try;if assigned(programf_crawler) then programf_crawler('allowurl',sender,stack,vars,x);except;end;
end;
//## program_cwallowip ##
procedure program_cwallowip(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
begin
try;if assigned(programf_crawler) then programf_crawler('allowip',sender,stack,vars,x);except;end;
end;
//## program_cwipurlonce ##
procedure program_cwipurlonce(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
begin
try;if assigned(programf_crawler) then programf_crawler('ipurlonce',sender,stack,vars,x);except;end;
end;
//## program_cwrobotsok ##
procedure program_cwrobotsok(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
begin
try;if assigned(programf_crawler) then programf_crawler('robotsok',sender,stack,vars,x);except;end;
end;
//## program_cwpushcrawl ##
procedure program_cwpushcrawl(sender:tprogram;stack:tprogramstack;vars:tprogramvars;x:integer);
begin
try;if assigned(programf_crawler) then programf_crawler('pushcrawl',sender,stack,vars,x);except;end;
end;

//## create ##
constructor tprogram.create;
begin
//self
inherited create;
//setup
programf_create;
//vars
host:=nil;
inc(programcount);
isleep:=ms64;
//controls
ivars:=tprogramvars.create;
istack:=tprogramstack.create;
ic:=tdynamicword.create;
iv:=tdynamicword.create;
inl:=tdynamicword.create;//nearest label position
end;
//## destroy ##
destructor tprogram.destroy;
begin
try
//runend
runend;
//vars
programcount:=frcmin(programcount-1,0);
//clear
clear;
//controls
freeobj(@ivars);
freeobj(@istack);
freeobj(@ic);
freeobj(@iv);
freeobj(@inl);
//self
inherited;
except;end;
end;
//## _ondns ##
procedure tprogram._ondns(sender:tobject;tag:currency;ptr:tnetworkptr);
var
   irealip,iip:integer;
begin
try
//check
if (iid<>tag) then exit;
//get
iip:=lm.ip[ptr];
irealip:=mip.rip(iip);//store REAL actual value of website ip (since iip may well be a mapped version)
//set
vars.b[vars.vresult]:=(irealip<>0) and (iip<>0);
vars.i[vars.vout[0]]:=irealip;//real ip
vars.i[vars.vout[1]]:=iip;//real ip or mapped version
except;end;
try
if (iip=0) then tagerr:='DNS Failed';
iwaiting:=false;
except;end;
end;
//## _onpullcontent ##
procedure tprogram._onpullcontent(_url,_urlfinal,_urlredirect,_outtext:string;_tag,_id,_ip,_code:integer;_header,_content:string;_sendbytes,_recvbytes:currency);
var
   ui:tparseurl;
begin//Note: "ifinalurl" will no contain the best url, either the original "iurl" or a redirected-non-null url "_urlfinal"
try  //Update Code Support: 200, 919 => 200
//clean
if (_urlredirect<>'') then
   begin
   general.pu('http://'+_urlredirect,'',ui,[pusExcludeMark]);
   _urlredirect:=ui.cu;
   end;//end of if
if (_urlfinal<>'') then
   begin
   general.pu('http://'+_urlfinal,'',ui,[pusExcludeMark]);
   _urlfinal:=ui.cu;
   end;//end of if
//code
if (_code=wecDownloadExceedsLimit) then _code:=wecOK;
//get
vars.b[vars.vresult]:=(_urlredirect='') and (_code<900);
vars.s[vars.vout[0]]:=_content;
vars.i[vars.vout[1]]:=_code;
vars.s[vars.vout[2]]:=_urlfinal;
vars.b[vars.vout[3]]:=(_urlredirect<>'');
vars.s[vars.vout[4]]:=_urlredirect;
//result=TRUE if a) not a redirect and b) code is a valid html code (even 404's)
except;end;
try
tagerr:='Code: '+general.ecdb(_code,true);
iwaiting:=false;
except;end;
end;
//## pushend ##
function tprogram.pushend(var a:tprogramioinfo):boolean;
begin
try;result:=pushb(a.xlen,a.x,'');except;end;
end;
//## pushbol ##
function tprogram.pushbol(var a:tprogramioinfo;y:boolean;s:byte):boolean;
var
   v:char;
begin
try
//get
if y then v:=#1 else v:=#0;
//set
result:=pushb(a.xlen,a.x,chr(pvtBol)+chr(s)+v);
except;end;
end;
//## pushint ##
function tprogram.pushint(var a:tprogramioinfo;y:integer;s:byte):boolean;
var
   v:tint4;
begin
try
//get
v.val:=y;
//set
result:=pushb(a.xlen,a.x,chr(pvtInt)+chr(s)+v.chars[0]+v.chars[1]+v.chars[2]+v.chars[3]);
except;end;
end;
//## pushlab ##
function tprogram.pushlab(var a:tprogramioinfo;y:integer;s:byte):boolean;
var
   v:tint4;
begin
try
//get
v.val:=y;
//set
result:=pushb(a.xlen,a.x,chr(pvtLab)+chr(s)+v.chars[0]+v.chars[1]+v.chars[2]+v.chars[3]);
except;end;
end;
//## pushcur ##
function tprogram.pushcur(var a:tprogramioinfo;y:currency;s:byte):boolean;
var
   v:tcur8;
begin
try
//get
v.val:=y;
//set
result:=pushb(a.xlen,a.x,chr(pvtCur)+chr(s)+v.chars[0]+v.chars[1]+v.chars[2]+v.chars[3]+v.chars[4]+v.chars[5]+v.chars[6]+v.chars[7]);
except;end;
end;
//## pushstr ##
function tprogram.pushstr(var a:tprogramioinfo;y:string;s:byte):boolean;
var
   v:tint4;
begin
try
//get
v.val:=length(y);
//set
result:=pushb(a.xlen,a.x,chr(pvtStr)+chr(s)+v.chars[0]+v.chars[1]+v.chars[2]+v.chars[3]+y);
except;end;
end;
//## pullbol ##
function tprogram.pullbol(var a:tprogramioinfo;var y:boolean;var s:byte):boolean;
begin
try
//defaults
result:=false;
//set
if (a.pos>=1) and (a.pos<=(a.xlen-2)) and (byte(a.x[a.pos])=pvtBol) then
   begin
   s:=byte(a.x[a.pos+1]);
   y:=(a.x[a.pos+2]<>#0);
   inc(a.pos,3);
   result:=true;
   end;//end of if
except;end;
end;
//## pullint ##
function tprogram.pullint(var a:tprogramioinfo;var y:integer;var s:byte):boolean;
var
   v:tint4;
begin
try
//defaults
result:=false;
//set
if (a.pos>=1) and (a.pos<=(a.xlen-5)) and ((byte(a.x[a.pos])=pvtInt) or (byte(a.x[a.pos])=pvtLab)) then
   begin
   s:=byte(a.x[a.pos+1]);
   v.chars[0]:=a.x[a.pos+2];
   v.chars[1]:=a.x[a.pos+3];
   v.chars[2]:=a.x[a.pos+4];
   v.chars[3]:=a.x[a.pos+5];
   y:=v.val;
   inc(a.pos,6);
   result:=true;
   end;//end of if
except;end;
end;
//## pullcur ##
function tprogram.pullcur(var a:tprogramioinfo;var y:currency;var s:byte):boolean;
var
   v:tcur8;
begin
try
//defaults
result:=false;
//set
if (a.pos>=1) and (a.pos<=(a.xlen-9)) and (byte(a.x[a.pos])=pvtCur) then
   begin
   s:=byte(a.x[a.pos+1]);
   v.chars[0]:=a.x[a.pos+2];
   v.chars[1]:=a.x[a.pos+3];
   v.chars[2]:=a.x[a.pos+4];
   v.chars[3]:=a.x[a.pos+5];
   v.chars[4]:=a.x[a.pos+6];
   v.chars[5]:=a.x[a.pos+7];
   v.chars[6]:=a.x[a.pos+8];
   v.chars[7]:=a.x[a.pos+9];
   y:=v.val;
   inc(a.pos,10);
   result:=true;
   end;//end of if
except;end;
end;
//## pullstr ##
function tprogram.pullstr(var a:tprogramioinfo;var y:string;var s:byte):boolean;
var
   v:tint4;
begin
try
//defaults
result:=false;
//set
if (a.pos>=1) and (a.pos<=(a.xlen-5)) and (byte(a.x[a.pos])=pvtStr) then
   begin
   //length
   s:=byte(a.x[a.pos+1]);
   v.chars[0]:=a.x[a.pos+2];
   v.chars[1]:=a.x[a.pos+3];
   v.chars[2]:=a.x[a.pos+4];
   v.chars[3]:=a.x[a.pos+5];
   inc(a.pos,6);
   //get
   if (v.val<=0) then
      begin
      y:='';
      result:=true;
      end
   else if ((a.pos+v.val-1)<=a.xlen) then
      begin
      y:=copy(a.x,a.pos,v.val);
      inc(a.pos,v.val);
      result:=true;
      end;//end of if
   end;//end of if
except;end;
end;
//## canwrite ##
function tprogram.canwrite:boolean;
begin
try;result:=(icount>=1) and canread;except;end;
end;
//## writebin ##
function tprogram.writebin(var x,e:string):boolean;
label
   skipend;
var
   a:tprogramioinfo;
   v1,v2,v3:twrd2;
   maxp,p:integer;
   s:byte;
begin
try
//defaults
result:=false;
x:='';
e:=gecBusy;
//check
if not canwrite then
   begin
   if (icount<=0) then e:=gecEmpty;
   exit;
   end;//end of if
//init
e:=gecOutOfMemory;
a.x:='BE1000';
a.xlen:=length(a.x);
a.pos:=1;
//process
//HEADER
if not pushint(a,programf_count,0) then goto skipend;//func.count
if not pushint(a,ivars.count,0) then goto skipend;//var.count
if not pushint(a,icount,0) then goto skipend;//code.code
if not pushint(a,iposstart,0) then goto skipend;//pos.start
if not pushint(a,iposfinish,0) then goto skipend;//pos.finish
if not pushint(a,ivars.constcount,0) then goto skipend;//const.count
//VARS
maxp:=ivars.count-1;
for p:=0 to maxp do
begin
//init
s:=0;
if ivars.vl.items[p] then inc(s);
if ivars.va.items[p] then inc(s,2);
//decide
case ivars.vt.items[p] of
pvtBol:if not pushbol(a,ivars.vb.items[p],s) then goto skipend;
pvtInt:if not pushint(a,ivars.vi.items[p],s) then goto skipend;
pvtLab:if not pushlab(a,ivars.vi.items[p],s) then goto skipend;
pvtCur:if not pushcur(a,ivars.vc.items[p],s) then goto skipend;
pvtStr:if not pushstr(a,ivars.vs.items[p]^,s) then goto skipend;
else goto skipend;
end;//end of case
end;//end of loop
//CODE
maxp:=icount-1;
for p:=0 to maxp do
begin
//get
v1.val:=ic.items[p];
v2.val:=iv.items[p];
v3.val:=inl.items[p];
//set
pushb(a.xlen,a.x,
v1.chars[0]+v1.chars[1]+//command
v2.chars[0]+v2.chars[1]+//var.index
v3.chars[0]+v3.chars[1]//nearest.label [for loop]
);
end;//end of loop
//finalise
if not pushend(a) then goto skipend;
//successful
x:=a.x;
result:=true;
skipend:
except;end;
end;
//## canread ##
function tprogram.canread:boolean;
begin
try;result:=(not ilocked) and (not iloading) and (not irunning);except;end;
end;
//## readbin ##
function tprogram.readbin(x:string;var e:string):boolean;
label
   skipend;
var
   a:tprogramioinfo;
   v1,v2,v3:twrd2;
   _constcount,_posfinish,_posstart,_funccount,_varcount,_codecount,p:integer;
   t,s:byte;
   tmpstr:string;
begin
try
//defaults
result:=false;
e:=gecBusy;
//check
if not canread then exit else iloading:=true;
//init
e:=gecDataCorrupt;
clear;
a.x:=x;
a.xlen:=length(x);
a.pos:=7;//start past BExxxx header
if (a.xlen=0) then
   begin
   iloading:=false;
   exit;
   end;//end of if
//process
//HEADER
if (comparetext(copy(a.x,1,6),'BE1000')<>0) then
   begin
   e:=gecUnsupportedFormat;
   goto skipend;
   end;//end of if
if (not pullint(a,_funccount,s)) or (_funccount>programf_count) then goto skipend;//var.count
if (not pullint(a,_varcount,s)) or (_varcount<0) then goto skipend;//var.count
if (not pullint(a,_codecount,s)) or (_codecount<=0) then goto skipend;//code.code
if (not pullint(a,_posstart,s)) or (_posstart<0) or (_posstart>=_codecount) then goto skipend;//pos.start
if (not pullint(a,_posfinish,s)) or (_posfinish<0) or (_posfinish>=_codecount) then goto skipend;//pos.start
if (not pullint(a,_constcount,s)) or (_constcount<0) then goto skipend;//const.count
//VARS
//init
ivars.count:=_varcount;
ivars.constcount:=_constcount;
with ivars do
begin
va.setparams(_varcount,_varcount,0);
vb.setparams(_varcount,_varcount,0);
vi.setparams(_varcount,_varcount,0);
vc.setparams(_varcount,_varcount,0);
vs.setparams(_varcount,_varcount,0);
vdef.setparams(_varcount,_varcount,0);
vl.setparams(_varcount,_varcount,0);
vt.setparams(_varcount,_varcount,0);
end;//end of with
//get
for p:=0 to (_varcount-1) do
begin
if (a.pos>a.xlen) then goto skipend
else
   begin
   //get
   s:=0;
   t:=byte(a.x[a.pos]);
   //decide
   case t of
   pvtBol:if not pullbol(a,ivars.vb.items[p],s) then goto skipend;
   pvtInt,pvtLab:if not pullint(a,ivars.vi.items[p],s) then goto skipend;
   pvtCur:if not pullcur(a,ivars.vc.items[p],s) then goto skipend;
   pvtStr:if not pullstr(a,ivars.vs.items[p]^,s) then goto skipend;
   else goto skipend;
   end;//end of case
   //extra
   ivars.vl.items[p]:=(s=1) or (s=3);//locked
   ivars.va.items[p]:=(s=2) or (s=3);//any
   ivars.vt.items[p]:=t;
   //def
   ivars.vdef.items[p]^:=ivars.s[p];
   end;//end of if
end;//end of loop
//CODE
//init
ic.setparams(_codecount,_codecount,0);
iv.setparams(_codecount,_codecount,0);
inl.setparams(_codecount,_codecount,0);
//check
if ((a.pos-1+(_codecount*6))>a.xlen) then goto skipend;
//process
for p:=0 to (_codecount-1) do
begin
//get
v1.chars[0]:=a.x[a.pos+0];
v1.chars[1]:=a.x[a.pos+1];
v2.chars[0]:=a.x[a.pos+2];
v2.chars[1]:=a.x[a.pos+3];
v3.chars[0]:=a.x[a.pos+4];
v3.chars[1]:=a.x[a.pos+5];
//set
ic.items[p]:=v1.val;
iv.items[p]:=v2.val;
inl.items[p]:=v3.val;
//inc
inc(a.pos,6);
end;//end of loop
//finalise
icount:=_codecount;
iposstart:=_posstart;
iposfinish:=_posfinish;
//successful
result:=true;
skipend:
except;end;
try
//reduce
if not result then clear;
ivars.reduce;
//finalise
iloading:=false;
except;end;
end;
//## readtext ##
function tprogram.readtext(x:string;var e:string):boolean;
var
   tmp:integer;
begin
try;result:=readtextex(x,tmp,e);except;end;
end;
//## readtextex ##
function tprogram.readtextex(x:string;var lineerr:integer;var e:string):boolean;
label
   skipend;
var
   a:tdynamicstring;
begin
try
//defaults
result:=false;
a:=nil;
lineerr:=0;
e:='Busy';
//check
if not canread then exit else iloading:=true;
//process
//.clear
clear;
//.data
a:=tdynamicstring.create;
a.text:=x;
//.check
if (a.count=0) then
   begin
   e:='No Content';
   goto skipend;
   end;//end of if
//.get
if not _readtext(a,lineerr,e) then goto skipend;
//successful
result:=true;
skipend:
except;end;
try
//enhance error message
if (not result) and (lineerr>=1) and (lineerr<=a.count) then e:=e+rcode+'[ '+a.items[lineerr-1]^+' ]'+rcode;
//clear temp data
freeobj(@a);
ivars.reduce;
//error
if not result then clear;
//finalise
iloading:=false;
except;end;
end;
//## clear ##
procedure tprogram.clear;
begin
try
//clear
iwaiting:=false;
irunning:=false;
iposstart:=-1;
iposfinish:=-1;
ipos:=0;
icount:=0;
ivars.clear;
istack.clear;
ic.setparams(0,0,0);
iv.setparams(0,0,0);
inl.setparams(0,0,0);
except;end;
end;
//## canrun ##
function tprogram.canrun:boolean;
begin
try;result:=(not ilocked) and (not iloading) and (not irunning) and (iposstart<>-1) and (iposfinish<>-1);except;end;
end;
//## run ##
function tprogram.run(_onrunend:tnotifyevent):boolean;
begin
try
//defaults
result:=false;
//check
if not canrun then exit else ilocked:=true;
//init
fonrunend:=_onrunend;
ipos:=iposstart;
quitstatus:=0;//not in use
//id
iid:=ivars.newid;
//system vars
ivars.vi.items[ivars.vid]:=iid;
istack.clear;
screentext:='';
msstart:=ms64;
//start
inc(programactive);
irunning:=true;
ilocked:=false;
//successful
result:=true;
except;end;
end;
//## quit ##
procedure tprogram.quit;
begin//0=not in use, 1=waiting to quit, 2=quit allowed, 3=quit started
try;if irunning and (quitstatus=0) then inc(quitstatus);except;end;
end;
//## runend ##
procedure tprogram.runend;
begin
try
//check
if not irunning then exit;
if ilocked then exit else ilocked:=true;
//event
if assigned(fonrunend) then fonrunend(self);
if assigned(finternalonrunend) then finternalonrunend(self);
except;end;
try
//flush
iid:=0;//no handle, set on "run"
igo:='';
screentext:='';
fonrunend:=nil;
ivars.flush;
istack.clear;
ipos:=iposstart;
iwaiting:=false;
quitstatus:=0;
programactive:=frcmin(programactive-1,0);
irunning:=false;
ilocked:=false;
except;end;
end;
//## canstep ##
function tprogram.canstep:boolean;
begin
try;result:=(not istepbusy) and (not ilocked) and irunning and (not iwaiting);except;end;
end;
//## step ##
function tprogram.step:integer;
begin
try;result:=stepex(1);except;end;
end;
//## stepex ##
function tprogram.stepex(numberofcommands:integer):integer;
var
   oldpos,p:integer;
   ok:boolean;
   t:currency;
begin
try
//defaults
result:=0;
//check
if not canstep then exit;
//runend
if (ipos<0) or (ipos>=icount) then
   begin
   runend;
   exit;
   end;//end of if
//.sleep
t:=ms64;
if (quitstatus>=1) and (isleep>(t+1000)) then isleep:=t+1000;//short sleep to max of 1,000ms
if (isleep>t) then exit;//normal
//.other
if istepbusy then exit else istepbusy:=true;
if (quitstatus=2) then//0=not in use, 1=waiting to quit, 2=quit allowed, 3=quit started
   begin
   ipos:=posfinish;
   inc(quitstatus);
   end;//end of if
//init
if (numberofcommands<1) then numberofcommands:=1;
//process
p:=0;
repeat
//.execute current command - high speed stepper
oldpos:=ipos;
tprogramfunction(programf_ptr[ic.items[ipos]])(self,istack,ivars,iv.items[ipos]);
inc(result);
ok:=(not ilocked) and irunning and (not iwaiting);
//.inc
if ok then
   begin
   if (oldpos=ipos) then inc(ipos);
   if (ipos<0) or (ipos>=icount) then
      begin
      runend;
      break;
      end;//end of if
   end
else break;
//inc
inc(p);
until (p>=numberofcommands) or (not ok) or istepexit;
except;end;
try
istepexit:=false;
istepbusy:=false;
general.croll(programinstructioncount,result);
except;end;
end;
//## gopush ##
procedure tprogram.gopush(p:integer);
begin
try;igo:=igo+from32bit(p);except;end;
end;
//## gopull ##
function tprogram.gopull(var p:integer):boolean;
var
   xlen:integer;
begin
try
//defaults
result:=false;
//get
xlen:=length(igo);
//set
if (xlen>=4) then
   begin
   //get
   p:=frcrange(to32bit(copy(igo,xlen-3,4)),0,icount-1);
   //trim
   delete(igo,xlen-3,4);
   //successful
   result:=true;
   end;//end of if
except;end;
end;
//## getvn ##
function tprogram.getvn(var x,n:string;var pos:integer):boolean;
var
   o,s,p,xlen:integer;
   eol:boolean;
begin
try
//defaults
result:=false;
n:='';
xlen:=length(x);
s:=pos;//assumed clear of previous sep "command[sep]|var1" where pos=|
//check
if (pos<1) or (pos>xlen) then exit;
//scan
repeat
//.decide
eol:=(pos>=xlen);
//.get
if (x[pos]=pvcSep) or eol then
   begin
   //get
   if eol and (x[pos]<>pvcSep) then o:=1 else o:=0;
   n:=lowercase(copy(x,s,pos-s+o));
   result:=(n<>'');
   //inc
   inc(pos);
   break;
   end;//end of if
//inc
inc(pos);
until (pos>xlen);
except;end;
end;
//## getvv ##
function tprogram.getvv(var x,v:string;var pos:integer;var isvalue:boolean):boolean;
label
   skipend,redo;
var
   o,tmplen,s,p,xlen:integer;
   z,tmp:string;
   isnumber,eol,incode,instr:boolean;
begin
try
//defaults
result:=true;
v:='';
xlen:=length(x);
s:=pos;//assumed clear of previous sep "command[sep]|var1" where pos=|
tmp:=x;
tmplen:=0;
instr:=false;
incode:=false;
isvalue:=true;
isnumber:=true;
//check
if (pos<1) or (pos>xlen) then exit;
//scan
result:=false;
isvalue:=false;
repeat
//.decide
eol:=(pos>=xlen);
//.code
redo:
if (not instr) then
   begin
   case incode of
   true:if (eol or (x[pos]='/') or (x[pos]=pvcSep) or (x[pos]='"')) then
      begin
      if eol and ((x[pos]<>'/') and (x[pos]<>pvcSep)) then o:=1 else o:=0;
      //.decide - note: value is always equal to or smaller than name (/name=5)
      z:=copy(x,s,pos-s+o);
      if (z='n') then//new line
         begin
         inc(tmplen);
         tmp[tmplen]:=#13;
         inc(tmplen);
         tmp[tmplen]:=#10;
         end
      else if (z='tab') then//tab
         begin
         inc(tmplen);
         tmp[tmplen]:=#9;
         end
      else if misc.isint(z) then
         begin//ascii value
         inc(tmplen);
         tmp[tmplen]:=char(frcrange(strint(z),0,255));
         end
      else goto skipend;//undefined code
      //.dec
      if not eol then
         begin
         incode:=false;
         goto redo;
         end;//end of if
      end;//end of if
   false:if (x[pos]='/') then
      begin
      isnumber:=false;
      isvalue:=true;//*
      incode:=true;
      s:=pos+1;
      end;//end of if
   end;//end of case
   end;//end of if
//.stop on "sep"
if (not instr) and (x[pos]=pvcSep) then break;
//.str
if (not incode) then
   begin
   if (x[pos]='"') then
      begin
      isnumber:=false;
      isvalue:=true;//*
      instr:=not instr;
      end
   else if instr or (x[pos]<>pvcSep) then
      begin
      inc(tmplen);
      tmp[tmplen]:=x[pos];
      end;//end of if
   end;//end of if
//inc
inc(pos);
until (pos>xlen);
//return result
v:=copy(tmp,1,tmplen);
result:=(not instr);
//is a pure number - thus indicate as a value
if isnumber and (not isvalue) and misc.isnumber(v) and (misc.iscur(v) or misc.isint(v)) then isvalue:=true;
skipend:
except;end;
end;
//## defc ##
function tprogram.defc(a:tdynamicstring;p:integer;var c,n,ecomment:string):boolean;
label
   skipend;
const
   _bol='bol'+pvcSep;
   _int='int'+pvcSep;
   _cur='cur'+pvcSep;
   _str='str'+pvcSep;
   _any='any'+pvcSep;
   _def='def'+pvcSep;
var
   i,pos:integer;
   t:byte;
   isvalue:boolean;
   pi:tprograminfo;
   v:string;
begin
try
//defaults
result:=false;
c:='';
n:='';
v:='';
//check
if (a=nil) then exit;
//command
c:=lowercase(copy(a.items[p]^,1,4));
if (c='') then
   begin
   c:='//';
   result:=true;
   end
else if (c=_bol) or (c=_int) or (c=_cur) or (c=_str) or (c=_any) then
   begin
   pos:=5;//<name=3><sep=1><now within var name>
   //get - var-name and option var-value
   if getvn(a.items[p]^,n,pos) then
      begin
      //value
      if getvv(a.items[p]^,v,pos,isvalue) then
         begin
         if not isvalue then
            begin
            if ivars.findex(v,i) then v:=ivars.s[i]
            else
               begin
               ecomment:='invalid variable name';
               goto skipend;
               end;//end of if
            end
         end
      else
         begin
         ecomment:='variable already defined';
         goto skipend;//error in value specification
         end;//end of if
      //init
      pi:=[];
      t:=pvtBol;
      //fill
      if (c=_bol) then t:=pvtBol
      else if (c=_int) then t:=pvtInt
      else if (c=_cur) then t:=pvtCur
      else if (c=_str) then t:=pvtStr
      else if (c=_any) then
         begin
         t:=pvtStr;
         pi:=pi+[piAny];
         end;//end of if
      //set
      result:=ivars.defineex(n,v,t,pi,i);
      if not result then ecomment:='variable already defined';
      end
   else ecomment:='invalid variable name';
   end
else if (c=_def) or (c='def') then
   begin
   c:='def';
   result:=true;
   end
else if (copy(c,1,2)='//') then
   begin
   c:='//';
   result:=true;
   end
else ecomment:='invalid definition command';
skipend:
except;end;
end;
//## _removeindent ##
procedure tprogram._removeindent(var x:string);
var
   xlen,p:integer;
   v:byte;
begin
try
//defaults
pos:=1;
xlen:=length(x);
//check
if (xlen=0) then exit;
//scan
for p:=1 to xlen do
begin
v:=byte(x[p]);
if (v<>32) and (v<>9) and (v<>160) then
   begin
   if (p>=2) then delete(x,1,p-1);
   break;
   end;//end of if
end;//end of loop
except;end;
end;
//## _readtext ##
function tprogram._readtext(x:tdynamicstring;var lineerr:integer;var e:string):boolean;
label
   redo,skipend;
var
   ifref:tdynamicinteger;
   funcif,funcifnot,funcendif:integer;
   pstart,ifpos,ifcount,lastlabel,a,b,ep,pos,tmp,line,minp,p:integer;
   z,ecomment,c,n:string;
   isvalue,once:boolean;
begin
try
//defaults
result:=false;
ifref:=nil;
e:='';
ecomment:='';
minp:=0;
ep:=-1;
lastlabel:=0;
lineerr:=0;
ifpos:=0;
ifcount:=0;
funcif:=-1;
funcifnot:=-1;
funcendif:=-1;
//check
if (x=nil) then
   begin
   e:=gecUnexpectedError;
   exit;
   end;//end of if
//init
ifref:=tdynamicinteger.create;
//DEFINE
for p:=minp to (x.count-1) do
begin
//filter
_removeindent(x.items[p]^);
//get
if defc(x,p,c,n,ecomment) then
   begin
   //.end of section
   if (c='def') then
      begin
      minp:=p+1;
      break;
      end;//end of if
   end
else
   begin
   ep:=p;
   goto skipend;
   end;//end of if
end;//end of loop
//LABELS
once:=false;
redo:
line:=0;
for p:=minp to (x.count-1) do
begin
//filter
_removeindent(x.items[p]^);
//get
if (copy(x.items[p]^,1,2)='//') or (not general.textgood(x.items[p]^)) then
   begin
   //ignore
   end
else
   begin
   //.commmand
   pos:=1;
   if not getvn(x.items[p]^,c,pos) then
      begin
      ecomment:='invalid function name';
      ep:=p;
      goto skipend;
      end;//end of if
   //.name - assumes "result" when no var specified
   if not getvv(x.items[p]^,n,pos,isvalue) then
      begin
      ecomment:='invalid value';
      ep:=p;
      goto skipend;
      end;//end of if
   //.read
   case once of
   //LABELS
   false:begin
      if (c='label') then
         begin
         if (not isvalue) and ivars.defineex(n,inttostr(line),pvtLab,[piLocked],tmp) then
            begin
            if (n='start') then iposstart:=line
            else if (n='finish') then iposfinish:=line;
            lastlabel:=line;
            end
         else
            begin
            ecomment:='label redefined';
            ep:=p;
            goto skipend;
            end;//end of if
         end;//end of if
      inl.value[line]:=lastlabel;
      end;//end of begin
   //COMMANDS
   true:begin
      //FUNCTION
      if not programf_find(c,a) then
         begin
         ecomment:='function not found';
         ep:=p;
         goto skipend;
         end;//end of if
      //VARIABLE
      //.no param. allowed for function
      if programf_banvar[a] then
         begin
         if (n<>'') then
            begin
            ecomment:='no parameter allowed';
            ep:=p;
            goto skipend;
            end
         else n:='nil';
         end
      //.dynamically create const vars
      else if (n='') then n:='result'//no parameter supplied (same as if "nil" var was type in)
      else if isvalue and (not ivars.defineconst(n,n,ivars.besttype(n),tmp)) then
         begin
         ecomment:='const creation failure';
         ep:=p;
         goto skipend;
         end;//end of if
      //.find var
      if (not ivars.findex(n,b)) then
         begin
         ecomment:='undefined '+general.aorbstr('variable','label',programf_onlylabel[a]);
         ep:=p;
         goto skipend;
         end;//end of if
      //.range of function and var pointers
      if (a>maxword) or (b>maxword) then
         begin
         e:='internal overflow';
         goto skipend;
         end;//end of if
      //range - ensure function and supplied var match (dynamic or const var needed for function)
      if programf_banconst[a] and (piConst in ivars.info[b]) then
         begin
         ecomment:='const value not allowed';
         ep:=p;
         goto skipend;
         end;//end of if
      //.goto <label only> "ivt.items[b]=pvtLabel"
      if programf_onlylabel[a] and (ivars.vt.items[b]<>pvtLab) then
         begin
         ecomment:='label reference required';
         ep:=p;
         goto skipend;
         end;//end of if
      //.if statements
      if (a=programf_ifptr) or (a=programf_ifnotptr) then
         begin
         ifpos:=p;
         ifref.value[ifcount]:=icount;
         inc(ifcount);
         end
      else if (a=programf_elseptr) then
         begin
         //check
         ifpos:=p;
         if (ifcount=0) then
            begin
            ecomment:='else without if';
            ep:=p;
            goto skipend
            end
         else if (inl.items[ifref.value[ifcount-1]]<0) then
            begin
            ecomment:='duplicate else';
            ep:=p;
            goto skipend;
            end;
         //get
         inl.items[ifref.value[ifcount-1]]:=icount+1;//point "if" just past "else"
         //set
         ifref.value[ifcount-1]:=-icount;//else uses negative value
         end
      else if (a=programf_endifptr) then
         begin
         //dec
         dec(ifcount);
         if (ifcount<0) then
            begin
            ecomment:='endif without if';
            ep:=p;
            goto skipend;
            end;//end of if
         //set
         tmp:=ifref.value[ifcount];
         if (tmp<0) then tmp:=-tmp;
         inl.items[tmp]:=icount;//point "if" or "else" to "endif"
         end;//end of if
      //set
      ic.value[icount]:=a;
      iv.value[icount]:=b;
      inc(icount);
      end;//end of begin
   end;//end of case
   //.inc
   inc(line);
   end;//end of if
end;//end of loop
//check
if (not once) then
   begin
   //set
   if (line=0) then
      begin
      e:='empty program';
      goto skipend;
      end
   else if (iposstart=-1) then
      begin
      e:='start label missing';
      goto skipend;
      end
   else if (iposfinish=-1) then
      begin
      e:='finish label missing';
      goto skipend;
      end
   else if (ifcount>0) then
      begin
      if (ifref.value[ifcount-1]<0) then ecomment:='if...else without endif'
      else ecomment:='if without endif';
      ep:=ifpos;
      goto skipend;
      end
   else
      begin
      once:=true;
      goto redo;
      end;//end of if
   end;//end of if
//successful
result:=true;
skipend:
except;end;
try;freeobj(@ifref);except;end;
try
if (not result) and (e='') then
   begin
   lineerr:=ep+1;
   e:='Error at line '+inttostr(lineerr)+general.insstr(': '+ecomment,ecomment<>'');
   end;//end of if
except;end;
end;

//## tprograms #################################################################
//## create ##
constructor tprograms.create;
var
   p:integer;
begin
//self
inherited create;
//vars
islowtime:=ms64;
itimer:=mtNiltimer;
for p:=0 to high(iitems) do iitems[p]:=nil;
//controls
mt.slowon(islowref);
itimer:=mt.new(_ontimer,200,true);
end;
//## destroy ##
destructor tprograms.destroy;
var
   p:integer;
begin
try
//timer
mt.del(itimer);
//clear
count:=0;
//self
inherited;
except;end;
end;
//## quitall ##
procedure tprograms.quitall;
var
   p:integer;
begin
try;for p:=0 to (icount-1) do if (iitems[p]<>nil) and iitems[p].running then iitems[p].quit;except;end;
end;
//## _ontimer ##
procedure tprograms._ontimer(sender:tobject);
const
   fastlimit=500;
   slowlimit=100;
var
   p,c:integer;
   ok:boolean;
begin
try
//check
if (sysstate>=ssClosed) then exit;
if (icount=0) then exit;
//SLOW
if ((ms64-islowtime)>=190) then
   begin
   //clear
   ifastcount:=0;
   //scan
   for p:=0 to (icount-1) do
   if (iitems[p]=nil) then break
   else
      begin
      c:=iitems[p].stepex(slowlimit);
      if (c>=1) then
         begin
         ifast[ifastcount]:=p;
         inc(ifastcount);
         ok:=true;
         end;//end of if
      end;//end of if
   //reset
   islowtime:=ms64;
   end
//FAST
else
   begin
   for p:=0 to (ifastcount-1) do
   if (iitems[ifast[p]]=nil) then break
   else ok:=(iitems[ifast[p]].stepex(fastlimit)>=1);
   end;//end of begin
//INTERVAL
//set
if ok then mt.slowoff(islowref);
mt.interval[itimer]:=mt.slowauto(islowref,50);//20x per second
except;end;
end;
//## _internalonrunend ##
procedure tprograms._internalonrunend(sender:tobject);
begin
try;if (sender<>nil) then iactive:=frcmin(iactive-1,0);except;end;
end;
//## setcount ##
procedure tprograms.setcount(x:integer);
var
   p,o:integer;
begin
try
//range
o:=icount;
x:=frcrange(x,0,high(iitems)+1);
//set
if (x<icount) then
   begin
   icount:=x;
   for p:=(o-1) downto x do freeobj(@iitems[p]);
   end
else if (x>icount) then
   begin
   for p:=o to (x-1) do
   begin
   iitems[p]:=tprogram.create;
   iitems[p].tag:=p;
   iitems[p].internalonrunend:=_internalonrunend;
   end;//end of loop
   icount:=x;
   end;//end of if
except;end;
end;
//## valid ##
function tprograms.valid(x:integer):boolean;
begin
try;result:=(x>=0) and (x<icount) and (iitems[x]<>nil);except;end;
end;
//## getprogram ##
function tprograms.getprogram(x:integer):tprogram;
begin
try;if valid(x) then result:=iitems[x] else result:=nil;except;end;
end;
//## read ##
function tprograms.read(x:string;var lineerr:integer;var e:string):boolean;
var
   a:tprogram;
   tmp:string;
begin
try
//defaults
result:=false;
e:=gecEmpty;
lineerr:=0;
a:=nil;
//check
if (x='') then exit;
//init
a:=tprogram.create;
//get
if (0=comparetext(copy(x,1,6),'BE1000')) then
   begin
   result:=a.readbin(x,e);
   if result then idatabin:=x;
   end
else
   begin
   result:=a.readtextex(x,lineerr,e) and a.writebin(tmp,e);
   if result then idatabin:=tmp;
   end;//end of if
except;end;
try;freeobj(@a);except;end;
end;
//## dataok ##
function tprograms.dataok:boolean;
begin
try;result:=(idatabin<>'');except;end;
end;
//## canrun ##
function tprograms.canrun:boolean;
begin
try;result:=(iactive<icount) and (icount>=1) and (idatabin<>'');except;end;
end;
//## run ##
function tprograms.run(_onexternal:tprogramexternalevent;_onrun,_onrunend:tnotifyevent):boolean;
begin
try;result:=runex(nil,_onexternal,_onrun,_onrunend);except;end;
end;
//## runex ##
function tprograms.runex(_host:tobject;_onexternal:tprogramexternalevent;_onrun,_onrunend:tnotifyevent):boolean;
var
   p:integer;
   e:string;
begin
try
//defaults
result:=false;
//check
if not canrun then exit;
if (ipos<0) then ipos:=0;
//scan
for p:=0 to (icount-1) do
begin
//.range
if (ipos>=icount) then ipos:=0;
//.get
if (iitems[ipos]<>nil) and iitems[ipos].canrun then
   begin
   if iitems[ipos].readbin(idatabin,e) then
      begin
      //init
      iitems[ipos].host:=_host;
      //event
      if assigned(_onrun) then _onrun(iitems[ipos]);
      //run
      result:=iitems[ipos].run(_onrunend);
      end;//end of if
   if result then inc(iactive);
   inc(ipos);
   break;
   end;//end of if
//.inc
inc(ipos);
end;//end of loop
except;end;
end;

//## taudiobasic ###############################################################
//## create ##
constructor taudiobasic.create;
var
   p:integer;
begin
//self
inherited;
//vars
for p:=0 to high(ipH) do fillchar(ipH[p],sizeof(ipH[p]),0);
iptime:=ms64;
//defaults
format:='44100 16 2';
itimer:=mt.new(_ontimer,200,true);
end;
//## destroy ##
destructor taudiobasic.destroy;
var
   p:integer;
   tmp:hwnd;
begin
try
//timer
mt.del(itimer);
//close
ilocked:=true;
paoc;
raoc;
//handle
try
if (ihandle<>0) then
   begin
   tmp:=ihandle;
   ihandle:=0;
   deallocatehwnd(tmp);
   end;//end of if
except;end;
//self
inherited;
except;end;
end;
//## setformat ##
procedure taudiobasic.setformat(x:string);
var
   v,a,b,c,p:integer;
   z:string;
begin//Input: "8/11/12/16/22/24/32/44/48" "8/16" "1/2", e.g. "44 16 2" for CD quality
try
//defaults
p:=1;
a:=8000;
b:=8;
c:=1;
//check
if (x=iformatstr) then exit;
//filter
general.swapchars(x,#32,#10);
//get
//.1 - hz
if general.nextline(p,x,z) then
   begin
   v:=strint(z);
   case v of
   8000,11025,12000,16000,22050,24000,32000,44100,48000:a:=v;
   end;//end of case
   end;//end of if
//.2 - bits
if general.nextline(p,x,z) then
   begin
   v:=strint(z);
   case v of
   8,16:b:=v;
   end;//end of case
   end;//end of if
//.3 - channels
if general.nextline(p,x,z) then
   begin
   v:=strint(z);
   case v of
   1,2:c:=v;
   end;//end of case
   end;//end of if
//set
with iformat do
begin
wFormatTag:=1;//"WAVE_FORMAT_PCM=1"
nSamplesPerSec:=a;//44.1Khz
wBitsPerSample:=b;//16bit
nChannels:=c;//stereo
nBlockAlign:=(nChannels*wBitsPerSample) div 8;
nAvgBytesPerSec:=nSamplesPerSec*nBlockAlign;
cbSize:=sizeof(iformat);
end;//end of with
isecsize:=iformat.nAvgBytesPerSec;
iblocksize:=frcrange(isecsize div 5,1,sizeof(taudiobasicbuffer));
//update
iformatmodified:=true;
iformatstr:=inttostr(iformat.nSamplesPerSec)+#32+inttostr(iformat.wBitsPerSample)+#32+inttostr(iformat.nChannels);
except;end;
end;
//## wndproc ##
procedure taudiobasic.wndproc(var message:tmessage);
begin
try
//check
if (ihandle=0) then exit;
//decide
case message.msg of
MM_WOM_DONE:begin
   ipcount:=frcmin(ipcount-1,0);
   pdo;
   end;//end of begin
//MM_WIM_DONE:;//yyyyyyyyyyyyyyy rdo(false);
end;//end of case

except;end;
end;
//## _ontimer ##
procedure taudiobasic._ontimer(sender:tobject);
var
   len:integer;
begin
try
//check
if ilocked then exit;
//yyyyyyyyyyyyyyyy NOT YET FINISHED - forma.caption:=inttostr(iphandle)+'>'+floattostr(iptime-ms64)+','+bn(iformatmodified)+','+bn(ilocked);//yyyyyyyyyyyyyy
//state
paoc;
raoc;
if iformatmodified then
   begin
   iformatmodified:=false;
   paoc;
   raoc;
   end;//end of if
//start
if not ipplaying then pdo;
//yyyyyyyyyyyyyyyyyyy if not irrecording then rdo;
except;end;
end;
//## pdo ##
procedure taudiobasic.pdo;
label
   redo;
var
   z:string;
   count,len,p:integer;
   h:pwavehdr;
   a:paudiobasicbuffer;
begin
try
//defaults
count:=0;
//check
if iformatmodified or ilocked or (iphandle=0) or (ipdata='') then
   begin
   ipplaying:=false;
   exit;
   end;//end of if
//get
redo:
h:=@ipH[ippos];
a:=paudiobasicbuffer(h^.lpData);
z:=copy(ipdata,1,iblocksize);
len:=length(z);
if (len=0) then exit;
for p:=1 to len do a[p-1]:=byte(z[p]);
h.dwBufferlength:=len;
//set
if (not iformatmodified) and (not ilocked) and (iphandle<>0) and (0=waveOutWrite(iphandle,h,sizeof(h^))) then
   begin
   //inc
   inc(count);
   inc(ippos);
   if (ippos>high(ipH)) then ippos:=0;
   //set
   ipplaying:=true;
   delete(ipdata,1,len);
   ipcount:=frcrange(ipcount+1,1,20);
   //next
   if (ipcount<=1) and (count<=5) then goto redo;
   end
else ipplaying:=false;
except;end;
end;
//## handle ##
function taudiobasic.handle:hwnd;
begin
try
if (ihandle=0) then ihandle:=allocatehwnd(wndproc);
result:=ihandle;
except;end;
end;
//## paoc ##
procedure taudiobasic.paoc;//automatic open/close
var
   p:integer;
   ptr:HWAVEOUT;
begin
try
//open
if (not iformatmodified) and (iptime>ms64) and (not ilocked) then
   begin
   if (iphandle=0) and (0=waveOutOpen(@iphandle,0,@iformat,handle,0,WAVE_ALLOWSYNC or CALLBACK_WINDOW)) then
      begin
      //init
      for p:=0 to high(ipH) do
      begin
      fillchar(ipB[p],sizeof(ipB[p]),0);
      ipH[p].lpData:=@ipB[p];
      ipH[p].dwBufferLength:=sizeof(ipB[p]);//required 14FEB2008
      ipH[p].dwUser:=$0;
      ipH[p].dwFlags:=$0;
      ipH[p].dwLoops:=$0;
      waveOutPrepareHeader(iphandle,@ipH[p],sizeof(ipH[p]));
      end;//end of loop
      ippos:=0;
      ipcount:=0;
      end;//end of if
   end
//close
else if (iphandle<>0) and (iformatmodified or ilocked or (iptime<=ms64)) then
   begin
   //clear
   ptr:=iphandle;
   iphandle:=0;
   //buffers
   for p:=0 to high(ipH) do waveOutUnprepareHeader(ptr,@ipH[p],sizeof(ipH[p]));
   ipdata:='';
   ippos:=0;
   ipcount:=0;
   ipplaying:=false;
   //close
   for p:=1 to 50 do if (0=waveOutClose(ptr)) then break else sleep(200);
   end
else if (iptime<=ms64) then ipdata:='';
except;end;
end;
//## raoc ##
procedure taudiobasic.raoc;//automatic open/close
var
   p:integer;
   ptr:HWAVEIN;
begin
try
//open
if (not iformatmodified) and (irtime>ms64) and (not ilocked) then
   begin
   if (irhandle=0) and (0=waveInOpen(@irhandle,0,@iformat,handle,0,WAVE_ALLOWSYNC or CALLBACK_WINDOW)) then
      begin
      //init
      for p:=0 to high(irH) do
      begin
      fillchar(irB[p],sizeof(irB[p]),0);
      irH[p].lpData:=@irB[p];
      irH[p].dwBufferLength:=sizeof(irB[p]);
      irH[p].dwUser:=$0;
      irH[p].dwFlags:=$0;
      irH[p].dwLoops:=$0;
      waveInPrepareHeader(irhandle,@irH[p],sizeof(irH[p]));
      end;//end of loop
      irpos:=0;
      ircount:=0;
      end;//end of if
   end
//close
else if (irhandle<>0) and (iformatmodified or ilocked or (irtime<=ms64)) then
   begin
   //clear
   ptr:=irhandle;
   irhandle:=0;
   //buffers
   for p:=0 to high(irH) do waveInUnprepareHeader(ptr,@irH[p],sizeof(irH[p]));
   irdata:='';
   irpos:=0;
   ircount:=0;
   irrecording:=false;
   //close
   for p:=1 to 50 do if (0=waveInClose(ptr)) then break else sleep(200);
   end
else if (irtime<=ms64) then irdata:='';
except;end;
end;
//## rdo ##
procedure taudiobasic.rdo;
var
   z,tmp:string;
   zlen,p:integer;
begin
try
//defaults
z:='';
tmp:='';
//check
if ilocked or (irhandle=0) then exit;
//get - read "wave-in" buffers and convert to a single length string as "z"
//yyyyyyyyyyyyyyy NOT YET FINISHED

//set - split "z" into one second chunks and write to "irqueue"
zlen:=length(z);
if (zlen=0) then exit;
p:=1;
except;end;
end;
//## pushonline ##
function taudiobasic.pushonline:boolean;
begin
try;result:=(iphandle<>0);except;end;
end;
//## pushlen ##
function taudiobasic.pushlen:integer;//amount of data length in push buffer for playback
begin
try;result:=length(ipdata);except;end;
end;
//## canpush ##
function taudiobasic.canpush:boolean;
begin
try;result:=canpushex(2);except;end;
end;
//## canpushex ##
function taudiobasic.canpushex(seconds:integer):boolean;
begin
try;result:=(pushlen<(frcmin(seconds,1)*isecsize));except;end;
end;
//## push ##
function taudiobasic.push(var data:string):boolean;
var
   len:integer;
begin
try
//defaults
result:=false;
iptime:=ms64+10000;//timeout after 10 seconds of inactivity
//get
if (length(data)>=1) then
   begin
   ipdata:=ipdata+data;
   data:='';
   //successful
   result:=true;
   end;//end of if
except;end;
end;
//## pullonline ##
function taudiobasic.pullonline:boolean;
begin
try;result:=(irhandle<>0);except;end;
end;
//## canpull ##
function taudiobasic.canpull:boolean;
begin
try;result:=pullonline and (length(irdata)>=1);except;end;
end;
//## pull ##
function taudiobasic.pull(var data:string;var count:integer):boolean;
var
   tmp:string;
begin
try
//defaults
result:=false;
count:=0;
tmp:='';
//yyyyyyyyyyyyyyyyyyyy NOT YET FINISHED
except;end;
end;

//## tass ######################################################################
//## create ##
constructor tass.create;
begin
//self
inherited;
//defaults

end;
//## destroy ##
destructor tass.destroy;
begin
try
//controls

//self
inherited;
except;end;
end;
//## findformat ##
function tass.findformat(var x,format:string;var binary:boolean):boolean;
var//Supports:
   //1. MID = Midi
   //2. RMI = Midi (using the RIFF multiformat system)
   //3. WAV = Wave (using the RIFF multiformat system)
   z2,zu,z,zlast:string;
begin
try
//defaults
result:=false;
binary:=true;
format:='';
z:=copy(x,1,20);
zu:=uppercase(z);
zlast:=copy(x,frcmin(length(x)-9,1),10);//last 10 bytes of "x"
//process
//.get
if (copy(zu,1,4)='MTHD') then format:='MID'
else if (copy(zu,1,4)='RIFF') then
   begin
   if (copy(zu,9,4)='RMID') then format:='RMI'
   else if (copy(zu,9,4)='WAVE') then format:='WAV';
   end
else if (copy(zu,1,5)='PCS1#') then format:='PCS'//pc speaker sound
else if (copy(zu,1,5)='SSD1#') then format:='SSD';//system sound
//successful
result:=(format<>'');
except;end;
end;
//## findformatb ##
function tass.findformatb(var x:string):string;
var
   binary:boolean;
begin
try
//defaults
result:='';
//get
findformat(x,result,binary);
except;end;
end;
//## supportformat ##
function tass.supportformat(filenameorext:string):boolean;
var
   e:string;
begin
try
//defaults
result:=false;
//get
e:=readfileext('.'+filenameorext,true);
//decide
result:=
(e='MID') or (e='RMI') or (e='WAV') or (e='PCS') or
(e='SSD');
except;end;
end;
//## extlabel ##
function tass.extlabel(extorfilename:string;var z:string):boolean;
label
   skipend;
var
   p:integer;
   ext:string;
begin
try
//defaults
result:=false;
z:='';
ext:=readfileext('.'+extorfilename,true);
//get
if supportformat(ext) then
   begin
   //decide
   if (ext='MID') then z:=ntranslate('midi')
   else if (ext='RMI') then z:=ntranslate('midi')
   else if (ext='WAV') then z:=ntranslate('wave')
   else if (ext='PCS') then z:=ntranslate('pc speaker')
   else if (ext='SSD') then z:=ntranslate('system sound')
   else goto skipend;
   //successful
   result:=true;
   end;//end of if
skipend:
except;end;
end;
//## playpcs ##
procedure tass.playpcs(x:string);
label
   redo;
var
   a:tstringlist;
   binary:boolean;
   z,format:string;
   p,_repeats,_delay,_strength:integer;
begin
try
//defaults
a:=nil;
a:=tstringlist.create;
//get
if findformat(x,format,binary) and (format='PCS') then
   begin
   z:=copy(x,6,length(x));
   general.swapchars(z,',',#13);
   general.swapchars(z,'|',#13);
   a.text:=z;
   end;//end of if
if (a.count<3) then
   begin
   a.clear;
   a.add('2');
   a.add('50');
   a.add('60');
   end;//end of if
//set
p:=0;
redo:
if ((p+2)<a.count) then
   begin
   //get
   _repeats:=frcrange(strint(a.strings[p+0]),0,20);
   _delay:=frcrange(strint(a.strings[p+1]),0,500);
   _strength:=frcrange(strint(a.strings[p+2]),0,100);
   //set
   general.shortbeepb(_repeats,_delay,_strength);
   //inc
   inc(p,3);
   goto redo;
   end;//end of if
except;end;
try;freeobj(@a);except;end;
end;
//## playssd ##
procedure tass.playssd(x:string);
var
   binary:boolean;
   z,format:string;
begin
try
//get
if findformat(x,format,binary) and (format='SSD') then
   begin
   //get
   z:=lowercase(copy(x,6,length(x)));
   z:=general.copyuptob(z,#32);
   z:=general.copyuptob(z,#10);
   z:=general.copyuptob(z,#13);
   //set
   if (z='asterisk') then messagebeep(MB_ICONASTERISK)//Asterisk
   else if (z='exclamation') then messagebeep(MB_ICONEXCLAMATION)//Exclamation
   else if (z='criticalstop') then messagebeep(MB_ICONHAND)//Critical Stop
   else if (z='question') then messagebeep(MB_ICONQUESTION)//Question
   else if (z='defaultsound') then messagebeep(MB_OK)//Default Sound
   else if (z='beep') then messagebeep(-1)//Beep
   else messagebeep(-1);//Beep
   end;//end of if
except;end;
end;

//## tmm #######################################################################
//## create ##
constructor tmm.create;
begin//sate: 0=nil, 1=opened, 2=playing, 3=closing
//self
inherited;
//defaults
istate:=msFree;
ihandle:=0;
ideviceid:=0;
ifilename:='';
ivalid:=false;
end;
//## destroy ##
destructor tmm.destroy;
var
   tmp:hwnd;
begin
try
//stop
stop;
//handle
if (ihandle<>0) then
   begin
   //.get
   tmp:=ihandle;
   ihandle:=0;
   //.set
   deallocatehwnd(tmp);
   end;//end of if
//self
inherited;
except;end;
end;
//## canplay ##
function tmm.canplay:boolean;
begin
try;result:=(istate=msFree) or (istate=msWorking);except;end;
end;
//## getplaying ##
function tmm.getplaying:boolean;
begin
try;result:=(istate<>msFree) or istopwait;except;end;
end;
//## play ##
function tmm.play(x:string;var e:string):boolean;
label
   skipend;
begin
try
//defaults
result:=false;
e:=gecUnexpectedError;
//check
if canplay then
   begin
   //.stop
   stop;
   //.init
   istate:=msHold;
   ivalid:=false;
   istopwait:=true;
   end
else exit;//end of if
//process
//.get
ifilename:=x;
if not fileexists(x) then
   begin
   e:=gecFileNotFound;
   goto skipend;
   end;//end of if
//.open
if not _open(e) then goto skipend;
istate:=msQueued;
//.play
if not _play(e) then goto skipend;
istate:=msWorking;
ivalid:=true;
result:=true;
skipend:
except;end;
try
if (not result) then
   begin
   istopwait:=false;
   stop;
   end;//end of if
except;end;
end;
//## canstop ##
function tmm.canstop:boolean;
begin
try;result:=(istate<>msFree) and (not istoplock);except;end;
end;
//## stop ##
procedure tmm.stop;
begin
try
//check
if not canstop then exit;
//process
//.istoplock
istoplock:=true;
//.stop
_stop;
//.wait
while istopwait do
begin
sleep(100);
application.processmessages;
end;//end of loop
//.free
ivalid:=false;
istate:=msFree;
except;end;
try;istoplock:=false;except;end;
end;
//## _stop ##
procedure tmm._stop;
var
   genparm:tmci_generic_parms;
begin
try
if (ideviceid<>0) then
   begin
   //init
   genparm.dwCallback:=0;
   //set
   mciSendCommand(ideviceid,mci_close,longint(mci_wait),longint(@genparm));
   ideviceid:=0;
   end;//end of if
except;end;
end;
//## _open ##
function tmm._open(var e:string):boolean;
label
   skipend;
var
   openparm:tmci_open_parms;
   ferror,fflags:longint;
begin
try
//defaults
result:=false;
//check
e:=gecUnexpectedError;
if (istate<>msHold) then exit;
//process
//.fill
fillchar(openparm,sizeof(openparm),0);
openparm.dwCallback:=0;
//..Note: must convert "long filenames => short filename" since "MCI" can only handle ~125c filenames safely, after this they fail to open/play - 23FEB2008
//..Also: "misc.shortfile" only works for existing filenames (short names accessed from disk system)
if (ifilename<>'') then openparm.lpstrElementName:=pchar(misc.shortfile(ifilename));
//..flags
fflags:=mci_wait;
if (ifilename<>'') then fflags:=fflags or mci_open_element;
//.set
ferror:=mciSendCommand(0,mci_open,fflags,longint(@openparm));
if (ferror<>0) then
   begin
   e:=gecTaskFailed;
   goto skipend;
   end;//end of if
//successful
ideviceid:=openparm.wdeviceid;
result:=true;
skipend:
except;end;
end;
//## _play ##
function tmm._play(var e:string):boolean;
var
   playparm:tmci_play_parms;
   ferror,fflags:longint;
begin
try
//defaults
result:=false;
e:=gecUnexpectedError;
//check
if (istate<>msQueued) then exit;
//process
//.fill
fflags:=mci_notify;
playparm.dwCallback:=handle;
ferror:=mciSendCommand(ideviceid,mci_play,fflags,longint(@playparm));
//return result
result:=(ferror=0);
except;end;
end;
//## gethandle ##
function tmm.gethandle:hwnd;
begin
try
//get
if (ihandle=0) then ihandle:=allocatehwnd(wndproc);
//set
result:=ihandle;
except;end;
end;
//## getmode ##
function tmm.getmode:tmmodes;
var
   statusparm:tmci_status_parms;
   ferror,fflags:longint;
begin
try
//check
if not ivalid then result:=mmNotReady
else
   begin
   fflags:=mci_wait or mci_status_item;
   statusparm.dwItem:=mci_status_mode;
   ferror:=mciSendCommand(ideviceid,mci_status,fflags,longint(@statusparm));
   result:=tmmodes(statusparm.dwReturn-524);//MCI Mode #s are 524+enum
   end;//end of if
except;end;
end;
//## getposition ##
function tmm.getposition:longint;
var
   statusparm:tmci_status_parms;
   ferror,fflags:longint;
begin
try
//check
if not ivalid then result:=0
else
   begin
   fflags:=mci_wait or mci_status_item;
   statusparm.dwItem:=mci_status_position;
   ferror:=mciSendCommand(ideviceid,mci_status,fflags,longint(@statusparm));
   result:=frcmin(statusparm.dwReturn,0);
   end;//end of if
except;end;
end;
//## setposition ##
procedure tmm.setposition(x:longint);
var
   seekparm:tmci_seek_parms;
   ferror,fflags:longint;
begin
try
if ivalid then
   begin
   fflags:=mci_wait or mci_to;
   seekparm.dwCallback:=0;
   seekparm.dwto:=x;
   ferror:=mciSendCommand(ideviceid,mci_seek,fflags,longint(@seekparm));
   end;//end of if
except;end;
end;
//## getlength ##
function tmm.getlength:longint;
var
   statusparm:tmci_status_parms;
   ferror,fflags:longint;
begin
try
//check
if not ivalid then result:=0
else
   begin
   fflags:=mci_wait or mci_status_item;
   statusparm.dwItem:=mci_status_length;
   ferror:=mciSendCommand(ideviceid,mci_status,fflags,longint(@statusparm));
   result:=frcmin(statusparm.dwReturn,0);
   end;//end of if
except;end;
end;
//## wndproc ##
procedure tmm.wndproc(var message:tmessage);
var
   m:cardinal;
   w,l:longint;
begin
try
//process
//.get
m:=message.msg;
w:=message.wparam;
l:=message.lparam;
//.decide
case m of
mm_mcinotify:begin
   case w of
   mci_notify_aborted,mci_notify_successful,mci_notify_failure:begin
      //.istopwait
      istopwait:=false;
      //.stop
      stop;
      //.event
      fireevent(onnotify,self);
      end;//end of if
   end;//end of case
   end;//end of begin
end;//end of case
except;end;
end;

//## tmapperip #################################################################
//## create ##
constructor tmapperip.create;
var
   p:integer;
begin
//self
inherited;
//vars
imax:=high(iips);
//controls
for p:=0 to imax do iips[p]:=tdynamicinteger.create;
end;
//## destroy ##
destructor tmapperip.destroy;
var
   p:integer;
begin
try
//controls
for p:=0 to imax do freeobj(@iips[p]);
//self
inherited;
except;end;
end;
//## count ##
function tmapperip.count:integer;
begin
try;result:=iips[0].count;except;end;
end;
//## clear ##
procedure tmapperip.clear;
var
   p:integer;
begin
try;for p:=0 to imax do iips[p].clear;except;end;
end;
//## add ##
function tmapperip.add(s,d:integer):boolean;
var
   i:integer;
begin
try
//defaults
result:=false;
//get
i:=iips[0].count;
//set
iips[0].value[i]:=s;
iips[1].value[i]:=d;
//successful
result:=true;
except;end;
end;
//## gettext ##
function tmapperip.gettext:string;
var
   p,len:integer;
begin
try
//defaults
result:='';
len:=0;
//get
for p:=0 to (iips[0].count-1) do if (iips[0].items[p]<>0) and (iips[1].items[p]<>0) then
   begin
   pushb(len,result,_strip(iips[0].items[p])+'='+_strip(iips[1].items[p])+rcode);
   end;//end of if
//finalise
pushb(len,result,'');
except;end;
end;
//## settext ##
procedure tmapperip.settext(x:string);
var
   s,d,tmplen,p,p2:integer;
   tmp:string;
begin
try
//clear
clear;
//get
p:=1;
while general.nextline(p,x,tmp) do if general.textgood(tmp) then
   begin
   tmplen:=length(tmp);
   for p2:=1 to tmplen do if (tmp[p2]='=') then
      begin
      s:=_intip(copy(tmp,1,p2-1));
      d:=_intip(copy(tmp,p2+1,tmplen));
      if (s<>0) and (d<>0) then add(s,d);
      break;
      end;//end of if
   end;//end of if
except;end;
end;
//## ip ##
function tmapperip.ip(sip:integer):integer;
var
   tmp:integer;
begin//Automatically switches to "dip" if one exists, otherwise uses "sip"
try
//defaults
result:=sip;
//get
if find(sip,tmp) then result:=tmp;
except;end;
end;
//## find ##
function tmapperip.find(sip:integer;var dip:integer):boolean;
var
   index:integer;
begin
try;result:=findex(sip,dip,index);except;end;
end;
//## findex ##
function tmapperip.findex(sip:integer;var dip,index:integer):boolean;
var
   i:integer;
begin
try
//defaults
result:=false;
dip:=0;
index:=-1;
//check
if (sip=0) then exit;
//scan
i:=iips[0].find(0,sip);
if (i>=0) then
   begin
   //set
   index:=i;
   dip:=iips[1].items[i];
   result:=true;
   end;//end of if
except;end;
end;
//## rip ##
function tmapperip.rip(dip:integer):integer;
var
   tmp:integer;
begin//Automatically switches to "sip" if one exists, otherwise uses "dip"
try
//defaults
result:=dip;
//get
if rfind(dip,tmp) then result:=tmp;
except;end;
end;
//## rfind ##
function tmapperip.rfind(dip:integer;var sip:integer):boolean;//reverse lookup
var
   index:integer;
begin
try;result:=rfindex(dip,sip,index);except;end;
end;
//## rfindex ##
function tmapperip.rfindex(dip:integer;var sip,index:integer):boolean;
var
   i:integer;
begin
try
//defaults
result:=false;
sip:=0;
index:=-1;
//check
if (dip=0) then exit;
//scan
i:=iips[1].find(0,dip);
if (i>=0) then
   begin
   //set
   index:=i;
   sip:=iips[0].items[i];
   result:=true;
   end;//end of if
except;end;
end;

//## tfonts ####################################################################
//## create ##
constructor tfonts.create;
begin
//self
inherited;
//controls
inames:=tdynamicname.create;
istyles:=tdynamicbyte.create;
//defaults - empty by default
istyle:=fnsNil;
icount:=0;
end;
//## createsys ##
constructor tfonts.createsys(sysVar:prootobject);
begin
inherited createsys(sysVar);
style:=fnsBoth;
end;
//## destroy ##
destructor tfonts.destroy;
begin
try
//controls
freeObj(@inames);
freeObj(@istyles);
//self
inherited;
except;end;
end;
//## stylelabel ##
function tfonts.stylelabel(x:tfontsstyle;sep,s,p:string):string;
begin
try
result:=general.insstr(s,(fnsScreen=x) or (fnsBoth=x));
result:=result+general.insstr(general.insstr(sep,result<>'')+p,(fnsPrinter=x) or (fnsBoth=x));
except;end;
end;
//## setstyle ##
procedure tfonts.setstyle(x:tfontsstyle);
begin
try
//set
if (x<>istyle) then
   begin
   istyle:=x;
   refresh;
   end;//end of if
except;end;
end;
//## find ##
function tfonts.find(x:string):integer;
begin
try;result:=inames.findfast(0,x);except;end;
end;
//## getname ##
function tfonts.getname(x:integer):string;
begin
try;result:=inames.value[x];except;end;
end;
//## getstyle ##
function tfonts.getstyle(x:integer):tfontsstyle;
begin
try;result:=tfontsstyle(istyles.value[x]);except;end;
end;
//## getscreen ##
function tfonts.getscreen(x:integer):boolean;
var
   tmp:tfontsstyle;
begin
try;tmp:=styles[x];result:=(fnsScreen=tmp) or (fnsBoth=tmp);except;end;
end;
//## getprinter ##
function tfonts.getprinter(x:integer):boolean;
var
   tmp:tfontsstyle;
begin
try;tmp:=styles[x];result:=(fnsPrinter=tmp) or (fnsBoth=tmp);except;end;
end;
//## gettext ##
function tfonts.gettext:string;
begin
try;result:=inames.text;except;end;
end;
//## refresh ##
procedure tfonts.refresh;
var
   a:tdynamicnamelist;
   b:tdynamicbyte;
   pi,i,p:integer;
   s:tfontsstyle;
begin
try
//defaults
a:=nil;
b:=nil;
a:=tdynamicnamelist.create;
b:=tdynamicbyte.create;
//process
//SCREEN
try
if (fnsScreen=istyle) or (fnsBoth=style) then
   begin
   for p:=0 to (screen.fonts.count-1) do
   begin
   i:=a.add(screen.fonts.strings[p]);
   if (i>=0) then b.value[i]:=byte(fnsScreen);
   end;//end of loop
   end;//end of if
except;end;
//PRINTER
try
if (fnsPrinter=istyle) or (fnsBoth=style) then
   begin
   for p:=0 to (printer.fonts.count-1) do
   begin
   i:=a.addb(printer.fonts.strings[p],false);
   if (i>=0) then
      begin
      s:=tfontsstyle(b.value[i]);
      if (s=fnsScreen) or (s=fnsBoth) then s:=fnsBoth else s:=fnsPrinter;
      b.value[i]:=byte(s);
      end;//end of if
   end;//end of loop
   end;//end of if
except;end;
//.sort
a.sort(true);
//.clear
inames.clear;
istyles.clear;
//.set
for p:=0 to (a.count-1) do
begin
pi:=a.sorted.items[p];
i:=inames.count;
inames.value[i]:=a.items[pi]^;
istyles.value[i]:=b.items[pi];
end;//end of loop
icount:=inames.count;
except;end;
try;freeobj(@a);freeobj(@b);except;end;
end;

//##################################### tmt ####################################
//## create ##
constructor tmt.create;
begin
inherited;
//vars
iminutesindex:=ms64;
//controls
//.itask - Warning: do not create a "tthread" object when system is shuting down otherwise Delphi can crash
itask:=nil;
if (sysstate=ssOK) then itask:=ttimertask.create;
//.other
istate:=tdynamicbyte.create;
ievent:=tdynamicnotifyevent.create;
iinterval:=tdynamiccurrency.create;
iref:=tdynamiccurrency.create;
ienabled:=tdynamicboolean.create;
//events
if (itask<>nil) then
   begin
   itask.ontask:=_ontimer;
   itask.interval:=1;
   itask.run;
   end;//end of if
//.onappmsg
if (sysstate=ssOK) and (sysvar<>nil) then application.hookmainwindow(onappmsg);
end;
//## destroy ##
destructor tmt.destroy;
begin
try
//ishutdown
ishutdown:=true;
//closing
closing;
//controls
//.itask
if (itask<>nil) then
   begin
   itask.free;
   itask:=nil;
   end;//end of if
//.unhook
if ihooked then
   begin
   ihooked:=false;
   application.unhookmainwindow(onappmsg);
   end;//end of if
//.clear
clear;
//.other
freeObj(@istate);
freeObj(@ievent);
freeObj(@iinterval);
freeobj(@ienabled);
freeobj(@iref);
//self
inherited;
except;end;
end;
//## closing ##
procedure tmt.closing;
begin
try
//check
if (sysstate<>ssOK) or (sysvar=nil) then exit;
//process
//.vs.autosave
if (fvs<>nil) then fvs._autosave;
//.set
sysstate:=ssClosing;
except;end;
end;
//## onappmsg ##
function tmt.onappmsg(var Message: TMessage):boolean;
begin//these should not be called as long as MAINFORM is running
try
case message.msg of
wm_close:begin
   result:=true;
   if (sysstate=ssOK) and appprompt then closing;
   message.result:=0;//OK
   end;//end of begin
wm_queryendsession:begin
   result:=true;
   message.result:=integer(appprompt);
   if twmendsession(message).endsession then closing;
   end;
wm_endsession:begin
   result:=true;
   if twmendsession(message).endsession then closing;
   message.result:=0;//OK
   end;
end;//end of case
except;end;
end;
//## slowoff ##
procedure tmt.slowoff(var secref:currency);
begin
try;secref:=gettickcountSEC;except;end;
end;
//## slowon ##
procedure tmt.slowon(var secref:currency);
begin
try;secref:=gettickcountSEC-60000;except;end;
end;
//## slowauto ##
function tmt.slowauto(var secref:currency;_interval:currency):currency;
const
   maxwait=10000;//wait 10 seconds before slowing down to 200ms interval
begin
try
//defaults
result:=_interval;
//process
if (_interval<200) and ((gettickcountSEC-secref)>=maxwait) then result:=200;
except;end;
end;
//## stop ##
procedure tmt.clear;
begin
try
istate.clear;
ievent.clear;
iinterval.clear;
ienabled.clear;
iref.clear;
except;end;
end;
//## _ontimer ##
procedure tmt._ontimer(sender:tobject);
var//Cycle range: 1..200ms
   lca,lc,p:integer;
   tmpref,_time,_next,tmp,t:currency;
   _override:boolean;
begin
try
//check
if ishutdown then exit;
//defaults
_next:=200;//max time to wait before calling this event again
lc:=0;//load count - for "sysinfo"
lca:=0;
tmp:=0;
t:=ms64;
gettickcountSEC:=t;
getDIM:=general.dim(now);
_override:=(sysstate<>ssOK);
//process
//.ssClosed
if (sysstate=ssFinished) then exit;
if (sysstate>=ssClosed) or ( (sysstate=ssClosing) and ((forma=nil) or forma.empty) ) then
   begin
   siCloseAll;
   exit;
   end;//end of if
//.system vars
systemidletime:=frccurmin((ms64-systemidleref),0);
//.events
for p:=0 to (istate.count-1) do
begin
if (istate.items[p]=msWorking) then
   begin
   //.lc
   inc(lc);
   //.decide
   if ienabled.items[p] and (iinterval.items[p]>=1) then
      begin
      if _override or (iref.items[p]<>int(t/iinterval.items[p])) then
         begin
         //.event
         if assigned(ievent.items[p]) then
            begin
            ievent.items[p](self);
            //shutdown - ignore all from now on
            if ishutdown then exit;
            end;//end of if
         //.reset
         if (istate.items[p]=msWorking) and (iinterval.items[p]>=1) then iref.items[p]:=int(t/iinterval.items[p]);
         end;//end of if
      //.smallest next
      if _override then _next:=200
      else if (_next>1) and (istate.items[p]=msWorking) and ienabled.items[p] and (iinterval.items[p]>=1) then
         begin
         tmpref:=int(t/iinterval.items[p]);
         tmp:=iinterval.items[p]-(t-(tmpref*iinterval.items[p]));
         if (tmp<=0) then tmp:=iinterval.items[p];
         if (tmp<_next) then _next:=tmp;
         end;//end of if
      //.lca
      inc(lca);
      end;//end of if
   end;//end of if
end;//end of loop
//.sysinfo
timerload:=lc;
timerloadactive:=lca;
//.minutes
if ((ms64-iminutesindex)>=60000) then
   begin
   general.croll(iminutes,1);
   iminutesindex:=ms64;
   end;//end of if
//.next
if (_next<1) then _next:=1
else if (_next>200) then _next:=200;
itask.next:=_next;
except;end;
end;
//## minutesreset ##
procedure tmt.minutesreset;
begin
try
iminutesindex:=ms64;
iminutes:=0;
except;end;
end;
//## minutespartial ##
function tmt.minutespartial:currency;
begin
try;result:=frccurrange(60000-(ms64-iminutesindex),0,59999);except;end;
end;
//## new ##
function tmt.new(_event:tnotifyevent;_interval:currency;_enabled:boolean):integer;
var
   p:integer;
begin
try
//error
result:=mtNilTimer;
//check
if (sysstate>=ssFinished) then exit;
//process
//.new
p:=istate.find(0,msFree);
if (p=-1) then
   begin
   //.inc size
   p:=size;
   size:=size+1;
   if (p=size) then exit;
   end;//end of if
//.hold
istate.items[p]:=msHold;
//.fill
ievent.items[p]:=_event;
iinterval.items[p]:=frccurmin(_interval,1);
ienabled.items[p]:=_enabled;
//.ref - set so "event" won't be triggered until "first interval" has elapsed - 30SEP2007
iref.items[p]:=int(ms64/iinterval.items[p]);
//.working
istate.items[p]:=msWorking;
//return result
result:=p+1;//zero-based -> one-based
except;end;
end;
//## del ##
procedure tmt.del(var _instance:integer);
begin
try
if canvalue(_instance) then
   begin
   //hold
   istate.items[_instance-1]:=msHold;
   //clear
   ievent.items[_instance-1]:=nil;
   ienabled.items[_instance-1]:=false;
   iref.items[_instance-1]:=0;
   iinterval.items[_instance-1]:=0;
   //free
   istate.items[_instance-1]:=msFree;
   _instance:=mtNilTimer;
   end;//end of if
except;end;
end;
//## getsize ##
function tmt.getsize:integer;
begin
try;result:=istate.size;except;end;
end;
//## setsize ##
procedure tmt.setsize(x:integer);
begin
try
//range
x:=frcmin(x,1);
//check
if (x=size) then exit;
//set
ievent.setparams(x,x,0);
iinterval.setparams(x,x,0);
ienabled.setparams(x,x,0);
iref.setparams(x,x,0);
istate.setparams(x,x,0);
except;end;
end;
//## valid ##
function tmt.valid(x:integer):boolean;
begin//1..SIZE (1 based)
try;result:=(x>mtNilTimer) and (x<=size) and (istate.items[x-1]<>msFree);except;end;
end;
//## canvalue ##
function tmt.canvalue(x:integer):boolean;
begin
try;result:=(sysstate<=ssClosing) and valid(x);except;end;
end;
//## getevent ##
function tmt.getevent(x:integer):tnotifyevent;
begin
try;if canvalue(x) then result:=ievent.value[x-1] else result:=nil;except;end;
end;
//## setevent ##
procedure tmt.setevent(x:integer;y:tnotifyevent);
begin
try;if canvalue(x) then ievent.items[x-1]:=y;except;end;
end;
//## getinterval ##
function tmt.getinterval(x:integer):currency;
begin
try;if canvalue(x) then result:=iinterval.value[x-1] else result:=1;except;end;
end;
//## setinterval ##
procedure tmt.setinterval(x:integer;y:currency);
begin
try;if canvalue(x) then iinterval.items[x-1]:=frccurmin(y,1);except;end;
end;
//## getenabled ##
function tmt.getenabled(x:integer):boolean;
begin
try;if canvalue(x) then result:=ienabled.items[x-1] else result:=false;except;end;
end;
//## setenabled ##
procedure tmt.setenabled(x:integer;y:boolean);
begin
try;if canvalue(x) then ienabled.items[x-1]:=y;except;end;
end;

//########################### trates ###########################################
//## create ##
constructor trates.create;
begin
inherited;
//vars
iunits[byte(rteuDay)]:=86400;
iunits[byte(rteuHour)]:=3600;
iunits[byte(rteuMin)]:=60;
iunits[byte(rteuSec)]:=1;
iclearongo:=true;
igoing:=false;
//defaults
clear;
end;
//## clear ##
procedure trates.clear;
var
   p:integer;
begin
try
istarttime:=ms64;
ifinishtime:=istarttime;
for p:=low(icounts) to high(icounts) do icounts[p]:=0;
except;end;
end;
//## setgoing ##
procedure trates.setgoing(x:boolean);
begin
try;if x then go else stop;except;end;
end;
//## go ##
procedure trates.go;
begin
try
if not going then
   begin
   sync;
   if clearongo then clear else sync;
   igoing:=true;
   end;//end of if
except;end;
end;
//## stop ##
procedure trates.stop;
begin
try
if going then
   begin
   igoing:=false;
   gettimeperiod;
   end;//end of if
except;end;
end;
//## gettimeperiod ##
function trates.gettimeperiod:currency;
begin
try
//.get
if going then ifinishtime:=ms64;
result:=ifinishtime-istarttime;
//.enforce range
result:=frccurmin(result,1);
except;end;
end;
//## sync ##
procedure trates.sync;
var
   d:currency;
begin
try
//check
if going then exit;
//process
//.get
d:=ms64-ifinishtime;
if (d<0) then exit;
//.set
istarttime:=istarttime+d;
ifinishtime:=ifinishtime+d;
except;end;
end;
//## rate ##
function trates.rate(_s:tratestyle;_u:trateunits):currency;
var
   p,u,c:currency;
begin
try
//defaults
result:=0;
//process
//.get
c:=icounts[byte(_s)];
if (_u=rteuPercentage) then
   begin
   u:=value(rtesTotal);
   if (u<1) then u:=1;
   result:=frcrange(round((c/u)*100),0,100);
   end
else
   begin
   u:=iunits[byte(_u)];
   p:=frccurmin(int(gettimeperiod/1000),1);//seconds
   result:=round(c*(u/p));
   end;//end of if
except;end;
end;
//## ratestr ##
function trates.ratestr(_s:tratestyle;_u:trateunits):string;
begin
try;result:=general.curcomma(rate(_s,_u));except;end;
end;
//## value ##
function trates.value(_s:tratestyle):currency;
begin
try;result:=icounts[byte(_s)];except;end;
end;
//## incby ##
procedure trates.incby(_s:tratestyle;_by:currency);
begin
try
if going then
   begin
   general.croll(icounts[byte(_s)],_by);
   //.total
   if (_s<>rtesTotal) then general.croll(icounts[byte(rtesTotal)],_by);
   end;//end of if
except;end;
end;
//## incone ##
procedure trates.incone(_s:tratestyle);
begin
try;incby(_s,1);except;end;
end;

//########################### ttask ############################################
//## create ##
constructor ttask.create;
begin
ivalid:=true;
imode:=tkmCreate;
ontask:=nil;
inherited freeonterminate:=true;
inherited create(true);
imode:=tkmFree;
inc(threadcount);
end;
//## destroy ##
destructor ttask.destroy;
begin
try
//check
if not ivalid then exit;
ivalid:=false;
//controls
imode:=tkmDestroy;
_ondestroy;
//self
dec(threadcount);
inherited;
except;end;
end;
//## free ##
procedure ttask.free;
begin
try;terminate;except;end;
end;
//## terminate ##
procedure ttask.terminate;
begin
try
imode:=tkmDestroy;
if suspended then inherited resume;
except;end;
end;
//## execute ##
procedure ttask.execute;
label
     start;
begin
try
//start
start:
case imode of
tkmStopping,tkmInUse:imode:=tkmInUse;
tkmDestroy:exit;
else
   begin
   inherited suspend;
   goto start;
   end;//end of begin
end;//end of case
//task
dotask;
//finish
if (imode<>tkmDestroy) then
   begin
   imode:=tkmFree;
   synchronize(_suspend);
   if (imode<>tkmDestroy) then goto start;
   end;//end of if
except;end;
end;
//## _suspend ##
procedure ttask._suspend;
begin
try;if not suspended then inherited suspend;except;end;
end;
//## stop ##
procedure ttask.stop;
begin
try;synchronize(_stop);except;end;
end;
//## _stop ##
procedure ttask._stop;
begin
try;if (imode=tkmInUse) then imode:=tkmStopping;except;end;
end;
//## run ##
procedure ttask.run;
begin
try;synchronize(_run);except;end;
end;
//## _run ##
procedure ttask._run;
begin
try
if (imode=tkmFree) then
   begin
   imode:=tkmInUse;
   if suspended then inherited resume;
   end;//end of if
except;end;
end;
//## getrunning ##
function ttask.getrunning:boolean;
begin
try;result:=(imode<>tkmCreate) and (imode<>tkmDestroy) and (imode<>tkmFree);except;end;
end;
//## resume ##
procedure ttask.resume;
begin
{nil}
end;
//## suspend ##
procedure ttask.suspend;
begin
{nil}
end;
//## quit ##
function ttask.quit:boolean;
begin
try;result:=(imode<>tkmInUse);except;end;
end;
//## _ontask ##
procedure ttask._ontask;
begin//Note: Not safe to fire event if destroying (control may be gone by time host responds)
try;if (imode<>tkmDestroy) and assigned(ontask) then ontask(self);except;end;
end;
//## _ondestroy ##
procedure ttask._ondestroy;
begin
{nil}
end;
//## doontask ##
procedure ttask.doontask;
begin
try;synchronize(_ontask);except;end;
end;
//## dotask ##
procedure ttask.dotask;
begin
try
//process

//finished
doontask;
except;end;
end;

//############################ ttimertask ######################################
//## dotask ##
procedure ttimertask.dotask;
var
   _now,s,sn:currency;
begin
try
//enforce range
interval:=frccurmin(interval,1);
s:=ms64;
sn:=s;
//process
while running do
begin
sleep(1);
_now:=ms64;
//.custom 1-X ms
if (next<=0) then
   begin
   if ((_now-s)>=interval) then
      begin
      s:=_now;
      sn:=_now;
      doontask;
      end;//end of if
   end
else if ((_now-sn)>=next) then
   begin
   //.reset
   sn:=_now;
   next:=0;
   //.event
   doontask;
   //.range - prevent large upper limit
   next:=frccurrange(next,0,500);
   end;//end of if
end;//end of loop
except;end;
end;

//############################ tlookupthread ###################################
//## _general ##
procedure tlookupthread._general;
begin
try;general;except;end;
end;
//## _netstart ##
procedure tlookupthread._netstart;
begin
try;ns.start;except;end;
end;
//## dotask ##
procedure tlookupthread.dotask;
label
     skipend;
var
   a:phostent;
   p:integer;
begin
try
//defaults
ip:=0;
if (host='') then goto skipend;
//process
//.start
synchronize(_netstart);
synchronize(_general);
//.decide
p:=_intIP(host);
if (0=comparetext(_strIP(p),host)) then ip:=p
else
    begin
    //.lookup
    a:=n_gethostbyname(pchar(host));
    if (a<>nil) then ip:=pint4(a.h_addr^).val;
    end;//end of if
skipend:
//.event
doontask;
except;end;
end;

//########################### tlookuphistory ###################################
//## create ##
constructor tlookuphistory.create;
begin
//controls
ihost:=tdynamicname.create;
itime:=tdynamiccurrency.create;
iip:=tdynamicinteger.create;
ihold:=tdynamicboolean.create;
//vars
iindex:=0;
isize:=0;
imax:=-1;
itimeout:=10000;//10 seconds
//defaults
size:=256;
end;
//## destroy ##
destructor tlookuphistory.destroy;
begin
try
//size
size:=0;
//controls
freeObj(@ihost);
freeObj(@itime);
freeObj(@iip);
freeObj(@ihold);
//self
inherited;
except;end;
end;
//## find ##
function tlookuphistory.find(host:string;var ip:integer):boolean;
var
   index:integer;
begin
try;result:=_find(host,index,ip);except;end;
end;
//## _find ##
function tlookuphistory._find(host:string;var index,ip:integer):boolean;
var
   p:integer;
begin
try
//defaults
result:=false;
index:=-1;
ip:=0;
//process
if (isize>=1) then
   begin
   p:=ihost.findfast(0,host);
   if (p>=0) and (not ihold.items[p]) and ((ms64-itime.items[p])<=itimeout) then
      begin
      index:=p;
      ip:=iip.items[p];
      result:=true;
      end;//end of if
   end;//end of if
except;end;
end;
//## add ##
function tlookuphistory.add(host:string;ip:integer):boolean;
var
   _index,_ip:integer;
begin
try
//defaults
result:=false;
//process
if (isize>=1) then
   begin
   //.check
   if (iindex<0) then iindex:=0
   else if (iindex>=isize) then iindex:=0;
   //.find
   if _find(host,_index,_ip) then
      begin
      iip.items[_index]:=ip;
      itime.items[_index]:=ms64;
      end
   //.new
   else
      begin
      ihold.items[iindex]:=true;
      ihost.value[iindex]:=host;
      iip.items[iindex]:=ip;
      itime.items[iindex]:=ms64;
      ihold.items[iindex]:=false;
      end;//end of if
   //.inc
   inc(iindex);
   if (iindex>=isize) then iindex:=0;
   //successful
   result:=true;
   end;//end of if
except;end;
end;
//## setsize ##
procedure tlookuphistory.setsize(x:integer);
begin
try
//range
x:=frcmin(x,0);
//process
if (x<>isize) then
   begin
   //.pre - shrink index range before index's to prevent errors
   if (x<isize) then
      begin
      isize:=x;
      imax:=x-1;
      end;//end of if
   //.set
   ihost.setparams(x,x,0);
   itime.setparams(x,x,0);
   iip.setparams(x,x,0);
   ihold.setparams(x,x,0);
   isize:=x;
   imax:=x-1;
   end;//end of if
except;end;
end;
//## settimeout ##
procedure tlookuphistory.settimeout(x:currency);
begin//500ms..Nms
try;itimeout:=frccurmin(x,500);except;end;
end;

//## tdomains ##################################################################
//## create ##
constructor tdomains.create;
var
   p:integer;
   c:currency;
begin
//self
inherited;
//vars
attemptlimit:=5;
imin:=low(iip);
imax:=high(iip);
ilookupitem:=maxint;//safe out of bounds value
ilookupdomain:='';
ilookupptr.c:=0;
ilookpos:=imin;
//items
c:=ms64;
for p:=imin to imax do
begin
istate[p]:=0;//free
iip[p]:=0;
ims[p]:=0;
idomain[p]:='';
iitag[p]:=0;
ictag[p]:=0;
icount[p]:=0;
end;//end of loop
//timer
itimer:=mt.new(_ontimer,500,true);
end;
//## destroy ##
destructor tdomains.destroy;
begin
try
//timer
mt.del(itimer);
//close
if (ilookupptr.c<>0) then lm.close(ilookupptr);
//self
inherited;
except;end;
end;
//## refreshIPS ##
procedure tdomains.refreshIPS;
var
   p:integer;
   _ms64:currency;
begin
try
//get
_ms64:=ms64;
//set
for p:=imin to imax do if (state[p]=2) then
   begin
   iip[p]:=0;
   icount[p]:=0;
   ims[p]:=_ms64;
   end;//end of if
except;end;
end;
//## gettext ##
function tdomains.gettext:string;
begin
try;result:=gettextex(rcode);except;end;
end;
//## gettextex ##
function tdomains.gettextex(sep:string):string;//list of domains in use in no particular order
var
   p:integer;
begin
try
//defaults
result:='';
//range
if (sep='') then sep:=rcode;
//get
for p:=imin to imax do if (state[p]<>0) and (domain[p]<>'') then result:=result+domain[p]+sep;
except;end;
end;
//## new ##
function tdomains.new:integer;
var
   p:integer;
begin
try
//defaults - 0=error, 1..X=handle
result:=0;
//scan
for p:=imin to imax do if (istate[p]=0) then
   begin
   //successful
   result:=p;
   //clear
   istate[p]:=1;//hold
   idomain[p]:='';
   iip[p]:=0;
   ims[p]:=ms64;
   iitag[p]:=0;
   ictag[p]:=0;
   icount[p]:=0;
   //inc
   inc(iactive);
   //quit
   break;
   end;//end of if
except;end;
end;
//## newex ##
function tdomains.newex(p:integer):boolean;
begin
try
//defaults
result:=false;
//check
if not valid(p) then exit;
//set
if (istate[p]=0) then
   begin
   //clear
   istate[p]:=1;//hold
   idomain[p]:='';
   iip[p]:=0;
   ims[p]:=ms64;
   iitag[p]:=0;
   ictag[p]:=0;
   icount[p]:=0;
   //inc
   inc(iactive);
   //successful
   result:=true;
   end;//end of if
except;end;
end;
//## del ##
procedure tdomains.del(var x:integer);
begin
try
if (state[x]<>0) then
   begin
   //clear
   istate[x]:=0;
   idomain[x]:='';
   iip[x]:=0;
   ims[x]:=0;
   icount[x]:=0;
   //vars
   iitag[x]:=0;
   ictag[x]:=0;
   //dec
   iactive:=frcmin(iactive-1,0);
   //x
   x:=0;
   end;//end of if
except;end;
end;
//## valid ##
function tdomains.valid(x:integer):boolean;
begin
try;result:=(x>=imin) and (x<=imax);except;end;
end;
//## getinuse ##
function tdomains.getinuse(x:integer):boolean;
begin
try;result:=(state[x]<>0);except;end;
end;
//## sethold ##
procedure tdomains.sethold(x:integer;y:boolean);
begin
try;if (state[x]<>0) then istate[x]:=general.aorb(2,1,y);except;end;//2=inuse, 1=hold
end;
//## gethold ##
function tdomains.gethold(x:integer):boolean;
begin
try;result:=(state[x]=1);except;end;
end;
//## getstate ##
function tdomains.getstate(x:integer):byte;
begin
try;if valid(x) then result:=istate[x] else result:=0;except;end;
end;
//## getitag ##
function tdomains.getitag(x:integer):integer;
begin
try;if (state[x]<>0) then result:=iitag[x] else result:=0;except;end;
end;
//## setitag ##
procedure tdomains.setitag(x:integer;y:integer);
begin
try;if (state[x]<>0) then iitag[x]:=y;except;end;
end;
//## getctag ##
function tdomains.getctag(x:integer):currency;
begin
try;if (state[x]<>0) then result:=ictag[x] else result:=0;except;end;
end;
//## setctag ##
procedure tdomains.setctag(x:integer;y:currency);
begin
try;if (state[x]<>0) then ictag[x]:=y;except;end;
end;
//## getip ##
function tdomains.getip(x:integer):integer;
begin
try;if (state[x]<>0) then result:=iip[x] else result:=0;except;end;
end;
//## getcount ##
function tdomains.getcount(x:integer):integer;
begin
try;if (state[x]<>0) then result:=icount[x] else result:=0;except;end;
end;
//## getdomain ##
function tdomains.getdomain(x:integer):string;
begin
try;if (state[x]<>0) then result:=idomain[x] else result:='';except;end;
end;
//## asdomain ##
function tdomains.asdomain(x:string):string;
var
   ui:tparseurl;
begin
try
//defaults
result:='';
//filter
general.pu('http://'+x,'',ui,[]);
result:=ui.h;
except;end;
end;
//## setdomain ##
procedure tdomains.setdomain(x:integer;y:string);
begin
try
//check
if (state[x]=0) then exit;
//get
if (y<>'') then y:=asdomain(y);
//set
if (y='') then
   begin
   idomain[x]:='';
   iip[x]:=0;
   icount[x]:=0;
   istate[x]:=2;//inuse
   end
else if (state[x]=1) or (comparetext(idomain[x],y)<>0) then//state or domain differs from current
   begin
   //lock
   ims[x]:=ms64+60000;
   //vars
   iitag[x]:=0;
   ictag[x]:=0;
   //set
   iip[x]:=0;
   icount[x]:=0;
   idomain[x]:=y;
   istate[x]:=2;//inuse
   //unlock
   ims[x]:=ms64;//update right now
   end;//end of if
except;end;
end;
//## _ontimer ##
procedure tdomains._ontimer(sender:tobject);
var
   i,minp,maxp,p:integer;
   c:currency;
begin
try
//check
if (sysstate>=ssClosed) then exit;
if (ilookupptr.c<>0) then exit;
//init
c:=ms64;
maxp:=imax;
minp:=frcrange(ilookpos,imin,imax);
i:=imin;//reset if no items waiting
//scan
for p:=minp to maxp do if (state[p]=2) and (iip[p]=0) and (icount[p]<attemptlimit) and (c>=ims[p]) and (idomain[p]<>'') then
   begin
   //init
   ilookupitem:=p;
   ilookupdomain:=idomain[p];
   //get
   ilookupptr:=lm.open(idomain[p],0,_onlookup);
   if (ilookupptr.c=0) then
      begin
      ilookupitem:=maxint;//safe out of bounds value
      ilookupdomain:='';
      end
   else
      begin
      //inc
      i:=p+1;
      //quit
      break;
      end;//end of if
   end;//end of if
//next
if (i>imax) then i:=imin;
ilookpos:=i;
except;end;
end;
//## _onlookup ##
procedure tdomains._onlookup(sender:tobject;tag:currency;ptr:tnetworkptr);
begin
try
//get
if (state[ilookupitem]=2) and (comparetext(ilookupdomain,idomain[ilookupitem])=0) then
   begin
   general.iroll(icount[ilookupitem],1);
   iip[ilookupitem]:=lm.ip[ilookupptr];
   ims[ilookupitem]:=ms64+30000;//wait 30 seconds before trying again
   end;//end of if
except;end;
try
//clear
ilookupitem:=maxint;//safe out of bounds value
ilookupdomain:='';
ilookupptr.c:=0;
except;end;
end;

//## tlookupmanagement #########################################################
//## create ##
constructor tlookupmanagement.create;
var
   p:integer;
begin
//self
inherited;
//vars
imaxthread:=0;
imax:=-1;
isize:=0;
itime:=ms64;
//controls
ihistory:=tlookuphistory.create;
for p:=0 to high(ithreads) do ithreads[p]:=nil;
istate:=tdynamicbyte.create;
iptr:=tdynamiccurrency.create;
itag:=tdynamiccurrency.create;
iurl:=tdynamicstring.create;
ihost:=tdynamicstring.create;
iip:=tdynamicinteger.create;
iport:=tdynamicword.create;
ihold:=tdynamicboolean.create;
ionclose:=tdynamicnotifyevent.create;
ilink:=tnotifylist.create;
//defaults
maxthread:=1;
size:=256;
ihistory.size:=256;
//timer
mt.slowon(islowref);
itimer:=mt.new(_ontimer,200,true);
end;
//## destroy ##
destructor tlookupmanagement.destroy;
var
   p:integer;
begin
try
//timer
mt.del(itimer);
//controls
//.closeall
closeall;
//.threads
imaxthread:=0;
iactivethreads:=0;
for p:=high(ithreads) downto 0 do freethread(p);
//.other
freeObj(@ilink);
freeObj(@ihistory);
freeObj(@istate);
freeObj(@iptr);
freeObj(@itag);
freeObj(@iurl);
freeObj(@ihost);
freeObj(@iip);
freeObj(@iport);
freeObj(@ionclose);
freeObj(@ihold);
//self
inherited;
except;end;
end;
//## _ontimer ##
procedure tlookupmanagement._ontimer(sender:tobject);
var
   oneormore,ok,openok:boolean;
   _ip,pn,i,p:integer;
   _open:byte;
   _ptr:tnetworkptr;
begin
try
//check
if (sysstate>=ssClosed) then exit;
//process
oneormore:=false;
openok:=true;
_open:=byte(lusOpen);
//.scan
pn:=iindex;
for p:=0 to imax do
begin
//.decide
if (_open=istate.items[pn]) then
   begin
   oneormore:=true;
   //host is ip - no need to use find or threaded lookup
   _ip:=_intIP(ihost.items[pn]^);
   if (0=comparetext(_strip(_ip),ihost.items[pn]^)) then
      begin
      //get
      iip.items[pn]:=_ip;
      //set
      istate.items[pn]:=byte(lusDead);
      _ptr:=ptr[pn];
      if assigned(onclose[_ptr]) then close(_ptr);
      end
   else
      begin
      case ihistory.find(ihost.items[pn]^,iip.items[pn]) of
      true:begin//within history
         istate.items[pn]:=byte(lusDead);
         _ptr:=ptr[pn];
         if assigned(onclose[_ptr]) then close(_ptr);
         end;//end of begin
      false:if openok then//use threaded lookup
         begin
         openok:=newthread(i);
         if openok then
            begin
            istate.items[pn]:=byte(lusFind);
            ithreads[i].ptr.c:=iptr.items[pn];
            ithreads[i].host:=ihost.items[pn]^;
            ithreads[i].run;
            end;//end of if
         end;//end of begin
      end;//end of case
      end;//end of if
   end;//end of if
//.inc
inc(pn);
if (pn>imax) then pn:=0;
end;//end of loop
//.inc index
inc(iindex,maxthread);
if (iindex>imax) then iindex:=0;
//.notify
ilink.notify;
//.slow
if oneormore then mt.slowoff(islowref);
mt.interval[itimer]:=mt.slowauto(islowref,20);//50x per second
except;end;
end;
//## link ##
function tlookupmanagement.link(_event:tnotifyevent):integer;
begin
try;result:=ilink.new(_event);except;end;
end;
//## unlink ##
procedure tlookupmanagement.unlink(var _instance:integer);
begin
try;ilink.del(_instance);except;end;
end;
//## setsize ##
procedure tlookupmanagement.setsize(x:integer);
begin
try
//range
x:=frcmin(x,1);
//process
if (x<>isize) then
   begin
   if (x<isize) then
      begin
      imax:=x-1;
      isize:=x;
      end;//end of if
   istate.setparams(x,x,0);
   iptr.setparams(x,x,0);
   iurl.setparams(x,x,0);
   ihost.setparams(x,x,0);
   iip.setparams(x,x,0);
   iport.setparams(x,x,0);
   itag.setparams(x,x,0);
   ihold.setparams(x,x,0);
   ionclose.setparams(x,x,0);
   imax:=x-1;
   isize:=x;
   end;//end of if
except;end;
end;
//## createthread ##
procedure tlookupmanagement.createthread(x:integer);
var
   tmp:tlookupthread;
begin
try
if (x>=0) and (x<=high(ithreads)) and (ithreads[x]=nil) then
   begin
   //.create
   tmp:=tlookupthread.create;
   tmp.ontask:=_ontask;
   //.set
   ithreads[x]:=tmp;
   end;//end of if
except;end;
end;
//## freethread ##
procedure tlookupmanagement.freethread(x:integer);
var
   tmp:tlookupthread;
begin
try
if (x>=0) and (x<=high(ithreads)) and (ithreads[x]<>nil) then
   begin
   tmp:=ithreads[x];
   ithreads[x]:=nil;
   tmp.ontask:=nil;
   tmp.terminate;
   end;//end of if
except;end;
end;
//## _ontask ##
procedure tlookupmanagement._ontask(sender:tobject);
var
   tmp:tlookupthread;
begin
try
//check
if (sysstate>=ssClosed) then exit;
if (sender=nil) or (not (sender is tlookupthread)) then exit;
tmp:=sender as tlookupthread;
//process
//.ip mapping
if (tmp.ip<>0) and ipmapping then tmp.ip:=mip.ip(tmp.ip);
//.history
ihistory.add(tmp.host,tmp.ip);
//.valid
if inuse[tmp.ptr] and (not dead[tmp.ptr]) then
   begin
   iip.items[tmp.ptr.index]:=tmp.ip;
   istate.items[tmp.ptr.index]:=byte(lusDead);
   //.doonclose
   if assigned(onclose[tmp.ptr]) then close(tmp.ptr);
   end;//end of if
except;end;
end;
//## setmaxthread ##
procedure tlookupmanagement.setmaxthread(x:integer);
begin
try;imaxthread:=frcrange(x,1,high(ithreads)+1);except;end;
end;
//## syncthreads ##
procedure tlookupmanagement.syncthreads;
var
   p,old:integer;
begin
try
//check - Warning: creating a "tthread" object when system is closing can cause Delphi to crash
if (sysstate<>ssOK) then exit;
//process
if (imaxthread>=1) and (imaxthread<>iactivethreads) then
   begin
   //.get
   old:=iactivethreads;
   //.shrink
   if (imaxthread<iactivethreads) then
      begin
      iactivethreads:=imaxthread;
      for p:=(old-1) downto imaxthread do freethread(p);
      end
   //.enlarge
   else if (imaxthread>iactivethreads) then
      begin
      for p:=old to (imaxthread-1) do createthread(p);
      end;//end of if
   iactivethreads:=imaxthread;
   end;//end of if
except;end;
end;
//## getinuse ##
function tlookupmanagement.getinuse(x:tnetworkptr):boolean;
begin
try;result:=(x.index>=0) and (x.index<=imax) and (x.c=iptr.items[x.index]) and (istate.items[x.index]<>0);except;end;
end;
//## new ##
function tlookupmanagement.new(var x:integer):boolean;
var
   p:integer;
begin
try
//defaults
result:=false;
x:=-1;
//process
for p:=0 to imax do if (not ihold.items[p]) and (istate.items[p]=0) then
   begin
   general.croll(ihits,1);
   ihold.items[p]:=true;//hold
   x:=p;
   result:=true;
   break;
   end;//end of if
except;end;
end;
//## newthread ##
function tlookupmanagement.newthread(var x:integer):boolean;
var
   p:integer;
begin
try
//defaults
result:=false;
x:=-1;
//process
//.sync
syncthreads;
//.get
for p:=0 to (imaxthread-1) do if (ithreads[p]<>nil) and (not ithreads[p].running) then
   begin
   x:=p;
   result:=true;
   break;
   end;//end of if
except;end;
end;
//## open ##
function tlookupmanagement.open(url:string;tag:currency;autoclose:tlookupevent):tnetworkptr;
label
   skipend;
var
   ui:tparseurl;
   p:integer;
begin
try
//defaults
result.c:=0;
p:=-1;
//process
//.new
if not new(p) then goto skipend;
//.set
general.pu('http://'+url,'',ui,[]);
ionclose.items[p]:=tnotifyevent(autoclose);
iurl.items[p]^:=url;
ihost.items[p]^:=ui.h;
iip.items[p]:=0;
iport.items[p]:=ui.pt;
itag.items[p]:=tag;
//.pointer
general.irollb(iid,1,1);//1..MAXINT
result.index:=p;//index
result.id:=iid;
iptr.items[p]:=result.c;
istate.items[p]:=byte(lusOpen);
skipend:
except;end;
try
//unhold - held for only this procedure's lifetime
if (p<>-1) then ihold.items[p]:=false;
except;end;
end;
//## close ##
procedure tlookupmanagement.close(x:tnetworkptr);
var
   tmp:tlookupevent;
begin
try
if inuse[x] then
   begin
   //.doonclose
   tmp:=onclose[x];
   if assigned(tmp) then tmp(self,itag.items[x.index],x);
   //.reduce memory
   ionclose.items[x.index]:=nil;
   iurl.items[x.index]^:='';
   ihost.items[x.index]^:='';
   iptr.items[x.index]:=0;
   //.free
   istate.items[x.index]:=0;
   //sysinfo - count
   general.croll(networklookup,1);
   end;//end of if
except;end;
end;
//## closeall ##
procedure tlookupmanagement.closeall;
var
   p:integer;
begin
try;for p:=0 to imax do close(ptr[p]);except;end;
end;
//## getstate ##
function tlookupmanagement.getstate(x:tnetworkptr):tlookupstate;
begin
try;if inuse[x] then result:=tlookupstate(istate.items[x.index]) else result:=lusFree;except;end;
end;
//## statestr ##
function tlookupmanagement.statestr(x:tlookupstate):string;
begin
try
case x of
lusFree:result:='Free';
lusOpen:result:='Open';
lusFind:result:='Find';
lusDead:result:='Dead';
else
   result:='?';
end;//end of case
except;end;
end;
//## geturl ##
function tlookupmanagement.geturl(x:tnetworkptr):string;
begin
try;if inuse[x] then result:=iurl.items[x.index]^ else result:='';except;end;
end;
//## gethost ##
function tlookupmanagement.gethost(x:tnetworkptr):string;
begin
try;if inuse[x] then result:=ihost.items[x.index]^ else result:='';except;end;
end;
//## getip ##
function tlookupmanagement.getip(x:tnetworkptr):integer;
begin
try;if inuse[x] then result:=iip.items[x.index] else result:=0;except;end;
end;
//## getport ##
function tlookupmanagement.getport(x:tnetworkptr):word;
begin
try;if inuse[x] then result:=iport.items[x.index] else result:=0;except;end;
end;
//## gettag ##
function tlookupmanagement.gettag(x:tnetworkptr):currency;
begin
try;if inuse[x] then result:=itag.items[x.index] else result:=0;except;end;
end;
//## getonclose ##
function tlookupmanagement.getonclose(x:tnetworkptr):tlookupevent;
begin
try;if inuse[x] then result:=tlookupevent(ionclose.items[x.index]) else result:=nil;except;end;
end;
//## getptr ##
function tlookupmanagement.getptr(x:integer):tnetworkptr;
begin
try
if (x>=0) and (x<=imax) then result:=tnetworkptr(iptr.items[x])
else result.c:=0;
except;end;
end;
//## empty ##
function tlookupmanagement.empty:boolean;
begin
try;result:=(active=0);except;end;
end;
//## getactive ##
function tlookupmanagement.getactive:integer;
var
   p:integer;
begin
try
//defaults
result:=0;
//process
for p:=0 to imax do if (istate.items[p]<>0) then inc(result);
except;end;
end;
//## getpending ##
function tlookupmanagement.getpending:integer;
var
   p:integer;
   s:tlookupstate;
begin
try
//defaults
result:=0;
//process
for p:=0 to imax do
   begin
   s:=tlookupstate(istate.items[p]);
   if (s=lusOpen) or (s=lusFind) then inc(result);
   end;//end of loop
except;end;
end;
//## getdead ##
function tlookupmanagement.getdead(x:tnetworkptr):boolean;
begin
try;result:=(state[x]=lusDead);except;end;
end;

//############################### tnetwork #####################################
//## create ##
constructor tnetwork.create;
begin
//self
inherited;
//vars
mt.slowon(islowref);
isendfactor:=50;//50 times per second
ifastdelay:=frcmin(1000 div isendfactor,1);
iid:=0;
itimeout:=60000;//60 sec's
ilastsocket:=invalid_socket;
throttle:=196608;//6 x 32,767
//controls
idisableto:=tdynamicboolean.create;
ihold:=tdynamicboolean.create;
iisserver:=tdynamicboolean.create;
irecvnil:=tdynamicboolean.create;
istate:=tdynamicbyte.create;
istyle:=tdynamicbyte.create;
ierror:=tdynamicbyte.create;
iptr:=tdynamiccurrency.create;
iserverptr:=tdynamiccurrency.create;
ilook:=tdynamiccurrency.create;
isocket:=tdynamicinteger.create;
iip:=tdynamicinteger.create;
iipproxy:=tdynamicinteger.create;
ichoke:=tdynamicinteger.create;
itimeoutb:=tdynamiccurrency.create;
itime:=tdynamiccurrency.create;
irecv:=tdynamiccurrency.create;
isent:=tdynamiccurrency.create;
iport:=tdynamicword.create;
iproxy:=tdynamicstring.create;
iurl:=tdynamicstring.create;
ionaccept:=tdynamicnotifyevent.create;
ionread:=tdynamicnotifyevent.create;
ionwrite:=tdynamicnotifyevent.create;
ifromsocket:=tdynamiccurrency.create;//stores index references related to socket number
ilink:=tnotifylist.create;
//defaults (upto 256 sockets - can't exceed 256, since "tnetworkptr" handles only 0..255 for index)
ua:='';
isize:=0;
size:=1024;
//timer
itimer1000:=mt.new(_ontimer1000,1000,true);
itimer20:=mt.new(_ontimer20,200,true);
end;
//## destroy ##
destructor tnetwork.destroy;
begin
try
//timer
mt.del(itimer20);
mt.del(itimer1000);
//closeall
closeall;
//controls
freeobj(@ilink);
freeobj(@ihold);
freeobj(@iisserver);
freeobj(@irecvnil);
freeobj(@istate);
freeobj(@istyle);
freeobj(@ierror);
freeobj(@isocket);
freeobj(@iptr);
freeobj(@iserverptr);
freeobj(@ilook);
freeobj(@iip);
freeobj(@iipproxy);
freeobj(@ichoke);
freeobj(@itimeoutb);
freeobj(@itime);
freeobj(@irecv);
freeobj(@isent);
freeobj(@idisableto);
freeobj(@iport);
freeobj(@iproxy);
freeobj(@iurl);
freeobj(@ionaccept);
freeobj(@ionread);
freeobj(@ionwrite);
freeobj(@ifromsocket);
//session
if isession then WSACleanup;
//self
inherited;
except;end;
end;
//## stats ##
function tnetwork.stats(showheader:boolean;colsep,linesep:string):string;
var
   cc,p,len:integer;
   c:tnetworkptr;
   ns:tnetworkstyle;
   lt,tmp:string;
   ui:tparseurl;
begin
try
//defaults
result:='';
cc:=size;
len:=0;
if (colsep='') then colsep:=#9;
if (linesep='') then linesep:=rcode;
//process
//.header
if showheader then pushb(len,result,
   tsType+colsep+
   tsSent+colsep+
   tsRecv+colsep+
   tsIdle+colsep+
   tsResource+colsep+
   tsID+colsep+
   tsUrl+linesep);
//.total
pushb(len,result,
   tsTotal+colsep+
   general.curcomma(sentall)+colsep+
   general.curcomma(recvall)+colsep+
   '-'+colsep+
   '-'+colsep+
   '-'+colsep+
   '-'+colsep+
   linesep);
//.get
for p:=0 to max do
begin
c:=ptr[p];
if inuse[c] then
   begin
   //.type
   tmp:='';
   ns:=style[c];
   case ns of
   nwsClient:tmp:=tsClient;
   nwsClientRemote:tmp:=tsServerThread;
   nwsServer:tmp:=tsServer;
   nwsServerUDP:tmp:=tsServer+#32+tsUDP;
   else
      tmp:='-';
   end;//end of case
   tmp:=tmp+colsep;
   //.sent/recv
   tmp:=tmp+general.curcomma(sentbytes[c])+colsep+general.curcomma(recvbytes[c])+colsep;
   //.timeout progress (timeop)
   tmp:=tmp+timeop[c]+colsep;
   //.resource
   case ns of
   nwsClient:tmp:=tmp+_strip(ip[c])+colsep;
   nwsServerUDP,nwsServer,nwsClientRemote:tmp:=tmp+inttostr(port[c])+colsep;
   else
      tmp:=tmp+'-'+colsep;
   end;//end of case
   //.id
   tmp:=tmp+inttostr(c.index)+colsep;
   //.url
   case ns of
   nwsClient:begin
      general.pu('http://'+url[c],'',ui,[]);
      tmp:=tmp+ui.cu+colsep;
      end;//end of begin
   nwsClientRemote:begin
      tmp:=tmp+general.udv(url[c],'-')+colsep;//comment purposes only (url=request line=> e.g. "/HOME.HTM")
      end;//end of begin
   else
      tmp:=tmp+'-'+colsep;
   end;//end of case
   //.set
   pushb(len,result,tmp+linesep);
   //.dec
   dec(cc);
   end;//end of if
end;//end of loop
//.fill with blank lines (we end up with a fixed height list for stable display)
for p:=1 to cc do pushb(len,result,linesep);
//.finalise
pushb(len,result,'');
except;end;
end;
//## ehl ##
function tnetwork.ehl(var x:string):boolean;//exceeds header limit
begin
try;result:=(length(x)>nwHeaderLimit);except;end;
end;
//## setsize ##
procedure tnetwork.setsize(x:integer);
var
   tmp:currency;
   p,old:integer;
begin
try
//range
x:=frcmin(x,1);
//process
if (x<>isize) then
   begin
   //.get
   old:=isize;
   //.shrink - delete "sockets"
   if (x<isize) then for p:=(old-1) downto x do close(ptr[p]);
   //.set
   isize:=x;
   imax:=x-1;
   ihold.setparams(imax+1,imax+1,0);
   iisserver.setparams(imax+1,imax+1,0);
   irecvnil.setparams(imax+1,imax+1,0);
   istate.setparams(imax+1,imax+1,0);
   istyle.setparams(imax+1,imax+1,0);
   ierror.setparams(imax+1,imax+1,0);
   iptr.setparams(imax+1,imax+1,0);
   iserverptr.setparams(imax+1,imax+1,0);
   ilook.setparams(imax+1,imax+1,0);
   isocket.setparams(imax+1,imax+1,0);
   iip.setparams(imax+1,imax+1,0);
   iipproxy.setparams(imax+1,imax+1,0);
   ichoke.setparams(imax+1,imax+1,0);
   itime.setparams(imax+1,imax+1,0);
   itimeoutb.setparams(imax+1,imax+1,0);
   irecv.setparams(imax+1,imax+1,0);
   isent.setparams(imax+1,imax+1,0);
   idisableto.setparams(imax+1,imax+1,0);
   iport.setparams(imax+1,imax+1,0);
   iproxy.setparams(imax+1,imax+1,0);
   iurl.setparams(imax+1,imax+1,0);
   ionaccept.setparams(imax+1,imax+1,0);
   ionread.setparams(imax+1,imax+1,0);
   ionwrite.setparams(imax+1,imax+1,0);
   //.enlarge - reset timeout's
   if (x>isize) then
      begin
      tmp:=ms64;
      for p:=old to (x-1) do itime.items[p]:=tmp;
      end;//end of if
   end;//end of if
except;end;
end;
//## link ##
function tnetwork.link(_event:tnotifyevent):integer;
begin
try;result:=ilink.new(_event);except;end;
end;
//## unlink ##
procedure tnetwork.unlink(var _instance:integer);
begin
try;ilink.del(_instance);except;end;
end;
//## setua ##
procedure tnetwork.setua(x:string);
begin
try
//process
//.get
x:=ns.safeua(x);
if (x='') then x:=ns.safeua(programua);
//.set
iua:=x;
except;end;
end;
//## setthrottle ##
procedure tnetwork.setthrottle(x:integer);
var
   df:integer;
begin
try
//defaults
df:=frcmin(isendfactor div 10,2);
//set
ithrottle:=frcrange(x,1,nwMaxThrottle);
isendbuffer:=frcmin(ithrottle div df,1);
except;end;
end;
//## settimeout ##
procedure tnetwork.settimeout(x:currency);
begin
try;itimeout:=frccurmin(x,8000);except;end;
end;
//## htons ##
function tnetwork.htons(x:word):word;
var
   b,a:twrd2;
begin
try
//process
a.val:=x;
b.bytes[0]:=a.bytes[1];
b.bytes[1]:=a.bytes[0];
//return result
result:=b.val;
except;end;
end;
//## _ontimer20 ##
procedure tnetwork._ontimer20(sender:tobject);
begin
try
//notify
ilink.notify;
//interval
mt.interval[itimer20]:=mt.slowauto(islowref,ifastdelay);
except;end;
end;
//## _ontimer1000 ##
procedure tnetwork._ontimer1000(sender:tobject);
var
   p:integer;
begin
try
//.refill chokes
for p:=0 to imax do ichoke.items[p]:=ithrottle;
//.timeout
for p:=0 to imax do if timedout(p) then
   begin
   //..error
   if (istate.items[p]=byte(nwsOpen)) then ierror.items[p]:=byte(nweOpenTimeout)
   else if (istate.items[p]=byte(nwsIO)) then ierror.items[p]:=byte(nweIOTimeout);
   //..dead
   dodead(p);
   end;//end of if
except;end;
end;
//## getactive ##
function tnetwork.getactive:integer;
var
   p:integer;
begin
try
//defaults
result:=0;
//process
for p:=0 to imax do if (istate.items[p]<>0) then inc(result);
except;end;
end;
//## getstatecount ##
function tnetwork.getstatecount(x:tnetworkstate):integer;
var
   p:integer;
begin
try
//defaults
result:=0;
//process
for p:=0 to imax do if (x=tnetworkstate(istate.items[p])) then inc(result);
except;end;
end;
//## internalwndproc ##
function tnetwork.internalwndproc(hWnd:hwnd;msg:uint;wparam:wparam;lparam:lparam):lresult;
var//wrds[0]=mode, wrds[1]=error
   a:tint4;
   p:tnetworkptr;
begin
try
//defaults
result:=0;
//process
if (sysstate<=ssClosing) and (msg=cm_socketmessage) and (wparam>=0) and (wparam<ifromsocket.count) then
   begin
   //.socket (0..N) -> ptr
   p.c:=ifromsocket.items[wparam];
   if inuse[p] then
      begin
      //.get
      a.val:=lparam;
      //.decide
      case a.wrds[0] of
      FD_CONNECT:if (a.wrds[1]=0) and (istate.items[p.index]=byte(nwsOpen)) then
                    begin
                    itime.items[p.index]:=ms64;
                    istate.items[p.index]:=byte(nwsIO);
                    end
                 else
                    begin
                    ierror.items[p.index]:=byte(nweOpenTimeout);
                    dodead(p.index);
                    end;//end of if
      FD_CLOSE:dodead(p.index);
      FD_ACCEPT:fireevent(ionaccept.items[p.index],self);
      FD_READ:fireevent(ionread.items[p.index],self);
      FD_WRITE:fireevent(ionwrite.items[p.index],self);
      end;//end of case
      end;//end of if
   end;//end of if
except;end;
end;
//## dodead ##
procedure tnetwork.dodead(x:integer);
begin
try
if (x>=0) and (x<=imax) and (istate.items[x]<>0) and (istate.items[x]<>byte(nwsDead)) then
   begin
   istate.items[x]:=byte(nwsDead);
   end;//end of if
except;end;
end;
//## new ##
function tnetwork.new(var x:integer):boolean;
var
   p:integer;
begin
try
//defaults
result:=false;
x:=-1;
//process
for p:=0 to imax do if (not ihold.items[p]) and (istate.items[p]=0) then
   begin
   ihold.items[p]:=true;//hold
   x:=p;
   result:=true;
   break;
   end;//end of if
except;end;
end;
//## open ##
function tnetwork.open(url,proxy:string;var requesturl,host:string):tnetworkptr;
label
   skipend;
var
   ui:tparseurl;
   e,s,p:integer;
   tmp:string;
begin
try
//defaults
p:=-1;
result.c:=0;//error
s:=invalid_socket;
requesturl:='';
host:='';
//session
if (not isession) then isession:=(0=wsastartup(winsocketVersion,isessioninfo));
//process
//.new
if not new(p) then goto skipend;
//.socket
s:=n_socket(PF_INET,SOCK_STREAM,IPPROTO_TCP);
ilastsocket:=s;
if (s=invalid_socket) then goto skipend;
//.requesturl
general.pu('http://'+url,'',ui,[pusExcludeMark]);
if (proxy='') then tmp:='' else tmp:='http://'+ui.h;
requesturl:=tmp+ui.p+ui.f+ui.d;
host:=ui.h;
//.data
istyle.items[p]:=byte(nwsClient);
idisableto.items[p]:=false;
iisserver.items[p]:=false;
ierror.items[p]:=byte(nweOK);
isocket.items[p]:=s;
irecvnil.items[p]:=false;
iurl.items[p]^:=url;
iproxy.items[p]^:=proxy;
ichoke.items[p]:=ithrottle;
iip.items[p]:=0;//unknown at this stage
iipproxy.items[p]:=0;//unknown at this stage
iport.items[p]:=ui.pt;
ilook.items[p]:=0;//no lookup pointer yet
ionaccept.items[p]:=nil;
ionread.items[p]:=nil;
ionwrite.items[p]:=nil;
isent.items[p]:=0;
irecv.items[p]:=0;
//.style
wsaasyncselect(s,pg.handle,cm_socketmessage,longint(FD_READ or FD_WRITE or FD_CONNECT or FD_CLOSE));
//.pointer
general.irollb(iid,1,1);//1..MAXINT
result.index:=p;//index
result.id:=iid;
ifromsocket.value[s]:=result.c;//socket -> ptr (reverse lookup)
iptr.items[p]:=result.c;
iserverptr.items[p]:=0;
//.state
itime.items[p]:=ms64;//time active
istate.items[p]:=byte(nwsOpen);
//.lookup - proxy support fixed 21-OCT-2005
ilook.items[p]:=lm.open(general.aorbstr(url,proxy,proxy<>''),result.c,_onlookup).c;
if (ilook.items[p]=0) then
   begin
   ierror.items[p]:=byte(nweOpenAddress);
   dodead(p);
   end;//end of if
skipend:
except;end;
try
//unhold - held for only this procedure's lifetime
if (p<>-1) then ihold.items[p]:=false;
except;end;
end;
//## openserver ##
function tnetwork.openserver(_port,_maxconn:integer;_onaccept:tnotifyevent):tnetworkptr;
label
   skipend;
var
   a:tsockaddrin;
   s:tsocket;
   p:integer;
begin
try
//defaults
result.c:=0;
p:=-1;
s:=invalid_socket;
//session
if (not isession) then isession:=(0=wsastartup(winsocketVersion,isessioninfo));
//range
if (_port<=0) then exit;
if (_maxconn<=0) then _maxconn:=SOMAXCONN;
//process
//.new
if not new(p) then goto skipend;
//.socket
s:=n_socket(PF_INET,SOCK_STREAM,IPPROTO_TCP);
ilastsocket:=s;
if (s=invalid_socket) then goto skipend;
//.init
fillchar(a,sizeof(a),0);
a.sin_family:=PF_INET;
a.sin_addr.s_addr:=INADDR_ANY;
a.sin_port:=htons(_port);
//.bind
if (0<>n_bind(s,a,sizeof(a))) then goto skipend;
//.styles
wsaasyncselect(s,pg.handle,cm_socketmessage,longint(FD_READ or FD_WRITE or FD_ACCEPT or FD_CONNECT or FD_CLOSE));
//.listen
if (0<>n_listen(s,_maxconn)) then goto skipend;
//.pointer
general.irollb(iid,1,1);//1..MAXINT
result.index:=p;//index
result.id:=iid;
ifromsocket.value[s]:=result.c;//socket -> ptr (reverse lookup)
iptr.items[p]:=result.c;
iserverptr.items[p]:=0;
//.data
istyle.items[p]:=byte(nwsServer);
idisableto.items[p]:=false;
iisserver.items[p]:=true;
ierror.items[p]:=byte(nweOK);
isocket.items[p]:=s;
irecvnil.items[p]:=false;
iurl.items[p]^:='';
iproxy.items[p]^:='';
ichoke.items[p]:=ithrottle;
iip.items[p]:=0;//na
iipproxy.items[p]:=0;//na
iport.items[p]:=_port;//for comment purposes only, not used for server functions
ilook.items[p]:=0;//no lookup pointer yet
ionaccept.items[p]:=_onaccept;
isent.items[p]:=0;
irecv.items[p]:=0;
//.state
itime.items[p]:=ms64;//time active
istate.items[p]:=byte(nwsOpen);
skipend:
except;end;
try
//error - close socket
if (result.c=0) and (s<>invalid_socket) then n_closesocket(s);
//unhold - held for only this procedure's lifetime
if (p<>-1) then ihold.items[p]:=false;
except;end;
end;
//## openserverUDP ##
function tnetwork.openserverUDP(_port:integer):tnetworkptr;
label
   skipend;
var
   a:tsockaddrin;
   s:tsocket;
   p:integer;
begin
try
//defaults
result.c:=0;
p:=-1;
s:=invalid_socket;
//session
if (not isession) then isession:=(0=wsastartup(winsocketVersion,isessioninfo));
//range
if (_port<=0) then exit;
//process
//.new
if not new(p) then goto skipend;
//.socket
s:=n_socket(PF_INET,SOCK_DGRAM,IPPROTO_UDP);
ilastsocket:=s;
if (s=invalid_socket) then goto skipend;
//.init
fillchar(a,sizeof(a),0);
a.sin_family:=PF_INET;
a.sin_addr.s_addr:=n_htonl(INADDR_ANY);
a.sin_port:=htons(_port);
//.bind
if (0<>n_bind(s,a,sizeof(a))) then goto skipend;
//.non-blocking (program runs while waiting for data)
wsaasyncselect(s,pg.handle,cm_socketmessage,longint(FD_READ or FD_WRITE));//16JAN2008
//.pointer
general.irollb(iid,1,1);//1..MAXINT
result.index:=p;//index
result.id:=iid;
ifromsocket.value[s]:=result.c;//socket -> ptr (reverse lookup)
iptr.items[p]:=result.c;
iserverptr.items[p]:=0;
//.data
istyle.items[p]:=byte(nwsServerUDP);
idisableto.items[p]:=false;
iisserver.items[p]:=true;
ierror.items[p]:=byte(nweOK);
isocket.items[p]:=s;
irecvnil.items[p]:=false;
iurl.items[p]^:='';
iproxy.items[p]^:='';
ichoke.items[p]:=ithrottle;
iip.items[p]:=0;//na
iipproxy.items[p]:=0;//na
iport.items[p]:=_port;//for comment purposes only, not used for server functions
ilook.items[p]:=0;//no lookup pointer yet
ionaccept.items[p]:=nil;
isent.items[p]:=0;
irecv.items[p]:=0;
//.state
itime.items[p]:=ms64;//time active
istate.items[p]:=byte(nwsOpen);
skipend:
except;end;
try
//error - close socket
if (result.c=0) and (s<>invalid_socket) then n_closesocket(s);
//unhold - held for only this procedure's lifetime
if (p<>-1) then ihold.items[p]:=false;
except;end;
end;
//## acceptclient ##
function tnetwork.acceptclient(_serverptr:tnetworkptr;_serverport:word;_socket:tsocket):tnetworkptr;
label//_socket => server inbound client socket - translate into network pointer
   skipend;
var
   c:tsockaddrin;
   p:integer;
begin
try
//defaults
p:=-1;
result.c:=0;//error
//.slow state
mt.slowoff(islowref);
//check
if (_socket=invalid_socket) then exit;
//session
if (not isession) then isession:=(0=wsastartup(winsocketVersion,isessioninfo));
//process
//.new
if not new(p) then goto skipend;
//.socket
ilastsocket:=_socket;
//.data
istyle.items[p]:=byte(nwsClientRemote);
idisableto.items[p]:=false;
iisserver.items[p]:=false;
ierror.items[p]:=byte(nweOK);
isocket.items[p]:=_socket;
irecvnil.items[p]:=false;
iurl.items[p]^:='';
iproxy.items[p]^:='';
ichoke.items[p]:=ithrottle;
ns.remoteip(_socket,iip.items[p]);//get remote client's ip address
iipproxy.items[p]:=iip.items[p];//by default, set to same as ip (only change when we have a full header and can find "proxy-sourceip"
iport.items[p]:=_serverport;//for comment purposes only, not used for "clientremote" functions
ilook.items[p]:=0;//no lookup pointer yet
ionaccept.items[p]:=nil;
isent.items[p]:=0;
irecv.items[p]:=0;
//.pointer
general.irollb(iid,1,1);//1..MAXINT
result.index:=p;//index
result.id:=iid;
ifromsocket.value[_socket]:=result.c;//socket -> ptr (reverse lookup)
iptr.items[p]:=result.c;
iserverptr.items[p]:=currency(_serverptr);//allows this client socket to update it's server's sent/recv counters
//.state
itime.items[p]:=ms64;//time active
istate.items[p]:=byte(nwsIO);//straight to "connect"
skipend:
except;end;
try
//unhold - held for only this procedure's lifetime
if (p<>-1) then ihold.items[p]:=false;
//sysinfo - count
general.croll(networkhitsin,1);
except;end;
end;
//## _onlookup ##
procedure tnetwork._onlookup(sender:tobject;tag:currency;ptr:tnetworkptr);
var
   a:tsockaddrin;
   nptr:tnetworkptr;
   tmp:integer;
begin
try
//process
//.network pointer
nptr.c:=tag;
//.check
if inuse[nptr] then
   begin
   //.look - reset (assumes autoclose)
   ilook.items[nptr.index]:=0;
   //.time
   itime.items[nptr.index]:=ms64;
   //.set
   tmp:=lm.ip[ptr];
   iip.items[nptr.index]:=tmp;
   iipproxy.items[nptr.index]:=mip.rip(tmp);//store REAL actual value of website ip (since iip may well be a mapped version)
   iport.items[nptr.index]:=lm.port[ptr];
   //.decide
   //..bad
   if (iip.items[nptr.index]=0) then
      begin
      ierror.items[nptr.index]:=byte(nweOpenAddress);
      dodead(nptr.index);
      end
   else
   //..good
      begin
      //.connect
      fillchar(a,sizeof(a),0);
      a.sin_family:=PF_INET;
      a.sin_addr.s_addr:=iip.items[nptr.index];
      a.sin_port:=n_htons(iport.items[nptr.index]);
      if (socket_error=n_connect(isocket.items[nptr.index],a,sizeof(a))) then
         begin
         //.error
         if (WSAGetLastError<>WSAEWOULDBLOCK) then
            begin
            ierror.items[nptr.index]:=byte(nweOpenTimeout);
            dodead(nptr.index);
            end;//end of if
         end;//end of if
      end;//end of if
   end;//end of if
except;end;
end;
//## cansend ##
function tnetwork.cansend(x:tnetworkptr;var y:string;linger:boolean):boolean;
begin//Must always return TRUE if active and sometime it may be possible to send
try
result:=
 (x.index>=0) and
 (x.index<=imax) and
 (x.c=iptr.items[x.index]) and
 (
 (istate.items[x.index]=byte(nwsOpen)) or
 (istate.items[x.index]=byte(nwsIO))
 ) and
 (linger or (y<>''));
except;end;
end;
//## send ##
function tnetwork.send(x:tnetworkptr;var y:string):integer;
var
   len,tmp:integer;
   np:tnetworkptr;
begin
try
//defaults
result:=0;
//process
if cansend(x,y,false) and (istate.items[x.index]=byte(nwsIO)) and (ichoke.items[x.index]>=1) then
   begin
   len:=frcmin(frcmax(length(y),frcmax(ichoke.items[x.index],isendbuffer)),1);
   tmp:=n_send(isocket.items[x.index],pointer(y)^,len,0);
   if (tmp>=1) then
      begin
      //successful
      result:=tmp;
      //.shrink string
      delete(y,1,tmp);
      //.sent
      general.croll(sentall,tmp);
      general.croll(isent.items[x.index],tmp);
      //."remoteclient" then also update it's parent - server
      if (istyle.items[x.index]=byte(nwsClientRemote)) then
         begin
         np:=tnetworkptr(iserverptr.items[x.index]);
         if (nwsServer=style[np]) then general.croll(isent.items[np.index],tmp);
         end;//end of if
      //.shrink choke
      ichoke.items[x.index]:=frcmin(ichoke.items[x.index]-tmp,0);
      //.time
      itime.items[x.index]:=ms64;
      //.slow state
      mt.slowoff(islowref);
      end;//end of if
   end;//end of if
except;end;
end;
//## canrecv ##
function tnetwork.canrecv(x:tnetworkptr):boolean;
begin
try
result:=
 (x.index>=0) and
 (x.index<=imax) and
 (x.c=iptr.items[x.index]) and
 (
 (istate.items[x.index]=byte(nwsOpen)) or
 (istate.items[x.index]=byte(nwsIO)) or
 ((istate.items[x.index]=byte(nwsDead)) and (not irecvnil.items[x.index]))
 );
except;end;
end;
//## recv ##
function tnetwork.recv(x:tnetworkptr;var y:string):integer;
const//High speed, 100mbps multi-cycle recv. 26-JAN-2006
   bufsize=maxword;
var
   buf:array[0..(bufsize-1)] of char;
   zerocount,len,maxp,p,z:integer;
   tmp:string;
   np:tnetworkptr;
begin
try
//defaults
result:=0;
zerocount:=0;
maxp:=frcmin(isendbuffer div bufsize,1)*2;
//process
for p:=1 to maxp do
begin
if canrecv(x) and ((istate.items[x.index]=byte(nwsIO)) or (istate.items[x.index]=byte(nwsDead))) and (ichoke.items[x.index]>=1) then
   begin
   len:=frcmin(frcmax(bufsize,ichoke.items[x.index]),1);
   z:=n_recv(isocket.items[x.index],buf,len,0);
   if (z=0) then inc(zerocount);
   if (z>=1) then
      begin
      //successful
      zerocount:=0;
      inc(result,z);
      //.enlarge string
      setstring(tmp,buf,z);
      y:=y+tmp;
      //.recv
      general.croll(recvall,z);
      general.croll(irecv.items[x.index],z);
      //."remoteclient" then also update it's parent - server
      if (istyle.items[x.index]=byte(nwsClientRemote)) then
         begin
         np:=tnetworkptr(iserverptr.items[x.index]);
         if (nwsServer=style[np]) then general.croll(irecv.items[np.index],z);
         end;//end of if
      //.shrink choke
      ichoke.items[x.index]:=frcmin(ichoke.items[x.index]-z,0);
      //.time
      itime.items[x.index]:=ms64;
      //.slow state
      mt.slowoff(islowref);
      end
   //.connection is dead and all data has been drained from buffers
   else if (istate.items[x.index]=byte(nwsDead)) then irecvnil.items[x.index]:=true;
   //.zerocount
   if (zerocount>=8) then break;
   end
else break;//end of if
//.breath
if general.pause then application.processmessages;
end;//end of loop
except;end;
end;
//## canrecvfrom ##
function tnetwork.canrecvfrom(x:tnetworkptr):boolean;
begin
try
result:=
 (x.index>=0) and
 (x.index<=imax) and
 (x.c=iptr.items[x.index]) and (isocket.items[x.index]<>invalid_socket);
except;end;
end;
//## recvfrom ##
function tnetwork.recvfrom(x:tnetworkptr;var ca:tsockaddrin;var y:string):integer;
const
   bufsize=4096;
var
   buf:array[0..(bufsize-1)] of char;
   caLEN,len:integer;
begin
try
//defaults
result:=0;
caLEN:=sizeof(ca);
y:='';
//process
if canrecvfrom(x) then
   begin
   len:=n_recvfrom(isocket.items[x.index],buf,sizeof(buf),0,ca,caLEN);
   if (len>=1) then
      begin
      //.get
      setstring(y,buf,len);
      //.recv
      result:=len;
      general.croll(recvall,result);
      general.croll(irecv.items[x.index],result);
      end;//end of if
   end;
except;end;
end;
//## canrecvfrom ##
function tnetwork.cansendto(x:tnetworkptr):boolean;
begin
try
result:=
 (x.index>=0) and
 (x.index<=imax) and
 (x.c=iptr.items[x.index]) and (isocket.items[x.index]<>invalid_socket);
except;end;
end;
//## sendto ##
function tnetwork.sendto(x:tnetworkptr;var ca:tsockaddrin;var y:string):integer;
const//Timeout occurs after 5 seconds
   bufsize=4096;
var
   buf:array[0..(bufsize-1)] of char;
   v,len,caLEN:integer;
   t:currency;
   s:tsocket;
begin
try
//defaults
result:=0;
//check
if not cansendto(x) then exit;
//process
//.fill
len:=frcmax(length(y),bufsize);
if (len=0) then exit;
tonullstr(@buf,bufsize,y);
//.init
caLEN:=sizeof(ca);
s:=isocket.items[x.index];
t:=ms64;
//.send
repeat
v:=n_sendto(s,buf,len,0,ca,caLEN);
if (v>=1) then
   begin
   t:=ms64;
   inc(result,v);
   break;
   end;//end of if
//.breath
if general.pause then application.processmessages;
until ((ms64-t)>=5000) or (not cansendto(x));
//.stats
if (result>=1) and cansendto(x) then
   begin
   general.croll(nw.sentall,result);
   general.croll(isent.items[x.index],result);
   end;//end of if
except;end;
end;
//## recvinc ##
procedure tnetwork.recvinc(x:tnetworkptr;by:currency);
begin
try
if (by>=1) then
   begin
   general.croll(networkhitsin,1);
   general.croll(recvall,by);
   if canrecvfrom(x) then general.croll(irecv.items[x.index],by);
   end;//end of if
except;end;
end;
//## sentinc ##
procedure tnetwork.sentinc(x:tnetworkptr;by:currency);
begin
try
if (by>=1) then
   begin
   general.croll(networkhitsout,1);
   general.croll(sentall,by);
   if cansendto(x) then general.croll(isent.items[x.index],by);
   end;//end of if
except;end;
end;
//## close ##
procedure tnetwork.close(x:tnetworkptr);
var
   wasclient:boolean;
begin
try
if inuse[x] then
   begin
   //.reduce memory
   wasclient:=(istyle.items[x.index]=byte(nwsClient));
   istyle.items[x.index]:=byte(nwsUnknown);
   irecvnil.items[x.index]:=false;
   iproxy.items[x.index]^:='';
   iurl.items[x.index]^:='';
   iptr.items[x.index]:=0;
   iserverptr.items[x.index]:=0;
   irecv.items[x.index]:=0;
   isent.items[x.index]:=0;
   itimeoutb.items[x.index]:=0;
   ionaccept.items[x.index]:=nil;
   ionread.items[x.index]:=nil;
   ionwrite.items[x.index]:=nil;
   //.look
   if (ilook.items[x.index]<>0) then
      begin
      lm.close(tnetworkptr(ilook.items[x.index]));
      ilook.items[x.index]:=0;
      end;//end of if
   //.free
   istate.items[x.index]:=0;
   //.close
   n_closesocket(isocket.items[x.index]);
   //sysinfo - count
   if wasclient then general.croll(networkhitsout,1);
   end;//end of if
except;end;
end;
//## closeall ##
procedure tnetwork.closeall;
var
   p:integer;
begin
try;for p:=0 to imax do close(ptr[p]);except;end;
end;
//## getinuse ##
function tnetwork.getinuse(x:tnetworkptr):boolean;
begin
try;result:=(x.index>=0) and (x.index<=imax) and (x.c=iptr.items[x.index]) and (istate.items[x.index]<>0);except;end;
end;
//## getdead ##
function tnetwork.getdead(x:tnetworkptr):boolean;
begin
try;result:=(state[x]=nwsDead);except;end;
end;
//## timedout ##
function tnetwork.timedout(x:integer):boolean;
var//Note: for clients only
   s:tnetworkstate;
   d:currency;
begin
try
//defaults
result:=false;
//process
//.disable timeout
if idisableto.items[x] then
   begin
   itime.items[x]:=ms64;
   exit;
   end;//end of if
//.get
if not iisserver.items[x] then
   begin
   s:=tnetworkstate(istate.items[x]);
   if (s=nwsOpen) then d:=25000//25sec
   else if (s=nwsIO) then
      begin
      d:=itimeoutb.items[x];
      if (d<=0) then d:=itimeout;
      end
   else d:=0;
   //.set
   if (d>=1) then result:=((ms64-itime.items[x])>=d);
   end;//end of if
except;end;
end;
//## gettimeop ##
function tnetwork.gettimeop(x:tnetworkptr):string;
var//Note: for clients only
   s:tnetworkstate;
   d:currency;
begin
try
//defaults
result:='-';
//process
//.get
if inuse[x] and (not idisableto.items[x.index]) and (not iisserver.items[x.index]) then
   begin
   s:=tnetworkstate(istate.items[x.index]);
   if (s=nwsOpen) then d:=25000//25sec
   else if (s=nwsIO) then
      begin
      d:=itimeoutb.items[x.index];
      if (d<=0) then d:=itimeout;
      end
   else d:=0;
   //.set
   if (d>=1) then result:=general.insstr('*',itimeoutb.items[x.index]>=1)+inttostr(round(frccurmin((ms64-itime.items[x.index]),0)/1000))+'s';
   end;//end of if
except;end;
end;
//## geterror ##
function tnetwork.geterror(x:tnetworkptr):tnetworkerror;
begin
try;if inuse[x] then result:=tnetworkerror(ierror.items[x.index]) else result:=nweInvalidPtr;except;end;
end;
//## geterrorcode ##
function tnetwork.geterrorcode(x:tnetworkptr):integer;
begin
try
case error[x] of
nweOK:result:=wecOK;
nweOpenAddress:result:=wecAddressNotFound;
nweOpenTimeout:result:=wecConnectionFailed;
nweIOTimeout:result:=wecTimedOut;
nweInvalidPtr:result:=wecCancelled;
else
   result:=wecUndefinedError;
end;//end of case
except;end;
end;
//## ffc ##
procedure tnetwork.ffc(x:tnetworkptr;var header:string);//find and force closure - only if reply in header is "403"
begin
try
if inuse[x] then
   begin
   case general.src(header) of
   403:timeoutb[x]:=5000;//change IO timeout downto 5 seconds (stops Yahoo-slurp from keeping connection open for long periods!!!
   end;//end of case
   end;//end of if
except;end;
end;
//## gettime ##
function tnetwork.gettime(x:tnetworkptr):currency;
begin
try;if inuse[x] then result:=itime.items[x.index] else result:=ms64;except;end;
end;
//## settime ##
procedure tnetwork.settime(x:tnetworkptr;y:currency);
begin
try;if inuse[x] then itime.items[x.index]:=y;except;end;
end;
//## gettimeoutb ##
function tnetwork.gettimeoutb(x:tnetworkptr):currency;
begin
try;if inuse[x] then result:=itimeoutb.items[x.index] else result:=0;except;end;
end;
//## settimeoutb ##
procedure tnetwork.settimeoutb(x:tnetworkptr;y:currency);
begin
try;if inuse[x] then itimeoutb.items[x.index]:=frccurmin(y,0);except;end;
end;
//## getdisableto ##
function tnetwork.getdisableto(x:tnetworkptr):boolean;
begin
try;if inuse[x] then result:=idisableto.items[x.index] else result:=false;except;end;
end;
//## setdisableto ##
procedure tnetwork.setdisableto(x:tnetworkptr;y:boolean);
begin
try
if inuse[x] then
   begin
   idisableto.items[x.index]:=y;
   if y then itime.items[x.index]:=ms64;
   end;//end of if
except;end;
end;
//## getstate ##
function tnetwork.getstate(x:tnetworkptr):tnetworkstate;
begin
try;if inuse[x] then result:=tnetworkstate(istate.items[x.index]) else result:=nwsFree;except;end;
end;
//## getstyle ##
function tnetwork.getstyle(x:tnetworkptr):tnetworkstyle;
begin
try;if inuse[x] then result:=tnetworkstyle(istyle.items[x.index]) else result:=nwsUnknown;except;end;
end;
//## statestr ##
function tnetwork.statestr(x:tnetworkstate):string;
begin
try
case x of
nwsFree:result:='Free';
nwsOpen:result:='Open';
nwsIO:result:='IO';
nwsDead:result:='Dead';
else
   result:='?';
end;//end of case
except;end;
end;
//## getsocket ##
function tnetwork.getsocket(x:tnetworkptr):tsocket;
begin
try;if inuse[x] then result:=tsocket(isocket.items[x.index]) else result:=invalid_socket;except;end;
end;
//## geturl ##
function tnetwork.geturl(x:tnetworkptr):string;
begin
try;if inuse[x] then result:=iurl.items[x.index]^ else result:='';except;end;
end;
//## seturl ##
procedure tnetwork.seturl(x:tnetworkptr;y:string);
begin//Note: nwsClient=url is resource being worked only [static, read-pnly]
     //      nwsRemoteClient, nwsServer = url is a comment [dynamic, read/write]
try;if inuse[x] and (nwsClient<>tnetworkstyle(istyle.items[x.index])) then iurl.items[x.index]^:=y;except;end;
end;
//## getonaccept ##
function tnetwork.getonaccept(x:tnetworkptr):tnotifyevent;
begin
try;if inuse[x] then result:=ionaccept.items[x.index] else result:=nil;except;end;
end;
//## setonaccept ##
procedure tnetwork.setonaccept(x:tnetworkptr;y:tnotifyevent);
begin
try;if inuse[x] then ionaccept.items[x.index]:=y;except;end;
end;
//## getonread ##
function tnetwork.getonread(x:tnetworkptr):tnotifyevent;
begin
try;if inuse[x] then result:=ionread.items[x.index] else result:=nil;except;end;
end;
//## setonread ##
procedure tnetwork.setonread(x:tnetworkptr;y:tnotifyevent);
begin
try;if inuse[x] then ionread.items[x.index]:=y;except;end;
end;
//## getonwrite ##
function tnetwork.getonwrite(x:tnetworkptr):tnotifyevent;
begin
try;if inuse[x] then result:=ionwrite.items[x.index] else result:=nil;except;end;
end;
//## setonwrite ##
procedure tnetwork.setonwrite(x:tnetworkptr;y:tnotifyevent);
begin
try;if inuse[x] then ionwrite.items[x.index]:=y;except;end;
end;
//## getproxy ##
function tnetwork.getproxy(x:tnetworkptr):string;
begin
try;if inuse[x] then result:=iproxy.items[x.index]^ else result:='';except;end;
end;
//## getip ##
function tnetwork.getip(x:tnetworkptr):integer;
begin
try;if inuse[x] then result:=iip.items[x.index] else result:=0;except;end;
end;
//## getipb ##
function tnetwork.getipb(x:integer):integer;
begin
try;if (x>=0) and (x<=imax) and (istate.items[x]<>0) then result:=iip.items[x] else result:=0;except;end;
end;
//## getipproxy ##
function tnetwork.getipproxy(x:tnetworkptr):integer;
begin
try;if inuse[x] then result:=iipproxy.items[x.index] else result:=0;except;end;
end;
//## setipproxy ##
procedure tnetwork.setipproxy(x:tnetworkptr;y:integer);
begin
try;if inuse[x] then iipproxy.items[x.index]:=y;except;end;
end;
//## getipproxyb ##
function tnetwork.getipproxyb(x:integer):integer;
begin//high access mode (does not check "inuse")
try;if (x>=0) and (x<=imax) and (istate.items[x]<>0) then result:=iipproxy.items[x] else result:=0;except;end;
end;
//## getport ##
function tnetwork.getport(x:tnetworkptr):word;
begin
try;if inuse[x] then result:=iport.items[x.index] else result:=0;except;end;
end;
//## getsentbytes ##
function tnetwork.getsentbytes(x:tnetworkptr):currency;
begin
try;if inuse[x] then result:=isent.items[x.index] else result:=0;except;end;
end;
//## getrecvbytes ##
function tnetwork.getrecvbytes(x:tnetworkptr):currency;
begin
try;if inuse[x] then result:=irecv.items[x.index] else result:=0;except;end;
end;
//## getisserver ##
function tnetwork.getisserver(x:tnetworkptr):boolean;
begin
try;if inuse[x] then result:=iisserver.items[x.index] else result:=false;except;end;
end;
//## getlook ##
function tnetwork.getlook(x:tnetworkptr):tnetworkptr;
begin
try;if inuse[x] then result:=tnetworkptr(ilook.items[x.index]) else result.c:=0;except;end;
end;
//## getptr ##
function tnetwork.getptr(x:integer):tnetworkptr;
begin
try
if (x>=0) and (x<=imax) then result:=tnetworkptr(iptr.items[x])
else result.c:=0;
except;end;
end;
//## getserverptr ##
function tnetwork.getserverptr(x:tnetworkptr):tnetworkptr;
begin
try;if inuse[x] then result:=tnetworkptr(iserverptr.items[x.index]) else result.c:=0;except;end;
end;

//############################# tclientbasic ###################################
//## create ##
constructor tclientbasic.create;
begin
//self
inherited;
//vars
irecvlimit:=maxcur;//unlimited download
ilink:=-1;
iua:='';
//link
ilink:=nw.link(_ontimer);
end;
//## destroy ##
destructor tclientbasic.destroy;
begin
try
//controls
nw.unlink(ilink);
//self
inherited;
except;end;
end;
//## getua ##
function tclientbasic.getua:string;
begin
try
//defaults
result:=ns.safeua(iua);
//check
if (result='') then result:=ns.safeua(programua);
except;end;
end;
//## setrecvlimit ##
procedure tclientbasic.setrecvlimit(x:currency);
begin
try
//range
if (x<1) then x:=1;
//set
irecvlimit:=x;
except;end;
end;
//## _ontimer ##
procedure tclientbasic._ontimer(sender:tobject);
label
   skipone;
var
   v,z:string;
   tmpip,d,r,s,tmp,hlen,p:integer;
begin
try
//check
if (sysstate>=ssClosed) then exit;
//process
if iopendone then
   begin
   if nw.inuse[iptr] then
      begin
      //.ip
      if (not iipset) and (nw.state[iptr]=nwsIO)then
         begin
         iip:=nw.ip[iptr];
         iipset:=true;
         tmpip:=nw.ipproxy[iptr];
         //.banprivate
         if banprivate and misc.ipprivate(tmpip) then
            begin
            closecode(wecIPBanned);
            goto skipone;
            end;//end of if
         end;//end of if
      //.send
      s:=nw.send(iptr,iheadersendtmp);
      if (s>=1) then
         begin
         //.inco
         general.croll(sendbytes,s);
         if (sendbytesp<>nil) then general.croll(sendbytesp^,s);
         end;//end of if
      //.recv
      r:=nw.recv(iptr,z);
      //..add
      if (r>=1) then
         begin
         //.inc
         general.croll(recvbytes,r);
         if (recvbytesp<>nil) then general.croll(recvbytesp^,r);
         //.data
         if ihok then
            begin
            icontent:=icontent+z;
            general.croll(icontentbytes,length(z));
            //.range
            if (imaxbytes>=0) and (icontentbytes>imaxbytes) then
               begin
               d:=round(icontentbytes-imaxbytes);
               icontentbytes:=imaxbytes;
               icontent:=copy(icontent,1,length(icontent)-d);
               end;//end of if
            //.event
            if assigned(onrecv) then onrecv(self,iheader,icontent,false);
            end
         else
            begin
            iheader:=iheader+z;
            if ns.hlen(iheader,hlen) then
               begin
               ihok:=true;
               icontent:=copy(iheader,hlen+1,length(iheader));
               icontentbytes:=length(icontent);
               iheader:=copy(iheader,1,hlen);
               //.max bytes
               if misc.headerfind(iheader,'content-length: ',v) then imaxbytes:=frccurmin(strcur(v),0)
               else imaxbytes:=-1;//unknown
               //.range
               if (imaxbytes>=0) and (icontentbytes>imaxbytes) then
                  begin
                  d:=round(icontentbytes-imaxbytes);
                  icontentbytes:=imaxbytes;
                  icontent:=copy(icontent,1,length(icontent)-d);
                  end;//end of if
               //.onrecv
               if assigned(onrecv) then onrecv(self,iheader,icontent,true);
               end
            else if nw.ehl(iheader) then closecode(wecHeaderExceedsLimit);
            end;//end of if
         z:='';
         end;//end of if
      //.close
      if canclose and
         (
         (icontentbytes>irecvlimit) or
         ( (not nw.cansend(iptr,iheadersendtmp,false)) and (not nw.canrecv(iptr)) )
         )
         then closecode(wecNotUsed);
      end
   else closecode(wecNotUsed);
skipone:
   //.doclose
   if imustclose then doclose;
   end;//end of if
except;end;
end;
//## canopen ##
function tclientbasic.canopen:boolean;
begin
try;result:=(not ibusy) and (not imustclose) and (not icloselocked);except;end;
end;
//## open ##
function tclientbasic.open(_url,_proxy:string):boolean;
begin
try
//defaults
result:=false;
//process
if canopen then
   begin
   //.open
   ibusy:=true;
   if (iptr.c=0) then
      begin
      //.clear
      ihok:=false;
      iopendone:=false;
      iheadersend:='';
      iheadersendtmp:='';
      iheader:='';
      icontent:='';
      imaxbytes:=-1;
      icontentbytes:=0;
      iip:=0;
      iipset:=false;
      iurl:=_url;
      iproxy:=_proxy;
      iheadersend:='';
      icode:=wecOK;//OK
      iclosecode:=wecNotUsed;//not used
      sendbytes:=0;
      recvbytes:=0;
      //.open
      iptr:=nw.open(_url,_proxy,irequesturl,ihost);
      //.event
      if assigned(onopen) then onopen(self,irequesturl,ihost,iheadersend)
      else _onopen(self,irequesturl,ihost,iheadersend);//default
      //.sync
      iheadersendtmp:=iheadersend;
      //.set
      result:=(iptr.c<>0);
      iopendone:=result;
      end;//end of if
   //.close
   if not result then
      begin
      fireevent(onclose,self);
      ibusy:=false;
      end;//end of if
   end;//end of if
except;end;
end;
//## _onopen ##
procedure tclientbasic._onopen(sender:tobject;_requesturl,_host:string;var _header:string);
begin
try
_header:=
   'GET '+_requesturl+' HTTP/1.0'+rcode+
   'Accept: */*'+rcode+
   'Accept-Language: en-us'+rcode+
   'User-Agent: '+ua+rcode+
   'Host: '+_host+rcode+
   rcode;
except;end;
end;
//## canclose ##
function tclientbasic.canclose:boolean;
begin
try;result:=ibusy and (not imustclose) and (not icloselocked);except;end;
end;
//## close ##
procedure tclientbasic.close;
begin
try;closecode(wecCancelled);except;end;
end;
//## closecode ##
procedure tclientbasic.closecode(errcode:integer);
begin
try
if canclose then
   begin
   iclosecode:=errcode;
   imustclose:=true;
   end;//end of if
except;end;
end;
//## doclose ##
procedure tclientbasic.doclose;
begin
try
if imustclose and (not icloselocked) and (iptr.c<>0) then
   begin
   //.lock
   icloselocked:=true;
   //.stop
   iopendone:=false;
   //.code
   if (iclosecode<>wecNotUsed) then icode:=iclosecode
   else if (icontentbytes>irecvlimit) then icode:=wecDownloadExceedsLimit//26-AUG-2006
   else if (nw.errorcode[iptr]<>wecOK) then icode:=nw.errorcode[iptr]
   else if (maxbytes>=0) and (maxbytes<>contentbytes) then icode:=wecTransferBroken
   else if (iheader<>'') then icode:=general.src(iheader)
   else icode:=wecNoData;//no data
   //.ip - get remote client's ip address, if not already (ie connection dropped etc)
   if (iip=0) and (iptr.c<>0) then iip:=nw.ip[iptr];
   //.close
   nw.close(iptr);
   iptr.c:=0;
   //.onclose
   fireevent(onclose,self);
   //.clear
   iclosecode:=wecNotUsed;//not used
   ihok:=false;
   irequesturl:='';
   ihost:='';
   iheadersend:='';
   iheadersendtmp:='';
   iheader:='';
   icontent:='';
   imaxbytes:=-1;
   icontentbytes:=0;
   //.closed
   imustclose:=false;
   ibusy:=false;
   icloselocked:=false;
   //._onfinish;
   _onfinish(self);
   end;
except;end;
end;
//## _onfinish ##
procedure tclientbasic._onfinish(sender:tobject);
begin
{nil}
end;

//############################ tclientredirect #################################
//## create ##
constructor tclientredirect.create;
begin
//self
inherited create;
//vars
imaxredirect:=10;//28-OCT-2006, was MAXINT but new default is 10
//events
inherited onopen:=__onopen;
inherited onrecv:=__onrecv;
inherited onclose:=__onclose;
end;
//## destroy ##
destructor tclientredirect.destroy;
begin
try
//close
close;
//self
inherited;
except;end;
end;
//## canopen ##
function tclientredirect.canopen:boolean;
begin
try;result:=(not ibusy);except;end;
end;
//## open ##
function tclientredirect.open(_url,_proxy:string):boolean;
begin
try
//process
if canopen then
   begin
   //busy
   ibusy:=true;
   imustclose:=false;
   iredirecturl:='';
   iredirectcount:=0;
   iurl:=_url;//once only
   ilastheader:='';
   imaxbytes:=-1;
   icontentbytes:=0;
   result:=openb(_url,_proxy);
   end
else result:=false;
except;end;
end;
//## openb ##
function tclientredirect.openb(_url,_proxy:string):boolean;
begin
try
//defaults
result:=false;
//process
if (inherited canopen) then
   begin
   ifinalurl:=_url;
   result:=inherited open(_url,_proxy);
   end;//end of if
except;end;
end;
//## canclose ##
function tclientredirect.canclose:boolean;
begin
try;result:=ibusy and (inherited canclose);except;end;
end;
//## close ##
procedure tclientredirect.close;
begin
try;closecode(wecCancelled);except;end;
end;
//## closecode ##
procedure tclientredirect.closecode(errcode:integer);
begin
try
if canclose then
   begin
   imustclose:=true;
   inherited closecode(errcode);
   end;//end of if
except;end;
end;
//## __onopen ##
procedure tclientredirect.__onopen(sender:tobject;requesturl,host:string;var header:string);
var
   hlen:integer;
begin
try
//.first only
if (iredirectcount=0) then
   begin
   if assigned(onopen) then onopen(self,requesturl,host,header)
   else _onopen(sender,requesturl,host,header);//default
   //.remember original header
   ilastheader:=header;
   end
else
//.modify existing
   begin
   //.host
   misc.headeradd(ilastheader,'host: ',host);
   //.requesturl
   hlen:=length(ilastheader);
   ns.ahRLb(ilastheader,hlen,'s','*',requesturl,'*','*');
   header:=ilastheader;
   end;//end of if
except;end;
end;
//## __onrecv ##
procedure tclientredirect.__onrecv(sender:tobject;var header,content:string;first:boolean);
var
   ui:tparseurl;
   rooturl,tmp:string;
   _pos,src:integer;
   mustredirect:boolean;
begin
try
//defaults
mustredirect:=false;
//process
//.redirecting
if first then
   begin
   src:=general.src(header);
   tmp:='';
   rooturl:='';
   //.get
   if misc.isredirect(src) and misc.headerfind(header,'location: ',tmp) then
      begin
      //.filter
      general.pu('http://'+ifinalurl,'',ui,[]);
      _pos:=1;
      rooturl:='http://'+ui.cu;
      //.decide
      if (tmp[1]='/') then tmp:=ui.ca+tmp//"http://www.blaiz.net" + "/path/abc.html"
      else if not general.findtext(_pos,tmp,'://') then tmp:=ui.ca+ui.p+tmp;//"http://www.blaiz.net" + "index.html" or "../index.html" etc
      end;//end of if
   //.filter
   if (tmp<>'') then
      begin
      general.pu('http://'+tmp,'',ui,[]);
      tmp:='http://'+ui.cu;
      //.set - prevent redirection to self (same url)
      if (tmp<>'') and (comparetext(rooturl,tmp)<>0) then
         begin
         iredirecturl:=tmp;
         inc(iredirectcount);
         end;//end of if
      end;//end of if
   end;//end of if
//.event
if (iredirecturl='') or (iredirectcount>imaxredirect) then
   begin
   imaxbytes:=inherited maxbytes;
   icontentbytes:=inherited contentbytes;
   if assigned(onrecv) then onrecv(self,header,content,first);
   end;//end of if
except;end;
end;
//## __onclose ##
procedure tclientredirect.__onclose(sender:tobject);
begin
try
//.event
if (iredirecturl='') or (iredirectcount>imaxredirect) or imustclose then
   begin
   fireevent(onclose,self);
   iredirecturl:='';
   imustclose:=false;
   imaxbytes:=-1;
   icontentbytes:=0;
   ibusy:=false;
   end;//end of if
except;end;
end;
//## _onfinish ##
procedure tclientredirect._onfinish(sender:tobject);
var
   tmp:string;
begin
try
//.redirect
if ibusy and (iredirecturl<>'') then
   begin
   tmp:=iredirecturl;
   iredirecturl:='';
   openb(tmp,iproxy);
   end;//end of if
except;end;
end;
//## setmaxredirect ##
procedure tclientredirect.setmaxredirect(x:integer);
begin
try;imaxredirect:=frcmin(x,0);except;end;
end;

//########################## tclients ##########################################
//## create ##
constructor tclients.create;
var
   p:integer;
begin
//vars
imax:=high(iclients);
icount:=imax+1;
for p:=0 to imax do
begin
iclients[p]:=nil;
ivars[p]:=nil;
iinuse[p]:=false;
end;//end of loop
//controls
for p:=0 to imax do
begin
iclients[p]:=tclientredirect.create;
iclients[p].tag:=p;
iclients[p].onopen:=_onopen;
iclients[p].onclose:=_onclose;
ivars[p]:=tdynamictext.create;
iref[p]:=0;
end;//end of loop
end;
//## destroy ##
destructor tclients.destroy;
var
   p:integer;
begin
try
//controls
for p:=0 to imax do iinuse[p]:=true;
for p:=0 to imax do
begin
freeObj(@iclients[p]);
freeObj(@ivars[p]);
end;//end of loop
//self
inherited;
except;end;
end;
//## getrecvlimit ##
function tclients.getrecvlimit:currency;
begin
try;result:=iclients[0].recvlimit;except;end;
end;
//## setrecvlimit ##
procedure tclients.setrecvlimit(x:currency);
var
   p:integer;
begin
try
x:=frccurmin(x,0);
for p:=0 to high(iclients) do iclients[p].recvlimit:=x;
except;end;
end;
//## open ##
function tclients.open(_url,_proxy,_post:string;_index,_ref:integer):integer;
begin//_index - allows for direct client access
try
//defaults
result:=-1;
//process
//.index
if (_index>=0) then
   begin
   if not valid(_index) then exit;
   if not iclients[_index].canopen then exit;
   result:=_index;
   end
else new(result);
//.open
if (result>=0) then
   begin
   //.use alternative header (usually for POST) - leave blank to ignore
   ipost[result]:=_post;
   iref[result]:=_ref;
   //.open
   if not iclients[result].open(_url,_proxy) then result:=-1;
   end;//end of if
except;end;
end;
//## _onopen ##
procedure tclients._onopen(sender:tobject;_requesturl,_host:string;var _header:string);
begin
try
if assigned(fonopen) then fonopen(sender,_requesturl,_host,_header)
else if (ipost[(sender as tclientredirect).tag]<>'') then _header:=ipost[(sender as tclientredirect).tag]
else
   begin
   _header:=
   'GET '+_requesturl+' HTTP/1.0'+rcode+
   'Accept: */*'+rcode+
   'Accept-Language: en-us'+rcode+
   'User-Agent: '+programua+rcode+
   'Host: '+_host+rcode+
   rcode;
   end;//end of if
except;end;
end;
//## _onclose ##
procedure tclients._onclose(sender:tobject);
var
   p:integer;
begin
try
//process
//.event
fireevent(fonclose,sender);
//.reset
p:=(sender as tclientredirect).tag;
iref[p]:=0;
ivars[p].clear;
iinuse[p]:=false;
istr[p]:='';
istr2[p]:='';
ival[p]:=0;
ival2[p]:=0;
except;end;
end;
//## getactive ##
function tclients.getactive:integer;
var
   p:integer;
begin
try
//defaults
result:=0;
//process
for p:=0 to imax do if (iclients[p]<>nil) and (not iclients[p].canopen) then inc(result);
except;end;
end;
//## valid ##
function tclients.valid(x:integer):boolean;
begin
try;result:=(x>=0) and (x<=imax);except;end;
end;
//## getclient ##
function tclients.getclient(x:integer):tclientredirect;
begin
try;if valid(x) then result:=iclients[x] else result:=nil;except;end;
end;
//## getinuse ##
function tclients.getinuse(x:integer):boolean;
begin
try;if valid(x) then result:=iinuse[x] else result:=false;except;end;
end;
//## getvars ##
function tclients.getvars(x:integer):tdynamictext;
begin
try;if valid(x) then result:=ivars[x] else result:=nil;except;end;
end;
//## getref ##
function tclients.getref(x:integer):integer;
begin
try;if valid(x) then result:=iref[x] else result:=0;except;end;
end;
//## getstr ##
function tclients.getstr(x:integer):string;
begin
try;if valid(x) then result:=istr[x] else result:='';except;end;
end;
//## getstr2 ##
function tclients.getstr2(x:integer):string;
begin
try;if valid(x) then result:=istr2[x] else result:='';except;end;
end;
//## setstr ##
procedure tclients.setstr(x:integer;y:string);
begin
try;if valid(x) then istr[x]:=y;except;end;
end;
//## setstr2 ##
procedure tclients.setstr2(x:integer;y:string);
begin
try;if valid(x) then istr2[x]:=y;except;end;
end;
//## getval ##
function tclients.getval(x:integer):integer;
begin
try;if valid(x) then result:=ival[x] else result:=0;except;end;
end;
//## getval2 ##
function tclients.getval2(x:integer):integer;
begin
try;if valid(x) then result:=ival2[x] else result:=0;except;end;
end;
//## setval ##
procedure tclients.setval(x:integer;y:integer);
begin
try;if valid(x) then ival[x]:=y;except;end;
end;
//## setval2 ##
procedure tclients.setval2(x:integer;y:integer);
begin
try;if valid(x) then ival2[x]:=y;except;end;
end;
//## new ##
function tclients.new(var x:integer):boolean;
var
   p:integer;
begin
try
//defaults
result:=false;
x:=-1;
//process
//.scan
for p:=0 to imax do if (not iinuse[p]) and (iclients[p]<>nil) and iclients[p].canopen then
   begin
   result:=true;
   iinuse[p]:=true;
   x:=p;
   break;
   end;//end of if
except;end;
end;

//########################### tclientdownload ##################################
//## create ##
constructor tclientdownload.create;
begin
//self
inherited create;
//controls
ifile:=tfilepush.create;
//defaults
irootpath:='';
ifilename:='';
irealfilename:='';
end;
//## destroy ##
destructor tclientdownload.destroy;
begin
try
//close
close;
//controls
freeObj(@ifile);
//self
inherited;
except;end;
end;
//## getprogress ##
function tclientdownload.getprogress:single;
begin
try
//defaults
result:=-1;
//check
if (ifilename='') then exit;
//process
if (maxbytes>=0) then result:=general.cpercentage(contentbytes,maxbytes);
except;end;
end;
//## __onrecv ##
procedure tclientdownload.__onrecv(sender:tobject;var header,content:string;first:boolean);
label
   skipend;
var
   e:string;
   src,ec:integer;
begin
try
//self
inherited;
//process
if (iredirecturl='') and (ifile<>nil) then
   begin
   //.create
   if first then
      begin
      //.src
      src:=general.src(header);
      if (src<>wecOK) then
         begin
         closecode(src);
         goto skipend;
         end;//end of if
      //.filename
      ifilename:=misc.urlasfile('',finalurl,istyle);
      //.decode
      if decodeurl then
         begin
         general.swapchars(ifilename,'+',#32);
         net_decode_str(ifilename);
         end;//end of if
      //.idestfilename
      case (idestfilename='') of
      true:begin
         //.create dir
         forcedirectories(extractfilepath(misc.jpf(rootpath,ifilename)));
         //.check
         irealfilename:=misc.jpf(rootpath,ifilename);
         end;//end of begin
      false:begin
         //.create dir
         forcedirectories(extractfilepath(idestfilename));
         //.check
         irealfilename:=idestfilename;
         end;//end of begin
      end;//end of case
      if fileexists(irealfilename) and (not replaceexisting) then
         begin
         closecode(wecFileExists);
         goto skipend;
         end;//end of if
      //.open
      if not ifile.open(irealfilename,e) then
         begin
         if (e=gecFileInUse) then ec:=wecFileInUse
         else if (e=gecBadFileName) then ec:=wecBadFileName
         else ec:=wecUndefinedError;
         //.closecode - close with specific error code
         closecode(ec);
         end;//end of if
      end;//end of if
   //.push
   if ifile.canpush and (not ifile.push(content,e)) then
      begin
      //.error code
      if (e=gecOutOfDiskSpace) then ec:=wecOutOfDiskSpace
      else ec:=wecUndefinedError;
      //.closecode - close with specific error code
      closecode(ec);
      end;//end of if
   end;//end of if
//.reset
content:='';
skipend:
except;end;
end;
//## __onclose ##
procedure tclientdownload.__onclose(sender:tobject);
var
   tmp:string;
begin
try
//clear
if (ifile<>nil) then
   begin
   tmp:=ifile.filename;
   ifile.close;
   end else tmp:='';
//delete file
if (icode=wecCancelled) and (tmp<>'') and fileexists(tmp) then remfile(tmp);
//self
inherited;
//filename - clear after informing host
ifilename:='';
irealfilename:='';
except;end;
end;
//## getrootpath ##
function tclientdownload.getrootpath:string;
begin
try
if (irootpath<>'') then
   begin
   if not directoryexists(irootpath) then forcedirectories(irootpath);
   result:=asfolder(irootpath);
   end
else result:=bvfportable(bvfFiles+'Download Folder\');
except;end;
end;
//## setstyle ##
procedure tclientdownload.setstyle(x:turlfilestyle);
begin
try;istyle:=x;except;end;
end;

//############################ tclientremote ###################################
//## create ##
constructor tclientremote.create;
begin
//self
inherited;
//controls
new(icontent);
new(iheader);
//vars
oContentLength:=true;
irecvlimit:=maxint;//unlimited download
ilink:=-1;
isn:='';
//link
ilink:=nw.link(_ontimer);
end;
//## destroy ##
destructor tclientremote.destroy;
begin
try
//link
nw.unlink(ilink);
//ptr
nw.close(iptr);
//controls
dispose(icontent);
dispose(iheader);
//self
inherited;
except;end;
end;
//## getsn ##
function tclientremote.getsn:string;
begin
try
//defaults
result:=ns.safeua(isn);
//check
if (result='') then result:=ns.safeua(servername);
except;end;
end;
//## setrecvlimit ##
procedure tclientremote.setrecvlimit(x:integer);
begin
try
//range
if (x<1) then x:=1;
//set
irecvlimit:=x;
except;end;
end;
//## _onheader ##
procedure tclientremote._onheader;
var//Display request line (using URL}
   p:integer;
   tmp:string;
begin
try
//get
p:=1;
general.nextline(p,iheader^,tmp);
//set
nw.url[iptr]:=tmp;
//.ipproxy
nw.ipproxy[iptr]:=misc.readip(iheader^,iip);
//syncLOGHI
syncLOGHI;
except;end;
end;
//## syncLOGHI ##
procedure tclientremote.syncLOGHI;
begin
try
if log then
   begin
   case raw of
   false:ilogHI:=iheader^;
   true:ilogHI:=
      'GET / TCP'+rcode+
       'Content-Length: '+floattostrex2(imaxbytes+2)+rcode;//+2 for 16bit length header
   end;//end of case
   end;//end of if
except;end;
end;
//## limitpassed ##
function tclientremote.limitpassed(_ip:integer;_bytes:currency;var header:string):boolean;
begin
try;if (not raw) and (host<>nil) then result:=host.passed(_ip,_bytes,header) else result:=true;except;end;
end;
//## _ontimer ##
procedure tclientremote._ontimer(sender:tobject);
label//Important Note: If a security restriction is reached, system automatically switches
     //                to error code "403", shuting down "_onrequest" and "_onsend" events
     //                so that system can by itself push out a preformatted 403 error message
     //                without the aid of external help.
   skipend;
var
   a:twrd2;
   v,z:string;
   d,r,s,tmp,hlen,p:integer;
   _linger,_wait:boolean;
begin
try
//check
if (sysstate>=ssClosed) then exit;
//process
_linger:=false;
if iopendone then
   begin
   if nw.inuse[iptr] then
      begin
      //.ip
      if not iwaiting then
         begin
         //.recv
         if (not icansend) then
            begin
            r:=nw.recv(iptr,z);
            //..add
            if (r>=1) then
               begin
               //.inc
               general.croll(recvbytes,r);
               if (recvbytesp<>nil) then general.croll(recvbytesp^,r);
               //.raw - use industry standard "2 byte length header"
               if (r>=2) and raw and (not ihok) then
                  begin
                  //.get
                  a.chars[0]:=z[2];
                  a.chars[1]:=z[1];
                  ihok:=true;
                  //.max data to recv
                  imaxbytes:=a.val;
                  if (irecvlimit>=0) and (imaxbytes>irecvlimit) then imaxbytes:=irecvlimit;
                  //.header (two byte length)
                  iheader^:=copy(z,1,2);
                  delete(z,1,2);
                  end;//end of if
               //.data
               if ihok then
                  begin
                  //.set
                  pushlimitb(icontentbytes,tio1Mb,imaxbytes,icontent^,z);
                  //.event
                  if assigned(onrecv) then onrecv(self,iheader^,icontent^,false);
                  end
               else
                  begin
                  iheader^:=iheader^+z;
                  if ns.hlen(iheader^,hlen) then
                     begin
                     ihok:=true;
                     //.content
                     pushlimitb(icontentbytes,tio1Mb,maxint,icontent^,copy(iheader^,hlen+1,length(iheader^)));
                     //.header
                     iheader^:=copy(iheader^,1,hlen);
                     //.max bytes
                     if misc.headerfind(iheader^,'content-length: ',v) then imaxbytes:=frcmin(strint(v),0)
                     else imaxbytes:=-1;//unknown
                     //.recvlimit - special, modify "content-length=>imaxbytes" to reflect new "recvlimit" range
                     if (irecvlimit>=0) and (imaxbytes>irecvlimit) then imaxbytes:=irecvlimit;
                     //.comment (using in-bound header)
                     _onheader;
                     //.limit check - if failed, switch to 403 mode, skipping "_onrequest" and outputing 403 error
                     if not limitpassed(iip,icontentbytes,iheader^) then icode:=wecForbidden;
                     //.range
                     pushlimitb(icontentbytes,tio1Mb,imaxbytes,icontent^,'');
                     //.onrecv
                     if (icode<>wecForbidden) and assigned(onrecv) then onrecv(self,iheader^,icontent^,true);
                     end
                  else if nw.ehl(iheader^) then
                     begin
                     syncLOGHI;
                     closecode(wecHeaderExceedsLimit);
                     end;//end of if
                  end;//end of if
               z:='';
               end;//end of if
            //.recv -> send
            if ihok and (icontentbytes>=imaxbytes) then
               begin
               //.wait
               iwaiting:=true;
               _wait:=true;
               //.finalise
               pushlimitb(icontentbytes,tio1Mb,imaxbytes,icontent^,'');
               //.disable timeout
               nw.disableto[iptr]:=true;
               //.event
               if (icode<>wecForbidden) and assigned(onrequest) then
                  begin
                  onrequest(self,iheader^,icontent^,_wait);
                  //unwait has already been trigger so escape this situation - 10JAN2008
                  if not iwaiting then goto skipend;
                  end
               else
                  begin
                  //.force default reply
                  iheader^:='';
                  icontent^:='';
                  _wait:=false;
                  end;//end of if
               //.reset timeout period
               imaxbytes:=length(icontent^);
               icontentbytes:=0;
               nw.time[iptr]:=ms64;
               //Note: upto host to call "unwait" to un-pause connection before timeout
               if not _wait then unwait;
               end;//end of if
            end
         else
            begin
            //.send
            if (iheader^<>'') then s:=nw.send(iptr,iheader^)
            else if (icontent^<>'') then
               begin
               s:=nw.send(iptr,icontent^);
               if (s>=1) then general.iroll(icontentbytes,s);
               end;//end of if
            if (s>=1) then
               begin
               //.inc
               general.croll(sendbytes,s);
               if (sendbytesp<>nil) then general.croll(sendbytesp^,s);
               end;//end of if
            //.onsend
            if (icode<>wecForbidden) and (length(icontent^)=0) and assigned(onsend) then onsend(self,content^,_linger);
            end;//end of if
         end;//end of if (end of "waiting" if)
      //.close
      if canclose and
         (
         ( (not icansend) and ((not nw.canrecv(iptr)) or (iwaiting and nw.dead[iptr])) ) or
         ( (icansend and ((not nw.cansend(iptr,iheader^,false)) and (not nw.cansend(iptr,icontent^,_linger)))) )
         )
         then closecode(wecNotUsed);
     end
   else closecode(wecNotUsed);
skipend:
   //.doclose
   if imustclose then doclose;
   end;//end of if
except;end;
end;
//## unwait ##
procedure tclientremote.unwait;
var
   a:twrd2;
   tmp:string;
begin
try
//check
if not iwaiting then exit;
//process
//.range
if (iheader^='') then
   begin
   case raw of
   false:begin
      icontent^:=wec.e403Forbidden;
      general.whBUFFERS(iheader^,icontent^,sn,'','html','',wecForbidden,false);
      end;//end of begin
   true:begin//iheader^ must contain 2-byte length
      a.val:=frcrange(length(icontent^),0,maxword);
      //Note: don't fill "iheader^", since it will require 2-Send-Loops and some programs expect the entire block as one single packet and stop listing
      iheader^:='';
      icontent^:=a.chars[1]+a.chars[0]+copy(icontent^,1,a.val);
      end;//end of begin
   end;//end of case
   end;//end of if
//.insert "content-length" into out-going header (if not present)
if (not raw) and oContentLength and (not misc.headerfind(iheader^,'content-length: ',tmp)) then misc.headeradd(iheader^,'Content-Length: ',inttostr(length(icontent^)));
//.continue
case raw of
false:ilogHO:=iheader^;//always assign since this is used in the "doclose" procedure and "iheader^" disappears as data is returned to client
true:ilogHO:=
      'TCP '+inttostr(icode)+#32+'-'+rcode+
      'Content-Length: '+inttostr(length(icontent^))+rcode;
end;//end of case
nw.disableto[iptr]:=false;//re-enable timeout
icansend:=true;
iwaiting:=false;
//.detect 403's etc
if (not raw) and ffc then nw.ffc(iptr,iheader^);
except;end;
end;
//## canopen ##
function tclientremote.canopen:boolean;
begin
try;result:=(iptr.c=0) and (not ibusy) and (not imustclose) and (not icloselocked);except;end;
end;
//## open ##
function tclientremote.open(_ptr:tnetworkptr):boolean;
begin
try
//defaults
result:=false;
//check
if (_ptr.c=0) then exit;
//process
if canopen then
   begin
   //.open
   ibusy:=true;
   //.clear
   itransactionstart:=ms64;
   ihok:=false;
   iopendone:=false;
   ilogHI:='';
   ilogHO:='';
   iheader^:='';
   icontent^:='';
   imaxbytes:=-1;
   icontentbytes:=0;
   iip:=0;
   icode:=wecOK;//OK
   iclosecode:=wecNotUsed;//not used
   sendbytes:=0;
   recvbytes:=0;
   iwaiting:=false;
   icansend:=false;
   logextra:='';
   logextralines:='';
   //.open
   iptr:=_ptr;
   //.ip
   iip:=nw.ip[iptr];
   //.set
   result:=(iptr.c<>0);
   iopendone:=result;
   //.close
   if not result then
      begin
      fireevent(onclose,self);
      ibusy:=false;
      end;//end of if
   end;//end of if
except;end;
end;
//## canclose ##
function tclientremote.canclose:boolean;
begin
try;result:=ibusy and (not imustclose) and (not icloselocked);except;end;
end;
//## close ##
procedure tclientremote.close;
begin
try;closecode(wecCancelled);except;end;
end;
//## closecode ##
procedure tclientremote.closecode(errcode:integer);
begin
try
if canclose then
   begin
   iclosecode:=errcode;
   imustclose:=true;
   end;//end of if
except;end;
end;
//## doclose ##
procedure tclientremote.doclose;
begin
try
if imustclose and (not icloselocked) and (iptr.c<>0) then
   begin
   //.lock
   icloselocked:=true;
   //.stop
   iopendone:=false;
   //.code
   if (iclosecode<>wecNotUsed) then icode:=iclosecode
   else if (nw.errorcode[iptr]<>wecOK) then icode:=nw.errorcode[iptr]
   else if (ilogHO<>'') then icode:=general.src(ilogHO)
   else icode:=general.aorb(wecNoData,wecOK,raw);//no data or OK(raw)
   //.ip - get remote client's ip address, if not already (ie connection dropped etc)
   if (iip=0) and (iptr.c<>0) then ns.remoteip(nw.socket[iptr],iip);
   //.close
   nw.close(iptr);
   iptr.c:=0;
   //.onclose
   fireevent(onclose,self);
   //.log
   if log then rawlog.addheaderb(@ilogHI,@ilogHO,icode,ip,icontentbytes,itransactionstart,logextra,logextralines,raw);
   //.bandwidth counting (out-going only)
   if (fsecip<>nil) then fsecip.passed(misc.readIP(ilogHI,iip),icontentbytes,icode,false,true);
   //.clear
   iclosecode:=wecNotUsed;//not used
   ihok:=false;
   ilogHI:='';//log header in
   ilogHO:='';//log header out
   iheader^:='';
   icontent^:='';
   logextra:='';
   imaxbytes:=-1;
   icontentbytes:=0;
   icansend:=false;
   iwaiting:=false;
   //.closed
   imustclose:=false;
   ibusy:=false;
   icloselocked:=false;
   //._onfinish;
   _onfinish(self);
   end;
except;end;
end;
//## _onfinish ##
procedure tclientremote._onfinish(sender:tobject);
begin
{nil}
end;

//## tclientproxy ##############################################################
//## create ##
constructor tclientproxy.create;
begin
//self
inherited create;
//vars
iid:=general.machineserialSTR+'-'+general.programserialSTR;
end;
//## destroy ##
destructor tclientproxy.destroy;
begin
try
//close
close;
//self
inherited;
except;end;
end;
//## unwait ##
procedure tclientproxy.unwait;
begin
//nil
end;
//## _onfinish ##
procedure tclientproxy._onfinish(sender:tobject);
begin
try
//.out
ihok:=false;
ioutonce:=false;
nw.close(iout);
iout.c:=0;
icontent^:='';
iheader^:='';
icontentbytes:=0;
except;end;
end;
//## _ontimer ##
procedure tclientproxy._ontimer(sender:tobject);
const
   buffersize=128000;
label
   skipend;
var
   v,z:string;
   d,r,s,tmp,hlen,p:integer;
   _linger,_wait:boolean;
   _url,_requesturl,_host:string;
begin
try
//check
if (sysstate>=ssClosed) then exit;
//process
_linger:=false;
if iopendone then
   begin
   if nw.inuse[iptr] then
      begin
      if not iwaiting then
         begin
         //RECV (in -> out) ----------------------------------------------------
         if (not icansend) then
            begin
            if (length(icontent^)<buffersize) then
               begin
               r:=nw.recv(iptr,z);
               //..add
               if (r>=1) then
                  begin
                  //.inc
                  general.croll(recvbytes,r);
                  if (recvbytesp<>nil) then general.croll(recvbytesp^,r);
                  //.data
                  if ihok then
                     begin
                     icontent^:=icontent^+z;
                     general.iroll(icontentbytes,r);
                     end
                  else
                     begin
                     iheader^:=iheader^+z;
                     if ns.hlen(iheader^,hlen) then
                        begin
                        ihok:=true;
                        //.content
                        icontent^:=icontent^+copy(iheader^,hlen+1,length(iheader^));
                        icontentbytes:=length(icontent^);
                        //.header
                        iheader^:=copy(iheader^,1,hlen);
                        //.max bytes
                        if misc.headerfind(iheader^,'content-length: ',v) then imaxbytes:=frcmin(strint(v),0)
                        else imaxbytes:=-1;//unknown
                        //.comment (using in-bound header)
                        _onheader;
                        //.start
                        if not ioutonce then
                           begin
                           //.security
                           _url:='';
                           if (not limitpassed(iip,icontentbytes,iheader^)) or (not security(iip,iheader^,icontent^,_url)) then
                              begin
                              //.403 - forbidden
                              iheader^:='';
                              icontent^:=wec.e403Forbidden;
                              general.whBUFFERS(ilogHO,icontent^,sn,'','html','',wecForbidden,false);
                              //.detect 403's etc
                              if ffc then nw.ffc(iptr,ilogHO);
                              //.switch to "send"
                              ihok:=false;
                              icansend:=true;
                              ioutonce:=true;
                              icontent^:=ilogHO+icontent^;
                              goto skipend;
                              end
                           else
                              begin
                              //.out
                              ioutonce:=true;
                              iout:=nw.open('http://'+_url,'',_requesturl,_host);
                              end;//end of if
                           end;//end of if
                       end
                     else if nw.ehl(iheader^) then
                        begin
                        syncLOGHI;
                        closecode(wecHeaderExceedsLimit);
                        end;//end of if
                  end;//end of if
               end;//end of if - add
            z:='';
            end;//end of if
            //.push (in => out)
            if ioutonce then
               begin
               //.check
               if not nw.inuse[iout] then closecode(wecTransferBroken)
               else if (not nw.cansend(iout,iheader^,false)) and (not nw.cansend(iout,icontent^,true)) then closecode(wecTransferBroken);
               //.send
               if (iheader^<>'') then nw.send(iout,iheader^)
               else if (icontent^<>'') then nw.send(iout,icontent^);
               end;//end of if
            //SWITCH --------------------------------------------------------------
            //.recv -> send
            if ihok and (icontentbytes>=imaxbytes) and (length(iheader^)=0) and (length(icontent^)=0) then
               begin
               ihok:=false;
               icansend:=true;
               end;//end of if
            end
         else
         //SEND (in <- out) ----------------------------------------------------
            begin
            //.get
            if ioutonce and (length(icontent^)<buffersize) then
               begin
               //.get
               r:=nw.recv(iout,z);
               if (r>=1) then
                  begin
                  icontent^:=icontent^+z;
                  //.reply header - for internal purposes only
                  if not ihok then
                     begin
                     iheader^:=iheader^+z;
                     if ns.hlen(iheader^,hlen) then
                        begin
                        //.detect 403's etc
                        if ffc then nw.ffc(iptr,iheader^);
                        //.continue
                        ilogHO:=iheader^;
                        iheader^:='';
                        ihok:=true;
                        end;//end of if
                     end;//end of if
                  end;//end of if
                //.check
               if (length(icontent^)=0) then
                  begin
                  if not nw.inuse[iout] then closecode(wecNotUsed)
                  else if not nw.canrecv(iout) then closecode(wecNotUsed);
                  end;//end of if
               end;//end of if
            //.set
            if (icontent^<>'') then
               begin
               s:=nw.send(iptr,icontent^);
               if (s>=1) then
                  begin
                  general.croll(sendbytes,s);
                  general.iroll(icontentbytes,s);
                  if (sendbytesp<>nil) then general.croll(sendbytesp^,s);
                  end;//end of if
               end;//end of if
            end;//end of if
         end;//end of if (end of "waiting" if)
      //.close
      if canclose and
         (
         ( (not icansend) and ((not nw.canrecv(iptr)) or (iwaiting and nw.dead[iptr])) ) or
         ( (icansend and (not nw.cansend(iptr,icontent^,true))) )
         )
         then closecode(wecNotUsed);
     end
   else closecode(wecNotUsed);
   //.doclose
   if imustclose then doclose;
   end;//end of if
skipend:
except;end;
end;
//## security ##
function tclientproxy.security(ip:integer;var header,content,url:string):boolean;
var
   ok,_wait:boolean;
   t,u,p,v:string;
   i,hlen:integer;
   ui:tparseurl;
begin//Note: 1) fill "url" with redirection address (e.g. url=10.0.0.33)
try  //      2) use ip/header to determine if access is permitted for current user
//defaults
url:='';
_wait:=false;
//collision prevention
misc.headerfind(header,'proxy-id: ',v);
if (v='') then
   begin
   misc.headeradd(header,'Proxy-Id: ',iid);
   misc.headeradd(header,'Proxy-SourceIP: ',_strip(ip));
   end
else if (v=iid) then
   begin
   result:=false;
   exit;
   end;//end of if
//remove proxy formatting in "request line" (GET http://abc.com XXX => GET / XXX)
hlen:=length(header);
ns.ahRL(header,hlen,'g',t,u,p,v);
ok:=false;
if (u='') then
   begin
   u:='/';
   ok:=true;
   end
else if (u<>'') and (u[1]<>'/') then
   begin
   general.pu('http://'+u,'',ui,[]);
   u:=ui.p+ui.f+ui.d+ui.m;
   ok:=true;
   end;//end of if
if ok then ns.ahRLb(header,hlen,'s','*',u,'*','*');
//security
result:=assigned(onrequest) and onrequest(self,header,content,_wait);
//url
if result then
   begin
   //.get
   if assigned(onurl) then onurl(self,header,content,url);
   //.check
   result:=(url<>'');
   end;
except;end;
end;

//############################ tserverbasic ####################################
//## create ##
constructor tserverbasic.create;
var
   p:integer;
begin
//self
inherited;
//vars
for p:=low(iclients) to high(iclients) do iclients[p]:=nil;
iopentime:=ms64;
iptr.c:=0;
iport:=0;//no in use
iports:='';
imaxconn:=0;//prime var
maxconn:=20;
//timer
itimer:=mt.new(_ontimer,1000,true);
end;
//## destroy ##
destructor tserverbasic.destroy;
var
   p:integer;
begin
try
//timer
mt.del(itimer);
//close
_close;
//controls
for p:=(imaxconn-1) downto 0 do freeObj(@iclients[p]);
//self
inherited;
except;end;
end;
//## getaddress ##
function tserverbasic.getaddress:string;
begin
try;result:='http://localhost'+general.insstr(':'+inttostr(port),port<>80)+'/';except;end;
end;
//## getlog ##
function tserverbasic.getlog:boolean;//21-MAY-2006
begin
try;result:=iclients[0].log;except;end;
end;
//## setlog ##
procedure tserverbasic.setlog(x:boolean);
begin
try;iclients[0].log:=x;syncall;except;end;
end;
//## getraw ##
function tserverbasic.getraw:boolean;
begin
try;result:=iclients[0].raw;except;end;
end;
//## setraw ##
procedure tserverbasic.setraw(x:boolean);
begin
try;iclients[0].raw:=x;syncall;except;end;
end;
//## getrecvlimit ##
function tserverbasic.getrecvlimit:integer;
begin
try;result:=clients[0].recvlimit;except;end;
end;
//## setrecvlimit ##
procedure tserverbasic.setrecvlimit(x:integer);
begin
try;iclients[0].recvlimit:=x;syncall;except;end;
end;
//## getffc ##
function tserverbasic.getffc:boolean;
begin
try;result:=clients[0].ffc;except;end;
end;
//## setiplimit ##
procedure tserverbasic.setiplimit(x:integer);
begin
try;iiplimit:=frcmin(x,0);except;end;
end;
//## setffc ##
procedure tserverbasic.setffc(x:boolean);
begin
try;iclients[0].ffc:=x;syncall;except;end;
end;
//## syncall ##
procedure tserverbasic.syncall;
var
   p:integer;
begin
try
for p:=1 to (imaxconn-1) do if (clients[p]<>nil) then
   begin
   clients[p].ffc:=clients[0].ffc;
   clients[p].recvlimit:=clients[0].recvlimit;
   clients[p].log:=clients[0].log;
   end;//end of if
except;end;
end;
//## getclient ##
function tserverbasic.getclient(x:integer):tclientremote;
begin
try
//defaults
result:=nil;
//process
if (x>=0) and (x<imaxconn) then result:=iclients[x];
except;end;
end;
//## _ontimer ##
procedure tserverbasic._ontimer(sender:tobject);
begin
try
//check
if (sysstate>=ssClosed) then exit;
//process
if ((ms64-iopentime)>=5000) then
   begin
   //.set
   case (iptr.c<>0) of
   true:if (iports='') then _close;
   false:if (iports<>'') then _open;
   end;//end of case
   //.reset
   iopentime:=ms64;
   end;//end of if
except;end;
end;
//## portrange ##
function tserverbasic.portrange(_from,_to:integer):string;
begin
try;result:=misc.numbers(_from,_to,',');except;end;
end;
//## setports ##
procedure tserverbasic.setports(x:string);
begin
try
if (x<>iports) then
   begin
   iports:=x;
   _close;
   iopentime:=ms64-9999;//try straight away
   end;//end of if
except;end;
end;
//## _open ##
procedure tserverbasic._open;
var
   p:integer;
begin
try
//close
if (iptr.c<>0) then _close;
//open
if (iptr.c=0) and (iports<>'') then
   begin
   p:=freeport(iports,false);
   iptr:=nw.openserver(p,0,internalonaccept);
   if (iptr.c<>0) then
      begin
      iport:=p;
      iportbusy:=false;
      end
   else iportbusy:=true;
   end;//end of if
except;end;
end;
//## _close ##
procedure tserverbasic._close;
begin
try
if (iptr.c<>0) then
   begin
   //.port
   iportbusy:=false;
   iport:=0;
   //.socket
   nw.close(iptr);
   //.pointer
   iptr.c:=0;
   end;//end of if
except;end;
end;
//## getonline ##
function tserverbasic.getonline:boolean;
begin
try;result:=(iptr.c<>0) and (iport<>0);except;end;
end;
//## setmaxconn ##
procedure tserverbasic.setmaxconn(x:integer);
var
   p,old:integer;
begin
try
//range
x:=frcrange(x,1,high(iclients)+1);
old:=imaxconn;
//process
if (x<>old) then
   begin
   //.enlarge
   if (x>old) then
      begin
      for p:=old to (x-1) do
      begin
      iclients[p]:=createclient;
      iclients[p].tag:=p;//15-JUl-2005
      iclients[p].host:=self;//12-NOV-2006
      initclient(iclients[p]);
      end;//end of loop
      imaxconn:=x;
      end
   //.shrink
   else if (x<old) then
      begin
      imaxconn:=x;
      for p:=(old-1) downto x do freeObj(@iclients[p]);
      end;//end of if
   end;//end of if
except;end;
end;
//## initclient ##
procedure tserverbasic.initclient(x:tclientremote);
begin
try
x.sendbytesp:=@sendbytes;
x.recvbytesp:=@recvbytes;
x.log:=log;
x.onrequest:=_onrequest;
x.onsend:=_onsend;
x.onclose:=_onclose;
except;end;
end;
//## createclient ##
function tserverbasic.createclient:tclientremote;
begin
try;result:=tclientremote.create;except;end;
end;
//## connactivepeak ##
function tserverbasic.connactivepeak(reset:boolean):integer;
begin
try
result:=iconnactivepeak;
if (result<connactive) then result:=connactive;
if reset then iconnactivepeak:=0;
except;end;
end;
//## internalonaccept ##
procedure tserverbasic.internalonaccept(sender:tobject);
var
  a:tsockaddrin;
  sa,old:integer;
  caller:tsocket;
  accepted:boolean;
  socket:tsocket;
begin
try
//defaults
caller:=invalid_socket;
sa:=sizeof(old);
//process
//.check
socket:=nw.socket[iptr];
if (socket=invalid_socket) then exit;
//.set
if (0=n_getsockopt(invalid_socket,SOL_SOCKET,SO_OPENTYPE,pchar(@old),sa)) then
   begin
   sa:=sizeof(a);
   caller:=n_accept(socket,@a,@sa);
   end;
except;end;
try
if (caller<>invalid_socket) then
   begin
   //.get
   accepted:=false;
   _onaccept(self,caller,accepted);
   //.close - only if "not accepted" and "caller" is still valid (not invalid_socket)
   if (not accepted) and (caller<>invalid_socket) then n_closesocket(caller);
   end;//end of if
except;end;
end;
//## _onaccept ##
procedure tserverbasic._onaccept(sender:tobject;var caller:tsocket;var accepted:boolean);
begin
try;accepted:=(accept(caller)>=0);except;end;
end;
//## accept ##
function tserverbasic.accept(var _socket:tsocket):integer;
label
   skipend;
var
   _ip,p:integer;
   ptr:tnetworkptr;
   z:string;
begin
try
//defaults
result:=-1;
ptr.c:=0;
//check
if (_socket=invalid_socket) then exit;
//process
//.get
ns.remoteip(_socket,_ip);//get remote client's ip address
if (_ip=0) then exit;
//.raw
if raw then
   begin
   z:='';
   if (not passed(_ip,0,z)) then exit;
   end;//end of if
//.set
for p:=0 to (imaxconn-1) do if (iclients[p]<>nil) and iclients[p].canopen then
   begin
   //.network accept
   ptr:=nw.acceptclient(iptr,port,_socket);
   //.open
   if (ptr.c<>0) and (iclients[p]<>nil) and iclients[p].open(ptr) then
      begin
      inc(iconnactive);
      inc(iconnactivepeak);
      general.croll(hits,1);
      result:=p;
      end;//end of if
   //.quit
   break;
   end;//end of if
skipend:
except;end;
try//clean up
if (result=-1) and (ptr.c<>0) then
   begin
   nw.close(ptr);
   //.clear socket - prevents calling procedure from destroying socket
   _socket:=invalid_socket;
   end;//end of if
except;end;
end;
//## passed ##
function tserverbasic.passed(_ip:integer;_bytes:currency;var header:string):boolean;
var
   _ip2,_ipcount,v,p:integer;
   z:string;
begin
try
//defaults
result:=false;
_ipcount:=0;
//process
//.readIP
if (_ip=0) then exit else _ip:=misc.readIP(header,_ip);
//.max concurrent connections
if (iplimit>=1) then for p:=0 to (imaxconn-1) do
   begin
   v:=nw.ipproxyb[p];
   if (v<>0) and (v=_ip) then
      begin
      inc(_ipcount);
      if (_ipcount>iplimit) then exit;
      end;//end of if
   end;//end of loop
//.max IP hits/per day - Note: No error code at this stage, it can only be sourced upon a server formatted reply
if not secip.passed(_ip,_bytes,wecNotUsed,true,log) then exit;
//successful
result:=true;
except;end;
end;
//## _onrequest ##
function tserverbasic._onrequest(sender:tobject;var header,content:string;var wait:boolean):boolean;
begin
try
//defaults
result:=false;
if (sender<>nil) and (sender is tclientremote) then (sender as tclientremote).oContentlength:=true;
//event
if assigned(onrequest) then result:=onrequest(sender,header,content,wait)
else
   begin
   header:='';
   content:='';
   wait:=false;
   end;//end of if
except;end;
end;
//## _onsend ##
procedure tserverbasic._onsend(sender:tobject;var content:string;var _linger:boolean);
begin
try;if assigned(onsend) then onsend(sender,content,_linger);except;end;
end;
//## _onclose ##
procedure tserverbasic._onclose(sender:tobject);
begin
try
//.event
fireevent(fonclose,self);
//.dec
iconnactive:=frcmin(iconnactive-1,0);
except;end;
end;

//## tserverredirection ########################################################
//## create ##
constructor tserverredirection.create;
var
   p:integer;
begin
//self
inherited;
//controls
iitems:=tdynamictext.create;
end;
//## destroy ##
destructor tserverredirection.destroy;
var
   p:integer;
begin
try
//self
inherited;
//controls
freeobj(@iitems);
except;end;
end;
//## createclient ##
function tserverredirection.createclient:tclientremote;
begin
try;result:=tclientproxy.create;except;end;
end;
//## initclient ##
procedure tserverredirection.initclient(x:tclientremote);
begin
try
//self
inherited initclient(x);
//other
if (x is tclientproxy) then (x as tclientproxy).onurl:=_onurl;
except;end;
end;
//## seturls ##
procedure tserverredirection.seturls(x:string);
var
   i,p:integer;
   v,z:string;
begin
try
//remove spaces
general.swapstrs(x,#32,'');
//clear
iitems.clear;
//get
p:=1;
while general.nextline(p,x,z) do if general.textgood(z) then
   begin
   v:='';
   for i:=1 to length(z) do if (z[i]='=') then
      begin
      v:=copy(z,i+1,length(z));
      z:=copy(z,1,i-1);
      break;
      end;//end of if
   if general.textgood(z) and general.textgood(v) then iitems.value[z]:=v;
   end;//end of if
except;end;
end;
//## _onurl ##
procedure tserverredirection._onurl(sender:tobject;var header,content,url:string);
var
   p:integer;
   host,n:string;
   ok:boolean;
begin
try
//defaults
url:='';
ok:=false;
//get
host:='';
misc.headerfind(header,'host: ',host);
//scan
for p:=0 to (iitems.vars.count-1) do
begin
n:=iitems.vars.name[p];
if general.infb(host,';',n) then
   begin
   url:=iitems.vars.valuei[p];
   ok:=true;
   break;
   end;//end of loop
end;//end of loop
//connection must be "close" or we will wait til timeout!
misc.headeradd(header,'Connection: ','close');
misc.headeradd(header,'Proxy-Connection: ','close');
//use internet
if (not ok) and allowinternet then url:=host;
except;end;
end;

//## tserverudp ################################################################
//## create ##
constructor tserverudp.create;
var
   p:integer;
begin
//self
inherited;
//vars
isocket:=invalid_socket;
irecvlimit:=32767;
iopentime:=ms64;
iptr.c:=0;
iport:=0;//not in use
iports:='';
//timer
itimer:=mt.new(_ontimer,1000,true);
itimerfast:=mt.new(_ontimerfast,200,true);
mt.slowon(islowref);
end;
//## destroy ##
destructor tserverudp.destroy;
var
   p:integer;
begin
try
//timer
mt.del(itimer);
mt.del(itimerfast);
//close
_close;
//self
inherited;
except;end;
end;
//## _ontimerfast ##
procedure tserverudp._ontimerfast(sender:tobject);
const
   maxcount=20;
   bufsize=1024;
var
   buf:array[0..(bufsize-1)] of char;
   ca:tsockaddrin;//client address
   i,c,len,caLEN,p:integer;
   ok:boolean;
   x,e,extra,data:string;
   code,caIP:integer;
   caPORT:word;
   wait:boolean;
   time:currency;
begin
try
//check
if (isocket=invalid_socket) then exit;
ok:=false;
//process
//.get
for p:=1 to maxcount do if nw.canrecvfrom(iptr) then
   begin
   time:=ms64;
   len:=nw.recvfrom(iptr,ca,data);
   if (len>=1) then
      begin
      //.stats
      general.croll(recvbytes,len);
      general.croll(hits,1);
      general.croll(networkhitsin,1);
      //.get
      extra:='';
      caIP:=ca.sin_addr.S_addr;
      caPORT:=n_ntohs(ca.sin_port);
      code:=wecOK;
      //.event
      if assigned(onrequest) then onrequest(self,isocket,ca,caIP,caPORT,data,extra,code)
      else
         begin
         wait:=false;
         data:='';
         end;//end of if
      //.set
      unwait(ca,caIP,caPORT,len,time,code,data,extra);
      //.ok
      ok:=true;
      end;//end of if
   end;//end of loop
//.speed
if ok then mt.slowoff(islowref);
mt.interval[itimerfast]:=mt.slowauto(islowref,20);//50x per second
except;end;
end;
//## unwait ##
procedure tserverudp.unwait(ca:tsockaddrin;caIP:integer;caPort:word;recv,time:currency;code:integer;data,extra:string);
const
   sep=', ';
label
   redo;
var
   r,tt,sent:currency;
   c,datalen:integer;
begin
try
//get
c:=10;
datalen:=length(data);
//send
redo:
sent:=nw.sendto(iptr,ca,data);
//.retry sending single packet
if (sent<>datalen) and (c>=0) then
   begin
   dec(c);
   sleep(20);
   goto redo;
   end;//end of if
general.croll(sendbytes,sent);
//logs
if log then
   begin
   tt:=frccurmin(ms64-time,1);//transaction time (always 1ms or higher for safe division below)
   r:=tt/1000;
   extra:=extra+general.insstr(sep,extra<>'')+
    tsTransactiontimelc+': '+dates.uptime(tt,true,#32)+sep+
    lowercase(tsRecv)+': '+floattostrex2(recv)+sep+
    lowercase(tsSent)+': '+floattostrex2(sent)+sep+
    lowercase(tsRate)+': '+floattostrex2( int((recv+sent)/r) );
   rawlog.addentry(caIP,now,'GET / UDP',code,sent,'-','-',extra,'','');
   end;//end of if
except;end;
end;
//## setrecvlimit ##
procedure tserverudp.setrecvlimit(x:integer);
begin
try;irecvlimit:=frcrange(x,0,maxint);except;end;
end;
//## _ontimer ##
procedure tserverudp._ontimer(sender:tobject);
begin
try
//check
if (sysstate>=ssClosed) then exit;
//process
if ((ms64-iopentime)>=5000) then
   begin
   //.set
   case (iptr.c<>0) of
   true:if (iports='') then _close;
   false:if (iports<>'') then _open;
   end;//end of case
   //.reset
   iopentime:=ms64;
   end;//end of if
except;end;
end;
//## portrange ##
function tserverudp.portrange(_from,_to:integer):string;
begin
try;result:=misc.numbers(_from,_to,',');except;end;
end;
//## setports ##
procedure tserverudp.setports(x:string);
begin
try
if (x<>iports) then
   begin
   iports:=x;
   _close;
   iopentime:=ms64-9999;//try straight away
   end;//end of if
except;end;
end;
//## _open ##
procedure tserverudp._open;
var
   p:integer;
begin
try
//close
if (iptr.c<>0) then _close;
//open
if (iptr.c=0) and (iports<>'') then
   begin
   p:=freeport(iports,true);//24-APR-2007
   iptr:=nw.openserverUDP(p);
   if (iptr.c<>0) then
      begin
      iport:=p;
      isocket:=nw.socket[iptr];
      end;//end of if
   end;//end of if
except;end;
end;
//## _close ##
procedure tserverudp._close;
begin
try
if (iptr.c<>0) then
   begin
   //.port
   iport:=0;
   isocket:=invalid_socket;
   //.socket
   nw.close(iptr);
   //.pointer
   iptr.c:=0;
   end;//end of if
except;end;
end;
//## getonline ##
function tserverudp.getonline:boolean;
begin
try;result:=(iptr.c<>0) and (iport<>0);except;end;
end;

//## tnetworkusers #############################################################
//## writeuseraddress ##
function writeuseraddress(_username,_domain:string;var _address:string):boolean;
begin
try
//defaults
result:=false;
_address:='';
//range
general.remchar(_username,'@');
//set
if (_username<>'') and (_domain<>'') then
   begin
   _address:=_username+'@'+_domain;
   result:=true;
   end;//end of if
except;end;
end;
//## readuseraddress ##
function readuseraddress(_address:string;var _username,_domain:string):boolean;
var
   len,p:integer;
begin
try
//defaults
result:=false;
_username:='';
_domain:='';
len:=length(_address);
//check
if (len=0) then exit;
//scan
for p:=1 to len do if (_address[p]='@') then
   begin
   //set
   _username:=copy(_address,1,p-1);
   _domain:=copy(_address,p+1,len);
   //successful
   result:=(_username<>'') and (_domain<>'');
   break;
   end;//end of if
except;end;
end;
//## create ##
constructor tnetworkusers.create;
begin
//self
inherited create;
//defaults
timeout:=5*60*1000;//5 minutes
//vars
attemptlimit:=5;
limit:=1000;//1,000 users
tsFinding:=ntranslate('finding');
tsPermanent:=ntranslate('permanent');
tsVisitor:=ntranslate('visitor');
tsWaiting:=ntranslate('waiting');
tsSignal:=ntranslate('signal');
tsNoSignal:=ntranslate('no signal');
tsGroup:=ntranslate('group');
tsIP:=ntranslate('ip');
tsDisabled:=ntranslate('disabled');
//controls
iusername:=tdynamicstring.create;
iuref:=tdynamiccurrency.create;
igroupname:=tdynamicstring.create;
idomain:=tdynamicstring.create;
iimgname:=tdynamicstring.create;
iint1:=tdynamicinteger.create;
iint2:=tdynamicinteger.create;
iip:=tdynamicinteger.create;
imsgid:=tdynamicinteger.create;
iport:=tdynamicword.create;
ialive:=tdynamiccurrency.create;
iid:=tdynamiccurrency.create;
istatic:=tdynamicboolean.create;
ionce:=tdynamicboolean.create;
ifromuser:=tdynamicboolean.create;
ilookcount:=tdynamicbyte.create;
ilookms:=tdynamiccurrency.create;
iawake:=tdynamicbyte.create;
//timer
itimer:=mt.new(_ontimer,500,true);
_ontimer(self);
end;
//## destroy ##
destructor tnetworkusers.destroy;
begin
try
//timer
mt.del(itimer);
//controls
freeobj(@iusername);
freeobj(@iuref);
freeobj(@igroupname);
freeobj(@idomain);
freeobj(@iimgname);
freeobj(@iint1);
freeobj(@iint2);
freeobj(@iip);
freeobj(@imsgid);
freeobj(@iport);
freeobj(@ialive);
freeobj(@iid);
freeobj(@istatic);
freeobj(@ionce);
freeobj(@ifromuser);
freeobj(@ilookcount);
freeobj(@ilookms);
freeobj(@iawake);
//self
inherited;
except;end;
end;
//## refreshIPS ##
procedure tnetworkusers.refreshIPS;
var//Only reset those items that have a domain to fall back to, else leave as is (to prevent any data loss) 07FEB2008
   p:integer;
   _ms64:currency;
begin
try
//get
_ms64:=ms64;
//set
for p:=(iusername.count-1) downto 0 do if inuse[p] and (idomain.items[p]^<>'') then
   begin
   iip.items[p]:=0;
   ilookcount.items[p]:=0;
   ilookms.items[p]:=_ms64;//right away
   end;//end of if
except;end;
end;
//## deleteofflineusers ##
procedure tnetworkusers.deleteofflineusers;//27NOV2007
var
   p:integer;
begin
try;for p:=(iusername.count-1) downto 0 do if inuse[p] and (not onlineuser[p]) then del(p);except;end;
end;
//## setlimit ##
procedure tnetworkusers.setlimit(x:integer);//restrict the number of users that can be cached - prevents memory overflow
begin
try;ilimit:=frcmin(x,10);except;end;
end;
//## getcount ##
function tnetworkusers.getcount:integer;
begin
try;result:=iuref.count;except;end;
end;
//## _ontimer ##
procedure tnetworkusers._ontimer(sender:tobject);
var//2x per second - so upto 100 users scanned per second
   p:integer;
   _ms64:currency;
begin
try
//init
_ms64:=ms64;
//refs
irefOnline:=ms64-(itimeout*2);//2 time units
irefDelete:=ms64-(itimeout*5);//5 time units (must be atleast "(2.X)*irefOnline" inorder to prevent feedback loop between lagging clients
//get
ionline:=getonlinecount;
//delete out of date users - tolerance determined by "delfast"
for p:=1 to frcmax(50,iuref.count) do
begin
//range
if (iuref.count=0) then break;
if (idelpos<0) then idelpos:=(iuref.count-1)
else if (idelpos>=iuref.count) then idelpos:=0;
//ONLINE
if ifromuser.items[idelpos] and (not ionce.items[idelpos]) and (ialive.items[idelpos]>=irefOnline) then
   begin
   ionce.items[idelpos]:=true;
   if assigned(fonOnline) then fonOnline(self,idelpos);
   end;//end of if
//OFFLINE
if inuse[idelpos] then
   begin
   //offline users - notify client
   if ifromuser.items[idelpos] and ionce.items[idelpos] and (ialive.items[idelpos]<irefOnline) then
      begin
      ionce.items[idelpos]:=false;
      ifromuser.items[idelpos]:=false;
      if assigned(fonOffline) then fonOffline(self,idelpos);
      end;//end of if
   //delete
   if (not istatic.items[idelpos]) and (ialive.items[idelpos]<irefDelete) then del(idelpos);
   end;
//DOMAIN LOOKUP
//.quick - domain name is IP so no lookup required - 04FEB2008
if (ilookpos<>idelpos) and inuse[idelpos] and (iip.items[idelpos]=0) and (ilookcount.items[idelpos]<attemptlimit) and (idomain.items[idelpos]^<>'') and (ilookms.items[idelpos]<=_ms64) then
   begin
   if (_strip(_intip(idomain.items[idelpos]^))=idomain.items[idelpos]^) then iip.items[idelpos]:=_intip(idomain.items[idelpos]^);
   end;//end of if
//.slow - domain name is a name and requires real lookup
if (not ilooking) and inuse[idelpos] and (iip.items[idelpos]=0) and (ilookcount.items[idelpos]<attemptlimit) and (idomain.items[idelpos]^<>'') and (ilookms.items[idelpos]<=_ms64) then
   begin
   ilooking:=true;
   ilookpos:=idelpos;
   if (0=lm.open(idomain.items[ilookpos]^,iid.items[ilookpos],_onlookup).c) then ilooking:=false;
   end;//end of if
//dec
dec(idelpos);
end;//end of loop
except;end;
end;
//## _onlookup ##
procedure tnetworkusers._onlookup(sender:tobject;tag:currency;ptr:tnetworkptr);
label
   skipend;
var
   mip,rip:integer;
begin
try
//check
if (not ilooking) then exit;
//init
mip:=lm.ip[ptr];//mapped version
//ITEM
if (not inuse[ilookpos]) then exit;
//.time stamp must be the same, otherwise item may have changed during the "DNS" lookup
if (iid.items[ilookpos]<>tag) then exit;
//set
inc(ilookcount.items[ilookpos],1);
ilookms.items[ilookpos]:=ms64+30000;//30 seconds before trying again
if (mip<>0) then iip.items[ilookpos]:=mip;
skipend:
except;end;
try;ilooking:=false;except;end;
end;
//## getvalid ##
function tnetworkusers.getvalid(x:integer):boolean;
begin
try;result:=(x>=0) and (x<iuref.count);except;end;
end;
//## getinuse ##
function tnetworkusers.getinuse(x:integer):boolean;
begin
try;result:=(x>=0) and (x<iuref.count) and (iuref.items[x]<>0);except;end;
end;
//## getactiveuser ##
function tnetworkusers.getactiveuser(x:integer):boolean;
begin
try;result:=(x>=0) and (x<iuref.count) and (iuref.items[x]<>0) and (iip.items[x]<>0) and (ialive.items[x]>=irefOnline);except;end;
end;
//## getonlineuser ##
function tnetworkusers.getonlineuser(x:integer):boolean;
begin
try;result:=(x>=0) and (x<iuref.count) and (iuref.items[x]<>0) and (iip.items[x]<>0) and ionce.items[x] and (ialive.items[x]>=irefOnline);except;end;
end;
//## getonlinecount ##
function tnetworkusers.getonlinecount:integer;
var
   p:integer;
begin
try
//defaults
result:=0;
//get
for p:=(iuref.count-1) downto 0 do if onlineuser[p] then inc(result);
except;end;
end;
//## onlineusers ##
function tnetworkusers.onlineusers(_sep:string;_sort:boolean;var _users:string;var _indexref:tdynamicinteger;var _count:integer):boolean;
var
   a:tstringlist;
   v2,i,p,len:integer;
   v1:string;
begin
try
//defaults
result:=false;
a:=nil;
a:=tstringlist.create;
_users:='';
_count:=0;
len:=0;
//range
if (_sep='') then _sep:=rcode;
//get
for p:=(iusername.count-1) downto 0 do if onlineuser[p] then a.add(iusername.items[p]^+'-'+inttostr(p));//username and it's index
//sort
if _sort then a.sort;
//set
for p:=0 to (a.count-1) do if (a.strings[p]<>'') then
   begin
   //get
   v1:=a.strings[p];
   v2:=0;
   for i:=length(v1) downto 1 do if (v1[i]='-') then
      begin
      v2:=strint(copy(v1,i+1,length(v1)));
      v1:=copy(v1,1,i-1);
      break;
      end;//end of if
   //set
   pushb(len,_users,v1+_sep);
   if (_indexref<>nil) then _indexref.value[_count]:=v2;
   inc(_count);
   end;//end of if
//finalise
pushb(len,_users,'');
if (_indexref<>nil) and (_indexref.size>_count) then _indexref.size:=_count;
//successful
result:=true;
except;end;
try;freeobj(@a);except;end;
end;
//## getint1 ##
function tnetworkusers.getint1(x:integer):integer;
begin
try;if inuse[x] then result:=iint1.items[x] else result:=0;except;end;
end;
//## getint2 ##
function tnetworkusers.getint2(x:integer):integer;
begin
try;if inuse[x] then result:=iint2.items[x] else result:=0;except;end;
end;
//## getawake ##
function tnetworkusers.getawake(x:integer):byte;
begin
try;if inuse[x] then result:=iawake.items[x] else result:=0;except;end;
end;
//## getip ##
function tnetworkusers.getip(x:integer):integer;
begin
try;if inuse[x] then result:=iip.items[x] else result:=0;except;end;
end;
//## getmsgid ##
function tnetworkusers.getmsgid(x:integer):integer;
begin
try;if inuse[x] then result:=imsgid.items[x] else result:=0;except;end;
end;
//## getport ##
function tnetworkusers.getport(x:integer):word;
begin
try;if inuse[x] then result:=iport.items[x] else result:=0;except;end;
end;
//## getusername ##
function tnetworkusers.getusername(x:integer):string;
begin
try;if inuse[x] then result:=iusername.items[x]^ else result:='';except;end;
end;
//## getgroupname ##
function tnetworkusers.getgroupname(x:integer):string;
begin
try;if inuse[x] then result:=igroupname.items[x]^ else result:='';except;end;
end;
//## getdomain ##
function tnetworkusers.getdomain(x:integer):string;
begin
try;if inuse[x] then result:=idomain.items[x]^ else result:='';except;end;
end;
//## getimgname ##
function tnetworkusers.getimgname(x:integer):string;
begin
try;if inuse[x] then result:=iimgname.items[x]^ else result:='';except;end;
end;
//## getaddress ##
function tnetworkusers.getaddress(x:integer):string;
begin
try
if inuse[x] then result:=iusername.items[x]^+'@'+general.aorbstr(_strip(iip.items[x]),idomain.items[x]^,idomain.items[x]^<>'')
else result:='';
except;end;
end;
//## getstatic ##
function tnetworkusers.getstatic(x:integer):boolean;
begin
try;result:=inuse[x] and istatic.items[x];except;end;
end;
//## stats ##
function tnetworkusers.stats(showheader,showgroup,showonline,privateIPsonly:boolean;colsep,linesep:string):string;
begin
try;result:=statsex(showheader,showgroup,showonline,privateIPsonly,colsep,linesep,200);except;end;
end;
//## _privateerror ##
function tnetworkusers._privateerror(ip:integer):boolean;//for stats only
begin
try
//defaults
result:=false;
//decide
if (ip<>0) and (not misc.ipprivate(ip)) then result:=true;
except;end;
end;
//## statsex ##
function tnetworkusers.statsex(showheader,showgroup,showonline,privateIPsonly:boolean;colsep,linesep:string;itemlimit:integer):string;
var
   y,len,cc,p2,p:integer;
   v:currency;
   z,_address,_signal,_type,_ip:string;
begin
try
//defaults
result:='';
len:=0;
if (colsep='') then colsep:=#9;
if (linesep='') then linesep:=rcode;
itemlimit:=frcmin(itemlimit,0);
cc:=itemlimit;
//process
//.header
if showheader then pushb(len,result,
   general.insstr(tsOnline+colsep,showonline)+
   tsSignal+colsep+
   general.aorbstr(tsType,tsGroup,showgroup)+colsep+
   tsIP+colsep+
   tsUserAddress+linesep);
//.get
for p:=0 to (iuref.count-1) do if (iuref.items[p]<>0) then
   begin
   //.signal
   _signal:=misc.signalbar(100*((ialive.items[p]-irefOnline)/(2*itimeout)));
   //.type/group
   case showgroup of
   true:_type:=igroupname.items[p]^;
   false:_type:=general.aorbstr(tsVisitor,tsPermanent,istatic.items[p]);
   end;//end of case
   //._ip
   _ip:=general.aorbstr(general.aorbstr(tsNotFound,general.aorbstr(tsWaiting,tsFinding,ilookpos=p),ilookcount.items[p]<attemptlimit),_strip(iip.items[p]),iip.items[p]<>0);
   //.address
   _address:=address[p];
   //.set
   pushb(len,result,
    general.insstr(misc.yes(onlineuser[p])+general.insstr(' - '+tsDisabled,privateIPsonly and _privateerror(iip.items[p]))+colsep,showonline)+
    _signal+colsep+
    _type+colsep+
    _ip+colsep+
    _address+linesep);
   //.dec
   dec(cc);
   //.limit (-1=unlimited)
   if (cc=0) then break;
   end;//end of if
//.fill with blank lines (we end up with a fixed height list for stable display)
for p:=1 to cc do pushb(len,result,linesep);
//.finalise
pushb(len,result,'');
except;end;
end;
//## findnext ##
function tnetworkusers.findnext(_start:integer;var _index:integer):boolean;
begin
try;result:=findnextex(_start,_index,false);except;end;
end;
//## findnextex ##
function tnetworkusers.findnextex(_start:integer;var _index:integer;includestatic:boolean):boolean;
var
   p:integer;
begin
try
//defaults
result:=false;
_index:=-1;
//range
if (_start<0) or (_start>=iuref.count) then exit;
//scan
for p:=_start to (iuref.count-1) do if (iuref.items[p]<>0) and (iip.items[p]<>0) and
   ((includestatic and istatic.items[p]) or (ialive.items[p]>=irefOnline)) then
   begin
   _index:=p;
   result:=true;
   break;
   end;//end of if
except;end;
end;
//## findu ##
function tnetworkusers.findu(_username:string;var i:integer):boolean;
var
   uref:currency;
   p:integer;
begin
try
//defaults
result:=false;
i:=-1;
//check
if (_username='') then exit;
//init
uref:=general.ref256U(_username);
//scan
p:=-1;
while true do
begin
p:=iuref.find(p+1,uref);
if (p=-1) or (p>=iuref.size) then break
else if (comparetext(iusername.items[p]^,_username)=0) then
   begin
   i:=p;
   result:=true;
   break;
   end;//end of if
end;//end of loop
except;end;
end;
//## findug ##
function tnetworkusers.findug(_username,_groupname:string;var i:integer):boolean;
var
   uref:currency;
   p:integer;
begin
try
//defaults
result:=false;
i:=-1;
//check
if (_username='') then exit;
//init
uref:=general.ref256U(_username);
//scan
p:=-1;
while true do
begin
p:=iuref.find(p+1,uref);
if (p=-1) or (p>=iuref.size) then break
else if (comparetext(igroupname.items[p]^,_groupname)=0) and (comparetext(iusername.items[p]^,_username)=0) then
   begin
   i:=p;
   result:=true;
   break;
   end;//end of if
end;//end of loop
except;end;
end;
//## settimeout ##
procedure tnetworkusers.settimeout(x:currency);
begin
try;itimeout:=frccurmin(x,1);except;end;
end;
//## new ##
function tnetworkusers.new(_username,_groupname:string;var p:integer;var _new:boolean):boolean;
var
   c,i:integer;
begin
try
//defaults
result:=false;
_new:=false;
p:=-1;
//check
if (_username='') then exit;
//get
if not findug(_username,_groupname,i) then
   begin
   //NEW
   //.find first empty
   _new:=true;
   i:=iuref.find(0,0);
   //.add
   if (i=-1) then
      begin
      //range
      if (iuref.count>=ilimit) then exit;
      i:=iuref.count;
      c:=i+1;
      iusername.setparams(c,c,0);
      iuref.setparams(c,c,0);
      igroupname.setparams(c,c,0);
      idomain.setparams(c,c,0);
      iimgname.setparams(c,c,0);
      iint1.setparams(c,c,0);
      iint2.setparams(c,c,0);
      iip.setparams(c,c,0);
      imsgid.setparams(c,c,0);
      iport.setparams(c,c,0);
      ialive.setparams(c,c,0);
      iid.setparams(c,c,0);
      istatic.setparams(c,c,0);
      ionce.setparams(c,c,0);
      ifromuser.setparams(c,c,0);
      ilookcount.setparams(c,c,0);
      ilookms.setparams(c,c,0);
      iawake.setparams(c,c,0);
      end;//end of if
   //set
   iusername.items[i]^:=_username;
   iuref.items[i]:=general.ref256U(_username);
   igroupname.items[i]^:=_groupname;
   iid.items[i]:=ms64;//used to ensure item is consistent for "DNS Lookup" (id must match before and after DNS proc or else it's ignored), so therefore should only be set when item is first created and not after
   general.iroll(iactive,1);
   end;//end of if
//successful
result:=(i>=0);
if result then p:=i;
except;end;
end;
//## addstatic ##
function tnetworkusers.addstatic(_addresses:string):boolean;
var
   a:tdynamicboolean;
   newcount,i,p:integer;
   _new:boolean;
   z,_username,_domain:string;
begin
try
//defaults
result:=false;
a:=nil;
a:=tdynamicboolean.create;
a.setparams(istatic.count,istatic.count,0);
i:=1;
newcount:=0;
//get
while general.nextline(i,_addresses,z) do if readuseraddress(z,_username,_domain) and new(_username,'',p,_new) then
   begin
   a.value[p]:=true;
   //new
   if _new then
      begin
      ialive.items[p]:=irefOnline+1;//offline by default
      inc(newcount);
      end;//end of if
   if _new or (comparetext(idomain.items[p]^,_domain)<>0) then
      begin
      iid.items[p]:=ms64;//item has been modified - cancels and in progress "DNS" lookup action
      idomain.items[p]^:=_domain;
      iip.items[p]:=_intip(_domain);//attempt to extract IP address from domain
      ilookcount.items[p]:=0;
      ilookms.items[p]:=ms64;//right away
      end;//end of if
   end;//end of if
//set static modes
for p:=(istatic.count-1) downto 0 do istatic.items[p]:=a.items[p];
//event
if (newcount>=1) and assigned(fonnew) then fonnew(self,-1);
except;end;
try;freeobj(@a);except;end;
end;
//## adduser ##
function tnetworkusers.adduser(_ip:integer;_port:word;_awake:byte;_username,_groupname,_domain,_imgname:string;_int1,_int2:integer;_fromuser,_updateexisting:boolean):boolean;
var
   tmp:boolean;
begin
try;result:=adduserex(_ip,0,_port,_awake,_username,_groupname,_domain,_imgname,_int1,_int2,_fromuser,_updateexisting,tmp);except;end;
end;
//## adduserex ##
function tnetworkusers.adduserex(_ip,_msgid:integer;_port:word;_awake:byte;_username,_groupname,_domain,_imgname:string;_int1,_int2:integer;_fromuser,_updateexisting:boolean;var _msgidOK:boolean):boolean;
var//Note: a) _msgid<=0 "ignore", _msgid>=1 add only if [x]._msgid<>_msgid (must be different) else reject request
   _new:boolean;
   p:integer;
begin
try
//defaults
result:=false;
_msgidOK:=false;
//get
if not new(_username,_groupname,p,_new) then exit;
if (_msgid<=0) then _msgidOK:=true;
//set
if (_new or _updateexisting) then
   begin
   //check
   if (_msgid>=1) then
      begin
      //message id is same as before, therefore this message is a repeat most likly sent by a hacker or attacker and must be ignored!
      if (imsgid.items[p]=_msgid) then exit
      //message id is new and thus message is OK and we can continue safely
      else
         begin
         imsgid.items[p]:=_msgid;
         _msgidOK:=true;
         end;//end of if
      end;//end of if
   //set
   iusername.items[p]^:=_username;//update (used for _online and _offline)
   if (_domain<>'') and (idomain.items[p]^='') then idomain.items[p]^:=_domain;
   iimgname.items[p]^:=_imgname;
   iint1.items[p]:=_int1;
   iint2.items[p]:=_int2;
   if (_awake<>255) then iawake.items[p]:=_awake;//255=ignore new value, keep previous
   if _fromuser then ifromuser.items[p]:=true;
   //alive
   if _new or _updateexisting then ialive.items[p]:=ms64;
   if _new and assigned(onnew) then onnew(self,p);
   //ip
   if (_ip=0) and (_domain<>'') then _ip:=_intip(_domain);//automatically sets IP if domain is an IP and not domain address type
   iip.items[p]:=_ip;
   iport.items[p]:=_port;
   //successful
   result:=true;
   end;//end of if
except;end;
end;
//## del ##
procedure tnetworkusers.del(x:integer);
begin
try
//check
if (x<0) or (x>=iuref.count) then exit;
//set
iuref.items[x]:=0;//not in use
iusername.items[x]^:='';
igroupname.items[x]^:='';
idomain.items[x]^:='';
iimgname.items[x]^:='';
iint1.items[x]:=0;
iint2.items[x]:=0;
iip.items[x]:=0;
imsgid.items[x]:=0;
iport.items[x]:=0;
ialive.items[x]:=0;
iid.items[x]:=0;
istatic.items[x]:=false;
ionce.items[x]:=false;
ifromuser.items[x]:=false;
ilookcount.items[x]:=0;
ilookms.items[x]:=0;
iawake.items[x]:=0;
iactive:=frcmin(iactive,0);
except;end;
end;

//## tudppackets ###############################################################
//## create ##
constructor tudppackets.create;
var
   p:integer;
begin
//self
inherited;
//vars
tsPacketsPerSecond:=lowercase(translate('packets/sec'));//packets per second
tsInboundQueue:=ntranslate('inbound queue');
tsOutboundQueue:=ntranslate('outbound queue');
tsThrottle:=ntranslate('throttle');
istatustime:=ms64-1000;
isocket:=invalid_socket;
iopentime:=ms64;
iptr.c:=0;
iport:=0;//not in use
iports:='';
//controls
iinqueue:=tqueuestring.create;
ioutqueue:=tqueuestring.create;
//defaults
pushrate:=0;
pullrate:=0;
//defaults
limit:=15000;//15,000 packets can be cached before overflow and some are dropped
//timer
itimer:=mt.new(_ontimer,200,true);//fixed @ 5fps, important for throttle
end;
//## destroy ##
destructor tudppackets.destroy;
var
   p:integer;
begin
try
//timer
mt.del(itimer);
//close
_close;
//controls
freeobj(@iinqueue);
freeobj(@ioutqueue);
//self
inherited;
except;end;
end;
//## setpushrate ##
procedure tudppackets.setpushrate(x:integer);
begin
try;ipushrate:=frcmin(x,0);except;end;
end;
//## setpullrate ##
procedure tudppackets.setpullrate(x:integer);
begin
try;ipullrate:=frcmin(x,0);except;end;
end;
//## getsafelevel ##
function tudppackets.getsafelevel:boolean;
begin//fixed at 75% of limit
try;result:=(ioutqueue.active<isafelevel);except;end;
end;
//## setlimit ##
procedure tudppackets.setlimit(x:integer);//maximum number of packets to cache for each of inbound and outbound caches
begin
try
//range
x:=frcmin(x,10);
ilimit:=x;
isafelevel:=frcmin(round(ilimit*0.75),5);
//set
iinqueue.size:=x;
ioutqueue.size:=x;
except;end;
end;
//## setUDPavedatalen ##
procedure tudppackets.setUDPavedatalen(x:word);
begin
try
//range
if (x<1) then x:=1
else if (x>UDPdatalimit) then x:=UDPdatalimit;
//sync
limit:=limit;
except;end;
end;
//## _ontimer ##
procedure tudppackets._ontimer(sender:tobject);
var//capable of 18,000+ 512b packets/second on 2Ghz/XP machine (~9Mb/second)
   maxp,tmp,ip,p:integer;
   port:word;
   data:string;
   c:currency;
begin
try
//check
if (sysstate>=ssClosed) then exit;
//port
if ((ms64-iopentime)>=5000) then
   begin
   //.set
   case (iptr.c<>0) of
   true:if (iports='') then _close;
   false:if (iports<>'') then _open;
   end;//end of case
   //.reset
   iopentime:=ms64;
   end;//end of if
//throttle - 5fps
if (ipushrate<=0) then ipushcount:=0 else ipushcount:=frcmin(ipushrate div 5,1);//convert 1.0sec/rate => 0.2sec/rate (1/5th)
if (ipullrate<=0) then ipullcount:=0 else ipullcount:=frcmin(ipullrate div 5,1);//convert 1.0sec/rate => 0.2sec/rate (1/5th)
//status
if ((ms64-istatustime)>=1000) then
   begin
   //init
   c:=0;
   general.croll(c,sendbytes);
   general.croll(c,recvbytes);
   //get
   istatus:=
   tsAddress+#9+_strip(machine_ip)+':'+general.aorbstr('?',inttostr(iport),online)+' / '+general.aorbstr(tsOffline,tsOnline,online)+rcode+
   tsHits+#9+general.curcomma(hits)+rcode+
   tsBandwidth+#9+general.curcomma(c)+#32+lowercase(tsBytes)+rcode+
   tsInboundQueue+#9+general.thousands(inboundactive)+' / '+general.thousands(ilimit)+rcode+
   tsOutboundQueue+#9+general.thousands(outboundactive)+' / '+general.thousands(ilimit)+rcode+
   tsThrottle+#9+general.aorbstr('-',general.thousands(ipushrate)+#32+tsPacketsPerSecond,ipushrate>=1)+rcode;
   //reset
   istatustime:=ms64;
   end;//end of if
//network stalled, so restart by force
//.outbound
for p:=1 to frcmin(ipushcount,30) do if not push then break;
//.inbound - only once since it will start by itself after that 11JAN2008
pull;
//inbound - main event driver, so it's "inbound" loop must be a higher iteration value
if (iinqueue.active>=1) then
   begin
   //init
   maxp:=ipullrate;
   if (maxp=0) then maxp:=20000;//upto 100,000 per second in theory
   //scan
   for p:=1 to maxp do if ((ipullrate<=0) or (ipullcount>=1)) and iinqueue.pullex(data,ip,port,tmp) then
      begin
      //dec
      if (ipullcount>=1) then dec(ipullcount);
      //event
      if assigned(fonrequest) then fonrequest(self,ip,port,data);
      //log
      if log then rawlog.addentry(ip,now,'GET / UDP',wecOK,length(data),'-','-','Client-port: '+inttostr(port),'','');
      end
      else break;
   end;//end of if
except;end;
end;
//## portrange ##
function tudppackets.portrange(_from,_to:integer):string;
begin
try;result:=misc.numbers(_from,_to,',');except;end;
end;
//## setports ##
procedure tudppackets.setports(x:string);
begin
try
if (x<>iports) then
   begin
   iports:=x;
   _close;
   iopentime:=ms64-9999;//try straight away
   end;//end of if
except;end;
end;
//## _open ##
procedure tudppackets._open;
var
   p:integer;
begin
try
//close
if (iptr.c<>0) then _close;
//open
if (iptr.c=0) and (iports<>'') then
   begin
   p:=freeport(iports,true);
   iptr:=nw.openserverUDP(p);
   if (iptr.c<>0) then
      begin
      iport:=p;
      isocket:=nw.socket[iptr];
      nw.onread[iptr]:=_onread;
      nw.onwrite[iptr]:=_onwrite;
      end;//end of if
   end;//end of if
except;end;
end;
//## _close ##
procedure tudppackets._close;
begin
try
if (iptr.c<>0) then
   begin
   //.port
   iport:=0;
   isocket:=invalid_socket;
   //.socket
   nw.close(iptr);
   //.pointer
   iptr.c:=0;
   end;//end of if
except;end;
end;
//## getonline ##
function tudppackets.getonline:boolean;
begin
try;result:=(iptr.c<>0) and (iport<>0);except;end;
end;
//## _onread ##
procedure tudppackets._onread(sender:tobject);
begin//only use if "non-linear" packets are ok, else rely solely on "_ontimer"
try;pull;except;end;
end;
//## _onwrite ##
procedure tudppackets._onwrite(sender:tobject);
begin//only use if "non-linear" packets are ok, else rely solely on "_ontimer"
try;push;except;end;
end;
//## canpull ##
function tudppackets.canpull:boolean;
begin
try;result:=iinqueue.canpush;except;end;
end;
//## pull ##
function tudppackets.pull:boolean;
const//we prefer to pull from network buffer, even if queue is full, since it shifts
     //full network buffer problem to our local queue full problem, allowing us to
     //control the situation and not the network protocol system!
   buflen=UDPdatalimit;
var
   buf:array[0..(buflen-1)] of char;
   tmp:string;
   ca:tsockaddrin;
   len,caLEN:integer;
begin
try
//defaults
result:=false;
caLEN:=sizeof(ca);
//get
if nw.canrecvfrom(iptr) then
   begin
   len:=frcrange(n_recvfrom(isocket,buf,buflen,0,ca,caLEN),0,buflen);
   if (len>=1) then
      begin
      //set
      general.croll(recvbytes,len);
      general.croll(inhits,1);
      general.croll(hits,1);
      nw.recvinc(iptr,len);
      setstring(tmp,buf,len);
      result:=iinqueue.pushex(tmp,ca.sin_addr.S_addr,n_ntohs(ca.sin_port),0);
      end;//end of if
   end;//end of if
except;end;
end;
//## canpush ##
function tudppackets.canpush:boolean;
begin//has throttle control
try;result:=((ipushrate<=0) or (ipushcount>=1)) and (ioutqueue.active>=1);except;end;
end;
//## push ##
function tudppackets.push:boolean;
const
   buflen=UDPdatalimit;
var
   buf:array[0..(buflen-1)] of char;
   c,len,caLEN:integer;
   tmp,ip:integer;
   port:word;
   data:string;
   ca:tsockaddrin;
begin
try
//defaults
result:=false;
caLEN:=sizeof(tsockaddrin);
//process
if canpush and nw.cansendto(iptr) and ioutqueue.pullex(data,ip,port,tmp) then
   begin
   //dec - throttle
   if (ipushcount>=1) then dec(ipushcount);//rate of packets allowed per second
   //get
   len:=frcrange(length(data),1,buflen);
   tonullstr(@buf,buflen,data);
   ca.sin_family:=PF_INET;
   ca.sin_port:=n_htons(port);
   ca.sin_addr.s_addr:=ip;
   //set
   len:=n_sendto(isocket,buf,len,0,ca,caLEN);
   case (len>=1) of
   true:begin//successful
      general.croll(sendbytes,len);
      nw.sentinc(iptr,len);
      result:=true;
      //.hits
      general.croll(outhits,1);
      end;//end of begin
   false:begin//failed to send packet, so add it back onto the list
      ioutqueue.pushex(data,ip,port,tmp);
      end;//end of begin
   end;//end of case
   end;//end of if
except;end;
end;
//## inflush ##
procedure tudppackets.inflush;
begin
try;if iinqueue.canclear then iinqueue.clear;except;end;
end;
//## outflush ##
procedure tudppackets.outflush;
begin
try;if ioutqueue.canclear then ioutqueue.clear;except;end;
end;
//## getinboundactive ##
function tudppackets.getinboundactive:integer;
begin
try;result:=iinqueue.active;except;end;
end;
//## getoutboundactive ##
function tudppackets.getoutboundactive:integer;
begin
try;result:=ioutqueue.active;except;end;
end;
//## cansend ##
function tudppackets.cansend:boolean;
begin
try;result:=ioutqueue.canpush;except;end;
end;
//## send ##
function tudppackets.send(ip:integer;port:word;data:string):boolean;
begin
try
//defaults
result:=false;
//set
if cansend then result:=(ip<>0) and (port<>0) and ioutqueue.pushex(data,ip,port,0);
except;end;
end;

//## tudpbasic #################################################################
//## create ##
constructor tudpbasic.create;
var
   p:integer;
   i4:tint4;
begin
//self
inherited;
//vars
ispeedtime:=ms64;
ihdrsize:=9;//size of protocol header - [style1][id4][serialno4]
idatalimit:=512-ihdrsize;
irclimit:=10;//10 trys
//.our unique serial number
isn:=general.serial('c');
if (isn=0) then isn:=random(maxint);
i4.val:=isn;
isnSTR:=i4.chars[0]+i4.chars[1]+i4.chars[2]+i4.chars[3];
//translations
tsTasks:=ntranslate('tasks');
tsInboundLoad:=ntranslate('inbound load');
tsOutboundLoad:=ntranslate('outbound load');
tsLoad:=ntranslate('load');
tsThrottle:=ntranslate('throttle');
tsMsgmin:=lowercase(translate('msg/min'));
tsMsgsec:=lowercase(translate('msg/sec'));
tsPKperMSG:=lowercase(translate('packets/message'));
tsInbound:=ntranslate('inbound');
tsConnections:=ntranslate('connections');
tsMessages:=ntranslate('messages');
tsOverhead:=ntranslate('overhead');
tsPackets:=ntranslate('packets');
tsBytes:=ntranslate('bytes');
tsOutbound:=ntranslate('outbound');
tsQueue:=ntranslate('queue');
tsFailed:=ntranslate('failed');
tsFailedmessages:=ntranslate('failed messages');
istatustime:=ms64-1000;
isocket:=invalid_socket;
iopentime:=ms64;
iptr.c:=0;
iport:=0;//not in use
iports:='';
//controls
//.client
icstate:=tdynamicbyte.create;
iccount:=tdynamicbyte.create;
ictime:=tdynamiccurrency.create;
icip:=tdynamicinteger.create;
icid:=tdynamicinteger.create;
icsn:=tdynamicinteger.create;
icusertag:=tdynamicinteger.create;
icport:=tdynamicword.create;
icdata:=tdynamicstring.create;
icdone:=tdynamicboolean.create;
icqueue:=tqueuestring.create;
irqueue:=tqueuestring.create;
iuqueue:=tqueuestring.create;
iwqueue:=tqueuestring.create;
icspeed:=trates.create;
//.server
isqueue:=tqueuestring.create;
isid:=tdynamicinteger.create;
issn:=tdynamicinteger.create;
isip:=tdynamicinteger.create;
isport:=tdynamicword.create;
istime:=tdynamiccurrency.create;
isspeed:=trates.create;
//defaults
inlimit:=1000;//1000 by default - 20FEB2008
rlimit:=1000;
ulimit:=1000;
wlimit:=1000;
throttle:=5000;//dialup speed
itimer:=mt.new(_ontimer,200,true);//fixed @ 5fps, important for throttle
mt.slowon(islowref);
itimerfast:=mt.new(_ontimerfast,200,true);//fixed @ 5fps, important for throttle
end;
//## destroy ##
destructor tudpbasic.destroy;
var
   p:integer;
begin
try
//timer
mt.del(itimer);
mt.del(itimerfast);
//close
_close;
//controls
freeobj(@icstate);
freeobj(@iccount);
freeobj(@ictime);
freeobj(@icip);
freeobj(@icid);
freeobj(@icsn);
freeobj(@icusertag);
freeobj(@icport);
freeobj(@icdata);
freeobj(@icdone);
freeobj(@icqueue);
freeobj(@irqueue);
freeobj(@iuqueue);
freeobj(@iwqueue);
freeobj(@icspeed);
//.server
freeobj(@isqueue);
freeobj(@isid);
freeobj(@issn);
freeobj(@isip);
freeobj(@isport);
freeobj(@istime);
freeobj(@isspeed);
//self
inherited;
except;end;
end;
//## setlimits ##
procedure tudpbasic.setlimits(x:integer);
begin
try
//range
x:=frcmin(x,100);
//set
rlimit:=x;
ulimit:=x;
wlimit:=x;
inlimit:=x;
except;end;
end;
//## getmsgsec ##
function tudpbasic.getmsgsec:integer;
begin
try;result:=frcmin(ithrottle div 1000,1);except;end;
end;
//## setmsgsec ##
procedure tudpbasic.setmsgsec(x:integer);
begin
try
//range
x:=x*1000;
//set
if (x<>throttle) then throttle:=x;
except;end;
end;
//## setthrottle ##
procedure tudpbasic.setthrottle(x:integer);
var
   _limit,_rate:integer;
begin
try
//range
x:=frcrange(x,5000,500000);//5..500K/sec
//get
if general.setint(x,ithrottle) then
   begin
   //safe ranges
   _limit:=frcrange((x div 50),100,5000);
   _rate:=frcrange(x div 1000,5,500);
   ilimit:=_limit;
   //client
   icstate.setparams(ilimit,ilimit,0);
   iccount.setparams(ilimit,ilimit,0);
   ictime.setparams(ilimit,ilimit,0);
   icip.setparams(ilimit,ilimit,0);
   icid.setparams(ilimit,ilimit,0);
   icsn.setparams(ilimit,ilimit,0);
   icusertag.setparams(ilimit,ilimit,0);
   icport.setparams(ilimit,ilimit,0);
   icdata.setparams(ilimit,ilimit,0);
   icdone.setparams(ilimit,ilimit,0);
   //server
   isid.setparams(ilimit,ilimit,0);
   issn.setparams(ilimit,ilimit,0);
   isip.setparams(ilimit,ilimit,0);
   isport.setparams(ilimit,ilimit,0);
   istime.setparams(ilimit,ilimit,0);
   //rate
   irate:=_rate;//5..500 - safe
   //sync
   ilimitmodified:=true;//sync.ed within _ontimer
   end;//end of if
except;end;
end;
//## newid ##
function tudpbasic.newid:integer;//1..maxint
begin
try
//defaults
result:=0;//error
//get
if (icoreid<=0) or (icoreid>=maxint) then icoreid:=1 else inc(icoreid);
result:=icoreid;
except;end;
end;
//## valid ##
function tudpbasic.valid(x:integer):boolean;
begin
try;result:=(x>=0) and (x<ilimit);except;end;
end;
//## ctime ##
function tudpbasic.ctime(rightaway:boolean):currency;
begin
try;if rightaway then result:=ms64-99999 else result:=ms64+2000;except;end;
end;
//## stime ##
function tudpbasic.stime:currency;
begin
try;result:=ms64+30000;except;end;//allow for a short linger
end;
//## ceventclose ##
procedure tudpbasic.ceventclose(x:integer;ok:boolean);
var
   data:string;
begin
try
//check
if (not valid(x)) or (icstate.items[x]=0) then exit;
//event
icstate.items[x]:=1;//hold
if assigned(fonclient) then fonclient(self,icip.items[x],icport.items[x],icusertag.items[x],'');
//delete
icdata.items[x]^:='';
icstate.items[x]:=0;//free
icactive:=frcmin(icactive-1,0);
//information
if ok then
   begin
   general.croll(messagesSent,1);
   icspeed.incby(rtesGood,1);
   end
else general.croll(messagesFail,1);
except;end;
end;
//## _onread ##
procedure tudpbasic._onread(sender:tobject);//09FEB2008
const//we prefer to pull from network buffer, even if queue is full, since it shifts
     //full network buffer problem to our local queue full problem, allowing us to
     //control the situation and not the network protocol system!
   buflen=512;
var
   buf:array[0..(buflen-1)] of char;
   tmp:string;
   ca:tsockaddrin;
   len,caLEN:integer;
   ok:boolean;
begin
try
//defaults
caLEN:=sizeof(ca);
//get
if nw.canrecvfrom(iptr) then
   begin
   len:=frcrange(n_recvfrom(isocket,buf,buflen,0,ca,caLEN),0,buflen);//range: hdrsize...512
   //inc
   if (len>=1) then
      begin
      //information
      nw.recvinc(iptr,len);
      general.croll(packetsRecv,1);
      general.croll(bytesRecv,len);
      general.croll(bandwidth,len);
      //set
      if (len>=ihdrsize) or iraw then
         begin
         setstring(tmp,buf,len);
         //decide - packets are "from X" ie. "from (s)erver -> client.queue"
         if isserver(buf[0]) then
            begin
            general.croll(__packetsClient,1);
            icqueue.pushex(tmp,ca.sin_addr.s_addr,n_ntohs(ca.sin_port),0);
            end
         else//allow "bad packets or hack/attack packet in" allows for logging down the road...
            begin
            //queue task - note must filter out repeats later, as this queue must remain fast
            general.croll(__packetsServer,1);
            ok:=isqueue.pushex(tmp,ca.sin_addr.s_addr,n_ntohs(ca.sin_port),0);
            //Warning: this could be a security breach, since any old packet that is marked
            //         "reliable" will be replied to, so we must stop doing this once the
            //         "isqueue" is full, which will act as a break to the system, reducing
            //         a full 20,000 packets/sec to throttle packets/sec reducing the overal
            //         outbound bandwidth to just over that of a dialup connection which is
            //         essentially useless for attacking purposes - 09FEB2008
            //Immediate reply with just "style+id+sn = 9 bytes" - confirm reception of inbound request from server (reliable only)
            if ok and isclient(buf[0]) and (buf[0]=ubsReliable) and sendpacket(ca.sin_addr.s_addr,n_ntohs(ca.sin_port),ubsServer+buf[1]+buf[2]+buf[3]+buf[4]+buf[5]+buf[6]+buf[7]+buf[8]) then general.croll(__packetsServer,1);
            end;//end of if
         end;//end of if
      end;//end of if
   end;//end of if
except;end;
end;
//## cfind ##
function tudpbasic.cfind(id,sn,ip:integer;port:word;var index:integer):boolean;
var//Note: sn=serial number of client's machine - keeps connections from multiple clients behind same IP unique
   p:integer;
begin
try
//defaults
result:=false;
index:=-1;
//scan
for p:=0 to (ilimit-1) do if (icstate.items[p]<>0) and (icid.items[p]=id) and (icsn.items[p]=sn) and (icip.items[p]=ip) and (icport.items[p]=port) then
   begin
   index:=p;
   result:=true;
   break;
   end;//end of if
except;end;
end;
//## cdo ##
function tudpbasic.cdo:boolean;//process client based items
var
   ucount,_usertag,tmp,ip,i,p:integer;
   port:word;
   _ms64:currency;
   ok:boolean;
   _id,_sn:tint4;
   data:string;
begin
try
//defaults
result:=false;
_ms64:=ms64;
//QUEUE - reply packets from server to tell client request was recved and processed
for p:=0 to (icqueue.active-1) do
if icqueue.pullex(data,ip,port,i) then
   begin
   _id.chars[0]:=data[2];
   _id.chars[1]:=data[3];
   _id.chars[2]:=data[4];
   _id.chars[3]:=data[5];
   _sn.chars[0]:=data[6];
   _sn.chars[1]:=data[7];
   _sn.chars[2]:=data[8];
   _sn.chars[3]:=data[9];
   //client request completed - event => close
   if cfind(_id.val,_sn.val,ip,port,i) then ceventclose(i,true);
   end
else break;
//SEND QUEUED
ucount:=frcmin(icpushcount div 2,1);
while true do
begin
ok:=false;
//reliable - place in connections queue
if (icactive<ilimit) and irqueue.pullex(data,ip,port,_usertag) then
   begin
   ok:=true;
   sendnow(ip,port,_usertag,data);//reliable only
   end;//end of if
//unreliable - send right now (use only half of "icpushcount")
if (ucount>=1) and iuqueue.pullex(data,ip,port,_usertag) then
   begin
   //range
   ok:=true;
   if (length(data)>idatalimit) then setlength(data,idatalimit);
   //send
   _id.val:=newid;
                      //style1      //id4                                               //serialno4 +data503
   sendpacket(ip,port,ubsUnreliable+_id.chars[0]+_id.chars[1]+_id.chars[2]+_id.chars[3]+isnSTR+data);
   general.croll(__packetsClient,1);
   //information
   general.croll(messagesSent,1);
   icspeed.incby(rtesGood,1);
   //inc
   icpushcount:=frcmin(icpushcount-1,0);
   dec(ucount);
   //event
   if assigned(fonclient) then fonclient(self,ip,port,_usertag,'');
   end;//end of if
//raw - send right now (use only half of "icpushcount")
if (ucount>=1) and iwqueue.pullex(data,ip,port,_usertag) then
   begin
   //range
   ok:=true;
   if (length(data)>511) then setlength(data,511);
   //send
   sendpacket(ip,port,ubsRaw+data);
   general.croll(__packetsClient,1);
   //information
   general.croll(messagesSent,1);
   icspeed.incby(rtesGood,1);
   //inc
   icpushcount:=frcmin(icpushcount-1,0);
   dec(ucount);
   //event
   if assigned(fonclient) then fonclient(self,ip,port,_usertag,'');
   end;//end of if
//quit
if not ok then break;
end;//end of loop
//ITEMS
i:=icpos;
for p:=0 to (ilimit-1) do
begin
//check
if (icactive<=0) then break;
if (i<0) or (i>=ilimit) then i:=0;
//get
if (icstate.items[i]=2) then
   begin
   ok:=(ictime.items[i]>=_ms64);
   if (iccount.items[i]<=0) and (not ok) then ceventclose(i,false)
   else if (icpushcount>=1) and (not ok) and sendpacket(icip.items[i],icport.items[i],icdata.items[i]^) then
      begin
      general.croll(__packetsClient,1);
      iccount.items[i]:=frcmin(iccount.items[i]-1,0);
      ictime.items[i]:=ctime(false);
      icpushcount:=frcmin(icpushcount-1,0);
      //make task timer run fast
      result:=true;
      end;//end of if
   end;//end of if
//inc
inc(i);
end;//end of loop
//set
icpos:=i;
except;end;
end;
//## getsactive ##
function tudpbasic.getsactive:integer;
begin
try;result:=isqueue.active;except;end;
end;
//## sdo ##
function tudpbasic.sdo:boolean;//process server based items
var
   datalen,tmp,ip,p:integer;
   port:word;
   _id,_sn:tint4;
   _raw:boolean;
   data:string;
begin
try
//defaults
result:=false;
//QUEUE - inbound packets from client to server
for p:=0 to (isqueue.active-1) do
if isqueue.pullex(data,ip,port,tmp) then
   begin
   //make task timer run fast
   result:=true;
   //init
   _id.val:=0;
   _sn.val:=0;
   datalen:=length(data);
   //get
   _raw:=(datalen>=1) and (data[1]=ubsRaw);
   if (not _raw) and (datalen>=ihdrsize) then
      begin
      _id.chars[0]:=data[2];
      _id.chars[1]:=data[3];
      _id.chars[2]:=data[4];
      _id.chars[3]:=data[5];
      _sn.chars[0]:=data[6];
      _sn.chars[1]:=data[7];
      _sn.chars[2]:=data[8];
      _sn.chars[3]:=data[9];
      end;//end of if
   //set - skip over "repeats" so "spushcount" only counts successful "event triggers"
   //Note: "iraw+_raw=>true=>is raw" else error when reading raw packets
   if sevent(_id.val,_sn.val,ip,port,(iraw and _raw),data) then ispushcount:=frcmin(ispushcount-1,0);
   if (ispushcount<=0) then break;
   end
else break;
except;end;
end;
//## sevent ##
function tudpbasic.sevent(id,sn,ip:integer;port:word;raw:boolean;var data:string):boolean;
var
   p:integer;
   _ms64:currency;
begin
try
//defaults
result:=false;
//raw - no caching or linger, process direct (not using reliable or unreliable methods, data packet is RAW but recongised by macthing to RAWHDR)
if raw and (ip<>0) and (port<>0) then
   begin
   //inc
   general.croll(messagesRecv,1);//Note: server has no way of knowing message was successful or failed, must assumed successful
   isspeed.incby(rtesGood,1);
   //event - remove "ubsRaw"
   if assigned(fonserver) then fonserver(self,ip,port,copy(data,2,length(data)),false,false);
   //successful
   result:=true;
   //quit
   exit;
   end;//end of if
//check
if (ip=0) or (port=0) or (id=0) or (sn=0) or (length(data)<ihdrsize) or (not isclient(data[1])) then
   begin
   if assigned(fonserver) then fonserver(self,ip,port,data,false,true);//error
   exit;
   end;//end of if
//init
_ms64:=ms64;
//find - ignore repeat requests (client sending request again due to dropped packet, handled at "_onread")
for p:=0 to (ilimit-1) do if (isid.items[p]=id) and (issn.items[p]=sn) and (isip.items[p]=ip) and (isport.items[p]=port) and (istime.items[p]>=_ms64) then exit;
//GET
//inc
general.croll(messagesRecv,1);//Note: server has no way of knowing message was successful or failed, must assumed successful
isspeed.incby(rtesGood,1);
//event
if assigned(fonserver) then fonserver(self,ip,port,copy(data,ihdrsize+1,length(data)),(data[1]=ubsReliable),false);
//new - moves to next position, we have 20,000 @ 500/sec should last about 40 seconds, long enough for client requests to timeout and use new ID - 23JAN2008
p:=ispos+1;
if (p>=ilimit) or (p<0) then p:=0;
ispos:=p;
//set
isid.items[p]:=id;
issn.items[p]:=sn;
isip.items[p]:=ip;
isport.items[p]:=port;
istime.items[p]:=stime;//linger time 30sec
//successful
result:=true;
except;end;
end;
//## sendpacket ##
function tudpbasic.sendpacket(ip:integer;port:word;data:string):boolean;
const
   buflen=512;
var
   buf:array[0..(buflen-1)] of char;
   ca:tsockaddrin;
   caLEN,len,slen:integer;
begin
try
//defaults
result:=false;
len:=frcrange(length(data),1,buflen);
//check
if (ip=0) or (port=0) or (len=0) then exit;
//get
caLEN:=sizeof(tsockaddrin);
tostruc(@buf,buflen,data);
ca.sin_family:=PF_INET;
ca.sin_addr.s_addr:=ip;
ca.sin_port:=n_htons(port);
//set
slen:=n_sendto(isocket,buf,len,0,ca,caLEN);
//information
if (slen>=1) then
   begin
   nw.sentinc(iptr,slen);
   general.croll(packetsSent,1);
   general.croll(bytesSent,slen);
   general.croll(bandwidth,slen);
   end;//end of if
//successful
result:=(slen=len);
except;end;
end;
//## _ontimerfast ##
procedure tudpbasic._ontimerfast(sender:tobject);
const
   ppc=10;//packets per cycle (up to 12 works)
var
   ok:boolean;
   ms:currency;
begin
try
//defaults
ok:=false;
//throttle
icpushcount:=ppc;
ispushcount:=ppc;
//get - client and server items
if cdo then ok:=true;
if sdo then ok:=true;
//set
if ok then mt.slowoff(islowref);
//interval
ms:=frccurrange(1000/(irate/ppc),10,1000);
mt.interval[itimerfast]:=frccurmin(mt.slowauto(islowref,ms),ms);//never slower than "ms" where ms>200 (since slow is 200ms)
except;end;
end;
//## _ontimer ##
procedure tudpbasic._ontimer(sender:tobject);
const
   sep=' -- ';
   indent='* ';
var
   inload,outload,c0,c1,c2,c3,c4:currency;
   ca,maxp,tmp,ip,p:integer;
   port:word;
   data:string;
begin
try
//check
if (sysstate>=ssClosed) then exit;
//port
if ((ms64-iopentime)>=5000) then
   begin
   //.set
   case (iptr.c<>0) of
   true:if (iports='') then _close;
   false:if (iports<>'') then _open;
   end;//end of case
   //.reset
   iopentime:=ms64;
   end;//end of if
//speed
if ((ms64-ispeedtime)>=2000) then
   begin
   icspeed.going:=(icactivelast>=1);//01FEB2008 - stretch stat so it has time to view it
   isspeed.going:=(sactive>=1);
   //reset
   ispeedtime:=ms64;
   icactivelast:=icactive;
   end;//end of if
//sync - re-sync active counters since "limit" changed - only safe way of re-aligning counters
if ilimitmodified then
   begin
   //init
   ilimitmodified:=false;
   ca:=0;
   //get
   for p:=0 to (ilimit-1) do if (icstate.items[p]<>0) then inc(ca);
   //set
   icactive:=ca;
   if (icactive>icactivelast) then icactivelast:=icactive;
   end;//end of if
//status
if ((ms64-istatustime)>=1000) then
   begin
   //init
   overheadRecv:=frccurmin(__packetsServer/frccurmin(messagesRecv,1),0);
   overheadSent:=frccurmin(__packetsClient/frccurmin(messagesSent,1),0);
   //.load
   c0:=general.cpercentage(iwqueue.active,iwqueue.size);
   c1:=general.cpercentage(irqueue.active,irqueue.size);
   c2:=general.cpercentage(iuqueue.active,iuqueue.size);
   c4:=frccurmin(csmallestex([iuqueue.size,irqueue.size]),ilimit);
   c3:=general.cpercentage(icactive,c4);
   outload:=clargestex([c0,c1,c2,c3]);
   inload:=general.cpercentage((sactive/10),irate);//10xrate=100% load
   c1:=clargestex([outload,inload]);
   //get
   istatus:=
   tsAddress+#9+_strip(machine_ip)+':'+general.aorbstr('?',inttostr(iport),online)+' / '+general.aorbstr(tsOffline,tsOnline,online)+rcode+
   tsBandwidth+#9+general.curcomma(bandwidth)+#32+lowercase(tsbytes)+rcode+
   tsTasks+#9+general.thousands(sactive)+' / '+general.thousands(isqueue.size)+rcode+
   tsFailed+#9+general.curcomma(messagesFail)+rcode+
   tsInboundLoad+#9+general.percentage(inload,true)+' - '+isspeed.ratestr(rtesGood,rteuMin)+#32+tsMsgmin+rcode+
   tsOutboundLoad+#9+general.percentage(outload,true)+' - '+icspeed.ratestr(rtesGood,rteuMin)+#32+tsMsgmin+rcode+
   tsThrottle+#9+general.aorbstr('-',general.thousands(irate)+#32+tsMsgsec+' ('+general.thousands(60*irate)+#32+tsMsgmin+')',throttle>=1)+rcode+
   statuscomments+
   //.advanced
   general.insstr(
   rcode+
   tsinbound+rcode+
   indent+tsTasks+#9+general.thousands(sactive)+' / '+general.thousands(isqueue.size)+rcode+
   indent+tsmessages+#9+general.curcomma(messagesRecv)+rcode+
   indent+tsoverhead+#9+floattostrex(overheadRecv,2)+#32+tsPKperMSG+rcode+
   indent+tspackets+#9+general.curcomma(packetsRecv)+rcode+
   indent+tsbytes+#9+general.curcomma(bytesRecv)+rcode+
   indent+ntranslate('rate')+#9+general.percentageb(general.cpercentage(isspeed.rate(rtesGood,rteuMin),irate*60),2,true)+' - '+isspeed.ratestr(rtesGood,rteuMin)+#32+tsMsgmin+rcode+//msg/min
   rcode+
   tsoutbound+rcode+
   indent+tsTasks+#9+general.thousands(icactive)+' / '+general.thousands(ilimit)+rcode+
   indent+tsqueue+'(r)'+#9+general.thousands(irqueue.active)+' / '+general.thousands(irqueue.size)+rcode+
   indent+tsqueue+'(u)'+#9+general.thousands(iuqueue.active)+' / '+general.thousands(iuqueue.size)+rcode+
   general.insstr(indent+tsqueue+'(w)'+#9+general.thousands(iwqueue.active)+' / '+general.thousands(iwqueue.size)+rcode,raw)+
   indent+tsmessages+#9+general.curcomma(messagesSent)+rcode+
   indent+tsoverhead+#9+floattostrex(overheadSent,2)+#32+tsPKperMSG+rcode+
   indent+tsfailedmessages+#9+general.curcomma(messagesFail)+rcode+
   indent+tspackets+#9+general.curcomma(packetsSent)+rcode+
   indent+tsbytes+#9+general.curcomma(bytesSent)+rcode+
   indent+ntranslate('rate')+#9+general.percentageb(general.cpercentage(icspeed.rate(rtesGood,rteuMin),irate*60),2,true)+' - '+icspeed.ratestr(rtesGood,rteuMin)+#32+tsMsgmin//msg/min
   ,advancedstatus);
   //reset
   istatustime:=ms64;
   end;//end of if
//network stalled, so restart by force
_onread(self);
except;end;
end;
//## portrange ##
function tudpbasic.portrange(_from,_to:integer):string;
begin
try;result:=misc.numbers(_from,_to,',');except;end;
end;
//## setports ##
procedure tudpbasic.setports(x:string);
begin
try
if (x<>iports) then
   begin
   iports:=x;
   _close;
   iopentime:=ms64-9999;//try straight away
   end;//end of if
except;end;
end;
//## _open ##
procedure tudpbasic._open;
var
   p:integer;
begin
try
//close
if (iptr.c<>0) then _close;
//open
if (iptr.c=0) and (iports<>'') then
   begin
   p:=freeport(iports,true);
   iptr:=nw.openserverUDP(p);
   if (iptr.c<>0) then
      begin
      iport:=p;
      isocket:=nw.socket[iptr];
      nw.onread[iptr]:=_onread;
      nw.onwrite[iptr]:=_onwrite;
      end;//end of if
   end;//end of if
except;end;
end;
//## _close ##
procedure tudpbasic._close;
begin
try
if (iptr.c<>0) then
   begin
   //.port
   iport:=0;
   isocket:=invalid_socket;
   //.socket
   nw.close(iptr);
   //.pointer
   iptr.c:=0;
   end;//end of if
except;end;
end;
//## getonline ##
function tudpbasic.getonline:boolean;
begin
try;result:=(iptr.c<>0) and (iport<>0);except;end;
end;
//## _onwrite ##
procedure tudpbasic._onwrite(sender:tobject);
begin
//nil
end;
//## isserver ##
function tudpbasic.isserver(style:char):boolean;
begin
try;result:=(style=ubsServer);except;end;
end;
//## isclient ##
function tudpbasic.isclient(style:char):boolean;
begin
try;result:=(style=ubsReliable) or (style=ubsUnreliable) or (style=ubsRaw);except;end;
end;
//## flush ##
procedure tudpbasic.flush;
var
   p:integer;
begin
try
for p:=0 to (ilimit-1) do
begin
ceventclose(p,false);
isip.items[p]:=0;
end;//end of loop
except;end;
end;
//## cansendnow ##
function tudpbasic.cansendnow:boolean;
begin
try;result:=(icactive<ilimit);except;end;
end;
//## sendnow ##
function tudpbasic.sendnow(ip:integer;port:word;usertag:integer;data:string):boolean;//reliable only
var
   i,p:integer;
   _id:tint4;
begin
try
//defaults
result:=false;
p:=-1;
//check
if (ip=0) or (port=0) or (not cansendnow) then exit;
if (length(data)>idatalimit) then setlength(data,idatalimit);
//new
for i:=0 to (ilimit-1) do if (icstate.items[i]=0) then
   begin
   p:=i;
   icstate.items[p]:=1;//hold
   inc(icactive);
   if (icactive>icactivelast) then icactivelast:=icactive;
   break;
   end;//end of if
if (p=-1) then exit;
//set
_id.val:=newid;
icdone.items[p]:=false;
ictime.items[p]:=ctime(true);
iccount.items[p]:=irclimit;
icid.items[p]:=_id.val;
icsn.items[p]:=isn;
icusertag.items[p]:=usertag;
icip.items[p]:=ip;
icport.items[p]:=port;
//data            //style1    //id4                                               //iserialno4 //data503
icdata.items[p]^:=ubsReliable+_id.chars[0]+_id.chars[1]+_id.chars[2]+_id.chars[3]+isnSTR+data;
icstate.items[p]:=2;//inuse
//successful
result:=true;
except;end;
end;
//## getinlimit ##
function tudpbasic.getinlimit:integer;
begin
try;result:=icqueue.size;except;end;
end;
//## setinlimit ##
procedure tudpbasic.setinlimit(x:integer);
begin
try
//range
x:=frcmin(x,100);
//set
icqueue.size:=x;
isqueue.size:=x;
except;end;
end;
//## getrlimit ##
function tudpbasic.getrlimit:integer;
begin
try;result:=irqueue.size;except;end;
end;
//## setrlimit ##
procedure tudpbasic.setrlimit(x:integer);
begin
try
irqueue.size:=frcmin(x,100);
irsafelevel:=frcmin(round(irqueue.size*0.75),5);
except;end;
end;
//## getulimit ##
function tudpbasic.getulimit:integer;
begin
try;result:=iuqueue.size;except;end;
end;
//## setulimit ##
procedure tudpbasic.setulimit(x:integer);
begin
try
iuqueue.size:=frcmin(x,100);
iusafelevel:=frcmin(round(iuqueue.size*0.75),5);
except;end;
end;
//## getwlimit ##
function tudpbasic.getwlimit:integer;
begin
try;result:=iwqueue.size;except;end;
end;
//## setwlimit ##
procedure tudpbasic.setwlimit(x:integer);
begin
try
iwqueue.size:=frcmin(x,100);
iwsafelevel:=frcmin(round(iwqueue.size*0.75),5);
except;end;
end;
//## rsafelevel ##
function tudpbasic.rsafelevel:boolean;
begin//fixed at 75% of limit
try;result:=(irqueue.active<irsafelevel);except;end;
end;
//## usafelevel ##
function tudpbasic.usafelevel:boolean;
begin//fixed at 75% of limit
try;result:=(iuqueue.active<iusafelevel);except;end;
end;
//## wsafelevel ##
function tudpbasic.wsafelevel:boolean;
begin//fixed at 75% of limit
try;result:=(iwqueue.active<iwsafelevel);except;end;
end;
//## rfree ##
function tudpbasic.rfree:integer;//number of queue slots available
begin
try;result:=frcmin(irqueue.size-irqueue.active,0);except;end;
end;
//## ufree ##
function tudpbasic.ufree:integer;//number of queue slots available
begin
try;result:=frcmin(iuqueue.size-iuqueue.active,0);except;end;
end;
//## wfree ##
function tudpbasic.wfree:integer;//number of queue slots available
begin
try;result:=frcmin(iwqueue.size-iwqueue.active,0);except;end;
end;
//## rcansend ##
function tudpbasic.rcansend:boolean;
begin
try;result:=(rfree>=1);except;end;
end;
//## ucansend ##
function tudpbasic.ucansend:boolean;
begin
try;result:=(ufree>=1);except;end;
end;
//## wcansend ##
function tudpbasic.wcansend:boolean;
begin
try;result:=(wfree>=1);except;end;
end;
//## rsend ##
function tudpbasic.rsend(ip:integer;port,usertag:word;data503:string):boolean;
begin
try
//defaults
result:=false;
//check
if (ip=0) or (port=0) or (not rcansend) then exit;
//range
if (length(data503)>idatalimit) then setlength(data503,idatalimit);
//add
result:=irqueue.pushex(data503,ip,port,usertag);
except;end;
end;
//## usend ##
function tudpbasic.usend(ip:integer;port,usertag:word;data503:string):boolean;
begin
try
//defaults
result:=false;
//check
if (ip=0) or (port=0) or (not ucansend) then exit;
//range
if (length(data503)>idatalimit) then setlength(data503,idatalimit);
//add
result:=iuqueue.pushex(data503,ip,port,usertag);
except;end;
end;
//## wsend ##
function tudpbasic.wsend(ip:integer;port,usertag:word;data511:string):boolean;
begin
try
//defaults
result:=false;
//check
if (ip=0) or (port=0) or (not wcansend) then exit;
//range
if (length(data511)>511) then setlength(data511,511);
//add
result:=iwqueue.pushex(data511,ip,port,usertag);
except;end;
end;

//## tudpex ####################################################################
//## create ##
constructor tudpex.create;
var
   p:integer;
begin
//self
inherited;
//vars
ircount:=5;
isocket:=invalid_socket;
iopentime:=ms64;
iptr.c:=0;
iport:=0;//not in use
iports:='';
//.randomise iid
iid:=frcrange(random(udlIDLimit+1),1,udlIDLimit);
//clear
imax:=high(iitems);
for p:=0 to imax do iitems[p].inuse:=false;
ipitems:=@iitems;
//defaults
timeout:=30000;//30 seconds
//timer
itimer:=mt.new(_ontimer,1000,true);
itimerfast:=mt.new(_ontimerfast,250,true);
mt.slowon(islowref);
end;
//## destroy ##
destructor tudpex.destroy;
var
   p:integer;
begin
try
//timer
mt.del(itimer);
mt.del(itimerfast);
//close
_close;
//self
inherited;
except;end;
end;
//## _onread ##
procedure tudpex._onread(sender:tobject);
begin//only use if "non-linear" packets are ok, else rely solely on "_ontimer"
try;if (not linearflow) then pull;except;end;
end;
//## _onwrite ##
procedure tudpex._onwrite(sender:tobject);
begin
try
//range
if (ipos<0) then ipos:=0
else if (ipos>imax) then ipos:=0;
//push
push(ipos);
except;end;
end;
//## safelevel ##
function tudpex.safelevel:boolean;
begin
try;result:=(iactive<((imax+1) div 2));except;end;
end;
//## safelevelex ##
function tudpex.safelevelex(safezone:integer):boolean;
begin
try
//range
safezone:=frcrange(safezone,5,imax-5);
//get
result:=(iactive+safezone)<=imax;
except;end;
end;
//## activeinc ##
procedure tudpex.activeinc(x:integer;_inc:boolean);
var
   by:integer;
begin
try
//get
if _inc then by:=1 else by:=-1;
//set
if valid[x] then
   begin
   iactive:=frcmin(iactive+by,0);
   if (iitems[x].id>=udiClient) then iactiveclient:=frcmin(iactiveclient+by,0)
   else if (iitems[x].id<=udiServer) then iactiveserver:=frcmin(iactiveserver+by,0);
   end;//end of if
except;end;
end;
//## settimeout ##
procedure tudpex.settimeout(x:currency);
begin
try;itimeout:=frccurmin(x,8000);except;end;
end;
//## getvalid ##
function tudpex.getvalid(x:integer):boolean;
begin
try;result:=(x>=0) and (x<=imax);except;end;
end;
//## getinuse ##
function tudpex.getinuse(x:integer):boolean;
begin
try;result:=valid[x] and iitems[x].inuse;except;end;
end;
//## newid ##
function tudpex.newid(_type:integer):integer;
begin
try
//range
if (iid<0) then iid:=1
else if (iid>udlIDLimit) then iid:=1;
//set             //server(-N..-1)  //client(1..N)  //0=invalid id
if (_type<=udiServer) then result:=-iid else result:=iid;
//inc
inc(iid);
except;end;
end;
//## setpushing ##
procedure tudpex.setpushing(x:integer;_pushing:boolean);
begin
try
if valid[x] then
   begin
   iitems[x].pushing:=_pushing;
   iitems[x].aok:=false;
   iitems[x].bok:=false;
   end;//end of if
except;end;
end;
//## new ##
function tudpex.new(id,ip:integer;port:word;var r:integer):boolean;
var
   n,p:integer;
begin
try
//defaults
result:=false;
r:=-1;
n:=-1;
//check
if (id=udiNil) or (ip=0) or (port=0) then exit;
//scan
for p:=0 to imax do
if iitems[p].inuse then
   begin
   if (iitems[p].id=id) and (iitems[p].ip=ip) and (iitems[p].port=port) then
      begin
      r:=p;
      break;
      end;//end of if
   end
else if (n=-1) then n:=p;
//set
if (r=-1) and (n>=0) then
   begin
   r:=n;
   //fill
   iitems[r].extra:='';//for log
   iitems[r].id:=id;
   iitems[r].ip:=ip;
   iitems[r].port:=port;
   //.ca
   fillchar(iitems[r].ca,sizeof(iitems[r].ca),0);
   iitems[r].ca.sin_family:=PF_INET;
   iitems[r].ca.sin_port:=n_htons(port);
   iitems[r].ca.sin_addr.s_addr:=ip;
   //counters
   iitems[r].timeout:=ms64;
   iitems[r].rcount:=0;
   end;//end of if
//successful
result:=(r>=0);
except;end;
end;
//## client ##
function tudpex.client(ip:integer;port:word;data:string;_onclose:teventudpex;var rid:integer):boolean;
begin
try;result:=clientex(ip,port,data,0,_onclose,rid);except;end;
end;
//## clientex ##
function tudpex.clientex(ip:integer;port:word;data:string;tag:integer;_onclose:teventudpex;var rid:integer):boolean;
label
   skipend;
var
   len,p:integer;
   extra,a,b,tmp:string;
begin
try
//defaults
result:=false;
rid:=udiNil;
//check
if (not assigned(_onclose)) then exit;
//range
if (ip=0) or (port=0) then goto skipend;
//set
if new(newid(udiClient),ip,port,p) then
   begin
   //data
   encode(p,data,true);
   //flow
   setpushing(p,true);
   //event
   iitems[p].onclose:=_onclose;
   //user
   iitems[p].tag:=tag;
   //reset
   iitems[p].timeout:=ms64;
   //set
   rid:=iitems[p].id;
   //inc
   activeinc(p,true);
   //successful
   iitems[p].inuse:=true;
   //.push
   push(p);
   result:=true;
   end;//end of if
skipend:
except;end;
try
if not result then
   begin
   tmp:='';
   extra:='';
   if assigned(_onclose) then _onclose(self,-1,udiNil,tmp,extra);
   end;//end of if
except;end;
end;
//## closeitem ##
procedure tudpex.closeitem(x:integer;force:boolean);
label
   skipend;
var
   tmo:boolean;
   tmp:string;
begin
try
//process
if inuse[x] then
   begin
   tmo:=(ms64-iitems[x].timeout)>itimeout;
   if force or tmo then
      begin
      //client - retry
      if (iitems[x].id>=udiClient) and (not force) and tmo and (iitems[x].rcount<ircount) then
         begin
         //restore data
         iitems[x].adata:=iitems[x]._adata;
         iitems[x].bdata:=iitems[x]._bdata;
         //flow
         setpushing(x,true);
         //counters
         inc(iitems[x].rcount);
         general.croll(iretrys,1);
         iitems[x].timeout:=ms64;
         goto skipend;
         end;//end of if
      //client - event
      if (iitems[x].id>=udiClient) and assigned(iitems[x].onclose) then
         begin
         //data
         if tmo then tmp:='' else tmp:=iitems[x].adata+iitems[x].bdata;
         //call event
         iitems[x].onclose(self,x,iitems[x].id,tmp,iitems[x].extra);
         //log
         dolog(x);
         end;//end of if
      //close
      iitems[x].inuse:=false;
      //dec
      activeinc(x,false);
      end;//end of if
   end;//end of if
skipend:
except;end;
end;
//## dolog ##
procedure tudpex.dolog(x:integer);
var
   extra:string;
begin
try
//logs
if valid[x] and log then
   begin
   //get
   extra:=iitems[x].extra;
   //set
   rawlog.addentry(iitems[x].ip,now,'GET / UDP-ABC',wecOK,length(iitems[x].adata+iitems[x].bdata),'-','-','',extra,'');
   end;//end of if
except;end;
end;
//## encode ##
procedure tudpex.encode(x:integer;y:string;orgsync:boolean);
var//Note: converts plain data => 1/2 managed packets
   id,d1,d2:string;
   s1,s2:char;
   ylen:integer;
begin
try
if valid[x] then
   begin
   //swap dest. packet handler (client=>server and server=>client)
   id:=from32bit(-iitems[x].id);
   ylen:=length(y);
   //range
   if (ylen>0) then d1:=copy(y,1,udlData) else d1:='';
   if (ylen>udlData) then d2:=copy(y,1+udlData,udlData) else d2:='';
   //status
   if (d2='') then
      begin
      s1:='c';//1 packet only
      s2:='c';
      end
   else
      begin
      s1:='a';//2 packets (A+B)
      s2:='b';
      end;//end of if
   //packets
   //.1
   iitems[x].adata:=id+s1+d1;//1st packet
   iitems[x].bdata:=general.insstr(id+s2+d2,d2<>'');//2nd optional packet
   //orgsync
   if orgsync then
      begin
      iitems[x]._adata:=iitems[x].adata;
      iitems[x]._bdata:=iitems[x].bdata;
      end;//end of if
   end;//end of if
except;end;
end;
//## decode ##
procedure tudpex.decode(x:integer;orgsync:boolean);
begin//Note: converts 1/2 managed packets => plain data
try
if valid[x] then
   begin
   //get
   iitems[x].adata:=copy(iitems[x].adata,udlHead+1,udlData);//1st packet data
   iitems[x].bdata:=copy(iitems[x].bdata,udlHead+1,udlData);//2nd packet data
   //orgsync
   if orgsync then
      begin
      iitems[x]._adata:=iitems[x].adata;
      iitems[x]._bdata:=iitems[x].bdata;
      end;//end of if
   end;//end of if
except;end;
end;
//## pull ##
function tudpex.pull:boolean;
label
   skipend;
var
   buf:array[0..(udlPacket-1)] of char;
   tmp:string;
   ca:tsockaddrin;
   i,id,ip,len,caLEN:integer;
   port:word;
   s:char;
begin
try
//defaults
result:=false;
caLEN:=sizeof(ca);
//get
if nw.canrecvfrom(iptr) then
   begin
   len:=n_recvfrom(isocket,buf,udlPacket,0,ca,caLEN);
   //.inc
   if (len>=1) then nw.recvinc(iptr,len);
   //.data
   if (len>=udlHead) then
      begin
      //data has been transfered (keep network speed fast)
      result:=true;
      //fill
      setstring(tmp,buf,len);
      ip:=ca.sin_addr.S_addr;
      port:=n_ntohs(ca.sin_port);
      id:=to32bit(copy(tmp,1,4));
      //check
      if (id=udiNil) then goto skipend;
      //get
      if new(id,ip,port,i) then
         begin
         //init
         if not iitems[i].inuse then
            begin
            iitems[i].inuse:=true;
            //.server - must be set to "pushing=false(pulling)" since this instance has just been created
            if (id<=udiServer) then setpushing(i,false);
            //.inc
            activeinc(i,true);
            end;//end of if
         //flow check (client or server must be "pushing=false" else we must ignore this data
         if iitems[i].pushing then goto skipend;
         //reset
         iitems[i].timeout:=ms64;
         //status
         s:=tmp[5];
         if (s='a') or (s='A') then
            begin
            if not iitems[i].aok then
               begin
               iitems[i].adata:=tmp;
               iitems[i].aok:=true;
               end;//end of if
            end
         else if (s='b') or (s='B') then
            begin
            if not iitems[i].bok then
               begin
               iitems[i].bdata:=tmp;
               iitems[i].bok:=true;
               end;//end of if
            end
         else if (s='c') or (s='C') then
            begin
            iitems[i].adata:=tmp;
            iitems[i].bdata:='';
            iitems[i].aok:=true;
            iitems[i].bok:=true;
            end;//end of if
         //flow change
         if iitems[i].aok and iitems[i].bok then
            begin
            //server: [we are here] recv(pushing=false) -> send(pushing=true)
            if (iitems[i].id<=udiServer) then
               begin
               //decode
               decode(i,false);
               //event
               tmp:='';
               if assigned(fonserver) then
                  begin
                  tmp:=iitems[i].adata+iitems[i].bdata;
                  fonserver(self,i,iitems[i].id,tmp,iitems[i].extra);
                  dolog(i);
                  end;//end of if
               //reset
               iitems[i].timeout:=ms64;
               iitems[i].rcount:=0;
               //encode
               encode(i,tmp,true);
               //flow
               setpushing(i,true);
               push(i);
               end
            //client: send(pushing=true) -> recv(pushing=false) [we are here] -> done
            else if (iitems[i].id>=udiClient) then
               begin
               //decode
               decode(i,false);
               //close
               closeitem(i,true);
               end;//end of if
            end;//end of if
         end;//end of if
      end;//end of if
   end;//end of if
skipend:
except;end;
end;
//## push ##
function tudpex.push(p:integer):boolean;
label//Attempts to send both packets (if 2) one after the other.
   skipend,redo;
var
   buf:array[0..(udlPacket-1)] of char;
   c,len,caLEN:integer;
   port:word;
   tmp:string;
   aok,bok,once:boolean;
begin
try
//defaults
result:=false;
//check
if (not inuse[p]) or (not iitems[p].pushing) or (iitems[p].id=udiNil) then exit;
//init
caLEN:=sizeof(tsockaddrin);
once:=true;
//get
redo:
aok:=(iitems[p].adata<>'');
bok:=(iitems[p].bdata<>'');
if (aok or bok) and nw.cansendto(iptr) then
   begin
   //get
   if aok then
      begin
      len:=frcmax(length(iitems[p].adata),udlPacket);
      tonullstr(@buf,udlPacket,iitems[p].adata);
      end
   else if bok then
      begin
      len:=frcmax(length(iitems[p].bdata),udlPacket);
      tonullstr(@buf,udlPacket,iitems[p].bdata);
      end
   else goto skipend;
   //send
   len:=n_sendto(isocket,buf,len,0,iitems[p].ca,caLEN);
   if (len>=1) then
      begin
      //data has been transfered (keep network speed fast)
      result:=true;
      nw.sentinc(iptr,len);
      //shrink
      if aok then iitems[p].adata:=''
      else if bok then iitems[p].bdata:='';
      //reset
      iitems[p].timeout:=ms64;
      //set
      iitems[p].aok:=true;
      if (iitems[p].adata='') and (iitems[p].bdata='') then
         begin
         iitems[p].bok:=true;
         //.server: recv(pushing=false) -> send(pushing=true) -> done [we are here]
         if (iitems[p].id<=udiServer) then closeitem(p,true)
         //.client: send(pushing=true) [we are here] -> recv(pushing=false) -> done
         else if (iitems[p].id>=udiClient) then
            begin
            //flow
            setpushing(p,false);
            end;//end of if
         end
      else if once then
         begin
         once:=false;
         goto redo;
         end;//end of if
      end;//end of if
   end;//end of if
skipend:
except;end;
end;
//## _ontimerfast ##
procedure tudpex._ontimerfast(sender:tobject);
var
   ca:tsockaddrin;//client address
   p:integer;
begin
try
//check
if (isocket=invalid_socket) then exit;
//process
for p:=0 to imax do
begin
//.range
if (ipos<0) then ipos:=0
else if (ipos>imax) then ipos:=0;
//.push
push(ipos);
//.pull
pull;
//.timeout - auto: retry or close
closeitem(ipos,false);
//.inc
inc(ipos);
end;//end of loop
except;end;
end;
//## _ontimer ##
procedure tudpex._ontimer(sender:tobject);
begin
try
//check
if (sysstate>=ssClosed) then exit;
//process
if ((ms64-iopentime)>=5000) then
   begin
   //.set
   case (iptr.c<>0) of
   true:if (iports='') then _close;
   false:if (iports<>'') then _open;
   end;//end of case
   //.reset
   iopentime:=ms64;
   end;//end of if
except;end;
end;
//## portrange ##
function tudpex.portrange(_from,_to:integer):string;
begin
try;result:=misc.numbers(_from,_to,',');except;end;
end;
//## setports ##
procedure tudpex.setports(x:string);
begin
try
if (x<>iports) then
   begin
   iports:=x;
   _close;
   iopentime:=ms64-9999;//try straight away
   end;//end of if
except;end;
end;
//## _open ##
procedure tudpex._open;
var
   p:integer;
begin
try
//close
if (iptr.c<>0) then _close;
//open
if (iptr.c=0) and (iports<>'') then
   begin
   p:=freeport(iports,true);
   iptr:=nw.openserverUDP(p);
   if (iptr.c<>0) then
      begin
      iport:=p;
      isocket:=nw.socket[iptr];
      nw.onread[iptr]:=_onread;
      nw.onwrite[iptr]:=_onwrite;
      end;//end of if
   end;//end of if
except;end;
end;
//## _close ##
procedure tudpex._close;
begin
try
if (iptr.c<>0) then
   begin
   //.port
   iport:=0;
   isocket:=invalid_socket;
   //.socket
   nw.close(iptr);
   //.pointer
   iptr.c:=0;
   end;//end of if
except;end;
end;
//## getonline ##
function tudpex.getonline:boolean;
begin
try;result:=(iptr.c<>0) and (iport<>0);except;end;
end;

//## tmanagedudpex #############################################################
//## create ##
constructor tmanagedudpex.create;
begin
//self
inherited;
//vars
irate:=1200;
inew:=-1;
iqueue:=-1;
iratetimer:=ms64;
ispeedtimer:=ms64;
//controls
iserver:=tudpex.create;
iip:=tdynamicinteger.create;
iport:=tdynamicword.create;
itag:=tdynamicinteger.create;
iid:=tdynamicinteger.create;
istr:=tdynamicstring.create;
isend:=tdynamicstring.create;
irecv:=tdynamicstring.create;
iobj:=tdynamicobject.create;
ionclose:=tdynamicnotifyevent.create;
iinuse:=tdynamicboolean.create;
ispeed:=trates.create;
//events
iserver.onserver:=_onserver;
//defaults
size:=1000;
//timer
itimer:=mt.new(_ontimer,500,true);
end;
//## destroy ##
destructor tmanagedudpex.destroy;
begin
try
//timer
mt.del(itimer);
//controls
freeobj(@iserver);
freeobj(@iip);
freeobj(@iport);
freeobj(@itag);
freeobj(@iid);
freeobj(@istr);
freeobj(@isend);
freeobj(@irecv);
freeobj(@iobj);
freeobj(@ionclose);
freeobj(@iinuse);
freeobj(@ispeed);
//self
inherited;
except;end;
end;
//## getstatus ##
function tmanagedudpex.getstatus(sep:char):string;
begin
try
result:=
tsStatistics+sep+
tsRate+#32+speed.ratestr(rtesTotal,rteuMin)+'/'+general.thousands(rate)+lowercase(tsUrlPerMin)+'; '+
speed.ratestr(rtesTotal,rteuHour)+#32+lowercase(tsUrlPerHour)+'; '+
speed.ratestr(rtesTotal,rteuDay)+#32+lowercase(tsUrlPerDay)+'; '+
tsQueue+#32+inttostr(active)+'/'+inttostr(size);
except;end;
end;
//## setrate ##
procedure tmanagedudpex.setrate(x:integer);//urls per min
begin
try;irate:=frcrange(x,1,60000);except;end;
end;
//## getsafelevel ##
function tmanagedudpex.getsafelevel:boolean;
begin
try;result:=(iactive<=(size div 2));except;end;
end;
//## getsize ##
function tmanagedudpex.getsize:integer;
begin
try;result:=iip.size;except;end;
end;
//## setsize ##
procedure tmanagedudpex.setsize(x:integer);
begin
try
//range
x:=frcmin(x,1);
//set
if (x<>size) then
   begin
   iip.setparams(x,x,0);
   iport.setparams(x,x,0);
   itag.setparams(x,x,0);
   iid.setparams(x,x,0);
   istr.setparams(x,x,0);
   isend.setparams(x,x,0);
   irecv.setparams(x,x,0);
   iobj.setparams(x,x,0);
   ionclose.setparams(x,x,0);
   iinuse.setparams(x,x,0);
   end;//end of if
except;end;
end;
//## getvalid ##
function tmanagedudpex.getvalid(x:integer):boolean;
begin
try;result:=(x>=0) and (x<size);except;end;
end;
//## getinuse ##
function tmanagedudpex.getinuse(x:integer):boolean;
begin
try;result:=valid[x] and iinuse.items[x];except;end;
end;
//## clearitem ##
procedure tmanagedudpex.clearitem(x:integer);
begin
try
if valid[x] then
   begin
   iinuse.items[x]:=false;
   iip.items[x]:=0;
   iport.items[x]:=0;
   isend.items[x]^:='';
   irecv.items[x]^:='';
   itag.items[x]:=0;
   iid.items[x]:=udiNil;
   istr.items[x]^:='';
   iobj.items[x]:=nil;
   ionclose.items[x]:=nil;
   end;//end of if
except;end;
end;
//## roll ##
function tmanagedudpex.roll(var index:integer;style:tmanagedudpexroll;range:integer):boolean;
var
   maxi,p,maxp:integer;
begin
try
//defaults
result:=false;
//init
//.range
if (range<=0) then range:=size;
maxp:=frcmin(frcmax(range-1,size-1),0);
//.index
if (index<-1) then index:=-1;
//.maxi
maxi:=size-1;
//scan
case style of
musNew:begin
   for p:=0 to maxp do
   begin
   //inc
   inc(index);
   if (index>maxi) then index:=0;
   //get
   if not iinuse.items[index] then
      begin
      result:=true;
      break;
      end;//end of if
   end;//end of loop
   end;//end of begin
musQueue:begin
   for p:=0 to maxp do
   begin
   //inc
   inc(index);
   if (index>maxi) then index:=0;
   //get
   if iinuse.items[index] and (iid.items[index]=udiNil) then
      begin
      result:=true;
      break;
      end;//end of if
   end;//end of loop
   end;//end of begin
end;//end of case
except;end;
end;
//## cannext ##
function tmanagedudpex.cannext:boolean;
begin
try;result:=(iactive>=1) and (iactiveidle>=1) and iserver.safelevel;except;end;
end;
//## next ##
function tmanagedudpex.next(var r:integer;range:integer):boolean;
begin//Note: returns next item in queue to progress (iid=udiNil)
try
//defaults
result:=false;
//check
if not cannext then exit;
//get
if roll(iqueue,musQueue,range) then
   begin
   result:=true;
   r:=iqueue;
   end;//end of if
except;end;
end;
//## canpull ##
function tmanagedudpex.canpull:boolean;
begin
try;result:=cannext and (iratecount>=1);except;end;
end;
//## pull ##
function tmanagedudpex.pull:boolean;
begin
try;result:=pullex(1);except;end;
end;
//## pullex ##
function tmanagedudpex.pullex(range:integer):boolean;
var
   i,p:integer;
begin
try
//defaults
result:=false;
range:=frcrange(range,1,size);
//system breath
general.updsys;
//scan
for i:=1 to range do
begin
//check
if (not canpull) then break;
//get
if next(iqueue,frcmin(size div 20,10)) then
   begin
   //get
   p:=iqueue;
   //dec - queue item is now in progress
   iactiveidle:=frcmin(iactiveidle-1,0);
   dec(iratecount);
   //set
   iserver.clientex(iip.items[p],iport.items[p],isend.items[p]^,p,_onclose,iid.items[p]);
   result:=true;
   end;//end of if
end;//end of loop
except;end;
end;
//## open ##
function tmanagedudpex.open(_ip:integer;_port:word;_sendtext:string;_onclose:tmanagedudpexcloseevent;var _rid:integer):boolean;
begin
try;result:=openex(_ip,_port,_sendtext,_onclose,0,'',nil,_rid);except;end;
end;
//## openex ##
function tmanagedudpex.openex(_ip:integer;_port:word;_sendtext:string;_onclose:tmanagedudpexcloseevent;_tag:integer;_str:string;_obj:tobject;var _rid:integer):boolean;
label
   skipend;
var
   extra,tmp:string;
begin
try
//defaults
result:=false;
_rid:=-1;
//check
if not assigned(_onclose) then exit;
//range
if (_ip=0) or (_port=0) then goto skipend;
//get
if roll(inew,musNew,0) then
   begin
   //set
   _rid:=inew;
   //clear
   clearitem(_rid);
   //fill
   iip.items[_rid]:=_ip;
   iport.items[_rid]:=_port;
   isend.items[_rid]^:=_sendtext;
   ionclose.items[_rid]:=tnotifyevent(_onclose);
   //user
   itag.items[_rid]:=_tag;
   istr.items[_rid]^:=_str;
   iobj.items[_rid]:=_obj;
   //inc
   inc(iactive);
   inc(iactiveidle);
   //inuse
   iinuse.items[_rid]:=true;
   result:=true;
   //pull
   pull;
   end;//end of if
skipend:
except;end;
try
//.close
if (not result) then
   begin
   tmp:='';
   extra:='';
   _onclose(self,-1,_ip,_port,_sendtext,tmp,extra,_tag,_str,_obj);
   end;//end of if
except;end;
end;
//## doclose ##
procedure tmanagedudpex.doclose(x:integer;var extra:string);
var
   tmp:string;
begin
try
if inuse[x] then
   begin
   //event
   if assigned(ionclose.items[x]) then tmanagedudpexcloseevent(ionclose.items[x])
      (self,x,iip.items[x],iport.items[x],isend.items[x]^,irecv.items[x]^,extra,itag.items[x],istr.items[x]^,iobj.items[x]);
   //clear
   clearitem(x);
   //dec
   iactive:=frcmin(iactive-1,0);
   //pull
   pull;
   end;//end of if
except;end;
end;
//## _onserver ##
procedure tmanagedudpex._onserver(sender:tobject;index,id:integer;var data,extra:string);
begin
try;if assigned(onserver) then onserver(self,index,id,data,extra);except;end;
end;
//## _onclose ##
procedure tmanagedudpex._onclose(sender:tobject;index,id:integer;var data,extra:string);
var
   tag:integer;
begin
try
//check
if iserver.inuse[index] then
   begin
   //get
   tag:=iserver.items[index].tag;
   //set
   if inuse[tag] and (iid.items[tag]=id) then
      begin
      //fill
      irecv.items[tag]^:=data;
      //rate
      if (data<>'') then ispeed.incby(rtesGood,1);
      //set
      doclose(tag,extra);
      end;//end of if
   end;//end of if
except;end;
end;
//## _ontimer ##
procedure tmanagedudpex._ontimer(sender:tobject);
var
   z:currency;
begin//Note: slow timer, for checking queue
try
//pull
pullex(10);
//rate
z:=ms64;
if ((z-iratetimer)>=1000) then
   begin
   iratecount:=frcmin((irate div 60),1);
   iratetimer:=z;
   end;//end of if
//speed
if ((z-ispeedtimer)>=5000) then
   begin
   ispeed.going:=(active>=1);
   ispeedtimer:=z;
   end;//end of if
except;end;
end;

//## tsecurityip ###############################################################
//## create ##
constructor tsecurityip.create;
begin//Works by: recording names (NAME) and storing a start time (TIME), which
     //          when (ms64-TIME) exceeds timeout, that NAME is reset allowing for
     //          more COUNTS by the same NAME, default TIMEOUT is 1 day (24 hours).
//self
inherited create;
//vars
ilastp:=-1;
//controls
iname:=tdynamicinteger.create;
ihit:=tdynamicinteger.create;
ierror:=tdynamicinteger.create;
ibyte:=tdynamiccurrency.create;
itime:=tdynamiccurrency.create;
//defaults
timeout:=86400*1000;//milliseconds for 1 day
hitlimit:=0;//no limit of hits per IP per day
errorlimit:=0;//no limit of hits per IP per day
bytelimit:=0;//no limit
size:=10000;
end;
//## destroy ##
destructor tsecurityip.destroy;
begin
try
//controls
freeobj(@iname);
freeobj(@ihit);
freeobj(@ierror);
freeobj(@ibyte);
freeobj(@itime);
//self
inherited;
except;end;
end;
//## readsettings ##
procedure tsecurityip.readsettings(_sysptr:integer);
begin
try
hitlimit:=vs.i[_sysptr+0];
errorlimit:=vs.i[_sysptr+1];
bytelimit:=vs.c[_sysptr+2];
except;end;
end;
//## find ##
function tsecurityip.find(n:integer):integer;
begin
try;result:=findb(n,false);except;end;
end;
//## findb ##
function tsecurityip.findb(n:integer;new:boolean):integer;
var
   p,sc,si,ei:integer;
   tindex:currency;
begin
try
//defaults
result:=-1;
ei:=-1;
si:=-1;
sc:=maxint;
tindex:=frccurmin(ms64-itimeout,0);
//check
if (n=0) then exit;
//quick compare - last search is same as this search
if (ilastn=n) and (ilastp>=0) and (ilastp<iname.count) and (iname.items[ilastp]=n) and (itime.items[ilastp]>=tindex) then result:=ilastp;
//scan
if (result<0) then
   begin
   for p:=0 to (size-1) do
   begin
   //.already exists
   if (n=iname.items[p]) then
      begin
      //.time period has elasped, so reset COUNT and TIME references
      if (itime.items[p]<tindex) then
         begin
         ihit.items[p]:=0;
         ierror.items[p]:=0;
         ibyte.items[p]:=0;
         itime.items[p]:=ms64;
         end;//end of if
      result:=p;
      break;
      end
   else if new then
      begin
      //.first empty
      if (0=iname.items[p]) or (itime.items[p]<tindex) then
         begin
         //.set
         ei:=p;
         //.stop searching for new entry
         new:=false;
         end
      //.smallest hit
      else if (ihit.items[p]<sc) then
         begin
         sc:=ihit.items[p];
         si:=p;
         end;//end of if
      end;//end of if
   end;//end of loop
   end;//end of if
//new
if (result<0) then
   begin
   //.set
   if (ei>=0) then result:=ei
   else if (si>=0) then result:=si;
   //.clear
   if (result>=0) then
      begin
      iname.items[result]:=n;
      ihit.items[result]:=0;
      ierror.items[result]:=0;
      ibyte.items[result]:=0;
      //.set time only once, it's then let to RUN OUT, this automatically resets COUNT
      itime.items[result]:=ms64;
      end;//end of if
   end;//end of if
//update last info
if (result>=0) then
   begin
   ilastn:=n;
   ilastp:=result;
   end;//end of if
except;end;
end;
//## iwe ##
function tsecurityip.iwe(x:integer):boolean;//is wec error
begin
try
//defaults
result:=true;
//process
case x of
200..299:result:=false;//ok
300..399:result:=false;//redirect
wecNotUsed:result:=false;
end;//end of case
except;end;
end;
//## passed ##
function tsecurityip.passed(n:integer;_bytes:currency;_error:integer;_hit,log:boolean):boolean;
var
   p:integer;
begin
try
//defaults
result:=false;
//process
//.find
p:=findb(n,true);
if (p=-1) then exit;
//.hit (optional)
if _hit then general.iroll(ihit.items[p],1);
//.error (optional)
if iwe(_error) then general.iroll(ierror.items[p],1);
//.byte
if (_bytes>=1) then general.croll(ibyte.items[p],_bytes);
//return result
result:=_passed(p);
//log - Note: log only on "inccount", since this is used first and only once per connection session 06-DEC-2006
if _hit and (not result) and log then rawlog.addbanned(n,ihit.items[p],ierror.items[p],ibyte.items[p]);
except;end;
end;
//## _passed ##
function tsecurityip._passed(x:integer):boolean;
begin
try
//defaults
result:=false;
//process
if (x>=0) and (x<size) then
   begin
   result:=
    ((ihitlimit=0) or (ihit.items[x]<=ihitlimit)) and
    ((ierrorlimit=0) or (ierror.items[x]<=ierrorlimit)) and
    ((ibytelimit=0) or (ibyte.items[x]<=ibytelimit)) and
    ((ms64-itime.items[x])<=itimeout);
   end;//end of if
except;end;
end;
//## clear ##
procedure tsecurityip.clear;
var
   p:integer;
   t:currency;
begin
try
t:=ms64;
for p:=(size-1) downto 0 do
begin
iname.items[p]:=0;
ihit.items[p]:=0;
ierror.items[p]:=0;
ibyte.items[p]:=0;
itime.items[p]:=t;
end;//end of loop
except;end;
end;
//## getsize ##
function tsecurityip.getsize:integer;
begin
try;result:=iname.size;except;end;
end;
//## setsize ##
procedure tsecurityip.setsize(x:integer);
begin
try
//range
x:=frcmin(x,1);
//set
iname.setparams(x,x,0);
ihit.setparams(x,x,0);
ierror.setparams(x,x,0);
ibyte.setparams(x,x,0);
itime.setparams(x,x,0);
except;end;
end;
//## getname ##
function tsecurityip.getname(x:integer):integer;
begin
try;if (x>=0) and (x<size) then result:=iname.items[x] else result:=0;except;end;
end;
//## gethit ##
function tsecurityip.gethit(x:integer):integer;
begin
try;if (x>=0) and (x<size) then result:=ihit.items[x] else result:=0;except;end;
end;
//## geterror ##
function tsecurityip.geterror(x:integer):integer;
begin
try;if (x>=0) and (x<size) then result:=ierror.items[x] else result:=0;except;end;
end;
//## getbyte ##
function tsecurityip.getbyte(x:integer):currency;
begin
try;if (x>=0) and (x<size) then result:=ibyte.items[x] else result:=0;except;end;
end;
//## sethitlimit ##
procedure tsecurityip.sethitlimit(x:integer);
begin
try;ihitlimit:=frcmin(x,0);except;end;
end;
//## seterrorlimit ##
procedure tsecurityip.seterrorlimit(x:integer);
begin
try;ierrorlimit:=frcmin(x,0);except;end;
end;
//## setbytelimit ##
procedure tsecurityip.setbytelimit(x:currency);
begin
try;ibytelimit:=frccurmin(x,0);except;end;
end;
//## settimeout ##
procedure tsecurityip.settimeout(x:currency);
begin
try;itimeout:=frccurmin(x,0);except;end;
end;
//## stats ##
function tsecurityip.stats(showheader:boolean;colsep,linesep:string):string;
var
   cc,i,p,len:integer;
   tindex:currency;
   d,b:tdynamicboolean;
begin
try
//defaults
result:='';
b:=nil;
d:=nil;
b:=tdynamicboolean.create;
d:=tdynamicboolean.create;
len:=0;
if (colsep='') then colsep:=#9;
if (linesep='') then linesep:=rcode;
tindex:=frccurmin(ms64-itimeout,0);
cc:=200;
//process
//.header
if showheader then pushb(len,result,
   tsIP+colsep+
   tsErrors+'/'+tsHits+colsep+
   tsBandwidth+colsep+
   tsTime+colsep+
   tsState+colsep+
   linesep);
//.scan for banned
b.setparams(ihit.count,ihit.count,0);
d.setparams(ihit.count,ihit.count,0);
for p:=0 to (b.count-1) do if (iname.items[p]<>0) and (itime.items[p]>=tindex) then b.items[p]:=(not _passed(p));
//.top 200 banned
for p:=0 to (b.count-1) do if (cc>=1) and b.items[p] and statsadd(p,result,len,tindex,colsep,linesep,b) then
   begin
   d.items[p]:=true;
   dec(cc);
   if (cc<=0) then break;
   end
   else if (cc<=0) then break;
//.top 200 largest hit's
ihit.sort(false);
for p:=0 to (b.count-1) do
begin
i:=ihit.sorted.value[p];
if (cc>=1) and (not b.items[i]) and (not d.items[i]) and statsadd(i,result,len,tindex,colsep,linesep,b) then
   begin
   dec(cc);
   if (cc<=0) then break;
   end
   else if (cc<=0) then break;
end;//end of loop
//.fill with blank lines (we end up with a fixed height list for stable display)
for p:=1 to cc do pushb(len,result,linesep);
//.finalise
pushb(len,result,'');
except;end;
try;freeobj(@b);freeobj(@d);except;end;
end;
//## statsadd ##
function tsecurityip.statsadd(p:integer;var x:string;var xlen:integer;var tindex:currency;var colsep,linesep:string;b:tdynamicboolean):boolean;
begin
try
//defaults
result:=false;
//process
if (b<>nil) and (p>=0) and (p<ihit.count) and (iname.items[p]<>0) and (itime.items[p]>=tindex) then
   begin
   //.set
   pushb(xlen,x,
    _strip(iname.items[p])+colsep+//ip
    general.thousands(ierror.items[p])+'/'+general.curcomma(ihit.items[p])+colsep+//errors/hits
    general.curcomma(ibyte.items[p])+colsep+//bytes
    dates.uptime(ms64-itime.items[p],true,#32)+colsep+//time
    general.aorbstr(tsAllowed,tsBanned,b.value[p])+linesep//state
    );
    //successful
    result:=true;
   end;//end of if
except;end;
end;

//## tsecurityfilter ###########################################################
//## create ##
constructor tsecurityfilter.create;
begin
//self
inherited create;
//controls
iipfrom:=tdynamiccurrency.create;
iipto:=tdynamiccurrency.create;
iipmask:=tdynamicstring.create;
iua:=tdynamicstring.create;
iuamask:=tdynamicstring.create;
iref:=tdynamicstring.create;
irefmask:=tdynamicstring.create;
//defaults
istyle:=0;
end;
//## destroy ##
destructor tsecurityfilter.destroy;
begin
try
//controls
freeobj(@iipfrom);
freeobj(@iipto);
freeobj(@iipmask);
freeobj(@iua);
freeobj(@iuamask);
freeobj(@iref);
freeobj(@irefmask);
//self
inherited
except;end;
end;
//## readsettings ##
procedure tsecurityfilter.readsettings(_sysptr:integer);
begin
try
//process
istyle:=frcrange(vs.i[_sysptr+0],0,2);//0..2
text:=vs.s[_sysptr+1];
except;end;
end;
//## clear ##
procedure tsecurityfilter.clear;
begin
try
itext:='';
//ip
iipfrom.clear;
iipto.clear;
iipmask.clear;
//ua
iua.clear;
iuamask.clear;
//ref
iref.clear;
irefmask.clear;
except;end;
end;
//## isip ##
function tsecurityfilter.isip(x:string):boolean;
var
   p:integer;
begin
try
//defaults
result:=(x<>'');
//scan
if result then for p:=1 to length(x) do
   begin
   case byte(x[p]) of
   45,46,48..57:;
   else
      begin//value out of range "-/./0..9"
      result:=false;
      break;
      end;//end of begin
   end;//end of case
   end;//end ofif
except;end;
end;
//## settext ##
procedure tsecurityfilter.settext(x:string);
var
   _from,_to:currency;
   _fromIP,_toIP,len,i,p:integer;
   a,b,c,tmp:string;
begin
try
//defaults
itext:='';
len:=0;
clear;
//process
//.set
p:=1;
//.scan
while general.nextline(p,x,tmp) do if (tmp<>'') then
   begin
   //.comment
   if (copy(tmp,1,2)='//') then
      begin
      pushb(len,itext,tmp+rcode);
      end
   else
      begin
      //.filter
      general.remchar(tmp,#32);//remove spaces
      general.remchar(tmp,#160);//remove extended spaces
      general.remchar(tmp,#9);//remove tabs
      if (tmp<>'') then
         begin
         //.get
         a:=tmp;
         b:='';
         c:='';
         for i:=1 to length(tmp) do if (tmp[i]='=') then
            begin
            a:=copy(tmp,1,i-1);
            b:=copy(tmp,i+1,length(tmp));
            break;
            end;//end of loop
         if (b='') then b:='*';
         //.c
         if (length(a)>=2) and (a[2]=':') then
            begin
            c:=lowercase(copy(a,1,2));
            delete(a,1,2);
            end;//end of if
         //.set
         if (a<>'') or (b<>'') then
            begin
            //REFERER
            if (c='r:') then
               begin
               i:=iref.count;
               iref.value[i]:=a;
               irefmask.value[i]:=b;
               pushb(len,itext,'r:'+a+general.insstr('='+b,b<>'')+rcode);
               end
            //IP or IP SET
            else if (c='i:') or ((c='') and isip(a)) then
               begin
               if asfilter(a,_from,_to,_fromIP,_toIP) then
                  begin
                  i:=iipfrom.count;
                  iipfrom.value[i]:=_from;
                  iipto.value[i]:=_to;
                  iipmask.value[i]:=b;
                  case (_fromIP<>_toIP) of
                  true:pushb(len,itext,'i:'+_strip(_fromIP)+'-'+_strip(_toIP)+general.insstr('='+b,b<>'')+rcode);
                  false:pushb(len,itext,'i:'+_strip(_fromIP)+general.insstr('='+b,b<>'')+rcode);
                  end;//end of case
                  end;//end of if
               end
            //UA
            else if (c='u:') or (c='') then
               begin
               i:=iua.count;
               iua.value[i]:=a;
               iuamask.value[i]:=b;
               pushb(len,itext,'u:'+a+general.insstr('='+b,b<>'')+rcode);
               end;//end of if
            end;//end of if
         end;//end of if
      end;//end of if
   end;//end of if
//.finalise
if (len<>0) then pushb(len,itext,'');
//.stats
icount:=iipmask.count+iuamask.count+irefmask.count;
except;end;
end;
//## ip8 ##
function tsecurityfilter.ip8(ip4:integer):currency;
var
   a:tint4;
   tmp:currency;
begin
try
//defaults
result:=0;
//process
//.get
a.val:=ip4;
//.set
result:=a.bytes[3]+a.bytes[2]*256+a.bytes[1]*65536;
//.math workaround
tmp:=16777216;
result:=result+(tmp*a.bytes[0]);
except;end;
end;
//## asfilter ##
function tsecurityfilter.asfilter(x:string;var _from,_to:currency;var _fromIP,_toIP:integer):boolean;
label
   skipend;
const
   sep='-';
var
   tmp,xlen,p:integer;
begin
try
//defaults
result:=false;
_from:=0;
_to:=0;
xlen:=length(x);
//check
if (xlen=0) then exit;
//process
for p:=1 to xlen do
begin
if (x[p]=sep) then
   begin
   if _intipb(copy(x,1,p-1),_fromIP) then _from:=ip8(_fromIP) else goto skipend;
   if _intipb(copy(x,p+1,xlen),_toIP) then _to:=ip8(_toIP) else goto skipend;
   break;
   end
else if (p=xlen) then
   begin
   if not _intipb(x,_fromIP) then goto skipend;
   _from:=ip8(_fromIP);
   _to:=_from;
   _toIP:=_fromIP;
   end;//end of if
end;//end of loop
//.swap
if (_from>_to) then
   begin
   swapcur(_from,_to);
   swapint(_fromIP,_toIP);
   end;//end of if
//successful
result:=true;
skipend:
except;end;
end;
//## ipfind ##
function tsecurityfilter.ipfind(_ip:integer):integer;
var
   i8:currency;
   p:integer;
begin
try
//defaults
result:=-1;
//check
if (iipfrom.count=0) then exit;
//init
i8:=ip8(_ip);
//process
for p:=0 to (iipfrom.count-1) do if (i8>=iipfrom.items[p]) and (i8<=iipto.items[p]) then
   begin
   result:=p;
   break;
   end;//end of if
except;end;
end;
//## uafind ##
function tsecurityfilter.uafind(_ua:string):integer;
var
   p:integer;
   _uablank:boolean;
begin
try
//defaults
result:=-1;
//check
if (iua.count=0) then exit;
_uablank:=(_ua='');
//range
general.remchar(_ua,'*');
//process
for p:=0 to (iua.count-1) do if (_uablank and (iua.items[p]^='')) or general.inf(_ua,iua.items[p]^) then
   begin
   result:=p;
   break;
   end;//end of if
except;end;
end;
//## reffind ##
function tsecurityfilter.reffind(_ref:string):integer;
var
   p:integer;
   _refblank:boolean;
begin
try
//defaults
result:=-1;
//check
if (iref.count=0) then exit;
_refblank:=(_ref='');
//range
general.remchar(_ref,'*');
//process
for p:=0 to (iref.count-1) do if (_refblank and (iref.items[p]^='')) or general.inf(_ref,iref.items[p]^) then
   begin
   result:=p;
   break;
   end;//end of if
except;end;
end;
//## passed ##
function tsecurityfilter.passed(_ip:integer;var _header:string):boolean;
var
   hlen,_ipproxy:integer;
   t,u,p,v,_pfd,_ua,_ref:string;
   ui:tparseurl;
begin
try
//defaults
result:=false;
_ipproxy:=0;
_ua:='-';
_ref:='-';
//get
//.ipproxy
if misc.headerfind(_header,'proxy-sourceip: ',v) then _ipproxy:=_intip(v);
//.ua
if misc.headerfind(_header,'user-agent: ',v) then _ua:=v;
//.ref
if misc.headerfind(_header,'referer: ',v) then _ref:=v;
//.pfd
hlen:=length(_header);
ns.ahRL(_header,hlen,'g',t,u,p,v);
general.pu('http://localhost'+u,'',ui,[]);
_pfd:=ui.p+ui.f+ui.d+ui.m;//allow "data" and "mark"
//set
result:=passedb(_ip,_ipproxy,_ua,_ref,_pfd);
except;end;
end;
//## passedb ##
function tsecurityfilter.passedb(_ip,_ipproxy:integer;_ua,_ref,_pfd:string):boolean;
label//Note: pdf=ui.p+ui.f+ui.d (includes ? data, so we can ban /search.html?q=xxx with "/search.html?*"
   skipend;
var
   i:integer;
begin
try
//defaults
result:=false;
//check
if (_pfd='') then _pfd:='/';//default file handling
//note: folders must have "index.html" appended, so that "ext" masking will work (*.htm*)
if (_pfd[length(_pfd)]='/') then _pfd:=_pfd+'index.html';
//range
if (_ua='') then _ua:='-';
if (_ref='') then _ref:='-';
//process
//.empty
if (icount=0) then
   begin
   result:=true;
   goto skipend;
   end;//end of if
//.decide
case istyle of
0:result:=true;
//DISALLOW
1:begin
  //.ip (check even if _ip=0.0.0.0)
  i:=ipfind(_ip);
  if (i>=0) and general.inf(_pfd,iipmask.items[i]^) then goto skipend;
  //.ipproxy (check only if _ipproxy<>0.0.0.0)
  if (_ipproxy<>0) then
     begin
     i:=ipfind(_ipproxy);
     if (i>=0) and general.inf(_pfd,iipmask.items[i]^) then goto skipend;
     end;//end of if
  //.ua (handles "ua=nil" ie. "=*.zip;*.exe")
  i:=uafind(_ua);
  if (i>=0) and general.inf(_pfd,iuamask.items[i]^) then goto skipend;
  //.ref (handles "ref=nil" ie. "=*.zip;*.exe")
  i:=reffind(_ref);
  if (i>=0) and general.inf(_pfd,irefmask.items[i]^) then goto skipend;
  //.ok
  result:=true;
  end;//end of begin
//ALLOW - Note: [ip+iproxy] or [ua] or [both], but both is NOT required for acces only 1 or the other.
2:begin
  //.ip (check even if _ip=0.0.0.0)
  i:=ipfind(_ip);
  if (i>=0) and general.inf(_pfd,iipmask.items[i]^) then
     begin
     //.ipproxy (check only if _ipproxy<>0.0.0.0)
     if (_ipproxy<>0) then
        begin
        i:=ipfind(_ipproxy);
        if (i<0) or (not general.inf(_pfd,iipmask.items[i]^)) then goto skipend;
        end;//end of if
     //.ok
     result:=true;
     goto skipend;
     end;//end of if
  //.ua (handles "ua=nil" ie. "=*.zip;*.exe")
  i:=uafind(_ua);
  if (i>=0) and general.inf(_pfd,iuamask.items[i]^) then
     begin
     //.ok
     result:=true;
     goto skipend;
     end;//end of if
  //.ref (handles "ref=nil" ie. "=*.zip;*.exe")
  i:=reffind(_ref);
  if (i>=0) and general.inf(_pfd,irefmask.items[i]^) then
     begin
     //.ok
     result:=true;
     goto skipend;
     end;//end of if
  end;//end of begin
end;//end of case
skipend:
except;end;
end;

//## tvirtualsecurityfilter ####################################################
//## _filter ##
function tvirtualsecurityfilter._filter(x:string):string;
var
   a:tsecurityfilter;
begin
try
//defaults
a:=nil;
a:=tsecurityfilter.create;
//get
a.text:=x;
//set
result:=a.text;
except;end;
try;freeobj(@a);except;end;
end;

//## tvirtualfiltersnippet #####################################################
//## _filter ##
function tvirtualfiltersnippet._filter(x:string):string;
var
   a:tstringlist;
   z:string;
   p,zlimit:integer;
begin
try
//defaults
a:=nil;
a:=tstringlist.create;
a.text:=x;
//get
for p:=0 to (a.count-1) do
begin
z:=a.strings[p];
if (z<>'') and misc.snippetenhance(z,z,zlimit,true) then a.strings[p]:=inttostr(zlimit)+'='+z;
end;//end of loop
//set
result:=a.text;
except;end;
try;freeobj(@a);except;end;
end;

//## tmanagedserver ############################################################
//## create ##
constructor tmanagedserver.create(_gui:tvirtualform;_sysptr:integer;_vars:string);
begin
createfrom(_gui,_sysptr,_vars,nil);
end;
//## createfrom ##
constructor tmanagedserver.createfrom(_gui:tvirtualform;_sysptr:integer;_vars:string;_server:tserverbasic);
const//Vars: contains variables of "title,mimes,
     //Note: set "oVariableHeight=false" when control is displayed on a vpsScrolling page and is not the last control
   sp=5;
var
   p,pageid:integer;
   pagetmp:tvirtualpage;
   tmph:string;
begin
//self
inherited create(_gui,_sysptr,_vars);
hunits:=17;//21OCT2007
oheight:=vhsUnit;//19OCT2007
oVariableheight:=true;//19OCT2007
//vars
filter:=true;
security:=true;
imimesshow:=vars.b['mimesshow'];
ibasicshow:=vars.b['basicshow'];//show basic security information
//controls
//.filters (A-D)
for p:=low(ifilters) to high(ifilters) do ifilters[p]:=tsecurityfilter.create;
//.iserver
iserver:=_server;
if (iserver=nil) then iserver:=createserver;
with iserver do
begin
maxconn:=100;
recvlimit:=32767;//32Kb recv. limit
end;//end of with
//.pages
ipages:=tvirtualpages.create(gui);
ipages.setup(self);
ipages.oseptop:=false;
ipages.aslinks;
ipages.tabs.caption:=general.udv(vars.value['title'],ntranslate('server'));
//SETTINGS
pagetmp:=ipages.newpage(ntranslate('settings'),tepWebPage20,rthtranslate('Important Server settings'),vpsScrolling,pageID) as tvirtualpage;
with (pagetmp as tvirtualpagescroll).client do
begin
//.stats
(new('panelserver','','','',valTop,nil) as tvirtualpanelserver).server:=iserver;
//.settings
new('titlesmall',ntranslate('settings'),'',rthtranslate('Important Server settings'),valTop,nil).valignsep:=2;
newb('droplist',ntranslate('port'),general.udv(vars.value['ports'],',80,81,82'),rthtranslate('Communications Port. Range 1-65536. Standard http (web) servers use port 80'),valTop,nil,_sysptr+msrPort,sgsInteger,general.udv(vars.value['port'],'80'),vs.rangeint(1,maxword));
//basicshow
if ibasicshow then
   begin
   newb('tick',ntranslate('require')+#32+ntranslate('authorisation'),'',rthtranslate('Bullet: Access restricted to authorised clients (Username and Password required)'),valTop,nil,_sysptr+msrRequireAuthorisation,sgsBoolean,'0','');
   newb('edit',ntranslate('user name'),'',rthtranslate('Username - case sensitive'),valTop,nil,_sysptr+msrUserName,sgsECap,'','');
   newb('password',ntranslate('password'),'',rthtranslate('Password - case sensitive'),valTop,nil,_sysptr+msrPassword,sgsECap,'','');
   end;//end of if
//.logs
new('titlesmall',ntranslate('logs'),'','',valTop,nil).valignsep:=2;
irecordlogs:=newb('tick',ntranslate('record logs'),'',rthtranslate('Bullet: Automatically record activity logs. Click "Log" link to view, and "All Logs" to view logs'' Folder'),valTop,nil,_sysptr+msrLogs,sgsBoolean,'1','');
iinheaders:=newb('tick',ntranslate('include request headers for errors'),'',rthtranslate('Bullet: Embed client request header in log. Plain text and base 64 encoded formats - for server replies other than 200 or 206'),valTop,nil,_sysptr+msrIncludeInheaders,sgsBoolean,'0','');
end;//end of with
//flow
pagetmp:=ipages.newpage(ntranslate('flow'),tepWebPage20,rthtranslate('Manage bandwidth flow and behaviour'),vpsScrolling,pageID) as tvirtualpage;
with (pagetmp as tvirtualpagescroll).client do
begin
(newb('droplist',ntranslate('transfer rate')+#32+'('+lowercase(translate('bytes/sec'))+')',vsvRate,rthtranslate('Maximum upload/download data transfer speed per client connection'),valTop,nil,(_sysptr+msrTransferRate),sgsInteger,inttostr(vsvRateDefault),vs.rangeint(nwMinThrottle,nwMaxThrottle)) as tvirtualdroplist).valuestyle:=vvsCommaNumber;//sys defaults
newb('droplist',ntranslate('transfer timeout')+#32+'(10..300'+#32+lowercase(translate('seconds'))+')',';10;15;20;25;30;40;50;60;120 - '+tsDefault+';180;240;300',rthtranslate('Close idle connections (no data flow) after elapsed period in seconds'),valTop,nil,(_sysptr+msrTimeout),sgsInteger,'120',vs.rangeint(10,300));
newb('droplist',ntranslate('maximum concurrent connections')+' ('+translate('per IP')+')',';0 - '+tsDefault+';1;2;3;4;5;7;10;15;20;30;40;50;',rthtranslate('Maximum number of simultaneous client connections permitted'),valTop,nil,_sysptr+msrIPlimit,sgsInteger,vs.rangeint(0,maxword),'0');
(newb('droplist',ntranslate('hit limit')+' ('+translate('per IP/day')+')',';0 - '+tsDefault+' ('+ntranslate('no limit')+');50;100;200;300;400;500;700;1,000;2,000;10,000',rthtranslate('Maximum client hits (requests) permitted within 24 hours, before automatically and temporarily banning client'),valTop,nil,(_sysptr+msrSecurityIP3+0),sgsInteger,'0',vs.rangeint(0,maxint)) as tvirtualdroplist).valuestyle:=vvsCommaNumber;
(newb('droplist',ntranslate('error limit')+' ('+translate('per IP/day')+')',';0 - '+tsDefault+' ('+ntranslate('no limit')+');1;2;5;10;12;15;20;25;30;40;50;75;100;200;250;300;350;400;450;500',rthtranslate('Maximum client errors (failed requests) permitted within 24 hours, before automatically and temporarily banning client'),valTop,nil,(_sysptr+msrSecurityIP3+1),sgsInteger,'0',vs.rangeint(0,maxint)) as tvirtualdroplist).valuestyle:=vvsCommaNumber;
(newb('droplist',ntranslate('bandwidth limit')+' ('+translate('per IP/day')+')',';0 - '+tsDefault+' ('+ntranslate('no limit')+');50,000;100,000;250,000;500,000;1,000,000;10,000,000;20,000,000;50,000,000;100,000,000;120,000,000;150,000,000;200,000,000;250,000,000;500,000,000;750,000,000;1,000,000,000;',rthtranslate('Maximum client bandwidth allowance permitted within 24 hours, before client automatically and temporarily banned'),valTop,nil,(_sysptr+msrSecurityIP3+2),sgsCurrency,'0',vs.rangecur(0,maxcur)) as tvirtualdroplist).valuestyle:=vvsCommaNumber;
newb('tick',ntranslate('403 force closure'),'',rthtranslate('Forcibly close "403" (forbidden/banned) client connections'),valTop,nil,_sysptr+msrForceClose,sgsBoolean,'0','');
end;//end of with
//filterA-D
for p:=low(ifilters) to high(ifilters) do
begin
pagetmp:=ipages.newpage(ntranslate('filter')+' '+char(65+p),tepWebPage20,rthtranslate('Multi-mode/type/masking flexible internet traffic filtration. Flowing from filter A through D (A->D)'),vpsNormal,pageID) as tvirtualpage;
with pagetmp do
begin
with newb('listb',ntranslate('mode'),
 #1+ntranslate('off')+
 #1+ntranslate('disallow')+
 #1+ntranslate('allow'),
 rthtranslate('Off: Filter not used (skipped) | Disallow: Permit all client requests, denying only those matching filters below | Allow: Deny all client requests, permitting only those matching filters below'),
 valTop,nil,(_sysptr+msrFilterA2+0+(p*2)),sgsInteger,'0',vs.rangeint(0,2)) as tvirtuallist do
 begin
 hunits:=3;
 oheight:=vhsUnit;
 end;//end of with
 newb('securityfilter',ntranslate('filters'),'',
  rthtranslate(
   'One filter per line, using format "type:name=mask1;mask2;mask3;" | '+
   'Type is one of three: "i" IP address/range, "u" user-agent and "r" referrer url | '+
   'Mask is full or partial file name/extension fragment i.e. "*.mp3" or "doc*.mp3" | '+
   'Example 1: "i:10.0.0.1-10.50.50.50=*.mp3;*.exe;*.zip;" | '+
   'Example 2: "u:*Googlebot*=*.mp3;*.exe;*.zip;*.xml;*?*;" | '+
   'Example 3: "r:*xyz.com*=/docs/*"'
   ),valTop,nil,(_sysptr+msrFilterA2+1+(p*2)),sgsString,'','');
end;//end of with
end;//end of loop
//mime
if imimesshow then
   begin
   //init
   tmph:=rthtranslate(
    'Set of file extension to internet format associations (mime type). One per line in format "file extension=mime/type". Example: "txt=text/plain" | '+
    'To restore defaults clear text box (right click > cut) and click "Apply" button | '+
    'Special case 1: File name with no extension (e.g. "abc.") use "<none>=text/plain" - Server returns mime type "text/plain" for files with no extension | '+
    'Special case 2: File name with no defined extension (e.g. "abc.xxx") use "<notfound>=application/octet-stream" - Server returns mime type "application/octet-stream" (binary data) for files with unspecified extension'
    );
   //get
   pagetmp:=ipages.newpage(ntranslate('mime types'),tepWebPage20,tmph,vpsNormal,pageID) as tvirtualpage;
   with pagetmp do newb('text',translate('Extension=mime/type')+#32+translate('one per line'),'',tmph,valTop,nil,_sysptr+msrMimeTypes,sgsString,mimes.defaults,'');
   end;//end of if
//events
iserver.onrequest:=_onrequest;//Uses it's own "onrequest" event for automatic security enforcement
//finished
createfinished;
end;
//## destroy ##
destructor tmanagedserver.destroy;
var
   p:integer;
begin
try
//init
destroyinit;
//controls
freeobj(@iserver);
for p:=low(ifilters) to high(ifilters) do freeobj(@ifilters[p]);
//self
inherited
except;end;
end;
//## createserver ##
function tmanagedserver.createserver:tserverbasic;
begin
try;result:=tserverbasic.create;except;end;
end;
//## _onrequest ##
function tmanagedserver._onrequest(sender:tobject;var header,content:string;var wait:boolean):boolean;
begin//Note: security cannot be automatically implemented when "tclientremote.raw=TRUE" (non HTTP mode)
try
//defaults
result:=false;
//decide
if filter and (not passedfilter((sender as tclientremote).ip,header,content)) then wait:=false
else if security and (not (sender as tclientremote).raw) and (not passedsecurity((sender as tclientremote).ip,header,content)) then wait:=false
else if assigned(onrequest) then
   begin
   result:=true;
   onrequest(sender,header,content,wait);
   end
else
   begin
   wait:=false;
   result:=true;
   end;//end of if
except;header:='';content:='';end;
end;
//## passedfilter ##
function tmanagedserver.passedfilter(ip:integer;var header,content:string):boolean;
var
   p:integer;
begin
try
//defaults
result:=false;
//scan
for p:=low(ifilters) to high(ifilters) do if (not ifilters[p].passed(ip,header)) then
   begin
   header:='';
   content:='';
   exit;
   end;//end of if
//ok
result:=true;
except;end;
end;
//## passedsecurity ##
function tmanagedserver.passedsecurity(ip:integer;var header,content:string):boolean;
var
   v:string;
begin
try
//defaults
result:=false;
//.authorization required
if ns.bupRESTRICTED(ibupAccess) then
   begin
   misc.headerfind(header,'Authorization: Basic ',v);
   if not ns.bupACCESS(v,ibupAccess) then
      begin
      header:='';
      content:=wec.e401AuthorizationRequired;
      general.whBUFFERS(header,content,servername,dates.gmtnow,'html','',wecAuthorizationRequired,true);
      exit;
      end;//end of if
   end;//end of if
//successful
result:=true;
except;end;
end;
//## passedall ##
function tmanagedserver.passedall(ip:integer;var header,content:string):boolean;
begin
try;result:=passedfilter(ip,header,content) and passedsecurity(ip,header,content);except;end;
end;
//## readwrite ##
procedure tmanagedserver.readwrite(mode:tvirtualstoragemode);
var
   _enforcefiltering:boolean;
   p:integer;
begin
try
case mode of
vsmReadfromcontrols:;
vsmWritetocontrols:;
vsmUpdatecontrols:begin
   //SERVER
   nw.throttle:=vs.i[(sysptr+msrTransferRate)];
   nw.timeout:=1000*vs.i[(sysptr+msrTimeout)];
   //.mimes
   if imimesshow then
      begin
      mimes.flush;
      mimes.addall(vs.s[sysptr+msrMimeTypes]);
      end;//end of if
   //.security ip's
   for p:=low(ifilters) to high(ifilters) do ifilters[p].readsettings(sysptr+msrFilterA2+0+(p*2));
   //.security
   if ibasicshow and vs.b[sysptr+msrRequireAuthorisation] then ibupAccess:=ns.bupCREATE(true,true,vs.s[sysptr+msrUsername],vs.s[sysptr+msrPassword])
   else ibupAccess:='*';
   //.logs
   iserver.log:=vs.b[sysptr+msrLogs];
   iinheaders.enabled:=iserver.log;
   rawlog.includeInheaders:=iserver.log and vs.b[sysptr+msrIncludeInheaders];
   //.security ip
   secip.readsettings(sysptr+msrSecurityIP3);
   //.port
   iserver.iplimit:=vs.i[sysptr+msrIPlimit];
   iserver.ports:=vs.s[sysptr+msrPort];
   iserver.ffc:=vs.b[sysptr+msrForceClose];
   end;//end of with
end;//end of case
except;end;
end;

//## tmanagedconnections #######################################################
//## create ##
constructor tmanagedconnections.create;
var
   p:integer;
begin
//self
inherited;
//vars
ispeedtimer:=ms64;
//controls
//.speed
ispeed:=trates.create;
//.ithreads
for p:=low(ithreads) to high(ithreads) do
begin
ithreads[p]:=tclientredirect.create;
ithreads[p].onopen:=_onopen;
ithreads[p].onclose:=_onclose;
ithreads[p].tag:=-1;//points to queue item (0..size-1), -1=not in use
end;//end of loop
//.other
iurl:=tdynamicstring.create;
iouttext:=tdynamicstring.create;
ithreadid:=tdynamicinteger.create;//1..20
itag:=tdynamicinteger.create;
irecvlimit:=tdynamiccurrency.create;
ionclose:=tdynamicnotifyevent.create;
istate:=tdynamicbyte.create;//msFree, msQueued, msWorking, msFinished
iban:=tdynamicbyte.create;
//defaults
itime:=ms64;
itimethread:=itime;
ipullindex:=-1;
ua:='-';
size:=1000;
rate:=120;
//timer
mt.slowon(islowref);
itimer:=mt.new(_ontimer,200,true);
end;
//## destroy ##
destructor tmanagedconnections.destroy;
var
   p:integer;
begin
try
//timer
mt.del(itimer);
//closeall
closeall;
//controls
for p:=low(ithreads) to high(ithreads) do freeobj(@ithreads[p]);
freeobj(@iurl);
freeobj(@iouttext);
freeobj(@ithreadid);
freeobj(@itag);
freeobj(@irecvlimit);
freeobj(@ionclose);
freeobj(@istate);
freeobj(@iban);
freeobj(@ispeed);
//self
inherited;
except;end;
end;
//## getstatus ##
function tmanagedconnections.getstatus(sep:char):string;
begin
try
result:=
tsStatistics+sep+
tsRate+#32+speed.ratestr(rtesTotal,rteuMin)+'/'+general.thousands(rate)+lowercase(tsUrlPerMin)+'; '+
speed.ratestr(rtesTotal,rteuHour)+#32+lowercase(tsUrlPerHour)+'; '+
speed.ratestr(rtesTotal,rteuDay)+#32+lowercase(tsUrlPerDay)+'; '+
tsQueue+#32+inttostr(active)+'/'+inttostr(size);
except;end;
end;
//## empty ##
function tmanagedconnections.empty:boolean;
begin
try;result:=(iactive=0) and (activethreads=0);except;end;
end;
//## getsafelevel ##
function tmanagedconnections.getsafelevel:boolean;
begin//50% capacity or less
try;result:=(iactive<=(size div 2));except;end;
end;
//## setrate ##
procedure tmanagedconnections.setrate(x:integer);
begin
try
//set
irate:=frcrange(x,1,2000);//urls per minute
//fill
ithreadlimit:=frcrange(irate div 50,low(ithreads),high(ithreads));//1..40
idelay:=frcmin(60000 div irate,1);
except;end;
end;
//## getactivethreads ##
function tmanagedconnections.getactivethreads:integer;
var
   p:integer;
begin
try
//defaults
result:=0;
//process
for p:=low(ithreads) to high(ithreads) do if not ithreads[p].canopen then inc(result);
except;end;
end;
//## pull ##
function tmanagedconnections.pull(var _id:integer):boolean;
var
   p,c,maxc:integer;
begin
try
//defaults
result:=false;
_id:=-1;
maxc:=frcmax(istate.size,frcmax(round(idelay*10),10000));//upto 10,000 items scanned per instance
c:=0;
//check
if (maxc=0) then exit;
//process
repeat
//.get
general.iroll(ipullindex,1);
if (ipullindex<0) then ipullindex:=0
else if (ipullindex>=istate.size) then ipullindex:=0;
//.decide
if (istate.items[ipullindex]=msQueued) then
   begin
   _id:=ipullindex;
   istate.items[_id]:=msWorking;
   result:=true;
   break;
   end;//end of if
//.inc
inc(c);
until (c>=maxc);
except;end;
end;
//## _ontimer ##
procedure tmanagedconnections._ontimer(sender:tobject);
var
   ok:boolean;
   _id,p:integer;
   z:currency;
begin
try
//defaults
ok:=false;
//check
if (sysstate>=ssClosed) then exit;
//process
//.find
if ((ms64-itimethread)>=idelay) then
   begin//threads=1..40
   for p:=low(ithreads) to ithreadlimit do if ithreads[p].canopen then
      begin
      //.get
      if pull(_id) then
         begin
         //.ok
         ok:=true;
         //.setup
         ithreads[p].onopen:=_onopen;
         ithreads[p].onclose:=_onclose;
         ithreads[p].banprivate:=(mcbBANPRIVATE in tmanagedconnectionban(iban.items[_id]));
         ithreads[p].maxredirect:=general.aorb(10,0,mcbBANREDIRECT in  tmanagedconnectionban(iban.items[_id]));
         ithreads[p].tag:=_id;//points to queue item
         ithreads[p].recvlimit:=irecvlimit.items[_id];
         ithreadid.items[_id]:=p;//points to thread item
         //.open
         if not ithreads[p].open(iurl.items[_id]^,'') then closeid(_id);
         //.break
         break;
         end
      else break;
      end;//end of if
   //.reset
   itimethread:=ms64;
   //.slow off
   if ok then mt.slowoff(islowref);
   mt.interval[itimer]:=mt.slowauto(islowref,frccurmax(idelay,200));
   end;//end of if
//activethreads
z:=ms64;
if ((ms64-itime)>=500) then
   begin
   iactivethreads:=getactivethreads;
   itime:=ms64;
   end;//end of if
//speed
if ((z-ispeedtimer)>=5000) then
   begin
   ispeed.going:=(active>=1);
   ispeedtimer:=z;
   end;//end of if
except;end;
end;
//## open ##
procedure tmanagedconnections.open(_url,_outtext:string;_tag:integer;_recvlimit:currency;_ban:tmanagedconnectionban;_onclose:tmanagedcloseevent;var _id:integer);
var//Always calls "close" even on fatal errors
   p:integer;
   ok:boolean;
begin
try
//defaults
ok:=false;
_id:=-1;
//process
//.find next free queue space
if (sysstate<=ssClosing) and assigned(_onclose) then for p:=0 to (istate.size-1) do if (istate.items[p]=msFree) then
   begin
   //.set
   istate.items[p]:=msHold;//hold
   itag.items[p]:=_tag;
   iurl.items[p]^:=_url;
   iouttext.items[p]^:=_outtext;
   irecvlimit.items[p]:=frccurmin(_recvlimit,0);
   ionclose.items[p]:=tnotifyevent(_onclose);
   ithreadid.items[p]:=0;//nil
   istate.items[p]:=msQueued;//queued
   iban.items[p]:=byte(_ban);
   //successful
   inc(iactive);
   _id:=p;
   ok:=true;
   //quit
   break;
   end;//end of if
//failed - no space
if (not ok) and assigned(_onclose) then _onclose(_url,_url,'',_outtext,_tag,-1,0,wecTaskFailed,'','',0,0);
except;end;
end;
//## _onopen ##
procedure tmanagedconnections._onopen(sender:tobject;_requesturl,_host:string;var _header:string);
var
   p:integer;
begin
try
//check
if not (sender is tclientbasic) then exit;
//defaults
_header:='';
//process
//.queue item id
p:=(sender as tclientbasic).tag;
//.get
if valid(p) and (istate.items[p]<>msFree) then _header:=iouttext.items[p]^;
//.check
if not general.textgood(_header) then
   begin
   _header:=
   'GET '+_requesturl+' HTTP/1.0'+rcode+
   'Accept: */*'+rcode+
   'Accept-Language: en-us'+rcode+
   'User-Agent: '+iua+rcode+
   'Host: '+_host+rcode+
   rcode;
   end;//end of if
except;end;
end;
//## setua ##
procedure tmanagedconnections.setua(x:string);
begin
try
//range
x:=ns.safeua(x);
if (x='') then x:='-';
//set
iua:=x;
iagent:=ns.agentname(x);
except;end;
end;
//## setsize ##
procedure tmanagedconnections.setsize(x:integer);
begin
try
//range
x:=frcmin(x,1);
//set
if (x<>istate.size) then
   begin
   istate.setparams(x,x,0);
   iurl.setparams(x,x,0);
   iouttext.setparams(x,x,0);
   ithreadid.setparams(x,x,0);
   itag.setparams(x,x,0);
   irecvlimit.setparams(x,x,0);
   iban.setparams(x,x,0);
   ionclose.setparams(x,x,0);
   end;//end of if
except;end;
end;
//## getsize ##
function tmanagedconnections.getsize:integer;
begin
try;result:=istate.size;except;end;
end;
//## valid ##
function tmanagedconnections.valid(x:integer):boolean;
begin
try;result:=(x>=0) and (x<istate.size);except;end;
end;
//## getstate ##
function tmanagedconnections.getstate(x:integer):byte;
begin
try;if valid(x) then result:=istate.items[x] else result:=msFree;except;end;
end;
//## _onclose ##
procedure tmanagedconnections._onclose(sender:tobject);
label
   skipend;
var
   a:tclientredirect;
begin
try
//check
if (sender=nil) or (not (sender is tclientredirect)) then exit;
a:=sender as tclientredirect;
if not valid(a.tag) then exit;
if (istate.items[a.tag]<>msWorking) then exit;//working
//stop
istate.items[a.tag]:=msFinished;//finished
//event
_closeid(iurl.items[a.tag]^,a.finalurl,a.redirecturl,iouttext.items[a.tag]^,itag.items[a.tag],a.tag,a.ip,a.code,a.header,a.content,a.sendbytes,a.recvbytes);
except;end;
end;
//## closeall ##
procedure tmanagedconnections.closeall;
var
   tmp,p:integer;
begin
try
for p:=0 to (istate.size-1) do if (istate.items[p]<>msFree) then
   begin
   tmp:=p;
   closeid(tmp);
   end;//end of if
except;end;
end;
//## closeid ##
procedure tmanagedconnections.closeid(var _id:integer);
var
   _threadid:integer;
begin
try
//check
if not valid(_id) then exit;
if (istate.items[_id]=msFree) or (istate.items[_id]=msFinished) then exit;
//process
//.stop
istate.items[_id]:=msFinished;//finished
//.close thread
_threadid:=ithreadid.items[_id];
if (_threadid>=low(ithreads)) and (_threadid<=high(ithreads)) and (ithreads[_threadid].tag=_id) and (not ithreads[_threadid].canopen) then
   begin
   ithreads[_threadid].onclose:=nil;
   ithreads[_threadid].close;
   ithreads[_threadid].tag:=-1;//no id
   end;//end of if
//.event
_closeid(iurl.items[_id]^,iurl.items[_id]^,'',iouttext.items[_id]^,itag.items[_id],_id,0,wecCancelled,'','',0,0);
//.clear
_id:=-1;
except;end;
end;
//## _closeid ##
procedure tmanagedconnections._closeid(_url,_urlfinal,_urlredirect,_outtext:string;_tag,_id:integer;_ip,_code:integer;_header,_content:string;sendbytes,recvbytes:currency);
begin
try
//check
if not valid(_id) then exit;
if (istate.items[_id]=msFree) then exit;
//process
if assigned(ionclose.items[_id]) then
   begin
   ispeed.incby(rtesGood,1);
   tmanagedcloseevent(ionclose.items[_id])(_url,_urlfinal,_urlredirect,_outtext,_tag,_id,_ip,_code,_header,_content,sendbytes,recvbytes);
   end;//end of if
except;end;
try
//.reset
iurl.items[_id]^:='';
iouttext.items[_id]^:='';
ithreadid.items[_id]:=0;
itag.items[_id]:=0;
irecvlimit.items[_id]:=0;
ionclose.items[_id]:=nil;
istate.items[_id]:=msFree;
iban.items[_id]:=0;
//.active
iactive:=frcmin(iactive-1,0);
except;end;
end;

//## tnavcacheimages ###########################################################
//yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy//44444444444444444
//## create ##
constructor tnavcacheimages.create;
begin
//self
inherited;
//controls
iname:=tdynamicnamelist.create;
iimage:=tdynamicobject.create;
inilimage:=newvb(tepWebPage20);
//defaults
clear;
end;
//## destroy ##
destructor tnavcacheimages.destroy;
begin
try
//empty
iimage.freevalues;
//controls
freeobj(@iname);
freeobj(@iimage);
freeobj(@inilimage);
//self
inherited;
except;end;
end;
//## getcount ##
function tnavcacheimages.getcount:integer;
begin
try;result:=iimage.count;except;end;
end;
//## getactive ##
function tnavcacheimages.getactive:integer;
var
   p:integer;
begin
try
//defaults
result:=0;
//get
for p:=0 to (iimage.count-1) do if (iimage.value[p]<>nil) and (iimage.value[p] is tvirtualbitmap) and (not (iimage.value[p] as tvirtualbitmap).empty) then inc(result);
except;end;
end;
//## getvalid ##
function tnavcacheimages.getvalid(x:integer):boolean;
begin
try;result:=getvalidex(x,true);except;end;
end;
//## getvalidex ##
function tnavcacheimages.getvalidex(x:integer;_upperlimit:boolean):boolean;
begin
try;result:=(iimage<>nil) and (x>=0) and ((not _upperlimit) or (x<iimage.count));except;end;
end;
//## find ##
function tnavcacheimages.find(_name:string):integer;
begin
try;result:=iname.findfast(0,_name);except;end;
end;
//## clear ##
procedure tnavcacheimages.clear;
begin
try
//clear
iimage.freevalues;
iname.clear;
//fill
tep[0]:=tepWebPage20;
except;end;
end;
//## getimg ##
function tnavcacheimages.getimg(x:integer):tvirtualbitmap;
var
   a:tobject;
begin
try
//defaults
result:=inilimage;
//get
if valid[x] then
   begin
   a:=iimage.items[x];
   if (a<>nil) and (a is tvirtualbitmap) and (not (a as tvirtualbitmap).empty) then result:=(a as tvirtualbitmap);
   end;//end of if
except;end;
end;
//## setimg ##
procedure tnavcacheimages.setimg(x:integer;y:tvirtualbitmap);
var//Note: "y=nil" will delete image[x] object and reset image index to nil.
   a:tobject;
begin
try
//check
if not validex[x,false] then exit;
//get
a:=iimage.value[x];
if (a<>y) then
   begin
   //set
   iimage.value[x]:=y;
   //clear
   if (a<>nil) then freeobj(@a);
   end;//end of if
except;end;
end;
//## getimgn ##
function tnavcacheimages.getimgn(x:string):tvirtualbitmap;
begin
try;result:=img[find(x)];except;end;
end;
//## setimgn ##
procedure tnavcacheimages.setimgn(x:string;y:tvirtualbitmap);
begin
try;img[iname.add(x)]:=y;except;end;
end;
//## settep ##
procedure tnavcacheimages.settep(x:integer;tep:string);
begin
try;img[x]:=newvb(tep);except;end;
end;
//## settepn ##
procedure tnavcacheimages.settepn(_name,tep:string);
begin
try;if (_name<>'') then imgn[_name]:=newvb(tep);except;end;
end;

//## ttnavcacheurls ############################################################
//yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy//55555555555555555555555
//## create ##
constructor tnavcacheurls.create;
begin
//self
inherited;
//vars
imax:=high(icache.items);
ipcache:=@icache;
//defaults
clear;
end;
//## destroy ##
destructor tnavcacheurls.destroy;
begin
try
//clear
clear;
//self
inherited;
except;end;
end;
//## getfolders ##
function tnavcacheurls.getfolders(x:integer):string;
begin
try;if inuse[x] then result:=icache.items[x].folders else result:='';except;end;
end;
//## getfiles ##
function tnavcacheurls.getfiles(x:integer):string;
begin
try;if inuse[x] then result:=icache.items[x].files else result:='';except;end;
end;
//## getcode ##
function tnavcacheurls.getcode(x:integer):integer;
begin
try;if inuse[x] then result:=icache.items[x].code else result:=wecOK;except;end;
end;
//## getua ##
function tnavcacheurls.getua(x:integer):string;
begin
try;if inuse[x] then result:=icache.items[x].ua else result:='';except;end;
end;
//## getub ##
function tnavcacheurls.getub(x:integer):string;
begin
try;if inuse[x] then result:=icache.items[x].ub else result:='';except;end;
end;
//## getvalid ##
function tnavcacheurls.getvalid(x:integer):boolean;
begin
try;result:=(x>=0) and (x<=imax);except;end;
end;
//## getinuse ##
function tnavcacheurls.getinuse(x:integer):boolean;
begin
try;result:=getvalid(x) and icache.items[x].inuse;except;end;
end;
//## pu ##
procedure tnavcacheurls.pu(x:string;var ui:tparseurl;_encode:boolean);
begin
try
//.encode
net_encode_url(x);
//.parse
general.pu('http://'+x,'',ui,[]);
//.decode
if not _encode then
   begin
   net_decode_str(ui.cu);
   net_decode_str(ui.ca);
   net_decode_str(ui.h);
   net_decode_str(ui.p);
   net_decode_str(ui.f);
   net_decode_str(ui.d);
   net_decode_str(ui.m);
   end;//end of if
//.hash patch
ui.f:=ui.f+ui.m;
ui.m:='';
except;end;
end;
//## getcount ##
function tnavcacheurls.getcount:integer;
begin
try;result:=imax+1;except;end;
end;
//## getactive ##
function tnavcacheurls.getactive:integer;
var
   p:integer;
begin
try
//defaults
result:=0;
//get
for p:=0 to imax do if icache.items[p].inuse then inc(result);
except;end;
end;
//## pull ##
function tnavcacheurls.pull(ua,ub:string;var index:integer):boolean;
var
   ui:tparseurl;
   p:integer;
begin
try
//defaults
result:=false;
index:=-1;
//range
if (ua<>'') then
   begin
   pu(ua,ui,false);
   ua:=ui.ca+ui.p;
   end;//end of if
if (ub<>'') then
   begin
   pu(ub,ui,false);
   ub:=ui.ca+ui.p;
   end;//end of if
//check
if (ua='') and (ub='') then exit;
//scan - case-insensitive
for p:=0 to imax do if icache.items[p].inuse and
  (
  (comparetext(ua,icache.items[p].ua)=0) or
  (comparetext(ua,icache.items[p].ub)=0) or
  (comparetext(ub,icache.items[p].ua)=0) or
  (comparetext(ub,icache.items[p].ub)=0)
  )
  then
  begin
  result:=true;
  index:=p;
  break;
  end;//end of if
except;end;
end;
//## push ##
function tnavcacheurls.push(ua,ub:string;code:integer;folders,files:string;var index:integer):boolean;
var
   ui:tparseurl;
   ei,ni,p:integer;
begin
try
//defaults
result:=false;
index:=-1;
ei:=-1;
ni:=-1;
//range
icache.index:=frcrange(icache.index,0,high(icache.items));
if (ua<>'') then
   begin
   pu(ua,ui,false);
   ua:=ui.ca+ui.p;
   end;//end of if
if (ub<>'') then
   begin
   pu(ub,ui,false);
   ub:=ui.ca+ui.p;
   end;//end of if
//check
if (ua='') and (ub='') then exit;
//scan1 [index..max]
for p:=icache.index to imax do
 if icache.items[p].inuse then
   begin
   if (ua=icache.items[p].ua) or (ua=icache.items[p].ub) or (ub=icache.items[p].ua) or (ub=icache.items[p].ub) then
      begin
      ei:=p;
      break;
      end;//end of if
   end
 else if (ni=-1) then ni:=p;//end of if
//scan2 [0..index-1]
if (ei=-1) then for p:=0 to (icache.index-1) do
 if icache.items[p].inuse then
   begin
   if (ua=icache.items[p].ua) or (ua=icache.items[p].ub) or (ub=icache.items[p].ua) or (ub=icache.items[p].ub) then
      begin
      ei:=p;
      break;
      end;//end of if
   end
 else if (ni=-1) then ni:=p;//end of if
//calc
if (ei=-1) then
   begin
   if (ni=-1) then
      begin
      //.set
      ni:=icache.index;
      //.inc
      inc(icache.index);
      if (icache.index>high(icache.items)) then icache.index:=0;
      end
   else if (ni>=0) and (ni<=high(icache.items)) then icache.index:=ni;
   end;//end of if
//set
if (ei=-1) and (ni>=0) then ei:=ni;
if (ei>=0) then
   begin
   icache.items[ei].ua:=ua;
   icache.items[ei].ub:=ub;
   icache.items[ei].code:=code;
   icache.items[ei].folders:=folders;
   icache.items[ei].files:=files;
   icache.items[ei].inuse:=true;
   index:=ei;
   result:=true;
   end;//end of if
except;end;
end;
//## clear ##
procedure tnavcacheurls.clear;
begin
try;clearex(false);except;end;
end;
//## clear ##
procedure tnavcacheurls.clearex(_prompt:boolean);
var
   tmp:tnavcacheurlitem;
   p:integer;
begin
try
//prompt
if _prompt and (not showquery60(translate('Clear cache')+'?')) then exit;
//init
with tmp do
begin
inuse:=false;
ua:='';
ub:='';
folders:='';
files:='';
code:=wecOk;
end;//end of with
//set
for p:=0 to imax do icache.items[p]:=tmp;
icache.index:=0;
except;end;
end;

//## tnavbase ##################################################################
//yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy//3333333
//## create ##
constructor tnavbase.create(_gui:tvirtualform);
var
   tmp:string;
begin
//self
inherited create(_gui);
align:=valTop;
oVariableheight:=true;
//vars
ionce:=true;//used for "nsHome"
nastyle:=naHome;
//controls

//INFO
//note: image name also defines "style" of data (ie. nav or folder or file or url etc)
iimage:=tdynamicstring.create;
ilabel:=tdynamicstring.create;
ides:=tdynamicstring.create;
iname:=tdynamicstring.create;
isize:=tdynamiccurrency.create;
idate:=tdynamicdatetime.create;
idateshow:=tdynamicboolean.create;
iindent:=tdynamicword.create;
inavs:=tdynamicstring.create;

//LIST
ilist:=new('baselist','','','',valTop,nil) as tvirtualbaselist;
ilist.bufferrows:=true;
ilist.oindent:=true;

//EVENTS
ilist.onimage:=_onimage;
ilist.onkey:=_onkey;
ilist.ondblclick:=_ondblclick;
ilist.ongetitem:=_getitemtext;
ilist.ongetindent:=_getindent;

//IMAGES
//.internal actions (refer to internal functions etc)
navimgs.tepn[naHome]:=tepHome16;
navimgs.tepn[naSettings]:=tepSettings16;
//.full actions - host+port+path+filename
navimgs.tepn[naLocal]:=tepLocal16;
navimgs.tepn[naUrl]:=tepUrl16;//yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy
navimgs.tepn[naEmail]:=tepEmail16;
//.partial actions - refer to internal "ihost" (<ihost+port>+path or filename etc)
navimgs.tepn[naHost]:=tepUrl16;
navimgs.tepn[naUp]:=tepUp16;
navimgs.tepn[naNav]:=tepNav16;
navimgs.tepn[naFolder]:=tepFolder16;
navimgs.tepn[naFile]:=tepFile16;

//DEFAULTS
timer:=250;//yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy
end;
//## destroy ##
destructor tnavbase.destroy;
begin
try
//controls
freeobj(@iimage);
freeobj(@ilabel);
freeobj(@ides);
freeobj(@iname);
freeobj(@isize);
freeobj(@idate);
freeobj(@idateshow);
freeobj(@iindent);
freeobj(@inavs);
//self
inherited;
except;end;
end;
//## filtername ##
function tnavbase.filtername(x:string):string;
begin
try;result:=general.swapcharsb(x,':','|');except;end;
end;
//## filtervalue ##
function tnavbase.filtervalue(x:string):string;
begin
try
result:=x;
general.swapstrs(result,#10,'');
general.swapstrs(result,#13,'');
general.swapchars(result,'\','/');
except;end;
end;
//## addressfilter ##
function tnavbase.addressfilter(x:string):string;
var//Note: filename, path or host, output is host and/or path (local or url)
   p:integer;
   ok:boolean;
begin
try
//defaults
result:=x;
ok:=false;
//filter
general.swapchars(x,'\','/');
//scan
for p:=length(result) downto 1 do if (result[p]='/') then
   begin
   result:=copy(result,1,p);
   ok:=true;
   break;
   end;//end of if
//finish
if not ok then result:=result+'/';
except;end;
end;
//## aalocal ##
function tnavbase.aalocal(x,xdefault:string):string;//address as local
begin
try
//range
x:=addressfilter(x);
//set
if (misc.at(x)=atlocal) then result:=x else result:=general.udv(xdefault,'c:');
except;end;
end;
//## aaurl ##
function tnavbase.aaurl(x,xdefault:string):string;//address as url
begin
try
//range
x:=addressfilter(x);
//set
if (misc.at(x)=aturl) then result:=x else result:=general.udv(xdefault,'localhost');
except;end;
end;
//## aastyle ##
function tnavbase.aastyle(x,xdefault:string):string;//address as current "nastyle"
begin
try;result:=aastyleex(x,xdefault,nastyle);except;end;
end;
//## aastyleex ##
function tnavbase.aastyleex(x,xdefault,_nastyle:string):string;
begin
try
//range
x:=addressfilter(x);
//set
if (_nastyle=naurl) then result:=aaurl(x,xdefault)
else if (_nastyle=nalocal) then result:=aalocal(x,xdefault)
else result:=xdefault;
except;end;
end;
//## setparams ##
procedure tnavbase.setparams(_address,_mask:string);
var//Force "_address" to current controls format (local or url)
   _action:string;
begin
try
//check
if reading then exit;
//range
_address:=aastyle(_address,iaddress);//use current address if inbound address format is not supported
//process
//.id
if (host<>nil) then id:=host.id;
//.get
if (iaddress<>_address) or (imask<>_mask) then
   begin
   //get
   iaddress:=_address;
   imask:=_mask;
   //set
   imustread:=true;
   end;//end of if
except;end;
end;
//## getaction ##
function tnavbase.getaction(x:integer):string;
begin
try;if valid[x] then result:=misc.navaction(iimage.value[x]) else result:='';except;end;
end;
//## _actionsupported ##
function tnavbase._actionsupported(x:string):boolean;
begin
try;result:=false;except;end;
end;
//## actionsupported ##
function tnavbase.actionsupported(x:integer):boolean;
begin
try;result:=_actionsupported(action[x]);except;end;
end;
//## _onaction ##
procedure tnavbase._onaction(sender:tobject);
var
   p:integer;
   _address:string;
begin
try
//init
p:=ilist.itemindex;
//check
if ireading or (not valid[p]) then exit;
//set
_address:=misc.navbaa(iimage.value[p],iname.value[p],ihost,ipath,ifile,inavs);
if actionsupported(x) then setparams(_address,imask)
else if (host<>nil) then host.setparams(_address,imask);
except;end;
end;
//## getprogress ##
function tnavbase.getprogress:single;
begin
try;if (host<>nil) then result:=host.progress else result:=0;except;end;
end;
//## setprogress ##
procedure tnavbase.setprogress(x:single);
begin
try;if (host<>nil) then host.progress:=x;except;end;
end;
//## canrefresh ##
function tnavbase.canrefresh:boolean;
begin
try;result:=not irefreshing;except;end;
end;
//## refresh ##
procedure tnavbase.refresh;
begin
try
if (not irefreshing) and (not ireading) then
   begin
   irefreshing:=true;
   imustread:=true;
   end;//endf if
except;end;
end;
//## canstop ##
function tnavbase.canstop:boolean;
begin
result:=false;
end;
//## stop ##
procedure tnavbase.stop;
begin
//nil
end;
//## canbookmark ##
function tnavbase.canbookmark:boolean;
begin
try;result:=(host<>nil) and host.canbookmark and icanbookmark;except;end;
end;
//## bookmark ##
procedure tnavbase.bookmark;
begin
try;if canbookmark and (host<>nil) then host.bookmark(iaddress,imask);except;end;
end;
//## canclear ##
function tnavbase.canclear:boolean;
begin
result:=false;
end;
//## clear ##
procedure tnavbase.clear;
begin
//nil
end;
//## _ontimer ##
procedure tnavbase._ontimer(sender:tobject);
begin
try
//.start read
if imustread and (not ireading) and showing then reading:=true;

//yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy
//yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyigrid.caption:=inttostr(gettickcount)+','+bn(gui.ismouse);//yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy
except;end;
end;
//## canasname ##
function tnavbase.canasname(action:string):boolean;
begin
try
result:=(action<>'host') and (action<>'url');
except;end;
end;
//## _getitemtext ##
procedure tnavbase._getitemtext(sender:tobject;index:integer;var value:string);
begin
try
//get
value:=labels[index];
//filter
if (value<>'') and canasname(images[index]) then value:=general.asname(value);
except;end;
end;
//## _getindent ##
procedure tnavbase._getindent(sender:tobject;index:integer;var value:word);
begin
try;if valid[index] then value:=iindent.value[index];except;end;
end;
//## _onimage ##
procedure tnavbase._onimage(sender:tobject;index:integer;var image:tvirtualbitmap);
begin//Image by name using GLOBAL image cache "navimg"
try;image:=navimgs.imgn[iimage.value[index]];except;end;
end;
//## _onkey ##
procedure tnavbase._onkey(sender:tobject;var key:byte);
begin
try;if (key=vk_return) or (key=vk_space) then _onaction(self);except;end;
end;
//## _ondblclick ##
procedure tnavbase._ondblclick(sender:tobject);
begin
try;_onaction(self);except;end;
end;
//## getvalid ##
function tnavbase.getvalid(x:integer):boolean;
begin
try;result:=(x>=0) and (x<ilist.count);except;end;
end;
//## gettext ##
function tnavbase.getlabel(x:integer):string;
begin
try;if valid[x] then result:=general.udv(ilabel.value[x],iname.value[x]) else result:='';except;end;
end;
//## getname ##
function tnavbase.getname(x:integer):string;
begin
try;if valid[x] then result:=iname.value[x] else result:='';except;end;
end;
//## getimage ##
function tnavbase.getimage(x:integer):string;
begin
try;if valid[x] then result:=iimage.value[x] else result:='';except;end;
end;
//## getaddress ##
function tnavbase.getaddress:string;
begin
try
result:='';
except;end;
end;
//## setreading ##
procedure tnavbase.setreading(x:boolean);
var
   tmp:integer;
begin
try
if (x<>ireading) then
   begin
   if x then
      begin
      //.start
      ireading:=true;
      //.clear
      iurl:='';
      ihost:='';
      ipath:='';
      ifile:='';
      ireadcount:=0;
      inavcount:=0;
      if (host<>nil) then host.sync;
      //.event
      _onreadstart(self);
      end
   else
      begin
      //.event
      _onreadend(self);
      //.navs
      tmp:=inavcount;
      inavs.setparams(tmp,tmp,0);
      //.vars
      tmp:=ireadcount;
      ilabel.setparams(tmp,tmp,0);
      ides.setparams(tmp,tmp,0);
      iname.setparams(tmp,tmp,0);
      iimage.setparams(tmp,tmp,0);
      isize.setparams(tmp,tmp,0);
      idate.setparams(tmp,tmp,0);
      idateshow.setparams(tmp,tmp,0);
      iindent.setparams(tmp,tmp,0);
      //.sync list
      ilist.setparams(-1,0,readcount,16,true);
      //.finish
      imustread:=false;
      ireading:=false;
      irefreshing:=false;
      if (host<>nil) then host.sync;
      end;//end of if
   end;//end of if
except;end;
end;
//## readcount ##
function tnavbase.readcount:integer;
begin
try;result:=ilabel.count;except;end;
end;
//## readone ##
function tnavbase.readone(_label,_des,_name,_image:string;_size:currency;_date:tdatetime;_dateshow:boolean;_indent:word):integer;//add item to list
var
   p:integer;
   z:string;
begin
try
//check - ensure all images start with type
z:=copy(_image,1,2);
if (z<>ntInternal) and (z<>ntFull) and (z<>ntPartial) then showerror60(translate(gecNotFound)+' ['+z+']');
//get
p:=ireadcount;
//set
ilabel.value[p]:=_label;
ides.value[p]:=_des;
iname.value[p]:=_name;
iimage.value[p]:=_image;
isize.value[p]:=_size;
idate.value[p]:=_date;
idateshow.value[p]:=_dateshow;
iindent.value[p]:=word(_indent);
//inc
inc(ireadcount);
except;end;
end;
//## _onreadstart ##
procedure tnavbase._onreadstart(sender:tobject);
begin//override this proc to include code for downloading content (ie. internet/network list)
try
//nil
except;end;
end;
//## _onreadend ##
procedure tnavbase._onreadend(sender:tobject);
begin//override this proc to include code for populating "ilist" control
try
//nil
except;end;
end;

//## tnavurl ###################################################################
//yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy//22222222222222222222222222222
//## create ##
constructor tnavurl.create(_gui:tvirtualform);
var
   p:integer;
begin
//self
inherited create(_gui);
nastyle:=naUrl;
icanbookmark:=true;

//controls
//.iclient
iclient:=tclientredirect.create;

//EVENTS
iclient.onrecv:=_onrecv;
iclient.onclose:=_onclose;

end;
//## destroy ##
destructor tnavurl.destroy;
begin
try
//init
destroyinit;
//controls
iclient.close;
freeobj(@iclient);
//self
inherited;
except;end;
end;
//## canstop ##
function tnavurl.canstop:boolean;
begin
try;result:=reading;except;end;
end;
//## stop ##
procedure tnavurl.stop;
begin
try;if canstop then iclient.close;except;end;
end;
//## canclear ##
function tnavurl.canclear:boolean;
begin
try;result:=(not reading);except;end;
end;
//## clear ##
procedure tnavurl.clear;
begin
try;navurls.clearex(true);except;end;
end;
//## _onreadstart ##
procedure tnavurl._onreadstart(sender:tobject);
var
   ui:tparseurl;
   i:integer;
begin
try
//init
host.progress:=0;
//find
if (not irefreshing) and navurls.pull(iaddress,'',i) then fill(i)
//get
else
   begin
   //get
   navurls.pu('http://'+iaddress,ui,true);
   //open (host+port+path only, no filename or data)
   iclient.recvlimit:=10000000;//10MB for index views only
   iclient.open('http://'+ui.ca+ui.p,'');
   end;//end of if
except;end;
end;
//## _onrecv ##
procedure tnavurl._onrecv(sender:tobject;var header,content:string;first:boolean);
begin
try
if (iclient.maxbytes>=1) then progress:=(iclient.contentbytes/iclient.maxbytes)*100;
except;end;
end;
//## _onclose ##
procedure tnavurl._onclose(sender:tobject);
begin
try
progress:=100;
fill(-1);
except;end;
end;
//## fill ##
procedure tnavurl.fill(index:integer);
label
   skipfill;
var
   iball,code,ib,tmplen,plen,_start,_length,len,p2,p:integer;
   ui:tparseurl;
   f,d:tstringlist;//f=folders, d=documents(files)
   fn,dn:tdynamicnamelist;
   showfiles,ispath,haspath:boolean;
   data,tmp:string;
begin
try
//defaults
len:=0;
f:=nil;
d:=nil;
fn:=nil;
dn:=nil;
iball:=4;
//init
f:=tstringlist.create;
d:=tstringlist.create;
fn:=tdynamicnamelist.create;
dn:=tdynamicnamelist.create;
showfiles:=true;//yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyynot (nsHideFiles in iquery.show);
if (index=-1) then
   begin
   data:=iclient.content;
   code:=iclient.code;
   end
else
   begin
   data:='';
   code:=navurls.code[index];
   end;//end of if

//process

//LISTING INFORMATION
//.get
if (index=-1) then navurls.pu(iclient.finalurl,ui,false) else navurls.pu(navurls.ub[index],ui,false);

//.set
iurl:=general.swapcharsb(ui.cu,'\','/');
ihost:=general.swapcharsb(ui.ca,'\','/');//host+port
ipath:=general.swapcharsb(ui.p,'\','/');
ifile:=ui.f;
//.navs (exclude "/"
for p:=2 to length(ipath) do if (ipath[p]='/') then
   begin
   inavs.value[inavcount]:=copy(ipath,1,p);
   inc(inavcount);
   end;//end of if
//.path
plen:=length(ipath);

//CORE
readone(tshome,'','',nahome,-1,-1,false,0);

//HOST
readone(ihost+' ['+general.ecdb(code,true)+']','','',nahost,-1,-1,false,iball);

//NAV
ib:=iball+8;//first indent amount
for p:=0 to (inavcount-1) do
begin
//.get
tmp:=copy(inavs.value[p],1,length(inavs.value[p])-1);//remove trailing slash
//.filter
for p2:=length(tmp) downto 1 do if (tmp[p2]='/') then
   begin
   tmp:=copy(tmp,p2+1,length(tmp));
   break;
   end;//end of if
//.set
readone(general.asname(tmp),'',inavs.value[p],nanav,-1,-1,false,ib+(p*4));
end;//end of loop

//UP
readone(tsup,'','',naup,-1,-1,false,iball);

//FOLDERS and/or FILES
if (index>=0) then goto skipfill;
//.scan
p:=1;
while general.readlink(p,_start,_length,data) do
begin
//.local links only (/xxx/ or xxxx)
if not general.put(data,_start,_length,true) then
   begin
   //.get
   tmp:=net_decode_str_b(copy(data,_start,_length));
   general.swapchars(tmp,'\','/');
   tmplen:=length(tmp);
   haspath:=(comparetext(ipath,copy(tmp,1,plen))=0);
   if (tmplen>=1) then ispath:=(tmp[tmplen]='/') else ispath:=false;
   //.set
   if (tmplen>=1) and (haspath or ((data[_start]<>'/') and (data[_start]<>'\'))) then
      begin
      //.folder
      if haspath then
         begin
         //.trim - remove pre-path
         tmp:=copy(tmp,plen+1,tmplen);
         tmplen:=length(tmp);
         //.scan
         if ispath then for p2:=1 to tmplen do if (tmp[p2]='/') then
            begin
            tmp:=copy(tmp,1,p2);
            break;
            end;//end of if
         end;//end of if
      //.filter
      general.rcr(tmp,0,31);//0..31 (remove all these characters)
      general.rcr(tmp,92,92);//92 = \
      general.rcr(tmp,47,47);//47 = /
      //.set
      if general.textgood(tmp) then
         begin
         if ispath then fn.add(tmp) else dn.add(tmp);
         end;//end of if
      end;//end of if
   end;//end of if
end;//end of loop

//FILL
skipfill:
//.sort f
if (index=-1) then f.text:=fn.text else f.text:=navurls.folders[index];
freeobj(@fn);
f.sort;
//.sort d
if (index=-1) then d.text:=dn.text else d.text:=navurls.files[index];
freeobj(@dn);
d.sort;

//FOLDERS
for p:=0 to (f.count-1) do readone('','',f.strings[p],nafolder,-1,-1,false,iball);

//FILES
if showfiles then for p:=0 to (d.count-1) do
   begin
   if ((imask='') or general.inf(d.strings[p],imask)) then readone('','',d.strings[p],nafile,-1,-1,false,iball);
   end;//end of if

//CACHESET
if (index=-1) then navurls.push(iclient.url,iclient.finalurl,iclient.code,f.text,d.text,p);
except;end;
try
freeobj(@f);
freeobj(@d);
freeobj(@fn);
freeobj(@dn);
except;end;
//finish
try;reading:=false;except;end;
end;

//## tnavlocal #################################################################
//yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy//99999999999999999
//## create ##
constructor tnavlocal.create(_gui:tvirtualform);
var
   p:integer;
begin
//yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy NOTE: fails to fill list when "local" tab is selected!!, need defaultsxxxxx
//self
inherited create(_gui);
nastyle:=naLocal;
icanbookmark:=true;
end;
//## destroy ##
destructor tnavlocal.destroy;
begin
try
//init
destroyinit;
//controls

//self
inherited;
except;end;
end;
//## _onreadstart ##
procedure tnavlocal._onreadstart(sender:tobject);
var
   ib,iball,p2,p:integer;
   tmp:string;
begin
try
//defaults
iball:=4;

//vars
iurl:='c:/windows/start menu/';
ihost:='c:';
ipath:='/windows/start menu/';
ifile:='abc.exe';

//.navs (exclude "/"
for p:=2 to length(ipath) do if (ipath[p]='/') then
   begin
   inavs.value[inavcount]:=copy(ipath,1,p);
   inc(inavcount);
   end;//end of if

//CORE
readone(tshome,'','',nahome,-1,-1,false,0);

//NAV
readone('c:','','',nahost,-1,-1,false,0);//yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy

ib:=iball+8;//first indent amount
for p:=0 to (inavcount-1) do
begin
//.get
tmp:=copy(inavs.value[p],1,length(inavs.value[p])-1);//remove trailing slash
//.filter
for p2:=length(tmp) downto 1 do if (tmp[p2]='/') then
   begin
   tmp:=copy(tmp,p2+1,length(tmp));
   break;
   end;//end of if
//.set
readone(general.asname(tmp),'',inavs.value[p],nanav,-1,-1,false,ib+(p*4));
end;//end of loop

//UP
readone(tsup,'','',naup,-1,-1,false,iball);

//FOLDERS/FILES
readone('','','misc',nafolder,-1,-1,false,0);
readone('','','runner.exe',nafile,-1,-1,false,0);
readone('','','text2exe.exe',nafile,-1,-1,false,0);
readone('','','pages.html',nafile,-1,-1,false,0);
except;end;
//finish
try;reading:=false;except;end;
end;

//## tnavbookmarks #############################################################
//yyyyyyyyyyyyyyyyyyyyyyyyy//aaaaaaaaaaaaaaaaaaaa
//## create ##
constructor tnavbookmarks.create(_gui:tvirtualform);
var
   p:integer;
begin
//yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy NOTE: fails to fill list when "local" tab is selected!!, need defaultsxxxxx
//self
inherited create(_gui);
nastyle:=naBookmarks;
end;
//## destroy ##
destructor tnavbookmarks.destroy;
begin
try
//init
destroyinit;
//controls

//self
inherited;
except;end;
end;
//## pull ##
procedure tnavbookmarks.pull;
label
   skipend;
var
   tmp,n,v,e:string;
   a:tdynamictext;
   p:integer;
begin
try
//defaults
a:=nil;
a:=tdynamictext.create;
//process

//CORE
readone(tshome,'','',nahome,-1,-1,false,0);

//CUSTOM
//.get
if not io.fromfilec(bvfportable(bvfSettings)+'nav.bookmarks.txt',tmp,e,10) then goto skipend;
a.text:=tmp;
tmp:='';
//.scan
for p:=0 to (a.vars.count-1) do
begin
//.filter
n:=filtername(a.vars.name[p]);
v:=filtervalue(a.vars.valuei[p]);
if (n<>'') and (n[1]='*') then n:='';//*=empty name
//.decide
case misc.at(v) of
atLocal:readone(n,'',v,nalocal,-1,-1,false,0);
atUrl  :readone(n,'',v,naurl,-1,-1,false,0);
atEmail:readone(n,'',v,naemail,-1,-1,false,0);
end;//end of case
end;//end of loop
skipend:
except;end;
try;freeobj(@a);except;end;
end;
//## add ##
procedure tnavbookmarks.add(_name,_address:string);
label
   skipend;
var//Note: _name and _address can store an extra entry to add
   tmp,v,n,e:string;
   a:tdynamictext;
   p:integer;
begin
try
//defaults
a:=nil;
a:=tdynamictext.create;
//process
//.get
if not io.fromfilec(bvfportable(bvfSettings)+'nav.bookmarks.txt',tmp,e,10) then goto skipend;
a.text:=tmp;
//.additional
if (_address<>'') then
   begin
   //.get
   n:=filtername(_name);
   v:=filtervalue(_address);
   if (n='') then n:='*'+inttostr(a.vars.count+1);
   //.set
   a.value[n]:=v;
   end;//end of if
//.set
tmp:=a.text;
io.toFILEc(bvfportable(bvfSettings)+'nav.bookmarks.txt',tmp,e,10);
//.refresh
refresh;
skipend:
except;end;
try;freeobj(@a);except;end;
end;
//## _onreadstart ##
procedure tnavbookmarks._onreadstart(sender:tobject);
begin
try;pull;reading:=false;except;end;
end;

//## tnavhome ##################################################################
//yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy//8888888888888
//## create ##
constructor tnavhome.create(_gui:tvirtualform);
var
   p:integer;
begin
//self
inherited create(_gui);
nastyle:=naHome;
//vars
ionce:=true;
end;
//## destroy ##
destructor tnavhome.destroy;
begin
try
//init
destroyinit;
//controls

//self
inherited;
except;end;
end;
//## _onreadstart ##
procedure tnavhome._onreadstart(sender:tobject);
begin
try
//CORE
readone(tshome,'','',nahome,-1,-1,false,0);
readone(tsbookmarks,'','',nabookmarks,-1,-1,false,0);
readone(tslocal,'','',ntinternal+'local',-1,-1,false,0);
readone(tsinternet,'','',ntinternal+'url',-1,-1,false,0);

//URL
readone('','','10.0.0.21:90',naurl,-1,-1,false,0);
readone('','','10.0.0.20:90',naurl,-1,-1,false,0);
readone('','','10.0.0.17:90',naurl,-1,-1,false,0);
readone('','','www.blaizenterprises.com',naurl,-1,-1,false,0);

readone('','','c:\windows\start menu\',nalocal,-1,-1,false,0);
except;end;
//finish
try;reading:=false;except;end;
end;

//## tnavview ##################################################################
//yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy//66666666666666666666666
//## create ##
constructor tnavview.create(_gui:tvirtualform);
var
   tmp:string;
   tmpnav:tnavbase;
   pageid:integer;
begin
//self
inherited create(_gui);
align:=valTop;
oVariableheight:=true;

//controls
//.ipages
ipages:=tvirtualpages.create(gui);
ipages.setup(self);
ipages.oseptop:=false;
ipages.osepbot:=false;
ipages.aslinks;
ipages.tabs.caption:=ntranslate('views');//yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy//????????

//.panels
new(naHome);
new(naBookmarks);
new(naLocal);
new(naUrl).alignsep:=10;

//.links
with ipages.tabs do
begin
iadd:=newllink(ntranslate('add'),tepPlusSign14,'',_onclick);//yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy
irefresh:=newllink(ntranslate('refresh'),tepRefresh14,'',_onclick);
istop:=newllink(ntranslate('stop'),tepStop14a,'',_onclick);
istop.image.run:=false;
iclear:=newllink(ntranslate('clear cache'),tepClear14,'',_onclick);
iprogress:=new('progress','','','',valLeft,nil) as tvirtualprogress;
iprogress.oWidth:=vwsWidth;
iprogress.width:=50;
iprogress.normal:=false;
iprogress.showtext:=false;
end;//end of with

//events
ipages.onpage:=_onpage;
//check
if (iroot=nil) then showerror60('no panels');
//defaults
updatebuttons;
timer:=250;
end;
//## destroy ##
destructor tnavview.destroy;
begin
try
//self
inherited;
except;end;
end;
//## canbookmark ##
function tnavview.canbookmark:boolean;
begin
try;result:=(ibookmarks<>nil);except;end;
end;
//## bookmark ##
procedure tnavview.bookmark(_address,_mask:string);
begin
try;if canbookmark then ibookmarks.add('',_address);except;end;
end;
//## setpanel ##
procedure tnavview.setpanel(x:string);
var//Compare only style names (home, settings, local or internet)
   a:tnavbase;
   xlen,p:integer;
begin
try
//get
x:=copy(x,3,length(x));
xlen:=length(x);
//scan
for p:=0 to (navscount-1) do
begin
a:=navs[p];
if (a<>nil) and (copy(a.nastyle,3,xlen)=x) then
   begin
   if (ipages.page<>p) then ipages.page:=p;
   break;
   end;//end of if
end;//end of loop
except;end;
end;
//## getpanel ##
function tnavview.getpanel:string;
begin
try;if (nav<>nil) and (not idisableonpage) then result:=nav.nastyle else result:='';except;end;
end;
//## _ontimer ##
procedure tnavview._ontimer(sender:tobject);
var
   a,b,c:string;
begin
try
//check
if reading or (not showing) then exit;
//process
if (imustpanel<>'') or (imustaddress<>'') or (imustmask<>'') then
   begin
   //get
   a:=imustpanel;
   b:=imustaddress;
   c:=imustmask;
   //clear
   imustpanel:='';
   imustaddress:='';
   imustmask:='';
   //set
   idisableonpage:=true;
   panel:=a;
   if (nav<>nil) then nav.setparams(b,c);
   idisableonpage:=false;
   end;//end of if
except;end;
end;
//## _onpage ##
procedure tnavview._onpage(sender:tobject);
begin
try
//check
if idisableonpage then exit;
//set
if (nav<>nil) and (id<>nav.id) then nav.setparams(ioaddress,iomask);
except;end;
end;
//## init ##
procedure tnavview.init(_address,_mask:string);
begin
try
//check
if (ioaddress=_address) and (iomask=_mask) then exit;
//get
ioaddress:=_address;
iomask:=_mask;
general.iroll(id,1);
//set
setparams(ioaddress,iomask);
except;end;
end;
//## setparams ##
procedure tnavview.setparams(_address,_mask:string);
var
   _at:taddresstype;
   _panel,_type,_action,_class:string;
begin
try
//check
if reading then exit;
//range
_address:=iroot.filtervalue(_address);
if (misc.navtype(_address)=ntInternal) then _at:=atUnknown else _at:=misc.at(_address);
//decide
case _at of
atUnknown:_panel:=misc.navaction(_address);
atLocal:_panel:=naLocal;
atUrl:_panel:=naUrl;
atEmail:_panel:='';//don't change panel, but still perform update
else _panel:=naHome;
end;//end of case
//delayed trigger
imustpanel:=_panel;
imustaddress:=_address;
imustmask:=_mask;
except;end;
end;
//## getprogress ##
function tnavview.getprogress:single;
begin
try;result:=iprogress.progress;except;end;
end;
//## setprogress ##
procedure tnavview.setprogress(x:single);
begin
try
iprogress.progress:=x;
iprogress.showtext:=(iprogress.progress>0);
except;end;
end;
//## getnavs ##
function tnavview.getnavs(x:integer):tnavbase;
begin
try
//defaults
result:=nil;
//get
if (ipages.pages[x]<>nil) and (ipages.pages[x] is tnavbase) then result:=ipages.pages[x] as tnavbase;
except;end;
end;
//## getnavscount ##
function tnavview.getnavscount:integer;
begin
try;result:=ipages.count;except;end;
end;
//## getnav ##
function tnavview.getnav:tnavbase;
begin
try
//defaults
result:=nil;
//get
if (ipages.pages[ipages.page]<>nil) and (ipages.pages[ipages.page] is tnavbase) then result:=ipages.pages[ipages.page] as tnavbase;
except;end;
end;
//## getreading ##
function tnavview.getreading:boolean;
begin
try;result:=(nav<>nil) and nav.reading;except;end;
end;
//## setreading ##
procedure tnavview.setreading(x:boolean);
begin
try;if (reading<>x) and (nav<>nil) then nav.reading:=x;except;end;
end;
//## sync ##
procedure tnavview.sync;
begin
try;updatebuttons;except;end;
end;
//## _onclick ##
procedure tnavview._onclick(sender:tobject);
var
   a:tnavbase;
begin
try
//check
a:=nav;
if (a=nil) then exit;
//get
if (sender=iadd) then
   begin
   if (not reading) and (nav<>nil) and nav.canbookmark then nav.bookmark;
   end
else if (sender=irefresh) then
   begin
   if (not reading) and (nav<>nil) then nav.refresh;
   end
else if (sender=istop) then
   begin
   if reading and (nav<>nil) then nav.stop;
   end
else if (sender=iclear) then
   begin
   if (not reading) and (nav<>nil) then nav.clear;
   end;//end of if
//update
updatebuttons;
except;end;
end;
//## updatebuttons ##
procedure tnavview.updatebuttons;
var
   c:tvirtualcursor;
   a:tnavbase;
   p:integer;
   ok:boolean;
begin
try
//get
a:=nav;
ok:=not reading;
//set
iadd.enabled:=(a<>nil) and a.canbookmark;
irefresh.enabled:=(a<>nil) and a.canrefresh;
istop.enabled:=(a<>nil) and a.canstop;
istop.image.run:=(a<>nil) and a.canstop;
iclear.enabled:=(a<>nil) and a.canclear;
for p:=0 to (navscount-1) do if (navs[p]<>nil) then
   begin
   if (navs[p].button<>nil) then navs[p].button.enabled:=ok;
   navs[p].enabled:=ok;
   end;//end of if
//progress
iprogress.showtext:=reading;
if not reading then progress:=0;
//cursor - to indicate we are reading
if reading then c:=vcBusy else c:=vcLink;
gui.screencursor:=c;
except;end;
end;
//## new ##
function tnavview.new(nastyle:string):tnavbase;
var
   tep,cap:string;
   pageID:integer;
begin
try
//defaults
result:=nil;
//get
if (nastyle=naHome) then
   begin
   result:=tnavhome.create(gui);
   cap:=tsHome;
   tep:=tepHome16;
   end
else if (nastyle=naBookmarks) then
   begin
   result:=tnavbookmarks.create(gui);
   cap:=tsBookmarks;
   tep:=tepBookMark16;
   if (ibookmarks=nil) then ibookmarks:=result as tnavbookmarks;
   end
else if (nastyle=naLocal) then
   begin
   result:=tnavlocal.create(gui);
   cap:=tsLocal;
   tep:=tepLocal16;
   end
else if (nastyle=naUrl) then
   begin
   result:=tnavurl.create(gui);
   cap:=tsUrl;
   tep:=tepInternet16;
   end;//end of if
//set
if (result<>nil) then
   begin
   ipages.newpageb(cap,tep,'',vpsNormal,result,pageID);
   result.host:=self;
   end;//end of if
//iroot
if (iroot=nil) then iroot:=result;//used for it's functions (filtername, filtervalue)
except;end;
end;

//## tnavdlg ###################################################################
//yyyyyyyyyyyyyyyyyyyyyyyyy//1111111111111111111111
//## create ##
constructor tnavdlg.create;
const
   vsp=2;
var
   vpage:tvirtualpagevsplit;
   e:string;
   p:integer;
begin
//self
inherited;

//vars
idata:='';

//controls
//.dlg
idlg:=tvirtualdlg.create(nil);
idlg.width:=550;
idlg.height:=410;
idlg.mkEscape:=false;
idlg.mkReturn:=false;

//.page (left/right)
vpage:=idlg.client.new('pagevsplit','','','',valTop,nil) as tvirtualpagevsplit;
with vpage do
begin
createinit(false,false);
pageheight:=66;
hspace:=5;

//NAV
with pages[0] do
begin
inav:=tnavview.create(gui);
inav.setup(pages[0]);
end;//end of with

//URLS
with pages[1] do
begin
//.address
with new('titlesmall',ntranslate('address'),'','',valTop,nil) do
begin
normal:=false;
valignsep:=1;
istop:=newlink(ntranslate('stop'),tepStop14a,'',__onclick);
iload:=newlink(ntranslate('load'),tepOpen14,'',__onclick);
iroot:=newlink(ntranslate('index'),tepRoot14,'',__onclick);//yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy
end;//end of with
iurls:=new('droplist','','','',valTop,__onclick) as tvirtualdroplist;
iurls.ofilter:=vfEncodedUrl;//filter values
end;//end of with
end;//end of with

//BUTTONS
icancel:=idlg.newbutton(ntranslate('cancel'),tepCancel20,mrCancel);
iopen:=idlg.newbutton(ntranslate('open'),tepYes20,mrOk);
end;
//## destroy ##
destructor tnavdlg.destroy;
begin
try
//controls
freeobj(@idlg);
//self
inherited;
except;end;
end;
//## __onclick ##
procedure tnavdlg.__onclick(sender:tobject);
begin
try
if (sender=iload) then
   begin
   //yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy
   end;//end of if
except;end;
end;
//## canopen ##
function tnavdlg.canopen:boolean;
begin
try;result:=not iopening;except;end;
end;
//## open ##
function tnavdlg.open(var _address,_mask,_data,e:string;_prompt:boolean):boolean;
var
   etmp:string;
begin
try
//defaults
result:=false;
_data:='';
e:=gecTaskCancelled;
//lock
if (not canopen) then exit else iopening:=true;
//process
//.form
idlg.caption:=ntranslate('open');//yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy
idlg.head.image.setanimation(tepInfo32,etmp);//yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy
//.setparams
inav.init(_address,_mask);
//.show (always modal, since time intensive task must be performed before we
//       can return control back to program).
result:=(modaloc(idlg.showmodal)=mrOK);

//RETURN RESULT
if result then
   begin
   //yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy
   end;//end of if
//.clear
idata:='';
except;end;
try;iopening:=false;except;end;
end;

//## tcacherobot ###############################################################
//## create ##
constructor tcacherobot.create;
begin
try
//self
inherited create(sizeof(tcacherobotREC));
title:=ntranslate('robot');
activetimeintensive:=true;
except;end;
end;
//## _createsupport ##
procedure tcacherobot._createsupport;
begin
try
//controls
iip:=tdynamicinteger.create;
idim:=tdynamicinteger.create;
iwec:=tdynamicinteger.create;
except;end;
end;
//## _destroysupport ##
procedure tcacherobot._destroysupport;
begin
try
//controls
freeobj(@iip);
freeobj(@idim);
freeobj(@iwec);
except;end;
end;
//## bpiRAM ##
function tcacherobot.bpiRAM:integer;
begin
try;result:=12;except;end;
end;
//## getactive ##
function tcacherobot.getactive:integer;
begin//Warning: time intensive processing
try;result:=activeSYNC;except;end;
end;
//## getinuse ##
function tcacherobot.getinuse(x:integer):boolean;
begin
try;result:=open and valid(x) and (iip.items[x]<>0) and (idim.items[x]>=timeoutDIM);except;end;
end;
//## setinuse ##
procedure tcacherobot.setinuse(x:integer;y:boolean);
begin
try
//nil - cannot set, since multiple unknown arguments (ip, dim) are required
except;end;
end;
//## sizeRAM ##
function tcacherobot.sizeRAM(x:integer):boolean;
begin
try
result:=false;
iip.setparams(x,x,0);
idim.setparams(x,x,0);
iwec.setparams(x,x,0);
result:=true;
except;end;
end;
//## fromRAM ##
function tcacherobot.fromRAM(x:integer;var rec):boolean;
begin
try
//defaults
result:=false;
//process
tcacherobotREC(rec).ip:=iip.items[x];
tcacherobotREC(rec).dim:=idim.items[x];
tcacherobotREC(rec).wec:=iwec.items[x];
//successful
result:=true;
except;end;
end;
//## toRAM ##
function tcacherobot.toRAM(x:integer;var rec):boolean;
begin
try
//defaults
result:=false;
//process
iip.items[x]:=tcacherobotREC(rec).ip;
idim.items[x]:=tcacherobotREC(rec).dim;
iwec.items[x]:=tcacherobotREC(rec).wec;
//successful
result:=true;
except;end;
end;
//## find ##
function tcacherobot.find(_ip:integer;var x:integer):boolean;
var
   t,p:integer;
begin
try
//defaults
result:=false;
x:=-1;
if (_ip=0) then exit;
t:=timeoutDIM;
//process
//.scan
for p:=0 to (iip.size-1) do if (iip.items[p]=_ip) and (idim.items[p]>=t) then
   begin
   //.found
   x:=p;
   result:=true;
   break;
   end;//end of if
except;end;
end;
//## findvalue ##
function tcacherobot.findvalue(_ip:integer;var _wec,_dim,_index:integer;var x:string):boolean;
var
   tmp:tcacherobotREC;
   p:integer;
begin
try
//defaults
result:=false;
x:='';
_wec:=wecUndefinedError;
_index:=-1;
_dim:=0;
//process
//.get
if find(_ip,p) and read(p,tmp) then
   begin
   _wec:=tmp.wec;
   _dim:=tmp.dim;
   _index:=p;
   x:=string(tmp.value);
   result:=true;
   end;//end of if
except;end;
end;
//## new ##
function tcacherobot.new(_ip:integer;var x,xcomment:integer):boolean;
var//Note: returns TRUE only if "_ip" does not already exist
   t,oti,ot,dim,i,p:integer;
begin
try
//defaults
result:=false;
x:=-1;
xcomment:=-1;
if (_ip=0) then exit;
ot:=maxint;//date limit (anything smaller is older)
oti:=-1;
i:=-1;
t:=timeoutDIM;
//process
//.scan
for p:=0 to (iip.size-1) do
   //.un-used record
   if (iip.items[p]=0) then
      begin
      if (i=-1) then i:=p;
      end
   else
      begin
      //.IP matches and within timeout period
      if (iip.items[p]=_ip) then
         begin
         xcomment:=p;
         if (idim.items[p]>=t) then
            begin
            x:=p;//ignore - since it already exists
            break;
            end;//end of if
         end;//end of if
      //.oldest
      if (idim.items[p]<ot) then
         begin
         ot:=idim.items[p];
         oti:=p;
         end;//end of if
      end;//end of if
//.set
if (x=-1) then
   begin
   //.get new
   if (i>=0) then x:=i//new and unsed
   else if (oti>=0) then x:=oti;//oldest and thus disposable
   //.successful
   result:=(x>=0);
   if result then xcomment:=x;
   end;//end of if
except;end;
end;
//## addonce ##
function tcacherobot.addonce(_ip,_wec:integer;var _index,_indexcomment:integer;_value:string):boolean;
var
   tmp:tcacherobotREC;
   p:integer;
begin
try
//defaults
result:=false;
_index:=-1;
_indexcomment:=-1;
//process
//.new
if open and new(_ip,p,_indexcomment) then
   begin
   //get
   tmp.ip:=_ip;
   tmp.dim:=getDIM;
   tmp.wec:=_wec;
   tonullstr(@tmp.value,sizeof(tmp.value),_value);
   //set
   _index:=p;
   result:=write(p,tmp) and toRAM(p,tmp);
   end;//end of if
except;end;
end;
//## pull ##
function tcacherobot.pull(var x:string):boolean;
begin//null - disabled
try
//defaults
result:=false;
x:='';
except;end;
end;
//## push ##
function tcacherobot.push(x:string):boolean;
begin//null - disabled
try
//defaults
result:=false;
except;end;
end;

//## tmanagedrobot #############################################################
//## create ##
constructor tmanagedrobot.create;
begin
//self
inherited;
//controls
iiplist:=tdynamicinteger.create;
icache:=tcacherobot.create;
end;
//## destroy ##
destructor tmanagedrobot.destroy;
begin
try
//controls
freeobj(@iiplist);
freeobj(@icache);
//self
inherited
except;end;
end;
//## lockip ##
function tmanagedrobot.lockip(_ip:integer;var _wec,_dim,_index:integer;var _value:string;var _cached:boolean):byte;
var//result: 0=no data - must supply robots.txt data, 1=must wait - already in use, 2=already cached - read the returned data
   p:integer;
begin
try
//defaults
result:=0;
_wec:=wecNoData;
_dim:=0;
_index:=-1;
_value:='';
_cached:=false;
//check
if (_ip=0) then
   begin
   _cached:=true;
   result:=2;
   exit;
   end;//end of if
//locked
p:=iiplist.find(0,_ip);
if (p>=0) then
   begin
   result:=1;
   exit;
   end;//end of if
//find
if icache.findvalue(_ip,_wec,_dim,_index,_value) then
   begin
   _cached:=true;
   result:=2;
   exit;
   end;//end of if
//lock ip
p:=iiplist.find(0,0);
if (p=-1) then p:=iiplist.count;
iiplist.value[p]:=_ip;
except;end;
end;
//## unlockip ##
procedure tmanagedrobot.unlockip(_ip:integer);
var
   p:integer;
begin
try
if (_ip<>0) then
   begin
   p:=iiplist.find(0,_ip);
   if (p>=0) then iiplist.items[p]:=0;
   end;//end of if
except;end;
end;
//## pushcontent ##
procedure tmanagedrobot.pushcontent(_ip,_code:integer;_content:string);
var
   _new,_index:integer;
   _value:string;
begin
try
//defaults
_value:='';
//get
if (_code=wecOK) then general.fromrobots(_content,_value,mc.agent,#10,sizeof(tbot));
//set
icache.addonce(_ip,_code,_new,_index,_value);
except;end;
end;

//## tcacheredirect ############################################################
//## create ##
constructor tcacheredirect.create;
begin
//self
inherited;
//controls
iu:=tdynamicstring.create;
iur:=tdynamicstring.create;
iuref:=tdynamiccurrency.create;
//defaults
size:=5000;
end;
//## create ##
destructor tcacheredirect.destroy;
begin
try
//controls
freeobj(@iu);
freeobj(@iur);
freeobj(@iuref);
//self
inherited;
except;end;
end;
//## getsize ##
function tcacheredirect.getsize:integer;
begin
try;result:=iu.size;except;end;
end;
//## setsize ##
procedure tcacheredirect.setsize(x:integer);
begin
try
//range
x:=frcmin(x,1);
//set
if (x<>size) then
   begin
   iu.setparams(x,x,0);
   iur.setparams(x,x,0);
   iuref.setparams(x,x,0);
   end;//end of if
except;end;
end;
//## find ##
function tcacheredirect.find(url:string;var redirecturl:string):boolean;
var
   ui:tparseurl;
   i,p:integer;
   vREF:currency;
begin
try
//defaults
result:=false;
redirecturl:='';
//filter
general.pu('http://'+url,'',ui,[pusExcludeMark]);
url:=ui.cu;
//check
if (url='') then exit;
//init
vREF:=general.ref256U(url);
//scan
p:=-1;
i:=-1;
while true do
begin
p:=iuref.find(p+1,vREF);
if (p=-1) or (p>=iuref.size) then break
else if (comparetext(iu.items[p]^,url)=0) then
    begin
    i:=p;
    break;
    end;//end of if
end;//end of loop
//set
if (i>=0) and (iur.items[i]^<>'') then
   begin
   redirecturl:=iur.items[i]^;
   result:=true;
   end;//end of if
except;end;
end;
//## add ##
procedure tcacheredirect.add(url,redirecturl:string);
var
   ui:tparseurl;
begin
try
//filter
general.pu('http://'+url,'',ui,[pusExcludeMark]);
url:=ui.cu;
if (url='') then exit;
general.pu('http://'+redirecturl,'',ui,[pusExcludeMark]);
redirecturl:=ui.cu;
if (redirecturl='') then exit;
//check - ignore identical in/out values
if (0=comparetext(url,redirecturl)) then exit;
//range
if (ipos<0) or (ipos>=iu.size) then ipos:=0;
//set
iuref.items[ipos]:=general.ref256U(url);
iu.items[ipos]^:=url;
iur.items[ipos]^:=redirecturl;
//inc
inc(ipos);
except;end;
end;

//############################# tipfilter ######################################
//## create ##
constructor tipfilter.create;
begin
ifrom:=nil;
ito:=nil;
//controls
ifrom:=tdynamiccurrency.create;
ito:=tdynamiccurrency.create;
end;
//## destroy ##
destructor tipfilter.destroy;
begin
try
//controls
freeObj(@ifrom);
freeObj(@ito);
//self
inherited;
except;end;
end;
//## getcount ##
function tipfilter.getcount:integer;
begin
try;result:=ifrom.count;except;end;
end;
//## setfilter ##
procedure tipfilter.setfilter(x:string);
var
   _from,_to:currency;
   _fromIP,_toIP,len,i,p:integer;
   tmp:string;
begin
try
//defaults
ifilter:='';
len:=0;
//process
//.set
p:=1;
ifrom.clear;
ito.clear;
//.scan
while general.nextline(p,x,tmp) do if asfilter(tmp,_from,_to,_fromIP,_toIP) then
   begin
   i:=ifrom.count;
   ifrom.value[i]:=_from;
   ito.value[i]:=_to;
   case (_fromIP<>_toIP) of
   true:pushb(len,ifilter,_strip(_fromIP)+'-'+_strip(_toIP)+rcode);
   false:  pushb(len,ifilter,_strip(_fromIP)+rcode);
   end;//end of case
   end;//end of if
//.finalise
if (len<>0) then pushb(len,ifilter,'');
except;end;
end;
//## ip8 ##
function tipfilter.ip8(ip4:integer):currency;
var
   a:tint4;
   tmp:currency;
begin
try
//defaults
result:=0;
//process
//.get
a.val:=ip4;
//.set
result:=a.bytes[3]+a.bytes[2]*256+a.bytes[1]*65536;
//.math workaround
tmp:=16777216;
result:=result+(tmp*a.bytes[0]);
except;end;
end;
//## asfilter ##
function tipfilter.asfilter(x:string;var _from,_to:currency;var _fromIP,_toIP:integer):boolean;
label
   skipend;
const
   sep='-';
var
   tmp,xlen,p:integer;
begin
try
//defaults
result:=false;
_from:=0;
_to:=0;
xlen:=length(x);
//check
if (xlen=0) then exit;
//process
for p:=1 to xlen do
begin
if (x[p]=sep) then
   begin
   if _intipb(copy(x,1,p-1),_fromIP) then _from:=ip8(_fromIP) else goto skipend;
   if _intipb(copy(x,p+1,xlen),_toIP) then _to:=ip8(_toIP) else goto skipend;
   break;
   end
else if (p=xlen) then
   begin
   if not _intipb(x,_fromIP) then goto skipend;
   _from:=ip8(_fromIP);
   _to:=_from;
   _toIP:=_fromIP;
   end;//end of if
end;//end of loop
//.swap
if (_from>_to) then
   begin
   swapcur(_from,_to);
   swapint(_fromIP,_toIP);
   end;//end of if
//successful
result:=true;
skipend:
except;end;
end;
//## find ##
function tipfilter.find(ip:integer):integer;
var
   i8:currency;
   p:integer;
begin
try
//defaults
result:=-1;
i8:=ip8(ip);
//process
for p:=0 to (ifrom.count-1) do if (i8>=ifrom.items[p]) and (i8<=ito.items[p]) then
   begin
   result:=p;
   break;
   end;//end of if
except;end;
end;
//## found ##
function tipfilter.found(ip:integer):boolean;
begin
try;result:=(find(ip)>=0);except;end;
end;

//############################ trawlog #########################################
//## create ##
constructor trawlog.create;
begin
//self
inherited;
//controls
ilist:=trolltext.create;
ilist.alltext:=true;
ilist.size:=200;
//vars
istyle:=[rlsDisk,rlsList];
itimeout:=10000;//save every 10 seconds
itmp:='';
itmpLEN:=0;
iban:='';
ibanLEN:=0;
itimeindex:=ms64;
ilastcanviewtime:=itimeindex;
ilastcanviewbantime:=itimeindex;
ilastcanviewtraffictime:=itimeindex;
//defaults
itimer:=mt.new(_ontimer,1000,true);
end;
//## destroy ##
destructor trawlog.destroy;
begin
try
//timer
mt.del(itimer);
//disk - save all RAM data now
disk;
//controls
freeObj(@ilist);
//self
inherited;
except;end;
end;
//## addlogextra ##
procedure trawlog.addlogextra(x:string;var z:string);
begin
try
if (z<>'') then z:=z+' | ';
z:=z+x;
except;end;
end;
//## _ontimer ##
procedure trawlog._ontimer(sender:tobject);
begin
try
//.disk
if (itimeout=0) or ((ms64-itimeindex)>=itimeout) then
   begin
   //.disk
   disk;
   //.reset
   itimeindex:=ms64;
   end;//end of if
except;end;
end;
//## fp ##
function trawlog.fp:string;
begin
try;result:=bvfportable(bvfLogs+programname+'\');except;end;
end;
//## fnLOG ##
function trawlog.fnLOG:string;
begin//automatically changes filename to "[001..100].txt" in current file exceeds 2Gb, allowing for upto 200Gb of log storage in one day
try;result:=misc.subfile(fp+programname+dates.logstyle+'.TXT',2000000000);except;end;
end;
//## fnBAN ##
function trawlog.fnBAN:string;
begin//automatically changes filename to "[001..100].txt" in current file exceeds 2Gb, allowing for upto 200Gb of log storage in one day
try;result:=misc.subfile(fp+programname+dates.logstyle+'-BANNED.TXT',2000000000);except;end;
end;
//## fnREQ ##
function trawlog.fnREQ:string;
begin//automatically changes filename to "[001..100].txt" in current file exceeds 2Gb, allowing for upto 200Gb of log storage in one day
try;result:=misc.subfile(fp+programname+dates.logstyle+'-REQUESTERR.TXT',2000000000);except;end;
end;
//## fnTRA ##
function trawlog.fnTRA:string;
begin//No subfile required - should never exceed 2Gb
try;result:=fp+programname+dates.logstyle+'-TRAFFIC.TXT';except;end;
end;
//## disk ##
procedure trawlog.disk;
var
   e,f,x:string;
begin
try
//process
//.get
if (itmpLEN<>0) then
   begin
   pushb(itmpLEN,itmp,'');
   x:=itmp;
   itmpLEN:=0;
   itmp:='';
   //.set
   f:=fnLOG;
   if programreadwrite then//07FEB2008
      begin
      io.toFILEAPPEND(f,x,e);
      icurrentfn:=f;
      end;//end of if
   //.extra information - separate files
   if (fsecip<>nil) then
      begin
      f:=fnTRA;
      x:=fsecip.stats(true,#9,rcode);
      if programreadwrite then//07FEB2008
         begin
         io.tofile(f,x,e);
         itrafficfn:=f;
         end;//end of if
      end;//end of if
   end;//end of if
//.banned
if (ibanLEN<>0) then
   begin
   pushb(ibanLEN,iban,'');
   x:=iban;
   ibanLEN:=0;
   iban:='';
   //.set
   f:=fnBAN;
   if programreadwrite then//07FEB2008
      begin
      io.toFILEAPPEND(f,x,e);
      ibanfn:=f;
      end;//end of if
   end;//end of if
except;end;
end;
//## canview ##
function trawlog.canview:boolean;
var
   s:currency;
begin
try
//defaults
s:=ms64;
//decide
if ((s-ilastcanviewtime)<2000) then result:=ilastcanview
else
   begin
   result:=(icurrentfn<>'') and fileexists(icurrentfn);
   ilastcanview:=result;
   ilastcanviewtime:=s;
   end;//end of if
except;end;
end;
//## view ##
procedure trawlog.view;
begin
try;if canview then run(icurrentfn,'');except;end;
end;
//## canviewban ##
function trawlog.canviewban:boolean;
var
   s:currency;
begin
try
//defaults
s:=ms64;
//decide
if ((s-ilastcanviewbantime)<2000) then result:=ilastcanviewban
else
   begin
   result:=(ibanfn<>'') and fileexists(ibanfn);
   ilastcanviewban:=result;
   ilastcanviewbantime:=s;
   end;//end of if
except;end;
end;
//## viewban ##
procedure trawlog.viewban;
begin
try;if canviewban then run(ibanfn,'');except;end;
end;
//## canviewtraffic ##
function trawlog.canviewtraffic:boolean;
var
   s:currency;
begin
try
//defaults
s:=ms64;
//decide
if ((s-ilastcanviewtraffictime)<2000) then result:=ilastcanviewtraffic
else
   begin
   result:=(itrafficfn<>'') and fileexists(itrafficfn);
   ilastcanviewtraffic:=result;
   ilastcanviewtraffictime:=s;
   end;//end of if
except;end;
end;
//## viewtraffic ##
procedure trawlog.viewtraffic;
begin
try;if canviewtraffic then run(itrafficfn,'');except;end;
end;
//## viewfolder ##
procedure trawlog.viewfolder;
begin
try;run(fp,'');except;end;
end;
//## addbanned ##
procedure trawlog.addbanned(ip,hitcount,errorcount:integer;bytecount:currency);
const
   sep=' / ';
var
   dt:tdatetime;
   y,m,d,hh,mm,ss,msec:word;
   oh,om,f:integer;
   dtOFFSET,z:string;
begin
try
//init
dt:=now;
decodedate(dt,y,m,d);
decodetime(dt,hh,mm,ss,msec);
dates.gmtOFFSET(oh,om,f);
dtOFFSET:=general.digpad(oh,2)+general.digpad(om,2);
//get
z:= _strIP(ip)+' ['+
 general.digpad(d,2)+'/'+_months_abrv[m]+'/'+general.digpad(y,4)+':'+general.digpad(hh,2)+':'+general.digpad(mm,2)+':'+general.digpad(ss,2)+#32+dtOFFSET+
 '] '+
 general.thousands(errorcount)+' errors'+sep+
 general.thousands(hitcount)+' hits'+sep+
 general.curcomma(bytecount)+' bytes';
//set
if (rlsDisk in style) then pushb(ibanLEN,iban,z+rcode);
except;end;
end;
//## addstr ##
procedure trawlog.addstr(x:string);
begin
try
//process
//.filter
general.swapchars(x,#10,#32);
general.swapchars(x,#13,#32);
//.add
//..disk
if (rlsDisk in style) then pushb(itmpLEN,itmp,x+rcode);
//..list
if (rlsList in style) then ilist.roll(x);
except;end;
end;
//## addentry ##
procedure trawlog.addentry(cip:integer;dt:tdatetime;rl:string;ec:integer;bytes:currency;rf,ua,extra,extralines,inputheader:string);
var//Example entry:
   //www.blaiz.net - - [16/Apr/2003:00:07:12 -0400] "GET /index.html HTTP/1.0" 200 2459 "http://www.tudogs.com/graphic_software3.php?pass=set" "Mozilla/4.0 (compatible; MSIE 6.0; Windows 98)"
   b64,sep,dtOFFSET,tmp:string;
   c,p,oh,om,f:integer;
   d,m,y,hh,mm,ss,msec:word;
begin
try
//extra
extra:=general.xxxlineb(1,extra);
if (extra<>'') then extra:=#32+'"'+extra+'"';
//process
decodedate(dt,y,m,d);
decodetime(dt,hh,mm,ss,msec);
dates.gmtOFFSET(oh,om,f);
dtOFFSET:=general.digpad(oh,2)+general.digpad(om,2);
case f of
1:dtOFFSET:='+'+dtOFFSET;//greater than
-1:dtOFFSET:='-'+dtOFFSET;//less than
end;//end of case
addstr(
 _strIP(cip)+' - - ['+
 general.digpad(d,2)+'/'+_months_abrv[m]+'/'+general.digpad(y,4)+':'+general.digpad(hh,2)+':'+general.digpad(mm,2)+':'+general.digpad(ss,2)+#32+dtOFFSET+
 '] "'+general.udv(general.xxxlineb(1,rl),'-')+'"'+
 #32+inttostr(ec)+
 #32+general.aorbstr(floattostrex2(bytes),'-',(bytes<0))+
 #32+'"'+general.udv(general.xxxlineb(1,rf),'-')+'"'+
 #32+'"'+general.udv(general.xxxlineb(1,ua),'-')+'"'+
 extra);
//.extralines
c:=0;
p:=1;
while general.nextline(p,extralines,tmp) do if (tmp<>'') then
   begin
   addstr(tmp);
   inc(c);
   end;//end of if
if (c>=1) then addstr('');//blank spacing line
//.header
if includeInheaders and ((ec<>wecOK) and (ec<>wecPartial)) then//28OCT2007
   begin
   //init
   sep:='>';
   b64:=io.tob64b(inputheader,0);
   //get
   p:=1;
   addstr(sep+'-- input header --');
   addstr(sep+'base64: '+b64);
   addstr(sep+'raw:');
   while general.nextline(p,inputheader,tmp) do addstr(sep+tmp);
   addstr(sep+'-- end --');
   addstr('');//blank spacing line
   end;//end of if
except;end;
end;
//## addheader ##
procedure trawlog.addheader(i,o:pstring;code:integer;ip:integer;bytes,tst:currency;extra,extralines:string);
begin
try;addheaderb(i,o,code,ip,bytes,tst,extra,extralines,false);except;end;
end;
//## addheaderb ##
procedure trawlog.addheaderb(i,o:pstring;code:integer;ip:integer;bytes,tst:currency;extra,extralines:string;raw:boolean);
const
   sep=', ';
var//Note: tst=transaction start time (time connection commenced, so we can track entire time taken for connection)
   _inheader,tmp,h,v,rl,rf,ua:string;
   r,tt,ic,oc:currency;
   ec:integer;
begin
try
//defaults
ec:=wecNoData;
rl:='-';
rf:='-';
ua:='-';
ic:=0;
oc:=0;
_inheader:='';
if not raw then
   begin
   if (i<>nil) then
      begin
      ic:=length(i^);
      _inheader:=i^;
      end;//end of if
   if (o<>nil) then oc:=length(o^)+frccurmin(bytes,0);
   end
else
   begin
   ic:=0;
   oc:=frccurmin(bytes,0);
   end;//end of if
tt:=frccurmin(ms64-tst,1);//transaction time (always 1ms or higher for safe division below)
r:=tt/1000;
if (r<=0) then r:=1;
//process
//.i
if (i<>nil) and (i^<>'') then
   begin
   rl:=general.xxxline(1,i^);
   misc.headerfind(i^,'Referer: ',rf);
   misc.headerfind(i^,'User-Agent: ',ua);
   end;//end of if
//.o
if (o<>nil) and (o^<>'') then ec:=general.srcb(o^,wecNoData);
if (code<>wecNotUsed) then ec:=code;//special override
//.bytes
if (0=comparetext(copy(rl,1,5),'HEAD ')) then bytes:=-1;
//.gzipped
if misc.headerfind(o^,'Content-Encoding: ',v) and (comparetext(v,'gzip')=0) then
   begin
   extra:=extra+general.insstr(sep,extra<>'')+'gzipped';
   end;//end of if
//.enhanced log information
if not misc.headerfind(i^,'host: ',h) then h:='-';
if misc.headerfind(i^,'content-length: ',tmp) then general.croll(ic,frccurmin(strcur(tmp),0));
extra:=extra+general.insstr(sep,extra<>'')+
 tsTransactiontimelc+': '+dates.uptime(tt,true,#32)+sep+
 tsClientHostlc+': '+h+sep+
 lowercase(tsRecv)+': '+floattostrex2(ic)+sep+
 lowercase(tsSent)+': '+floattostrex2(oc)+sep+
 lowercase(tsRate)+': '+floattostrex2( int((ic+oc)/r) );
//.ip switch
if misc.headerfind(i^,'proxy-sourceip: ',v) then
   begin
   extra:=extra+general.insstr(sep,extra<>'')+
    tsClientIPlc+': '+_strip(_intip(v))+sep+
    tsProxyIPlc+': '+_strip(ip);
   ip:=_intip(v);
   end;//end of if
//.add
addentry(ip,now,rl,ec,bytes,rf,ua,extra,extralines,_inheader);
except;end;
end;
//## listtext32k ##
function trawlog.listtext32k(up:boolean):string;
begin
try;result:=ilist.lines[32000,up];except;end;
end;

//############################ tids ############################################
//## create ##
constructor tids.create;
begin
inherited;
//controls
iid:=tdynamicname.create;
itime:=tdynamiccurrency.create;
//vars
iactive:=0;
//timer
itimer:=mt.new(_ontimer,10000,true);
end;
//## _ontimer ##
procedure tids._ontimer(sender:tobject);
begin
try;check;except;end;
end;
//## destroy ##
destructor tids.destroy;
begin
try
//itimer
mt.del(itimer);
//controls
freeObj(@iid);
freeObj(@itime);
//self
inherited;
except;end;
end;
//## settimeout ##
procedure tids.settimeout(x:currency);
begin//Note: if x<0 then timeout is ignored
try
if (x<>itimeout) then
   begin
   itimeout:=x;
   check;
   end;//end of if
except;end;
end;
//## getsize ##
function tids.getsize:integer;
begin
try;result:=iid.size;except;end;
end;
//## setsize ##
procedure tids.setsize(x:integer);
begin
try
x:=frcmin(x,0);
iid.setparams(x,x,0);
itime.setparams(x,x,0);
except;end;
end;
//## clear ##
procedure tids.clear;
begin
try
size:=0;
iactive:=0;
except;end;
end;
//## check ##
procedure tids.check;
var
   t:currency;
   p:integer;
begin
try
if (itimeout>=1) and (size>=1) then
   begin
   t:=ms64;
   for p:=0 to (size-1) do if (iid.items[p]^<>'') and ((t-itime.items[p])>itimeout) then _del(p);
   end;//end of if
except;end;
end;
//## valid ##
function tids.valid(_id:string):boolean;
var
   p:integer;
begin
try
//defaults
result:=false;
//process
if (_id<>'') then
   begin
   p:=iid.findfast(0,_id);
   if (p>=0) then
      begin
      itime.items[p]:=ms64;
      result:=true;
      end;//end of if
   end;//end of if
except;end;
end;
//## _del ##
procedure tids._del(index:integer);
begin
try
if (index>=0) and (index<size) and (iid.items[index]^<>'') then
   begin
   iid.items[index]^:='';
   dec(iactive);
   end;//end of if
except;end;
end;
//## del ##
procedure tids.del(_id:string);
begin
try;_del(iid.findfast(0,_id));except;end;
end;
//## new ##
function tids.new:string;
var
   i,p,s:integer;
begin
try
//error
result:='';
//process
//.find first unused spot/or just add
p:=iid.findfast(0,'');
if (p=-1) then
   begin
   size:=size+1000;
   p:=iid.findfast(0,'');
   if (p=-1) then exit;
   end;//end of if
//.add
setlength(result,20);
for i:=1 to length(result) do result[i]:=chr(65+random(26));//never reaches 26
iid.value[p]:=result;
itime.items[p]:=ms64;
inc(iactive);
except;end;
end;

//####################### tnetsession ##########################################
//## create ##
constructor tnetsession.create;
begin//note: message handling point is from "tpg.wndproc" which passes are
    //       all messages of type "cm_socketmessage"
try
inherited;
{ipinfo}
ipinfo:=@iinfo;
{defaults}
ilockcount:=0;
irunning:=false;
except;end;
end;
//## createsys ##
constructor tnetsession.createsys(sysVar:prootobject);
begin
inherited createsys(sysVar);
start;
end;
//## destroy ##
destructor tnetsession.destroy;
begin
try
//controls
//.stop
_stop;
//self
inherited;
except;end;
end;
//## canRESUME ##
function tnetsession.canRESUME(var header:string):boolean;//19-OCT-2006
var
   z:string;
begin
try;result:=misc.headerfind(header,'Range: ',z) and (comparetext(copy(z,1,5),'bytes')=0);except;end;
end;
//## supportRESUME ##
procedure tnetsession.supportRESUME(var header:string);
begin
try;misc.headeradd(header,'Accept-Ranges: ','bytes');except;end;
end;
//## readRESUMEi ##
function tnetsession.readRESUMEi(var header:string;var start,len:integer):boolean;
var
   s,l:currency;
begin
try
result:=readRESUME(header,s,l);
start:=round(s);
len:=round(l);
except;end;
end;
//## readRESUME ##
function tnetsession.readRESUME(var header:string;var start,len:currency):boolean;//26-DEC-2006
var
   d,tmp:string;
   i,p:integer;
   f:currency;
begin
try
//defaults
result:=false;
//init
start:=0;
len:=0;
//process
if canRESUME(header) and misc.headerfind(header,'Range: ',tmp) and (tmp<>'') then
   begin
   for p:=1 to length(tmp) do if (comparetext(copy(tmp,p,6),'bytes=')=0) then
      begin
      tmp:=copy(tmp,p+6,length(tmp));
      for i:=1 to length(tmp) do if (tmp[i]='-') then
         begin
         //set
         start:=frccurmin(strcur(copy(tmp,1,i-1)),0);
         d:=copy(tmp,i+1,length(tmp));
         if (d<>'') then
            begin
            f:=frccurmin(strcur(d),0);
            if (start<=f) then len:=f-start+1;
            end;//end of if
         //successful
         result:=true;
         break;
         end;//end o fif
      break;
      end;//end of if
   end;//end of if
except;end;
end;
//## canGZIP ##
function tnetsession.canGZIP(var header:string):boolean;//13-OCT-2006
var//IE5.X patched
   t,u,p,v,z,tmp:string;
   hlen,sp,tmpLEN,i:integer;
   ui:tparseurl;
begin
try
//defaults
result:=false;
//process
//.get
if misc.headerfind(header,'accept-encoding: ',tmp) then
   begin
   tmp:=tmp+',';
   tmpLEN:=length(tmp);
   //.decide
   sp:=1;
   for i:=1 to tmpLEN do
   if (tmp[i]=#32) then sp:=i+1
   else if (tmp[i]=',') then
      begin
      z:=uppercase(copy(tmp,sp,i-sp));
      sp:=i+1;
      if (z='GZIP') then
         begin
         result:=true;
         break;
        end;//end of if
      end;//end of if
   //.extension check - IE5.X patch (IE asks form *.ZIP with GZIP for transfer, but fails to expand compress transfer stream due to it's internal security measures. Note: IE6-XP correctly fixes this by not asking for GZIP as transfer)
   if result then
      begin
      //.get
      hlen:=length(header);
      ahRL(header,hlen,'g',t,u,p,v);
      general.pu('http://localhost'+u,'',ui,[pusExcludeMark]);
      //.masked - no need to check extensions
      tmp:=ui.f;
      for i:=1 to length(tmp) do if (tmp[i]='*') then
         begin
         result:=false;
         break;
         end;//end of if
      //.perform check
      if result and (not gzipsafeext(ui.e)) then result:=false;
      end;//end of if
   end;//end of if
except;end;
end;
//## gzipsafeext ##
function tnetsession.gzipsafeext(ext:string):boolean;
var
   tmp:string;
begin
try
//yes
result:=true;
//range
tmp:=readfileext(ext,false);//Note: return "nil" if no "dot" present
if (tmp<>'') and (ext<>'') then ext:=tmp;
//no
if
 (
 (comparetext(ext,'GZ')=0) or
 (comparetext(ext,'ZIP')=0) or
 (comparetext(ext,'TAR')=0) or
 (comparetext(ext,'Z')=0) or
 (comparetext(ext,'TGZ')=0) or
 (comparetext(ext,'EXE')=0)
 ) then result:=false;
except;end;
end;
//## GZIP ##
procedure tnetsession.GZIP(var header,content:string;autodecide:boolean);//browser controlled
var//Use compressed version of data only if it's smaller than uncompressed version
   a:tzof;
   tmp:string;
begin
try
//check
if (content='') then exit;
//defaults
a:=nil;
a:=tzof.create;
//process
//.compress
tmp:=a.httpGZIP(content);
if (not autodecide) or (length(tmp)<length(content)) then
   begin
   //.set
   content:=tmp;
   //..adjust "content-length: "
   misc.headeradd(header,'Content-Length: ',inttostr(length(content)));
   //..insert "content-encoding: "
   misc.headeradd(header,'Content-Encoding: ','gzip');
   end;//end of if
except;end;
try;freeobj(@a);except;end;
end;
//## GZIPheader ##
procedure tnetsession.GZIPheader(var header,content,pregzippedcontent:string;autodecide:boolean);//browser controlled
begin
try
//check
if (content='') then exit;
//process
//.compress
if (not autodecide) or (length(pregzippedcontent)<length(content)) then
   begin
   //.set
   content:=pregzippedcontent;
   //..adjust "content-length: "
   misc.headeradd(header,'Content-Length: ',inttostr(length(content)));
   //..insert "content-encoding: "
   misc.headeradd(header,'Content-Encoding: ','gzip');
   end;//end of if
except;end;
end;
//## multipart ##
function tnetsession.multipart(var header:string;var boundary:string):boolean;
const
   m='multipart/form-data;';
var
   z:string;
   mlen,zlen,p:integer;
   v:byte;
begin//multipart/form-data
try
//defaults
result:=false;
boundary:='';
mlen:=length(m);
//process
//.get
misc.headerfind(header,'content-type: ',z);
zlen:=length(z);
//.decide
if (0=comparetext(copy(z,1,mlen),m)) then for p:=(mlen+1) to zlen do
   begin
   //.get
   v:=ord(z[p]);
   if (v<>9) and (v<>32) then boundary:=boundary+z[p]
   else if (boundary<>'') then break;//end of if
   end;//end of if
//.strip "boundary="
if (boundary<>'') then for p:=1 to length(boundary) do if (boundary[p]='=') then
   begin
   boundary:=copy(boundary,p+1,length(boundary));
   break;
   end;//end of if
//return result
result:=(boundary<>'');
except;end;
end;
//## getuseragents ##
function tnetsession.getuseragents(sep:string):string;
begin
try
//process
//.get
if (sep='') then sep:=rcode;
//.set
result:=
 safeua('Mozilla/5.0 (Macintosh; U; PPC Mac OS X; en)')+sep+
 safeua('Mozilla/5.0 (X11; U; Linux i686; en-US)')+sep+
 safeua('Mozilla/4.7 (compatible; Windows)')+sep+
 safeua('Mozilla/4.0 (compatible; MSIE 6.0; Windows)')+sep+
 safeua('Mozilla/4.0 (compatible; MSIE 6.0; Windows XP)')+sep+
 safeua('Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)')+sep+
 safeua('Mozilla/4.0 (compatible; MSIE 5.00; Windows 98)')+sep+
 safeua('Mozilla/4.0 (compatible; MSIE 5.0; Windows 98; DigExt)')+sep+
 safeua('Mozilla/3.0 (compatible; Windows XP)')+sep+
 safeua('Mozilla/3.0 (compatible; Windows 2000)')+sep+
 safeua('Mozilla/2.0 (compatible)')+sep+
 safeua('Internet Explorer 6.x')+sep+
 safeua('Opera/7.54 (Windows NT 5.1; U)  [en]')+sep+
 safeua('-')+sep;
except;end;
end;
//## safeua ##
function tnetsession.safeua(x:string):string;
var
   p:integer;
begin
try
//defaults
result:='';
//process
//.get
result:=general.xxxline(1,x);
//.filter
for p:=1 to length(result) do
    case ord(result[p]) of
    32,64..90,97..122,48..57,95,40..47,58..59,91,93:;//[space,@-A-Z,a-z,0-9,_,"()*+,-./",":;",[,]]
    else
       result[p]:='_';
    end;//end of case
except;end;
end;
//## agentname ##
function tnetsession.agentname(x:string):string;
var
   p:integer;
begin
try
//defaults
result:=x;
//process
for p:=1 to length(result) do if (result[p]='/') or (result[p]='\') or (result[p]=#32) or (result[p]=#9) then
   begin
   result:=copy(result,1,p-1);
   break;
   end;//end of if
except;end;
end;
//## getmsghandle ##
function tnetsession.getmsghandle:hwnd;
begin
try;result:=pg.handle;except;end;
end;
//## bup ##
function tnetsession.bup(username,password:string):string;//basic: username & password for "http 401"
begin
try;result:=io.tob64b(username+':'+password,0);except;end;
end;
//## bupCREATE ##
function tnetsession.bupCREATE(enabled,restrict:boolean;username,password:string):string;
begin
try
if enabled then
   begin
   if restrict then result:=bup(username,password) else result:='*';
   end
else result:='';
except;end;
end;
//## bupENABLED ##
function tnetsession.bupENABLED(sysBUP:string):boolean;
begin//sysBUP: nil=no access, *=no restrictions, all others must match
try;result:=(sysBUP<>'');except;end;
end;
//## bupACCESS ##
function tnetsession.bupACCESS(brwBUP,sysBUP:string):boolean;
begin//sysBUP: nil=no access, *=no restrictions, all others must match
try
//filter - read to first space (strips 'realm="XXXX"' from user/password)
brwBUP:=general.upto(brwBUP,#32);
//return result
result:=bupENABLED(sysBUP) and ((sysBUP='*') or (brwBUP=sysBUP));
except;end;
end;
//## bupDUALENABLED ##
function tnetsession.bupDUALENABLED(sysBUP,sysBUP2:string):boolean;
begin
try;result:=bupENABLED(sysBUP) or bupENABLED(sysBUP2);except;end;
end;
//## bupRESTRICTED ##
function tnetsession.bupRESTRICTED(sysBUP:string):boolean;
begin
try;result:=(sysBUP<>'*');except;end;
end;
//## ahRLb ##
function tnetsession.ahRLb(var h:string;var hlen:integer;m:char;t,u,p,v:string):boolean;//adjust header request-line
begin
try;result:=ahRL(h,hlen,m,t,u,p,v);except;end;
end;
//## ahRL ##
function tnetsession.ahRL(var h:string;var hlen:integer;m:char;var t,u,p,v:string):boolean;//access header request-line
var//m=g (read), m=s (write) information
   //set "t, u, p or v" to "*" if to remain unchanged during "m=s"
   tmp,a:integer;
   tPOS,uPOS,pPOS,vPOS:tpoint;
begin
try
//defaults
if (m='g') then
   begin
   t:='';
   u:='';
   p:='';
   v:='';
   end;//end of if
//process
//.info
result:=rlINFO(h,hlen,tPOS,uPOS,pPOS,vPOS);
if result then
   begin
   //..get
   if (m='g') then
      begin
      t:=uppercase(copy(h,tPOS.x,tPOS.y));
      u:=copy(h,uPOS.x,uPOS.y);
      p:=uppercase(copy(h,pPOS.x,pPOS.y));
      v:=uppercase(copy(h,vPOS.x,vPOS.y));
      end
   //..set
   else if (m='s') then
      begin
      a:=0;
      tmp:=0;
      if (t<>'*') then general.replaceb(t,h,tPOS.x,tPOS.y,tmp);
      if (u<>'*') then
         begin
         inc(a,tmp);
         tmp:=0;
         inc(hlen,a);
         inc(uPOS.x,a);
         general.replaceb(u,h,uPOS.x,uPOS.y,tmp);
         end;//end of if
      if (p<>'*') then
         begin
         inc(a,tmp);
         tmp:=0;
         inc(hlen,a);
         inc(pPOS.x,a);
         general.replaceb(p,h,pPOS.x,pPOS.y,tmp);
         end;//end of if
      if (v<>'*') then
         begin
         inc(a,tmp);
         tmp:=0;
         inc(hlen,a);
         inc(vPOS.x,a);
         general.replaceb(v,h,vPOS.x,vPOS.y,tmp);
         end;//end of if
      end;//end of if
   end;//end of if
except;end;
end;
//## rlINFO ##
function tnetsession.rlINFO(var h:string;var hlen:integer;var tPOS,uPOS,pPOS,vPOS:tpoint):boolean;//request-line information
var
   s,c,max,i2,i,_pos,_start,_length:integer;
begin
try
//defaults
result:=false;
tPOS:=point(1,0);
uPOS:=tPOS;
pPOS:=tPOS;
vPOS:=tPOS;
if (hlen<1) then exit;
//process
//.scan
_pos:=1;
while general.readline(_pos,_start,_length,h) do
begin
//.check
if ((_start+_length-1)>hlen) then exit;
//.get
max:=_start+_length-1;
s:=max;
c:=0;
for i:=_start to max do if (h[i]=#32) and (c<=1) then
   begin
   //.set
   if (c=0) then tPOS:=point(_start,i-_start)
   else if (c=1) then
      begin
      uPOS:=point(s,i-s);
      pPOS:=point(i+1,max-i);
      for i2:=pPOS.x to (pPOS.x+pPOS.y-1) do if (h[i2]='/') then
         begin
         pPOS.y:=i2-pPOS.x;
         vPOS.x:=i2+1;
         vPOS.y:=max-vPOS.x+1;
         //.successful
         result:=true;
         //.stop
         break;
         end;//end of if
      //.stop
      break;
      end;//end of if
   //.inc
   inc(c);
   s:=i+1;
   end;//end of if
//.stop
break;
end;//end of while
except;end;
end;
//## hlen ##
function tnetsession.hlen(var x:string;var len:integer):boolean;
begin
try;result:=hlenb(x,length(x),len);except;end;
end;
//## hlenb ##
function tnetsession.hlenb(var x:string;xlen:integer;var len:integer):boolean;
var
   p:integer;
   u,w:string;
begin
try
//defaults
result:=false;
len:=0;
//.xlen
if (xlen<2) then exit;
p:=length(x);
if (xlen>p) then xlen:=p;
p:=1;
//..unix
u:=#10+#10;
//..windows
w:=(#13+#10)+(#13+#10);
//process
//.scan
repeat
if ((x[p]=#10) and ((p+1)<=xlen) and (copy(x,p,2)=u)) then
   begin
   len:=p+1;
   result:=true;
   break;
   end
else if ((x[p]=#13) and ((p+3)<=xlen) and (copy(x,p,4)=w)) then
   begin
   len:=p+3;
   result:=true;
   break;
   end;//end of if
//.inc
inc(p);
until (p>xlen);
except;end;
end;
//## start ##
function tnetsession.start:boolean;
begin
try
{process}
if (not running) then irunning:=(0=WSAStartup(winsocketVersion,iInfo));
{ilockcount}
ilockcount:=ilockcount+1;
{return result}
result:=running;
except;end;
end;
//## stop ##
procedure TNetSession.stop;
begin
try
{check}
ilockcount:=ilockcount-1;
if (ilockcount<>0) then exit;
{_stop}
_stop;
except;end;
end;
//## _stop ##
procedure TNetSession._stop;
begin
try
{check}
if not running then exit;
{process}
irunning:=false;
WSACleanup;
except;end;
end;
//## remoteipb ##
function tnetsession.remoteipb(_socket:integer):integer;
begin
try;remoteip(_socket,result);except;end;
end;
//## remoteip ##
function tnetsession.remoteip(_socket:integer;var _ip:integer):boolean;
var
   a:tsockaddrin;
   sa:integer;
begin
try
//defaults
result:=false;
_ip:=0;
//process
if (_socket<>invalid_socket) then
   begin
   sa:=sizeof(a);
   fillchar(a,sa,0);
   if (n_getpeername(_socket,a,sa)=0) then
      begin
      //RemoteHost - not available "gethostbyaddr" jams under little stress
      //RemoteAddress - works find since it gets raw "IP address"
      _ip:=_intIP(n_inet_ntoa(a.sin_addr));//remote address
      result:=true;
      end;//end of if
   end;//end of if
except;end;
end;
//## findservice ##
function tnetsession.findservice(def,http:integer;const service:string):integer;
var{update: patched to work with "http" and "https"}
  a:pservent;
begin
try
if (0=comparetext(service,'http')) then
   begin
   if (http>=1) then result:=http else result:=80
   end
else
   begin
   a:=n_getservbyname(pchar(service),'tcp');
   if (a<>nil) then result:=n_ntohs(a.s_port)
   else if (0=comparetext(service,'https')) then result:=443
   else result:=def;//use supplied default port
   end;//end of if
except;end;
end;
//## SetIdleMS ##
procedure TNetSession.SetIdleMS(x:integer);
begin
try
{enforce range}
x:=frcrange(x,100,30*60*1000);{100ms -> 30minutes}
{check}
if (x=iIdleMS) then exit;
{set}
iIdleMS:=x;
except;end;
end;
//## WithinTime ##
function TNetSession.WithinTime(var x:TWebHeader):boolean;
begin
try;result:=(getcurrenttime-whs.int[x,wbnIdletime])<=iIdleMS;except;end;
end;

//#################### tmimes ##################################################
//## create ##
constructor tmimes.create;
begin
inherited;
//controls
ie:=tdynamicvars.create;
im:=tdynamicvars.create;
//defaults
clear;
end;
//## destroy ##
destructor tmimes.destroy;
begin
try
//controls
freeObj(@ie);
freeObj(@im);
//self
inherited;
except;end;
end;
//## add ##
procedure tmimes.add(e,m:string);
begin
try
ie.value[e]:=m;
im.value[m]:=general.udv(e,'<none>');
except;end;
end;
//## addall ##
procedure tmimes.addall(em:string);
var
   p,_pos,_start,_length:integer;
   _e,_m,tmp:string;
begin
try
//prepare
_pos:=1;
//process
while general.readline(_pos,_start,_length,em) do
begin
//.get
tmp:=copy(em,_start,_length);
general.rdfsb(tmp,_e,_m,'=');
//.set
add(_e,_m);
end;//end of loop
except;end;
end;
//## em ##
function tmimes.em(e:string):string;//extension to mime type
begin
try;result:=emb(e,'');except;end;
end;
//## emb ##
function tmimes.emb(e,def:string):string;//extension to mime type
var
   i:integer;
begin
try
//range
e:=general.udv(e,'<none>');
//get
if (general.sc(e)=1) then result:=e
else
   begin
   //find
   i:=ie.find(e);
   if (i>=0) then result:=ie.valuei[i]
   else result:=ie.value['<notfound>'];
   end;//end of if
//check
if (result='') then
   begin
   result:=def;
   //fail safe reply
   if (result='') then result:='text/html';
   end;//end of if
except;end;
end;
//## me ##
function tmimes.me(m:string):string;//mime type to extension
begin
try;result:=im.value[m];except;end;
end;
//## getdefaults ##
function tmimes.getdefaults:string;
begin
try
result:=
'<none>=text/plain'+#13#10+//21OCT2007 - used when no extension present
'<notfound>=application/octet-stream'+#13#10+//21OCT2007 - used when extension is not found
'gz=application/x-gzip'+#13#10+
'Z=application/x-compress'+#13#10+
'tgz=application/x-compressed'+#13#10+
'pac=application/x-ns-proxy-autoconfig'+#13#10+
'js=application/x-javascript'+#13#10+
'mocha=application/x-javascript'+#13#10+
'pl=application/x-perl'+#13#10+
'tcl=application/x-tcl'+#13#10+
'sh=application/x-sh'+#13#10+
'csh=application/x-csh'+#13#10+
'ai=application/postscript'+#13#10+
'eps=application/postscript'+#13#10+
'ps=application/postscript'+#13#10+
'exe=application/octet-stream'+#13#10+
'bin=application/octet-stream'+#13#10+
'cpf=application/octet-stream'+#13#10+//compress packet file
'cpio=application/x-cpio'+#13#10+
'gtar=application/x-gtar'+#13#10+
'tar=application/x-tar'+#13#10+
'shar=application/x-shar'+#13#10+
'zip=application/x-zip-compressed'+#13#10+
'sit=application/x-stuffit'+#13#10+
'hqx=application/mac-binhex40'+#13#10+
'avi=video/x-msvideo'+#13#10+
'qt=video/quicktime'+#13#10+
'mov=video/quicktime'+#13#10+
'movv=video/quicktime'+#13#10+
'mpv2=video/x-mpeg2'+#13#10+
'mp2v=video/x-mpeg2'+#13#10+
'mpeg=video/mpeg'+#13#10+
'mpg=video/mpeg'+#13#10+
'mpe=video/mpeg'+#13#10+
'mpv=video/mpeg'+#13#10+
'vbs=video/mpeg'+#13#10+
'mpegv=video/mpeg'+#13#10+
'm1v=video/mpeg'+#13#10+
'ra=audio/x-pn-realaudio'+#13#10+
'ram=audio/x-pn-realaudio'+#13#10+
'mp2=audio/x-mpeg'+#13#10+
'mpa=audio/x-mpeg'+#13#10+
'abs=audio/x-mpeg'+#13#10+
'mpega=audio/x-mpeg'+#13#10+
'wav=audio/x-wav'+#13#10+
'aif=audio/x-aiff'+#13#10+
'aiff=audio/x-aiff'+#13#10+
'aifc=audio/x-aiff'+#13#10+
'au=audio/basic'+#13#10+
'snd=audio/basic'+#13#10+
'fif=application/fractals'+#13#10+
'ief=image/ief'+#13#10+
'png=image/x-png'+#13#10+
'pcd=image/x-photo-cd'+#13#10+
'bmp=image/x-MS-bmp'+#13#10+
'ico=image/x-MS-ico'+#13#10+
'rgb=image/x-rgb'+#13#10+
'ppm=image/x-portable-pixmap'+#13#10+
'pgm=image/x-portable-graymap'+#13#10+
'pbm=image/x-portable-bitmap'+#13#10+
'pnm=image/x-portable-anymap'+#13#10+
'xwd=image/x-xwindowdump'+#13#10+
'xpm=image/x-xpixmap'+#13#10+
'xbm=image/x-xbitmap'+#13#10+
'rasimage/x-cmu-raster'+#13#10+
'tiff=image/tiff'+#13#10+
'tif=image/tiff'+#13#10+
'jpeg=image/jpeg'+#13#10+
'jpg=image/jpeg'+#13#10+
'jpe=image/jpeg'+#13#10+
'jif=image/jpeg'+#13#10+
'jfif=image/jpeg'+#13#10+
'pjpeg=image/jpeg'+#13#10+
'pjp=image/jpeg'+#13#10+
'gif=image/gif'+#13#10+
'texi=application/x-texinfo'+#13#10+
'texinfo=application/x-texinfo'+#13#10+
'dvi=application/x-dvi'+#13#10+
'latex=application/x-latex'+#13#10+
'tex=application/x-tex'+#13#10+
'pdf=application/pdf'+#13#10+
'rtf=application/rtf'+#13#10+
'htm=text/html'+#13#10+
'html=text/html'+#13#10+
'help=text/html'+#13#10+//assumed by "SSR" as of 07-JAN-2007
'txt=text/plain'+#13#10+
'text=text/plain'+#13#10+
'mid=audio/x-midi'+#13#10+
'm3u=audio/x-mpegurl';
except;end;
end;
//## clear ##
procedure tmimes.clear;
begin//'=text/html'+#10+//nil -> "http://www.xyz.net/"
try
flush;
addall(getdefaults);
except;end;
end;
//## flush ##
procedure tmimes.flush;
begin
try
ie.clear;
im.clear;
except;end;
end;

//#################### TWebHeaders #############################################
//## create ##
constructor twebheaders.create;
begin
inherited;
end;
//## destroy ##
destructor TWebHeaders.destroy;
begin
try
//self
inherited;
except;end;
end;
//## hostnameb ##
function twebheaders.hostnameb(x:string;var h:string):boolean;
var//Trims to "/" or ":" extracting bare "host" name
   //42% faster, was 265ms/20K hosts @200mhz, now 165ms (test url: www.blaizadfafdasdf.aefasdf.asdfasd.net:172/abc/indexs/doc.html)
   p:integer;
begin
try
//defaults
result:=false;
//process
//.scan
for p:=1 to length(x) do if (x[p]='/') or (x[p]=':') then
   begin
   h:=copy(x,1,p-1);
   result:=true;
   exit;
   end;//end of if
//.else
h:=x;
except;end;
end;
//## hostname ##
function twebheaders.hostname(x:string):string;
begin
try;hostnameb(x,result);except;end;
end;
//## hostb ##
function twebheaders.hostb(x:string;var h,etc:string):boolean;
var//Trims to "/" extracting "host"
   p:integer;
begin
try
//defaults
result:=false;
h:=x;
etc:='';
//process
for p:=1 to length(x) do if (x[p]='/') or (x[p]=':') then
   begin
   h:=copy(x,1,p-1);
   etc:=copy(x,p,length(x));
   result:=true;
   break;
   end;//end of if
except;end;
end;
//## host ##
function twebheaders.host(x:string):string;
var
   etc:string;
begin
try;hostb(x,result,etc);except;end;
end;
//## alwslash ##
function twebheaders.alwslash(x:string):string;
begin
try
if (copy(x,length(x),1)<>'/') then x:=x+'/';
result:=x;
except;end;
end;
//## removehash ##
function twebheaders.removehash(x:string):string;
var
   p:integer;
begin
try
for p:=length(x) downto 1 do if (x[p]='#') then
    begin
    x:=copy(x,1,p-1);
    break;
    end;//end of if
result:=x;
except;end;
end;
//## sn ##
function TWebHeaders.sn(x:string):string;{system name}
begin
try
{default}
result:=x;
{insert "wbnSystem" if not present}
if (copy(result,1,length(wbnSystem))<>wbnSystem) then result:=wbnSystem+result;
except;end;
end;
//## clear ##
procedure TWebHeaders.clear(var x:TWebHeader;y:TWebHeaderClear);
begin
try;del(x,-1,-1,y);except;end;
end;
//## del ##
procedure TWebHeaders.del(var x:TWebHeader;s,f:integer;y:TWebHeaderClear);
var
   sLen,p:integer;
begin
try
{prepare}
sLen:=length(wbnSystem);
if (s<0) or (f<0) then
   begin
   s:=0;
   f:=wbhcMax;
   //tmp - only cleared if (s or f <0)
   if not (wbcsExcludeTEMP in y) then
      begin
      x.tmpN:='';
      x.tmpL:=0;
      x.tmp:='';
      end;//end of if
   end;//end of if
{process}
for p:=s to f do if not((wbcsExcludeSYSTEM in y) and (copy(x.n[p],1,sLen)=wbnSystem)) then
    begin
    x.nRef[p]:=0;
    x.n[p]:='';
    x.v[p]:='';
    end;//end of if
except;end;
end;
//## GetFind
function TWebHeaders.GetFind(var x:TWebHeader;n:string):integer;
var
   xnew:boolean;
begin
try
xnew:=false;
result:=new(x,n,xnew);
except;end;
end;
//## new ##
function TWebHeaders.new(var x:TWebHeader;n:string;var xnew:boolean):integer;
var
   ep,p,nRef:integer;
begin
try
{error}
result:=-1;
{check}
if (n='') then exit;
{prepare}
n:=lowercase(n);
nRef:=general.ref32(n);
ep:=-1;
{process}
//get
for p:=0 to wbhcMax do if (x.nRef[p]=nRef) and (x.n[p]=n) then
    begin
    {successful}
    result:=p;
    xnew:=false;
    break;
    end
    else if (ep=-1) and (x.nRef[p]=0) then ep:=p;
//add
if xnew and (ep<>-1) then
   begin
   p:=ep;
   x.nRef[p]:=general.Ref32(n);
   x.n[p]:=n;
   x.v[p]:='';
   result:=p;
   end;//end of if
except;end;
end;
//## PushValue ##
procedure TWebHeaders.PushValue(var x:TWebHeader;n:string;var v:string;vmax:integer);
var
   xnew:boolean;
   p:integer;
begin
try
{prepare}
n:=lowercase(n);
{process}
//flush
if (x.tmpN<>'') and (x.tmpN<>n) then flushtmp(x,true);
//set
x.tmpN:=n;
x.tmpL:=vmax;
x.tmp:=x.tmp+v;
//fill
if (length(x.tmp)>=49152) or (v='') then flushtmp(x,false);
except;end;
end;
//## flushtmp ##
procedure TWebHeaders.flushtmp(var x:TWebHeader;clr:boolean);
var
   p:integer;
   xnew:boolean;
begin
try
{check}
if (x.tmpN='') then exit;
{process}
//get
xnew:=true;
p:=new(x,x.tmpN,xnew);
if (p=-1) then exit;
//set
x.v[p]:=copy(x.v[p]+x.tmp,1,x.tmpL);
//clear
if clr or (length(x.v[p])>=x.tmpL) then
   begin
   x.tmp:='';
   x.tmpN:='';
   x.tmpL:=0;
   end;//end of if
except;end;
end;
//## SetValue ##
procedure TWebHeaders.SetValue(var x:TWebHeader;n,v:string);
var
   xnew:boolean;
   p:integer;
begin
try
{prepare}
n:=lowercase(n);
{process}
case (v='') of
false:begin
    //get
    xnew:=true;
    p:=new(x,n,xnew);
    if (p=-1) then exit;
    //filter
    if (n='content-length') then v:=IntToStr(frcmin(strint(v),0));
    //set
    x.v[p]:=v;
    end;//end of begin
true:begin
    //get
    p:=find[x,n];
    if (p=-1) then exit;
    //set
    del(x,p,p,[]);
    end;//end of begin
end;//end of case
except;end;
end;
//## GetValue ##
function TWebHeaders.GetValue(var x:TWebHeader;n:string):string;
var
   p:integer;
begin
try
{defaults}
result:='';
{process}
//search
p:=find[x,n];
if (p=-1) then exit;
//get
result:=x.v[p];
except;end;
end;
//## GetLen ##
function TWebHeaders.GetLen(var x:TWebHeader;n:string):integer;
var
   p:integer;
begin
try
{default}
result:=0;
{process}
//search
p:=find[x,n];
if (p=-1) then exit;
//set
result:=length(x.v[p]);
except;end;
end;
//## GetInt ##
function TWebHeaders.GetInt(var x:TWebHeader;n:string):integer;
var
   z:string;
begin
try
z:=Value[x,n];
case (z='') of
true:result:=0;
false:result:=StrToInt(z);
end;//end of case
except;end;
end;
//## SetInt ##
procedure TWebHeaders.SetInt(var x:TWebHeader;n:string;v:integer);
begin
try;Value[x,n]:=IntToStr(v);except;end;
end;
//## emfi ##
function TWebHeaders.emfi(var x:TWebHeader;y:string):boolean;{extract method and filename info}
Label
     SkipOne;
Var
   hp,mp,yLen,maxp,p:Integer;
   f,h,m,z:string;
begin{23-06-03: GET /datas/index.html HTTP/1.1 -> datas\index.html}
try
{error}
result:=false;
{prepare}
m:='';
h:='';
ylen:=length(y);
for p:=1 to yLen do if (y[p]=#10) or (y[p]=#13) then
    begin
    yLen:=p-1;
    y:=copy(y,1,ylen);
    break;
    end;//end ofif
//muv
value[x,wbnMUV]:=y;
//method
z:=uppercase(copy(y,1,10));
if (copy(z,1,4)='GET ') then m:='GET'
else if (copy(z,1,5)='POST ') then m:='POST'
else if (copy(z,1,5)='HEAD ') then m:='HEAD'
else m:='';
value[x,wbnMethod]:=m;
mp:=length(m)+2;
//http
for p:=ylen downto 1 do if (y[p]='/') then
    begin
    value[x,wbnHTTPv]:=copy(y,p+1,ylen);
    hp:=p-6;
    break;
    end;//end of if
//filename
f:=copy(y,mp,hp-mp+1);
maxp:=length(f);
//split filename "?"
for p:=1 to maxp do if (f[p]='?') then
    begin
    //set "content" - only if "GET"
    if (m='GET') then
       begin
       value[x,wbnContent]:=copy(f,p+1,maxp);
       int[x,wbnContentLength]:=len[x,wbnContent];
       end;//end of if
    //f
    f:=copy(f,1,p-1);
    //quit
    break;
    end;//end of if
dosunix_paths(f,false);
value[x,wbnFilename]:=f;
{successful}
result:=true;
except;end;
end;
//## env ##
function TWebHeaders.env(var x:string;var pos,ep:integer;var n,v:string):boolean;{extract name value}
label
     skipend,redo;
var
   dp,lastp,p,minp,maxp:integer;
   ok:boolean;
begin
try
{error}
result:=False;
{defaults}
ep:=-1;
n:='';
v:='';
ok:=False;
{search}
maxp:=length(x);
lastp:=pos;
redo:
case ok of
false:if (x[pos]=':') then
         begin
         n:=copy(x,lastp,pos-lastp);
         lastp:=pos+1;
         ok:=true;
         end;//end of if
true:if (x[pos]=#13) or (x[pos]=#10) or (pos=maxp) then
         begin
         if (x[pos]=#13) or (x[pos]=#10) then dp:=0 else dp:=1;
         v:=copy(x,lastp,pos-lastp+dp);
         pos:=pos+1;
         ep:=pos;
         {successful}
         result:=true;
         goto skipend;
         end;//end of if
end;//end of case
{loop}
pos:=pos+1;
if (pos<=maxp) then Goto ReDo;
skipend:
{finish - move to last rcode}
minp:=pos;
For p:=minp to maxp do if (x[p]<>#13) and (x[p]<>#10) then
   begin
   pos:=p;
   break;
   end;//end of if
except;end;
end;
//## echv ##
function TWebHeaders.echv(var _data,_muv,_getcontent,_httpv,_method,_filename:string):boolean;//extract critical header values
Label
     SkipOne;
Var
   hp,mp,tmpLEN,maxp,p:Integer;
   tmp,f,h,m,z:string;
begin{23-06-03: GET /datas/index.html HTTP/1.1 -> datas\index.html}
try
//defaults
result:=false;
_getcontent:='';
_method:='';
_httpv:='';
_filename:='';
_muv:='';
//prepare
m:='';
h:='';
tmp:=copy(_data,1,1024);
tmpLEN:=length(tmp);
//process
//.muv
for p:=1 to tmpLEN do if (tmp[p]=#10) or (tmp[p]=#13) then
    begin
    tmpLEN:=p-1;
    tmp:=copy(tmp,1,tmpLEN);
    break;
    end;//end ofif
_muv:=tmp;
//method
z:=uppercase(copy(tmp,1,10));
if (copy(z,1,4)='GET ') then m:='GET'
else if (copy(z,1,5)='POST ') then m:='POST'
else if (copy(z,1,5)='HEAD ') then m:='HEAD'
else if (copy(z,1,8)='CONNECT ') then m:='CONNECT'
else m:='';
_method:=m;
mp:=length(m)+2;
//http
for p:=tmpLEN downto 1 do if (tmp[p]='/') then
    begin
    _httpV:=copy(tmp,p+1,tmplen);
    hp:=p-6;
    break;
    end;//end of if
//filename
f:=copy(tmp,mp,hp-mp+1);
maxp:=length(f);
//split filename "?"
for p:=1 to maxp do if (f[p]='?') then
    begin
    //set "content" - only if "GET"
    if (m='GET') then _getcontent:=copy(f,p+1,maxp);
    //f
    f:=copy(f,1,p-1);
    //quit
    break;
    end;//end of if
dosunix_paths(f,false);
//.set
_filename:=f;
{successful}
result:=true;
except;end;
end;
//## rwh ##
function TWebHeaders.rwh(var x:TWebHeader;var y:string):boolean;{read web header}
var
   eohp,hlen:integer;
begin
try
{error}
result:=false;
{prepare}
clear(x,[wbcsExcludeTEMP,wbcsExcludeSYSTEM]);
{process}
//get
if not ehb(y,eohp,hlen) then exit;
//set
// .header
text[x]:=copy(y,1,hLen);
// .content
rc(x,copy(y,eohp,length(y)));
{successful}
result:=true;
except;end;
end;
//## crc ##
function TWebHeaders.crc(var x:TWebHeader):boolean;{can read content - i.e. content not at "content-length" size}
var
   z:integer;
begin
try
{prepare}
z:=int[x,wbnContentLength];
{process}
result:=(z>=1) and (len[x,wbnContent]<z);
except;end;
end;
//## rc ##
function TWebHeaders.rc(var x:TWebHeader;y:string):boolean;{read content}
begin{note: result=TRUE if more content is required, FALSE if content is full}
try
{check}
result:=crc(x);
//ignore - content is full
if not result then exit;
{process}
PushValue(x,wbnContent,y,int[x,wbnContentLength]);
{return further result}
result:=crc(x);
//finalise
if (not result) or (length(x.tmp)>=x.tmpL) then flushtmp(x,true);
except;end;
end;
//## ehb ##
function TWebHeaders.ehb(var x:string;var eohp,hlen:integer):boolean;{extract header boundaries}
label
     redo;
var
   e2len,elen,op,p,maxp:integer;
   e2,e:string;
begin
try
{error}
result:=false;
{defaults}
eohp:=0;//end of header position
hlen:=0;//header length
{prepare}
maxp:=length(x);
e:=#10+#10;{last line + 1 blank line}
e2:=(#13+#10)+(#13+#10);{last line + 1 blank line}
e2len:=length(e2);
elen:=length(e);
{process}
//get - extract header (look for lastline + 2xblank lines
for p:=1 to maxp do if (copy(x,p,elen)=e) or (copy(x,p,e2len)=e2) or (p=maxp) then
    begin
    //successful
    result:=true;
    //decide
    if (copy(x,p,e2len)=e2) then op:=e2len
    else if (copy(x,p,elen)=e) then op:=elen
    else op:=1;
    //eohPOS
    hLen:=p;
    eohp:=hLen+op;
    //quit
    break;
    end;//end of if
except;end;
end;
//## SetText ##
procedure TWebHeaders.SetText(var x:TWebHeader;y:string);
var
   sl,ep,p:integer;
   s,n,v:string;
begin
try
{prepare}
p:=1;
ep:=length(y);
s:=sn('');//system name
sl:=length(s);
{process}
//emfi - "__method" & "__filename"
emfi(x,copy(y,1,frcmax(ep,4096)));
//other name-value pairs
while TRUE do if webheaders.env(y,p,ep,n,v) then
   begin
   {get}
   //n - ignore system names "__xyz"
   n:=lowercase(n);
   if (copy(n,1,sl)<>n) then
      begin
      //remove leading space}
      if (copy(v,1,1)=#32) then v:=copy(v,2,length(v));
      {set}
      value[x,n]:=v;
      end;//end of if
   end else break;//end of while
except;end;
end;
//## GetText ##
function TWebHeaders.GetText(var x:TWebHeader):string;
var{excludes all fields: "content" or begining with "_"}
   len,sl,p:integer;
   s:string;
begin
try
{defaults}
result:='';
{prepare}
len:=0;
s:=sn('');//system name "__"
sl:=length(s);
{process}
for p:=0 to wbhcMax do if (x.nRef[p]<>0) and (x.n[p]<>wbnContent) and (copy(x.n[p],1,sl)<>s) then pushb(len,result,x.n[p]+': '+x.v[p]+RCode);
{finalise}
pushb(len,result,'');
except;end;
end;
//## GetOutput ##
function TWebHeaders.GetOutput(var x:TWebHeader):string;
begin
try;result:=Text[x]+RCode+RCode+value[x,wbnContent];except;end;
end;
//## GetCount ##
function TWebHeaders.GetCount(var x:TWebHeader):integer;
var
   p:integer;
begin
try
{defaults}
result:=0;
{process}
for p:=0 to wbhcMax do if (x.nRef[p]<>0) then result:=result+1;
except;end;
end;

//#################### ByteStream ##############################################
//## create ##
constructor TByteStream.create;
begin
inherited;
{clear}
clear;
end;
//## destroy ##
destructor TByteStream.destroy;
begin
try
{finalise}
finalise;
//self
inherited;
except;end;
end;
//## Clear ##
Procedure TByteStream.Clear;
begin
try
//iStream
iStream:=nil;
//iBuffer
iBuffer.Count:=0;
iBuffer.OffSet:=-1;{need to fill}
iBuffer.Modified:=False;
//iSize
iSize:=0;
//SeekMode
SeekMode:=bssmSeekForward;
except;end;
end;
//## SetStream ##
Procedure TByteStream.SetStream(X:TStream);
begin
try
{Process}
Case (X=nil) of
True:Clear;
False:begin
    {Finalise}
    If not Finalise then exit;
    {Hook}
    //iStream
    iStream:=X;
    //iSize
    iSize:=iStream.Size;
    //iBuffer
    iBuffer.Count:=0;
    iBuffer.OffSet:=-1;{Need to fill}
    iBuffer.Modified:=False;
    end;//end of begin
end;//end of case
except;end;
end;
//## Get ##
Function TByteStream.Get(X:Integer;Var Y:Byte):Boolean;
Label
     ReDo;
Var
   pX,bX:Integer;
begin
try
{Error}
Result:=False;
bX:=(X-iBuffer.OffSet);
{Process}
ReDo:
Case (bX>=0) and (bX<iBuffer.Count) of
True:begin
    Y:=iBuffer.Items[bX];
    {Successful}
    Result:=True;
    end;//end of begin
False:begin
    //SeekMode
    Case iSeekMode of
    bssmSeekForward:pX:=X;
    bssmSeekBackward:begin
                  pX:=X-bbccMax;
                  If (pX<0) then pX:=0;
                  end;//end of begin
    bssmSeekMiddle:begin
                  pX:=X-(bbccMax Div 2);
                  If (pX<0) then pX:=0;
                  end;//end of begin
    end;//end of case
    //Seek
    If (iStream.Position<>pX) then iStream.Position:=pX;
    //iBuffer - Null
    iBuffer.OffSet:=iStream.Position;
    iBuffer.Count:=0;
    //Read
    iBuffer.Modified:=False;
    iBuffer.Count:=iStream.Read(iBuffer.Items,bbccMaxSize);
    //Get
    bX:=(X-iBuffer.OffSet);
    If (bX<iBuffer.Count) then Goto ReDo;
    end;//end of begin
end;//end of case
except;end;
end;
//## PushStr ##
Function TByteStream.PushStr(Var X:Integer;Y:String):Boolean;
Var
   P,MinP,MaxP:Integer;
begin
try
{Error}
Result:=False;
MinP:=X;
MaxP:=MinP+Length(Y)-1;
For P:=MinP to MaxP Do
begin
If Not Put(P,Ord(Y[P-MinP+1])) then exit;
X:=P+1;
end;//end of loop
{Successful}
Result:=True;
except;end;
end;
//## Put ##
Function TByteStream.Put(X:Integer;Y:Byte):Boolean;
Label
     ReDo;
Var
   MinP,P,bX:Integer;
   Junk:Byte;
begin
try
{Error}
Result:=False;
{Process}
ReDo:
bX:=(X-iBuffer.OffSet);
Case (bX>=0) and (bX<bbccMaxSize) and (iBuffer.OffSet<>-1) of
True:begin
    iBuffer.Items[bX]:=Y;
    If (bX>=iBuffer.Count) then
       begin
       iBuffer.Count:=bX+1;
       If ((iBuffer.Count+iBuffer.OffSet)>iSize) then iSize:=iBuffer.Count+iBuffer.OffSet;
       end;//end of if
    iBuffer.Modified:=True;
    {Successful}
    Result:=True;
    end;//end of begin
False:begin
    //Write
    If iBuffer.Modified and (iBuffer.Count<>0) then
       begin
       //Seek
       iStream.Position:=iBuffer.OffSet;
       //Error
       If (iBuffer.Count<>iStream.Write(iBuffer.Items,iBuffer.Count)) then
          begin
          iBuffer.Count:=0;
          iBuffer.OffSet:=0;
          iBuffer.Modified:=False;
          exit;
          end;//end of if
       end;//end of if
    //Get
    Get(X,Junk);
    Goto ReDo;
    end;//end of begin
end;//end of case
except;end;
end;
//## Finalise ##
Function TByteStream.Finalise:Boolean;
begin
try
{Error}
Result:=False;
Case ((iStream=nil) or (iBuffer.Count=0)) or (Not iBuffer.Modified) of
True:Result:=True;
False:begin
     //Write Buffer
     iStream.Position:=iBuffer.OffSet;
     Result:=(iStream.Write(iBuffer.Items,iBuffer.Count)=iBuffer.Count);
     end;//end of begin
end;//end of case
except;end;
end;
//## ReadLine ##
Function TByteStream.ReadLine(Var sS:Integer;sF:Integer;Var S,F:Integer;FindByte:Byte;Var FindP:Integer):Boolean;
Label
     SkipOne;
Var
   Val:Byte;
   MinP,MaxP,P2,P:Integer;
begin
try
{Error}
Result:=False;
FindP:=-1;{Not Found}
If (sS<0) then sS:=0;MinP:=sS;
If (sF<0) then sF:=iSize-1;MaxP:=sF;
If (MinP>MaxP) then exit;
{Line Starter}
S:=MinP;
F:=S-1;
For P:=MinP to MaxP Do
begin
{Read Value}
If Not Get(P,Val) then Break;
{FindByte}
If (FindP=-1) and (Val=FindByte) then FindP:=P;
{Line Terminator}
If (Val=10) or (Val=13) or (P=MaxP) then
   begin
   Case (Val=10) or (Val=13) of
   True:F:=P-1;
   False:F:=P;
   end;//end of case
   {Successful}
   Result:=True;
   {Past End of Line}
   Case (P=MaxP) of
   True:sS:=MaxP+1;
   False:begin
        For P2:=P to MaxP Do
        begin
        sS:=P2;
        If Not Get(P2,Val) then Break;
        If (Val<>10) and (Val<>13) then break;
        end;//end of loop
        end;//end of begin
   end;//end of case
   {Exit Loop}
   break;
   end;//end of if
end;//end of loop
except;end;
end;
//## FindByte ##
Function TByteStream.FindByte(X:Byte;S,F:Integer):Integer;
Var
   P:Integer;
   Val:Byte;
begin
try
{Not Found}
Result:=-1;
{Search}
For P:=S to F Do
begin
Case Get(P,Val) of
False:break;
True:If (Val=X) then
        begin
        Result:=P;
        break;
        end;//end of if
end;//end of case
end;//end of loop
except;end;
end;
//## SwapByte ##
Function TByteStream.SwapByte(X,Y:Byte;S,F:Integer):Boolean;
Var
   P:Integer;
   Val:Byte;
begin
try
{Not Found}
Result:=False;
{Search}
For P:=S to F Do
begin
Case Get(P,Val) of
False:break;
True:If (Val=X) and Put(P,Y) then Result:=True;
end;//end of case
end;//end of loop
except;end;
end;
//## AsciiDecimalToBinary ##
Function TByteStream.AsciiDecimalToBinary(S,F,MaxV:Integer;Var X:TWordBuffer):Boolean;
Var
   Count,P:Integer;
   TmpVal:Integer;
   Val:Byte;
   A:TWordBuffer;
begin
try{ie 255<space>0<tab>139<letter>255<etc>170<..>123(ascii decimal) => 255|0|139|255|170|123(8bit binary)}
{Error}
Result:=False;
If (MaxV>High(Word)) or (MaxV=-1) then MaxV:=High(Word);
{Defaults}
TmpVal:=0;
Count:=-1;
{Prepare}
A.Count:=0;
For P:=S to F Do
begin
If Not Get(P,Val) then break;
A.Items[P-S]:=Val;
end;//end of loop
A.Count:=F-S+1;
{Process - Append to "X" buffer}
For P:=(A.Count-1) downTo 0 Do
begin
Val:=A.Items[P];
{Increment TmpVal}
If (Val>=48) and (Val<=57) then
   begin{Digit 0-9}
   If (Count<5) then
      begin
       If (Count<0) then Count:=0;
       Case Count of
       0:TmpVal:=TmpVal+(Val-48);
       1:TmpVal:=TmpVal+((Val-48)*10);
       2:TmpVal:=TmpVal+((Val-48)*100);
       3:TmpVal:=TmpVal+((Val-48)*1000);
       4:TmpVal:=TmpVal+((Val-48)*10000);
       end;//end of case
       {Count: 0=0, 1=10, 2=100, 3=1K, 4=10K, 5+=ignored}
       Count:=Count+1;
       end;//end of if
   end;//end of if
{Add TmpVal to Buffer and Clear}
If (Count<>-1) and ((Val<48) or (Val>57) or (P=0)) then
   begin
   If (X.Count<bbccMaxSize) then
      begin
      X.Count:=X.Count+1;
      {Enforce Max Range}
      If (TmpVal>MaxV) then TmpVal:=MaxV;
      X.Items[X.Count-1]:=TmpVal;
      {Successful}
      Result:=True;
      end;//end of if
   {Reset}
   Count:=-1;
   TmpVal:=0;
   end;//end of if
end;//end of loop
except;end;
end;
//## ByteToXHex ##
Function TByteStream.ByteToXHex(X:Byte;Var Y:TByteBuffer):Boolean;
Var
   A,B:Byte;
begin
try
{Error}
Result:=False;
{Byte -> AB}
A:=X div 16;
B:=X-A*16;
//0
Y.Items[Y.Count]:=48;Y.Count:=Y.Count+1;
//x
Y.Items[Y.Count]:=120;Y.Count:=Y.Count+1;
//A
Case A of
0..9:Y.Items[Y.Count]:=A+48;
10..15:Y.Items[Y.Count]:=A+87;
end;//end of case
Y.Count:=Y.Count+1;
//B
Case B of
0..9:Y.Items[Y.Count]:=B+48;
10..15:Y.Items[Y.Count]:=B+87;
end;//end of case
Y.Count:=Y.Count+1;
{Successful}
Result:=True;
except;end;
end;
//## XHexToBinary ##
Function TByteStream.XHexToBinary(S,F,MaxV:Integer;Var X:TByteBuffer):Boolean;
Label
     SkipOne;
Var
   MinP,P:Integer;
   A,B,Val:Byte;
begin
try{ie ?x00-?xFF -> 0,255}
{Error}
Result:=False;
If (MaxV>High(Byte)) or (MaxV=-1) then MaxV:=High(Byte);
{Process - Append to "X" buffer}
MinP:=-1;
For P:=S to F Do
begin
If Not Get(P,Val) then break;
If (P<=MinP) then Goto SkipOne;
{Increment TmpVal}
If ((Val=88) or (Val=120)) and (X.Count<bbccMaxSize) then
   begin
   MinP:=P+2;
   {?xFF => ?|VAL|AB}
   If Not Get(P+1,A) then break;
   If Not Get(P+2,B) then break;
   {Convert base16 Hex to 8bit binary byte}
   //A
   Case A of
   48..57:A:=A-48;{0-9}
   97..102:A:=A-87;{10-15}
   65..70:A:=A-55;{10-15}
   else
   A:=0;
   end;//end of case
   //B
   Case B of
   48..57:B:=B-48;{0-9}
   97..102:B:=B-87;{10-15}
   65..70:B:=B-55;{10-15}
   else
   B:=0;
   end;//end of case
   X.Items[X.Count]:=B+A*16;
   X.Count:=X.Count+1;
   {Successful}
   Result:=True;
   end;//end of if
SkipOne:
end;//end of loop
except;end;
end;
//## ReadWordValue ##
Function TByteStream.ReadWordValue(Var X:TWordBuffer;Var Y:Integer):Boolean;
Var
   MaxP,P:Integer;
begin
try
{Error}
Result:=False;
If (X.Count=0) then exit;
{Read Next Value}
Y:=X.Items[X.Count-1];
{Delete Last Value}
X.Count:=X.Count-1;
{Successful}
Result:=True;
except;end;
end;
//## SetSeekMode ##
Procedure TByteStream.SetSeekMode(X:Integer);
begin
try;iSeekMode:=FrcRange(X,0,bssmSeekMax);except;end;
end;
//## Str ##
Function TByteStream.Str(S,F:Integer):String;
Var
   Count,P:Integer;
   Val:Byte;
   X:String;
begin
try
{Empty}
Result:='';
X:='';
Count:=0;
{Extract}
For P:=S to F Do
begin
Case Get(P,Val) of
False:break;
True:begin
    Count:=Count+1;
    X:=X+Chr(Val);
    If (Count>=512) then
       begin
       Result:=Result+X;
       X:='';
       end;//end of if
    end;//end of begin
end;//end of case
end;//end of loop
{Return Result}
Result:=Result+X;
except;end;
end;

//#################### ByteImage ###############################################
//## create ##
constructor TByteImage.create;
begin
inherited;
{iImage}
Image:=nil;
end;
//## GetRow ##
Function TByteImage.GetRow(Y:Integer):PRGBColorRow;
begin
try
ReadRow(Y);
Result:=iRow;
except;end;
end;
//## ExpandBits ##
Procedure TByteImage.ExpandBits(X:Byte;Var Y:TByteBuffer);
Var
   A:Byte;
begin
try
//128
A:=0;
If (X>=128) then
   begin
   A:=1;
   X:=X-128;
   end;
Y.Count:=Y.Count+1;
Y.Items[Y.Count-1]:=A;
//64
A:=0;
If (X>=64) then
   begin
   A:=1;
   X:=X-64;
   end;
Y.Count:=Y.Count+1;
Y.Items[Y.Count-1]:=A;
//32
A:=0;
If (X>=32) then
   begin
   A:=1;
   X:=X-32;
   end;
Y.Count:=Y.Count+1;
Y.Items[Y.Count-1]:=A;
//16
A:=0;
If (X>=16) then
   begin
   A:=1;
   X:=X-16;
   end;
Y.Count:=Y.Count+1;
Y.Items[Y.Count-1]:=A;
//8
A:=0;
If (X>=8) then
   begin
   A:=1;
   X:=X-8;
   end;
Y.Count:=Y.Count+1;
Y.Items[Y.Count-1]:=A;
//4
A:=0;
If (X>=4) then
   begin
   A:=1;
   X:=X-4;
   end;
Y.Count:=Y.Count+1;
Y.Items[Y.Count-1]:=A;
//2
A:=0;
If (X>=2) then
   begin
   A:=1;
   X:=X-2;
   end;
Y.Count:=Y.Count+1;
Y.Items[Y.Count-1]:=A;
//1
A:=0;
If (X>=1) then
   begin
   A:=1;
   X:=X-1;
   end;
Y.Count:=Y.Count+1;
Y.Items[Y.Count-1]:=A;
except;end;
end;
//## SetImage ##
Procedure TByteImage.SetImage(X:TBitmap);
begin
try
If (X=iImage) then exit;
{Set Image}
iImage:=X;
Case (iImage=nil) of
True:begin
    iWidth:=0;
    iHeight:=0;
    end;//end of begin
False:begin
    iWidth:=iImage.Width;
    iHeight:=iImage.Height;
    end;//end of begin
end;//end of case
{ZeroDimensions}
iZeroWidth:=iWidth-1;If (iZeroWidth<0) then iZeroWidth:=0;
iZeroHeight:=iHeight-1;If (iZeroHeight<0) then iZeroHeight:=0;
{MoveTo - twice, 2nd time resets ipX & ipY}
MoveTo(0,0);
MoveTo(0,0);
{Reset Row}
iRowY:=-1;
except;end;
end;
//## MoveTo ##
Function TByteImage.MoveTo(X,Y:Integer):Boolean;
begin
try
iX:=FrcRange(X,-1,iZeroWidth);
iY:=FrcRange(Y,0,iZeroHeight);
except;end;
end;
//## PushPixel ##
Function TByteImage.PushPixel(Var X:TRGBColor):Boolean;
begin
try
{Out of Range}
Result:=False;
If (iX<0) or (iX>iZeroWidth) or (iY<0) or (iY>iZeroHeight) then exit;
{Process}
Pixels[iX,iY]:=X;
{Increment to Next Position}
iX:=iX+1;
If (iX>iZeroWidth) then
   begin
   iX:=0;
   iY:=iY+1;
   end;//end of if
{Successful}
Result:=True;
except;end;
end;
//## PullPixel ##
Function TByteImage.PullPixel(Var X:TRGBColor):Boolean;
begin
try
{Out of Range}
Result:=False;
If (iX>iZeroWidth) or (iY>iZeroHeight) then exit;
If (iX<0) then iX:=0;
If (iY<0) then iY:=0;
{Process}
X:=Pixels[iX,iY];
{Increment to Next Position}
iX:=iX+1;
If (iX>iZeroWidth) then
   begin
   iX:=0;
   iY:=iY+1;
   end;//end of if
{Successful}
Result:=True;
except;end;
end;
//## ReadRow ##
Function TByteImage.ReadRow(Y:Integer):Boolean;
begin
try
{Error}
Result:=False;
If (iImage=nil) then exit;
{Ok}
If (iRowY=Y) then
   begin
   Result:=True;
   exit;
   end;//end of if
{Read Row}
iRow:=iImage.ScanLine[Y];
iRowY:=Y;
{Successful}
Result:=True;
except;end;
end;
//## GetPixels ##
Function TByteImage.GetPixels(X,Y:Integer):TRGBColor;
begin
try
{Enforce Range}
If (X<0) or (X>iZeroWidth) or (Y<0) or (Y>iZeroHeight) then exit;
{Read Row}
If (Y<>iRowY) then ReadRow(Y);
{Read Pixel}
Result:=iRow[X];
except;end;
end;
//## SetPixels ##
Procedure TByteImage.SetPixels(X,Y:Integer;Z:TRGBColor);
begin
try
{Enforce Range}
If (X<0) or (X>iZeroWidth) or (Y<0) or (Y>iZeroHeight) then exit;
{Read Row}
If (Y<>iRowY) then ReadRow(Y);
{Write Pixel}
iRow[X]:=Z;
except;end;
end;

//###################### TColorIcon ############################################
//## create ##
constructor TColorIcon.create;
begin
inherited;
//vars
ilockcount:=0;
isize:=32;
itransparent:=false;
itransparentxy:=point(0,0);
iimage:=ccs.newbmp(32,32);
//defaults
image:=nil;
end;
//## destroy ##
destructor TColorIcon.destroy;
begin
try
freeObj(@iimage);
//self
inherited;
except;end;
end;
//## setsize ##
procedure tcoloricon.setsize(x:integer);
begin
try
//enforce range
x:=frcrange(x,ihMinSize,ihMaxSize);
case x of
0..16:x:=16;
17..32:x:=32;
33..48:x:=48;
49..64:x:=64;
65..72:x:=72;
73..96:x:=96;
else
   x:=96;
end;//end of case
//check
if (x=size) then exit;
//set
isize:=x;
//image
image:=image;
except;end;
end;
//## setimage ##
procedure tcoloricon.setimage(x:tbitmap);
begin
try
//size
ccs.size(iimage,size,size);
//set
if (x=nil) then ccs.cls(iimage,clWhite,'')
else ccs.draw(0,0,iimage,x,clnone);
//_update
_update;
except;end;
end;
//## readimage ##
procedure tcoloricon.readimage(x:tbitmap);
var
   s:integer;
begin
try
//check
if (x=nil) or (x.width<1) or (x.height<1) then exit;
//process
//.size
s:=16;
if (x.width>s) then s:=x.width;
if (x.height>s) then s:=x.height;
size:=s;
//.draw
iimage.canvas.stretchdraw(rect(0,0,iimage.width,iimage.height),x);
//_update
_update;
except;end;
end;
//## _update ##
procedure tcoloricon._update;
begin
try
//check
if general.locked(ilockcount) then exit;
//info
icolors:=-1;//slow, update when needed
ibpp:=ccs.bpp(iimage,0);
itransparentxy.x:=frcrange(itransparentxy.x,0,iimage.width);
itransparentxy.y:=frcrange(itransparentxy.y,0,iimage.height);
itransparentcolor:=ccs.transparentcolor(iimage,itransparentxy.x,itransparentxy.y,transparent);
//onchange
fireevent(fonchange,self);
except;end;
end;
//## getcolors ##
function tcoloricon.getcolors:integer;
begin
try
if (icolors=-1) then icolors:=ccs.countcolors(iimage);
result:=icolors;
except;end;
end;
//## settransparent ##
procedure tcoloricon.settransparent(x:boolean);
begin
try
if (x<>transparent) then
   begin
   itransparent:=x;
   _update;
   end;//end of if
except;end;
end;
//## settransparent ##
procedure tcoloricon.settransparentxy(x:tpoint);
begin
try
if (x.x<>transparentxy.x) or (x.y<>transparentxy.y) then
   begin
   itransparentxy:=x;
   _update;
   end;//end of if
except;end;
end;
//## draw ##
procedure tcoloricon.draw(acanvas:tcanvas;const srect:trect);
var
   a:tbitmap;
begin
try
a:=nil;
if transparent then
   begin
   a:=ccs.newbmp(width,height);
   ccs.copybmp(a,iimage);
   a.transparentcolor:=transparentcolor;
   a.transparent:=true;
   acanvas.draw(srect.left,srect.top,a);
   end
   else acanvas.draw(srect.left,srect.top,iimage);
except;end;
try;a.free;except;end;
end;
//## paintto ##
procedure tcoloricon.paintto(darea:trect;i:tbitmap);
begin
try;ccs.stretchdraw(darea,i,iimage,transparentcolor);except;end;
end;
//## getempty ##
function tcoloricon.getempty:boolean;
begin
try;result:=iimage.empty;except;end;
end;
//## getheight ##
function tcoloricon.getheight:integer;
begin
try;Result:=iimage.height;except;end;
end;
//## getwidth ##
function tcoloricon.getwidth:integer;
begin
try;result:=iimage.width;except;end;
end;
//## setwidth ##
procedure tcoloricon.setwidth(x:integer);
begin
try;size:=x;except;end;
end;
//## setheight ##
procedure tcoloricon.setheight(x:integer);
begin
try;size:=x;except;end;
end;
//## LoadFromClipboardFormat ##
procedure TColorIcon.LoadFromClipboardFormat(AFormat:Word;AData:THandle;APalette:HPALETTE);
var
   a:tbitmap;
begin
a:=nil;
a:=ccs.newbmp(1,1);
a.loadfromclipboardformat(aformat,adata,apalette);
image:=a;
freeObj(@a);
end;
//## SaveToClipboardFormat ##
procedure TColorIcon.SaveToClipboardFormat(var Format: Word; var Data: THandle; var APalette: HPALETTE);
begin
iimage.savetoclipboardformat(format,data,apalette);
end;
//## progress ##
procedure TColorIcon.progress(Sender: TObject;Stage:TProgressStage;PercentDone:Byte;RedrawNow:Boolean;const R:TRect;const Msg:string);
begin
try;if assigned(fonprogress) then fonprogress(sender,stage,percentdone,redrawnow,r,msg);except;end;
end;
//## Progressing ##
procedure TColorIcon.Progressing(PercentDone:Byte;const Msg:string);
begin
try;if general.pause then progress(self,psRunning,percentdone,false,rect(0,0,width,height),msg);except;end;
end;
//## assign ##
procedure tcoloricon.assign(source:tpersistent);
var
   a:tcoloricon;
begin
try
general.lock(ilockcount);
if (source is tcoloricon) then
   begin
   a:=source as tcoloricon;
   transparent:=a.transparent;
   transparentxy:=a.transparentxy;
   image:=a.image;
   end
else if (source is tgraphic) then
   begin
   ccs.cls(iimage,clwhite,'');
   iimage.canvas.draw(0,0,source as tgraphic);
   end;//end of if
//unlock
except;end;
try
general.unlock(ilockcount);
image:=image;
except;end;
end;
//## FreeImage ##
Procedure TColorIcon.FreeImage;
begin
try;iImage.FreeImage;except;end;
end;
//## Dormant ##
Procedure TColorIcon.Dormant;
begin
try;iImage.Dormant;except;end;
end;
//## WidthBytes ##
Function TColorIcon.WidthBytes(rBPP,W:Integer):Integer;
Var
   X:Integer;
begin
try
{Error}
Result:=-1;
{Process}
Case rBPP of
1:begin
  X:=(W Div 8);
  If (X<>(X Div 4)*4) then X:=((X Div 4)*4)+4;
  end;//end of begin
4:begin
  X:=(W Div 2);
  If (X<>(X Div 4)*4) then X:=((X Div 4)*4)+4;
  end;//end of begin
8:begin
  X:=W;
  If (X<>(X Div 4)*4) then X:=((X Div 4)*4)+4;
  end;//end of begin
24:begin
  X:=W*3;
  If (X<>(X Div 4)*4) then X:=((X Div 4)*4)+4;
  end;//end of begin
end;//end of case
{Successful}
Result:=X;
except;end;
end;
//## FillImageInfo ##
Function TColorIcon.FillImageInfo(Var X:TImageInfo):Boolean;
begin
try
{Error}
Result:=False;
{Process}
X.WIDTHbytes:=WidthBytes(X.BPP,X.WIDTH);
X.BMPbytes:=X.WIDTHbytes*X.HEIGHT;
X.MONObytes:=WidthBytes(1,X.WIDTH)*X.HEIGHT;
Case X.BPP of
1:X.PALbytes:=2*4;
4:X.PALbytes:=16*4;
8:X.PALbytes:=256*4;
else
{24}
X.PALbytes:=0;
end;//end of case
{Icon Related}
X.DATAbytes:=X.PALbytes+X.BMPbytes+X.MONObytes+ihInfoDataSize;
X.IMAGESbytes:=X.BMPbytes+X.MONObytes;
{Other}
if (transparentcolor<>clnone) then x.transcolor:=ccs.intrgb(transparentcolor);
{Successful}
Result:=True;
except;end;
end;
//## WriteHeader ##
Function TColorIcon.WriteHeader(X:TStream;Var Y:TImageInfo;Var E:String):Boolean;
Var
   A:TIconHeader;
   S:TPoint;
   Z,L,P:Integer;
   s1,s2:Byte;
begin
try
{Error}
Result:=False;
E:=gecUnexpectedError;
If (X=nil) then exit;
E:=gecOutOfMemory;
//clear
for p:=0 to ihMax do a[p]:=0;
{Common Data}
A[2]:=1;
A[4]:=1;
A[6]:=Byte(Y.Width);
A[7]:=Byte(Y.Height);
A[18]:=Byte(ihInfoSize);{22}
A[22]:=Byte(ihInfoDataSize);{40}
A[26]:=Byte(Y.Width);{1xWidth}
A[30]:=Byte(2*Y.Height);{2xHeight}
A[34]:=1;
{Individual Data}
//Size {InfoData(40)+Palette+BMP+Mono}
L:=Y.DATAbytes;
s1:=L Div 256;
s2:=L-(s1*256);
A[14]:=s2;
A[15]:=s1;
//Colors
Case Y.BPP of
1:Z:=2;
4:Z:=16;
else
Z:=0;
end;//end of case
A[8]:=Byte(Z);
//BPP
A[36]:=Byte(Y.BPP);
//Size2 {BMP+Mono}
L:=Y.IMAGESbytes;
s1:=L Div 256;
s2:=L-(s1*256);
A[42]:=s2;
A[43]:=s1;
{Write to Stream}
If (X.Write(A,SizeOf(A))<>SizeOf(A)) then exit;
{Successful}
Result:=True;
except;end;
end;
//## WritePalette ##
Function TColorIcon.WritePalette(X:TStream;Var Y:TColorPalette;Var E:String):Boolean;
Label
     SkipEnd;
Var
   A:TByteStream;
   Pos,MaxP,P:Integer;
begin
try
{Error}
Result:=False;
A:=nil;
E:=gecUnexpectedError;
If (X=nil) then exit;
E:=gecOutOfMemory;
{A}
A:=TByteStream.Create;
A.Stream:=X;
Pos:=X.Position;
{Y => X}
MaxP:=Y.Count-1;
For P:=0 to MaxP Do
begin{B,G,R,0}
If Not A.Put(Pos,Y.Items[P].B) then Goto SkipEnd;
Pos:=Pos+1;
If Not A.Put(Pos,Y.Items[P].G) then Goto SkipEnd;
Pos:=Pos+1;
If Not A.Put(Pos,Y.Items[P].R) then Goto SkipEnd;
Pos:=Pos+1;
If Not A.Put(Pos,0) then Goto SkipEnd;
Pos:=Pos+1;
end;//end of loop
{Successful}
Result:=True;
SkipEnd:
except;end;
try;freeObj(@a);except;end;
end;
//## offset4 ##
function tcoloricon.offset4(x:integer):integer;
var
   y:integer;
begin
try;y:=(x div 4)*4;if (x=y) then result:=y else result:=y+4;except;end;
end;
//## RoundRow ##
Function TColorIcon.RoundRow(Var X:TByteStream;Var Pos:Integer;Y:Integer):Boolean;
Var
   P,MinP,MaxP:Integer;
begin
try
{Ok}
Result:=True;
{Round to nearest 4th byte}
MinP:=Y;
MaxP:=OffSet4(MinP);
If (MinP=MaxP) then exit;
{Error}
Result:=False;
{Pad}
For P:=(MinP+1) to MaxP Do
begin
If Not X.Put(Pos,0) then exit;
Pos:=Pos+1;
end;//end of loop
{Successful}
Result:=True;
except;end;
end;
//## WriteBMP ##
Function TColorIcon.WriteBMP(X:TStream;Var Y:TBitmap;Var Z:TColorPalette;Var Info:TImageInfo;Var E:String):Boolean;
Label
     SkipEnd;
Var
   A:TByteStream;
   Row:PRGBColorRow;
   MaxP,Pos,rX,rY,MaxX,MaxY,P,P2,I,D:Integer;
   C,TransC:TRGBColor;
begin
try
{Error}
Result:=False;
A:=nil;
{Stream}
E:=gecUnexpectedError;
If (X=nil) then exit;
{Image}
E:=gecUnexpectedError;
If (Y=nil) then exit;
{Continue}
E:=gecOutOfMemory;
{A}
A:=TByteStream.Create;
A.Stream:=X;
Pos:=X.Position;
//transparent info
If transparent then TransC:=Info.TransColor;
{Y => X}
MaxX:=Info.ZeroWidth;
MaxY:=Info.ZeroHeight;
{Process}
For rY:=MaxY downTo 0 Do
begin
Row:=Y.ScanLine[rY];
 Case Info.BPP of
 0:begin{1 bit/Mono Transparency}
    D:=0;
    P2:=-1;
    For rX:=0 to MaxX Do
    begin
    C:=Row[rX];
    P2:=P2+1;
    Case Transparent of
    False:I:=0;
    True:If ccs.RGBEqual(C,TransC) then I:=1 else I:=0;
    end;//end of if
    Case P2 of
    7:D:=D+I;
    6:D:=D+I*2;
    5:D:=D+I*4;
    4:D:=D+I*8;
    3:D:=D+I*16;
    2:D:=D+I*32;
    1:D:=D+I*64;
    0:D:=D+I*128;
    end;//end of case
    If (rX=MaxX) then P2:=7;
    If (P2>=7) then
       begin
       If Not A.Put(Pos,Byte(D)) then Goto SkipEnd;
       Pos:=Pos+1;
       P2:=-1;
       D:=0;
       end;//end of if
    end;//end of loop
    {RoundRow}
    If Not RoundRow(A,Pos,Info.Width Div 8) then Goto SkipEnd;
    end;//end of begin
 1:begin{1 bit}
    D:=0;
    P2:=-1;
    For rX:=0 to MaxX Do
    begin
    C:=Row[rX];
    P2:=P2+1;
    Case Transparent and ccs.RGBEqual(C,TransC) of
    False:I:=ccs.FindPaletteRGB(Z,C);
    True:I:=0;{Transparent Color always Palette pos 0}
    end;//end of if
    If (I=-1) then I:=0;
    Case P2 of
    7:D:=D+I;
    6:D:=D+I*2;
    5:D:=D+I*4;
    4:D:=D+I*8;
    3:D:=D+I*16;
    2:D:=D+I*32;
    1:D:=D+I*64;
    0:D:=D+I*128;
    end;//end of case
    If (P2>=7) or (rX=MaxX) then
       begin
       If Not A.Put(Pos,Byte(D)) then Goto SkipEnd;
       Pos:=Pos+1;
       P2:=-1;
       D:=0;
       end;//end of if
    end;//end of loop
    {RoundRow}
    If Not RoundRow(A,Pos,Info.Width Div 8) then Goto SkipEnd;
    end;//end of begin
 4:begin{4 bit}
    D:=0;
    P2:=-1;
    For rX:=0 to MaxX Do
    begin
    P2:=P2+1;
    C:=Row[rX];
    Case Transparent and ccs.RGBEqual(C,TransC) of
    False:I:=ccs.FindPaletteRGB(Z,C);
    True:I:=0;{Transparent Color always Palette pos 0}
    end;//end of if
    If (I=-1) then I:=0;
    Case P2 of
    1:D:=D+I;
    0:D:=D+I*16;
    end;//end of case
    If (P2>=1) or (rX=MaxX) then
       begin
       If Not A.Put(Pos,D) then Goto SkipEnd;
       Pos:=Pos+1;
       P2:=-1;
       D:=0;
       end;//end of if
    end;//end of loop
    {RoundRow}
    If Not RoundRow(A,Pos,Info.Width Div 2) then Goto SkipEnd;
    end;//end of begin
 8:begin{8 bit}
    For rX:=0 to MaxX Do
    begin
    C:=Row[rX];
    Case Transparent and ccs.RGBEqual(C,TransC) of
    False:I:=ccs.FindPaletteRGB(Z,C);
    True:I:=0;{Transparent Color always Palette pos 0}
    end;//end of if
    If (I=-1) then I:=0;
    If Not A.Put(Pos,I) then Goto SkipEnd;
    Pos:=Pos+1;
    end;//end of loop
    {RoundRow}
    If Not RoundRow(A,Pos,Info.Width) then Goto SkipEnd;
    end;//end of begin
 24:begin{24 bit}
    For rX:=0 to MaxX Do
    begin
    C:=Row[rX];
    If Transparent and ccs.RGBEqual(C,TransC) then C:=rgbBlack;
    If Not A.Put(Pos,C.B) then Goto SkipEnd;
    Pos:=Pos+1;
    If Not A.Put(Pos,C.G) then Goto SkipEnd;
    Pos:=Pos+1;
    If Not A.Put(Pos,C.R) then Goto SkipEnd;
    Pos:=Pos+1;
    end;//end of loop
    {RoundRow}
    If Not RoundRow(A,Pos,Info.Width*3) then Goto SkipEnd;
    end;//end of begin
 else
  E:=gecUnexpectedError;
  Goto SkipEnd;
 end;//end of case
end;//end of loop
{Successful}
Result:=True;
SkipEnd:
except;end;
try;freeObj(@a);except;end;
end;
//## _BuildPalette ##
Function TColorIcon._BuildPalette(Var X:TBitmap;Var Pal:TColorPalette;Var Info:TImageInfo;Var E:String):Boolean;
Label
     SkipEnd;
Var
   Row:PRGBColorRow;
   MaxCount,pI,rX,rY,MaxX,MaxY:Integer;
   Z:TRGBColor;
begin
try
Result:=False;
E:=gecOutOfMemory;
{Check Dimensions}
If (Info.Width<1) or (Info.Height<1) then
   begin
   E:=gecUnexpectedError;
   exit;
   end;//end of if
{MaxCount}
Case Info.BPP of
1:MaxCount:=2;
4:MaxCount:=16;
8:MaxCount:=256;
else
 E:=gecUnexpectedError;
 exit;
end;//end of case
{Clear Palette}
Pal.Count:=0;
{PaletteEntry 0 reserved for TransparentMode}
If Transparent then
   begin
   Pal.Items[0]:=rgbBlack;
   Pal.Count:=1;
   end;//end of if
{Create the Palette from Image}
MaxY:=X.Height-1;
MaxX:=X.Width-1;
For rY:=0 to MaxY Do
begin
Row:=X.Scanline[rY];
 For rX:=0 to MaxX Do
 begin
 Z:=Row[rX];
 Case (Transparent and ccs.RGBEqual(Z,Info.TransColor)) of
 True:pI:=0;
 False:pI:=ccs.AddRGBToPalette(Pal,Row[rX]);{max of 256 colors}
 end;//end of case
 If (pI=-1) or (Pal.Count>=MaxCount) then Goto SkipEnd;
 end;//end of loop
end;//end of loop
SkipEnd:
{Enlarge Palette to MaxColors Specification}
MaxX:=MaxCount-1;
For rX:=Pal.Count to MaxX Do Pal.Items[rX]:=rgbBlack;
Pal.Count:=MaxX+1;
{Successful}
Result:=True;
except;end;
end;
//## SaveToStream ##
Procedure TColorIcon.SaveToStream(X:TStream);
Label
     SkipEnd;
Var
   ErrMsg:String;
   PalIntArray:TIntPalette;
   PalArray:TRGBPalette;
   Pal:TColorPalette;
   ImageInfo:TImageInfo;
begin
try
ErrMsg:=gecOutOfMemory;
Progress(Self,psStarting,0,False,Rect(0,0,Width,Height),'Saving');
{Palette}
Pal.Items:=@PalArray;
Pal.IntItems:=@PalIntArray;
Pal.Count:=0;{empty}
{Write Header}
ImageInfo.BPP:=BPP;
ImageInfo.Width:=Width;
ImageInfo.Height:=Height;
ImageInfo.ZeroWidth:=ImageInfo.Width-1;
ImageInfo.ZeroHeight:=ImageInfo.Height-1;
If Not FillImageInfo(ImageInfo) then
   begin
   ErrMsg:=gecUnexpectedError;
   Goto SkipEnd;
   end;//end of if
{Write Header}
If Not WriteHeader(X,ImageInfo,ErrMsg) then Goto SkipEnd;
{Palette}
If (BPP>=1) and (BPP<=8) then
   begin
   {Build}
   If Not _BuildPalette(iImage,Pal,ImageInfo,ErrMsg) then Goto SkipEnd;
   {Write}
   If Not WritePalette(X,Pal,ErrMsg) then Goto SkipEnd;
   end;//end of if
{BMP}
If Not WriteBMP(X,iImage,Pal,ImageInfo,ErrMsg) then Goto SkipEnd;
{Mono}
ImageInfo.BPP:=0;
If Not WriteBMP(X,iImage,Pal,ImageInfo,ErrMsg) then Goto SkipEnd;
{No Error}
ErrMsg:='';
SkipEnd:
except;end;
try;Progress(Self,psEnding,100,False,Rect(0,0,Width,Height),'Saving');except;end;
general.raiseerror(errmsg);
end;
//## SaveToFile ##
Function TColorIcon.SaveToFile(X:String):Boolean;
Label
     SkipEnd;
Var
   iStream:TStream;
begin
try
{Error}
Result:=False;
iStream:=nil;
{Remove File}
iErrorMessage:=gecFileInUse;
If Not RemFile(X) then Goto SkipEnd;
{Create Stream}
iErrorMessage:=gecBadFileName;
iStream:=TFileStream.Create(X,fmCreate);
{SaveToStream}
SaveToStream(iStream);
{Successful}
Result:=True;
SkipEnd:
except;end;
try;freeObj(@istream);except;end;
end;

//#################### TTextPicture ############################################
//## create ##
constructor TTextPicture.create;
begin
inherited;
{iImage}
iImage:=nil;
iImage:=TBitmap.Create;
Style:=tpscPlain;
BPP:=tpsbDefault;{64 colors}
{Update}
Update;
end;
//## destroy ##
destructor TTextPicture.destroy;
begin
try
freeObj(@iimage);
//self
inherited;
except;end;
end;
//## SetBPP ##
Procedure TTextPicture.SetBPP(X:Byte);
begin
try;iBPP:=FrcRange(X,tpsbMinBPP,tpsbMaxBPP);except;end;
end;
//## SetStyle ##
Procedure TTextPicture.SetStyle(X:Byte);
begin
try;iStyle:=FrcRange(X,0,tpscMax);except;end;
end;
//## FromInteger ##
Procedure TTextPicture.FromRGB(X:Integer;Var Y:TByteBuffer;Z:Integer);
Var
   A,B,C,D,E,P:Integer;
begin{No Overflow Protection}
try{3byte -> 4byte}
{Error}
If (X>tpccMaxInt) then X:=tpccMaxInt;
A:=Z*Z*Z;
B:=Z*Z;
C:=Z;
D:=1;
P:=Y.Count;
Y.Count:=Y.Count+4;
//4
E:=X Div A;
Y.Items[P+3]:=E;
X:=X-E*A;
//3
E:=X Div B;
Y.Items[P+2]:=E;
X:=X-E*B;
//2
E:=X Div C;
Y.Items[P+1]:=E;
X:=X-E*C;
//1
E:=X Div D;
Y.Items[P]:=E;
except;end;
end;
//## AsNum ##
Function TTextPicture.AsNum(Var X:Byte):Boolean;
begin
try
{Successful}
Result:=True;
{Process}
Case X of
48..57:X:=X-48;{0-9=10 "0..9"}
65..90:X:=X-55;{10-35=26 "A..Z"}
97..122:X:=X-61;{36-61=26 "a..z"}
40..41:X:=X+22;{62-63=2 "(..)"}
else
{Error: out of range}
Result:=False;
end;//end of case
except;end;
end;
//## AsByte ##
Function TTextPicture.AsByte(Var X:Byte):Boolean;
begin
try
{Successful}
Result:=True;
{Process}
Case X of
0..9:X:=X+48;{0-9=10 "0..9"}
10..35:X:=X+55;{10-35=26 "A..Z"}
36..61:X:=X+61;{36-61=26 "a..z"}
62..63:X:=X-22;{62-63=2 "(..)"}
else
{Error: out of range}
Result:=False;
end;//end of case
except;end;
end;
//## AsInteger ##
Function TTextPicture.AsInteger(Var X:TByteBuffer;Y:Integer):Integer;
Var
   A,P:Integer;
begin{No Overflow Protection}
try
{Default}
Result:=0;
A:=0;
{Process}
For P:=0 to (X.Count-1)Do
begin
Case P of
0:A:=X.Items[P];
1:A:=X.Items[P]*Y;
2:A:=X.Items[P]*Y*Y;
3:A:=X.Items[P]*Y*Y*Y;
4:A:=X.Items[P]*Y*Y*Y*Y;
5:A:=X.Items[P]*Y*Y*Y*Y*Y;
end;//end of case
Result:=Result+A;
If (P=5) then break;
end;//end of loop
except;end;
end;
//## Draw ##
procedure TTextPicture.Draw(ACanvas: TCanvas; const Rect: TRect);
begin;ACanvas.StretchDraw(Rect,iImage);end;
//## GetEmpty ##
function TTextPicture.GetEmpty:Boolean;
begin;Result:=iImage.Empty;end;
//## GetHeight ##
function TTextPicture.GetHeight:Integer;
begin;Result:=iImage.Height;end;
//## GetWidth ##
function TTextPicture.GetWidth:Integer;
begin;Result:=iImage.Width;end;
//## SetHeight ##
procedure TTextPicture.SetHeight(Value:Integer);
begin;iImage.Height:=Value;Update;end;
//## SetWidth ##
procedure TTextPicture.SetWidth(Value:Integer);
begin;iImage.Width:=Value;Update;end;
//## LoadFromClipboardFormat ##
procedure TTextPicture.LoadFromClipboardFormat(AFormat:Word;AData:THandle;APalette:HPALETTE);
begin;iImage.LoadFromClipboardFormat(AFormat,AData,APalette);Update;end;
//## SaveToClipboardFormat ##
procedure TTextPicture.SaveToClipboardFormat(var Format: Word; var Data: THandle; var APalette: HPALETTE);
begin;iImage.SaveToClipboardFormat(Format,Data,APalette);Update;end;
//## Update ##
Procedure TTextPicture.Update;
begin
try;iImage.PixelFormat:=pf24bit;except;end;
end;
//## Progress ##
procedure TTextPicture.Progress(Sender: TObject;Stage:TProgressStage;PercentDone:Byte;RedrawNow:Boolean;const R:TRect;const Msg:string);
begin
try
iLastTimerIndex:=GetCurrentTime;
if Assigned(FOnProgress) then FOnProgress(Sender,Stage,PercentDone,RedrawNow,R,Msg);
except;end;
end;
//## Progressing ##
procedure TTextPicture.Progressing(PercentDone:Byte;const Msg:string);
begin
try
if Not Assigned(FOnProgress) then exit;
If ((GetCurrentTime-iLastTimerIndex)>=250) then
   begin
   Progress(Self,psRunning,PercentDone,False,Rect(0,0,Width,Height),Msg);
   iLastTimerIndex:=GetCurrentTime;
   end;//end of if
except;end;
end;
//## Assign ##
Procedure TTextPicture.Assign(Source: TPersistent);
Var
   A:TBitmap;
begin
If (Source is TTextPicture) then
   begin
   CopyFrom((Source as TTextPicture).Image);
   Style:=(Source as TTextPicture).Style;
   BPP:=(Source as TTextPicture).BPP;
   end
else If (Source is TGraphic) then CopyFrom(Source as TGraphic)
else iImage.Assign(Source);
{Update}
Update;
end;
//## CopyFrom ##
Procedure TTextPicture.CopyFrom(X:TGraphic);
begin
try
{Size}
iImage.Width:=X.Width;
iImage.Height:=X.Height;
{Cls}
iImage.Canvas.Brush.Color:=clWhite;
iImage.Canvas.FillRect(Rect(0,0,iImage.Width,iImage.Height));
{Paint}
iImage.Canvas.Draw(0,0,X);
except;end;
end;
//## FreeImage ##
Procedure TTextPicture.FreeImage;
begin
try;iImage.FreeImage;except;end;
end;
//## Dormant ##
Procedure TTextPicture.Dormant;
begin
try;iImage.Dormant;except;end;
end;
//## LoadFromFile ##
Function TTextPicture.LoadFromStr(Var X:String):Boolean;
var
   m:tstreamstr;
begin
try
//defaults
result:=false;
m:=nil;
ierrormessage:=gecOutOfMemory;
//process
//.get
m:=tstreamstr.create(@x);
//.set
loadfromstream(m);
//successful
result:=true;
except;end;
try;freeObj(@m);except;end;
end;
//## LoadFromFile ##
Function TTextPicture.LoadFromFile(X:String):Boolean;
Var
   iStream:TStream;
begin
try
{Error}
Result:=False;
iStream:=nil;
{Open Stream}
iErrorMessage:=gecFileNotFound;
If Not FileExists(X) then exit;
iErrorMessage:=gecFileInUse;
iStream:=TFileStream.Create(X,fmOpenRead+fmShareDenyNone);
{LoadFromStream}
LoadFromStream(iStream);
{Successful}
Result:=True;
except;end;
try;freeObj(@iStream);except;end;
end;
//## SaveToStr ##
Function TTextPicture.SaveToStr(Var X:String):Boolean;
var
   m:tstreamstr;
begin
try
//defaults
result:=false;
m:=nil;
//process
//.get
iErrorMessage:=gecOutOfMemory;
m:=tstreamstr.create(@x);
m.position:=m.size-1;
//.set
savetostream(m);
//successful
result:=true;
except;end;
try;freeobj(@m);except;end;
end;
//## SaveToFile ##
Function TTextPicture.SaveToFile(X:String):Boolean;
Label
     SkipEnd;
Var
   iStream:TStream;
begin
try
{Error}
Result:=False;
iStream:=nil;
{Remove File}
iErrorMessage:=gecFileInUse;
If Not RemFile(X) then Goto SkipEnd;
{Create Stream}
iErrorMessage:=gecBadFileName;
iStream:=TFileStream.Create(X,fmCreate);
{SaveToStream}
SaveToStream(iStream);
{Successful}
Result:=True;
SkipEnd:
except;end;
try;freeObj(@iStream);except;end;
end;
//## ReadHeader ##
Function TTextPicture.ReadHeader(X:TStream;Var rBPP:Byte;Var W,H:Integer;Var Pal:TColorPalette):Boolean;
Label
     PreSkipEnd,SkipEnd,ReDo;
Var
   A:TByteStream;
   B:TByteBuffer;
   CommentCount,Count,pCount,P,Pos:Integer;
   Val:Byte;
   Z:TRGBColor;
   EOP,EOF:Boolean;
   d:tint4;
begin
try
{Error}
Result:=False;
rBPP:=tpsbDefault;{64 Colors}
W:=0;
H:=0;
Pal.Count:=0;
A:=nil;
If (X=nil) then exit;
{A}
A:=TByteStream.Create;
A.Stream:=X;
{Defaults}
CommentCount:=0;
EOF:=False;
EOP:=False;
Pos:=X.Position;
B.Count:=0;
Count:=0;
pCount:=0;
{Read}
ReDo:
If Not A.Get(Pos,Val) then Goto SkipEnd;
//Start Comment
Case Val of
tpccStartComment:CommentCount:=CommentCount+1;{Start of Embedded Comment}
tpccEndComment:CommentCount:=CommentCount-1;{End of Embedded Comment}
tpccEOF:If (CommentCount=0) then EOF:=True;{End of File}
tpccEOP:If (CommentCount=0) then EOP:=True;{End of Palette and Header}
else
 If (CommentCount=0) and AsNum(Val) then
    begin
    {Process Header}
    Case Count of
    {T}
    0:If (Val=tpccSOF) then Count:=Count+1;
    {Bits/Per/Pixel 1-6}
    1:Case (Val>=tpsbMinBPP) and (Val<=tpsbMaxBPP) of
      True:begin
          rBPP:=Val;
          Pal.Count:=rpccBPPS[rBPP];{bpp:color}
          {Standard Palette}
          If Not StdPalette(Pal) then Goto SkipEnd;
          Count:=Count+1;
          end;//end of begin
      False:Goto SkipEnd;{Unsupported bbp 1-3 only}
      end;//end of case
    {Width/Height}
    2,3:begin
      If (B.Count<3) then
         begin
         B.Items[B.Count]:=Val;
         B.Count:=B.Count+1;
         If (B.Count>=3) then
            begin
            Case Count of
            2:W:=AsInteger(B,64);{Width}
            3:H:=AsInteger(B,64);{Height}
            end;//end of case
            Count:=Count+1;
            B.Count:=0;
            end;//end of loop
         end;//end of if
      end;//end of begin
    {Palette 1-x}
    4:begin
      If (B.Count<4) then
         begin
         B.Items[B.Count]:=Val;
         B.Count:=B.Count+1;
         If (B.Count>=4) then
            begin
            {Color as Integer}
            d.val:=AsInteger(B,64);
            {Integer => RGB}
            Pal.Items[pCount].R:=d.r;
            Pal.Items[pCount].G:=d.g;
            Pal.Items[pCount].B:=d.b;
            pCount:=pCount+1;
            B.Count:=0;
            {Terminate Palette Processing}
            If (pCount>=Pal.Count) then Count:=Count+1;;
            end;//end of if
         end;//end of if
      end;//end of begin
    5:{null - wait for EOP or EOP}
    end;//end of case
    end;//end of if
end;//end of case
{Loop}
If (Not EOP) and (Not EOF) then
   begin
   Pos:=Pos+1;
   Goto ReDo;
   end;//end of if
PreSkipEnd:
{Successful}
Result:=EOP and (rBPP>0) and (W>0) and (H>0);
{Align Stream}
X.Position:=Pos+1;
SkipEnd:
except;end;
try;freeObj(@a);except;end;
end;
//## CountBPP ##
Function TTextPicture.CountBPP:Byte;
Var
   PalIntArray:TIntPalette;
   PalArray:TRGBPalette;
   Pal:TColorPalette;
begin
try
{Error}
Result:=tpsbMinBPP;
{Setup Palette}
Pal.Items:=@PalArray;
Pal.IntItems:=@PalIntArray;
Pal.Count:=0;{empty}
{Return Result}
If ccs.BuildPalette(iImage,Pal,rpccBPPS[tpsbMaxBPP]) then Result:=ccs.ColorsAsBPP(Pal.Count);
except;end;
end;
//## WriteHeader ##
Function TTextPicture.WriteHeader(X:TStream;Var Y:TBitmap;rBPP,W,H:Integer;Var Pal:TColorPalette):Boolean;
Label
     SkipEnd;
Var
   A:TByteStream;
   B:TByteBuffer;
   PalCount,P2,P,Pos:Integer;
   Val:Byte;
   Z:TRGBColor;
begin
try
{Error}
Result:=False;
A:=nil;
If (X=nil) then exit;
If (Y=nil) then exit;
{Unsupported Bits/Per/Pixel}
If (rBPP<tpsbMinBPP) or (rBPP>tpsbMaxBPP) then exit;
{A}
A:=TByteStream.Create;
A.Stream:=X;
{Defaults}
Pos:=X.Position;
B.Count:=0;
Pal.Count:=0;
{Write}
{T}
If Not A.Put(Pos,84) then Goto SkipEnd;
Pos:=Pos+1;
{Version 1}
Val:=rBPP;
If Not AsByte(Val) then Goto SkipEnd;
If Not A.Put(Pos,Val) then Goto SkipEnd;
Pos:=Pos+1;
{Width & Height}
For P2:=0 to 1 Do
begin
B.Count:=0;
Case P2 of
0:FromRGB(W,B,64);
1:FromRGB(H,B,64);
end;//end of case
If (B.Count<>4) then Goto SkipEnd;
For P:=0 to (B.Count-2) Do{Write frist 3 bytes only}
begin
If Not AsByte(B.Items[P]) then Goto SkipEnd;
If Not A.Put(Pos,B.Items[P]) then Goto SkipEnd;
Pos:=Pos+1;
end;//end of loop
end;//end of loop
{Palette}
//Custom Palette
Pal.Count:=0;{empty}
If Not ccs.BuildPalette(Y,Pal,rpccBPPS[rBPP]) then Goto SkipEnd;{2-8 colors max}
//Palette - Variable length palette (2-64)
For P:=0 to (Pal.Count-1) Do
begin
B.Count:=0;
FromRGB(Pal.IntItems[P],B,64);
If (B.Count<>4) then Goto SkipEnd;
//Write Palette Entry
For P2:=0 to (B.Count-1) Do
begin
If Not AsByte(B.Items[P2]) then Goto SkipEnd;
If Not A.Put(Pos,B.Items[P2]) then Goto SkipEnd;
Pos:=Pos+1;
end;//end of loop
end;//end of loop
//Palette Terminator EOP
If Not A.Put(Pos,tpccEOP) then Goto SkipEnd;
{Successful}
Result:=True;
{Align Stream}
X.Position:=Pos+1;
SkipEnd:
except;end;
try;freeObj(@a);except;end;
end;
//## ExpandPixels ##
Function TTextPicture.ExpandPixels(X,bpp:Byte;Var Y:TByteBuffer;Z:Integer):Boolean;
Var
   A:Byte;
begin
try
{Error}
Result:=False;
Case bpp of
4..6:begin{16/32/64 color : (0-63) }
  If (X>Z) then X:=Z;
  Y.Items[Y.Count]:=X;
  Y.Count:=Y.Count+1;
  end;//end of begin
3:begin{8 color : (0-7) + (0-7)*8 }
  Y.Count:=Y.Count+2;
  //A
  A:=X Div 8;
  If (A>Z) then A:=Z;
  Y.Items[Y.Count-1]:=A;
  X:=X-(A*8);
  //B
  A:=X;
  If (A>Z) then A:=Z;
  Y.Items[Y.Count-2]:=A;
  end;//end of begin
2:begin{4 color : (0-3) + (0-3)*4 + (0-3)*16 }
  Y.Count:=Y.Count+3;
  //A
  A:=X Div 16;
  If (A>Z) then A:=Z;
  Y.Items[Y.Count-1]:=A;
  X:=X-(A*16);
  //B
  A:=X Div 4;
  If (A>Z) then A:=Z;
  Y.Items[Y.Count-2]:=A;
  X:=X-(A*4);
  //C
  A:=X;
  If (A>Z) then A:=Z;
  Y.Items[Y.Count-3]:=A;
  end;//end of begin
1:begin{2 color : (0-1) + (0-1)*2 + (0-1)*4 + (0-1)*8 + (0-1)*16 + (0-1)*32 }
  Y.Count:=Y.Count+6;
  //A
  A:=X Div 32;
  If (A>Z) then A:=Z;
  Y.Items[Y.Count-1]:=A;
  X:=X-(A*32);
  //B
  A:=X Div 16;
  If (A>Z) then A:=Z;
  Y.Items[Y.Count-2]:=A;
  X:=X-(A*16);
  //C
  A:=X Div 8;
  If (A>Z) then A:=Z;
  Y.Items[Y.Count-3]:=A;
  X:=X-(A*8);
  //D
  A:=X Div 4;
  If (A>Z) then A:=Z;
  Y.Items[Y.Count-4]:=A;
  X:=X-(A*4);
  //E
  A:=X Div 2;
  If (A>Z) then A:=Z;
  Y.Items[Y.Count-5]:=A;
  X:=X-(A*2);
  //F
  A:=X;
  If (A>Z) then A:=Z;
  Y.Items[Y.Count-6]:=A;
  end;//end of begin
else
 exit;{Unknown bpp}
end;//end of case
{Successful}
Result:=True;
except;end;
end;
//## ReadHeader ##
Function TTextPicture.AsciiReader(X:TStream;rBPP:Integer;Var Y:TBitmap;Var Pal:TColorPalette):Boolean;
Label
     PreSkipEnd,SkipEnd,ReDo;
Var
   A:TByteStream;
   B:TByteBuffer;
   C:TByteImage;
   MaxPos,MaxX,MaxY,CommentCount,Count,MaxP,P,Pos:Integer;
   Val:Byte;
   Z:TRGBColor;
   EOF:Boolean;
begin
try
{Error}
Result:=False;
A:=nil;
If (X=nil) then exit;
{A}
A:=TByteStream.Create;
A.Stream:=X;
C:=TByteImage.Create;
C.Image:=Y;
{Defaults}
CommentCount:=0;
EOF:=False;
Pos:=X.Position;
Count:=0;
MaxX:=C.ZeroWidth;
MaxY:=C.ZeroHeight;
MaxP:=Pal.Count-1;
MaxPos:=X.Size;
B.Count:=0;
{Read}
ReDo:
If Not A.Get(Pos,Val) then Goto PreSkipEnd;
//Progress
Count:=Count+1;
If (Count>=10000) then
   begin
   {Progress}
   Progressing((Pos+1)*100 Div MaxPos,'Loading');
   Count:=0;
   end;//end of if
//Start Comment
Case Val of
tpccStartComment:CommentCount:=CommentCount+1;
tpccEndComment:CommentCount:=CommentCount-1;
tpccEOF:If (CommentCount=0) then EOF:=True;
else
 If (CommentCount=0) and AsNum(Val) then
    begin
    {Split into palette referenced pixels}
    B.Count:=0;
    If Not ExpandPixels(Val,rBPP,B,MaxP) then Goto PreSkipEnd;
    {Implement Pixels}
    For P:=0 to (B.Count-1) Do
    begin
    If Not C.PushPixel(Pal.Items[B.Items[P]]) then Goto PreSkipEnd;
    end;//end of loop
    end;//end of if
end;//end of case
{Loop}
If Not EOF then
   begin
   Pos:=Pos+1;
   Goto ReDo;
   end;//end of if
PreSkipEnd:
{Successful}
Result:=True;
{Align Stream}
X.Position:=Pos+1;
SkipEnd:
except;end;
try;A.Free;C.Free;except;end;
end;
//## CondensePixels ##
Function TTextPicture.CondensePixels(Var X:TByteBuffer;bpp:Byte;Var Z:Byte):Boolean;
Var
   A:Byte;
   P:Integer;
begin
try
{Error}
Result:=False;
Z:=0;
Case bpp of
4..6:begin{16/32/64 color : (0-63) }
  Z:=X.Items[X.Count-1];
  end;//end of begin
3:begin{8 color : (0-7) + (0-7)*8 }
  For P:=0 to 1 Do
  begin
  Case P of
  0:Z:=Z+X.Items[P];
  1:Z:=Z+X.Items[P]*8;
  end;//end of case
  end;//end of loop
  end;//end of begin
2:begin{4 color : (0-3) + (0-3)*4 + (0-3)*16 }
  For P:=0 to 2 Do
  begin
  Case P of
  0:Z:=Z+X.Items[P];
  1:Z:=Z+X.Items[P]*4;
  2:Z:=Z+X.Items[P]*16;
  end;//end of case
  end;//end of loop
  end;//end of begin
1:begin{2 color : (0-1) + (0-1)*2 + (0-1)*4 + (0-1)*8 + (0-1)*16 + (0-1)*32 }
  For P:=0 to 5 Do
  begin
  Case P of
  0:Z:=Z+X.Items[P];
  1:Z:=Z+X.Items[P]*2;
  2:Z:=Z+X.Items[P]*4;
  3:Z:=Z+X.Items[P]*8;
  4:Z:=Z+X.Items[P]*16;
  5:Z:=Z+X.Items[P]*32;
  end;//end of case
  end;//end of loop
  end;//end of begin
else
 exit;{Unknown bpp}
end;//end of case
{Successful}
Result:=True;
except;end;
end;
//## WriteSep ##
Function TTextPicture.WriteSep(X:TByteStream;Var Pos:Integer;Style:Integer;EOL:Boolean):Boolean;
begin
try
{Error}
Result:=False;
Case Style of
tpscBlocks:begin{"'+'"}
     If Not X.Put(Pos,39) then exit;
     Pos:=Pos+1;
     If Not X.Put(Pos,43) then exit;
     Pos:=Pos+1;
     {Return Code}
     If EOL then
        begin
        If Not X.Put(Pos,13) then exit;
        Pos:=Pos+1;
        If Not X.Put(Pos,10) then exit;
        Pos:=Pos+1;
        end;//end of if
     If Not X.Put(Pos,39) then exit;
     Pos:=Pos+1;
     end;//end of begin
tpscLines:begin{"RCode"}
     If Not X.Put(Pos,13) then exit;
     Pos:=Pos+1;
     If Not X.Put(Pos,10) then exit;
     Pos:=Pos+1;
     end;//end of begin
end;//end of case
{Successful}
Result:=True;
except;end;
end;
//## AsciiWriter ##
Function TTextPicture.AsciiWriter(X:TStream;S,rBPP:Integer;Var Y:TBitmap;Var Pal:TColorPalette):Boolean;
Label
     SkipEnd,ReDo;
Var
   A:TByteStream;
   B:TByteBuffer;
   C:TByteImage;
   Row:PRGBColorRow;
   pCount2,pCount,bMax,pMax,Count,pI,rX,rY,MaxX,MaxY,P,Pos:Integer;
   Val:Byte;
   Z:TRGBColor;
begin
try
{Error}
Result:=False;
A:=nil;
If (X=nil) then exit;
{Unsupported bpp}
If (rBPP<tpsbMinBPP) or (rBPP>tpsbMaxBPP) then exit;
{A}
A:=TByteStream.Create;
A.Stream:=X;
C:=TByteImage.Create;
C.Image:=Y;
{Defaults}
Pos:=X.Position;
MaxX:=C.ZeroWidth;
MaxY:=C.ZeroHeight;
{Clear B array}
bMax:=tpsbBPPAsPixels[rBPP];{bpp:#pixels}
For P:=0 to (bMax-1) Do B.Items[P]:=0;
B.Count:=0;
{Separator Setup}
Count:=0;
If Not WriteSep(A,Pos,S,False) then Goto SkipEnd;
pCount:=0;
pCount2:=1;
Case S of
tpscBlocks:pMax:=250;
tpscLines:pMax:=68;{lines never exceed 70 characters}
else
pMax:=-1;
end;//end of case
{Write}
For rY:=0 to MaxY Do
begin
Progressing((rY+1)*100 Div (MaxY+1),'Saving');
Row:=C.Row[rY];
 For rX:=0 to MaxX Do
 begin
 pI:=ccs.FindPaletteRGB(Pal,Row[rX]);
 {Use palette entry 1(0) if color not found}
 If (pI=-1) then pI:=0;
 B.Items[B.Count]:=pI;
 B.Count:=B.Count+1;
 If (B.Count>=bMax) then
    begin
    {Condense Xpixels into 1byte}
    If Not CondensePixels(B,rBPP,Val) then Goto SkipEnd;
    {Write Byte}
    If Not AsByte(Val) then
       begin
       Goto SkipEnd;
       end;//end of if
    If Not A.Put(Pos,Val) then Goto SkipEnd;
    B.Count:=0;
    Pos:=Pos+1;
    {Seperator}
    If (pMax<>-1) then
       begin
       pCount:=pCount+1;
       If (pCount>=pMax) then
          begin
          pCount2:=pCount2+1;
          pCount:=0;
          If Not WriteSep(A,Pos,S,(S=tpscBlocks) and (pCount2>=4)) then Goto SkipEnd;
          If (pCount2>=4) then pCount2:=0;
          end;//end of if
       end;//end of if
    end;///end of if
 end;//end of loop
end;//end of loop
{Write any unfinished pixels}
If (B.Count<>0) then
   begin
   {Condense Xpixels into 1byte}
   If Not CondensePixels(B,rBPP,Val) then Goto SkipEnd;
   B.Count:=0;
   {Write Byte}
   If Not AsByte(Val) then Goto SkipEnd;
   If Not A.Put(Pos,Val) then Goto SkipEnd;
   Pos:=Pos+1;
   end;//end of if
{Write EOF}
Val:=tpccEOF;
If Not A.Put(Pos,Val) then Goto SkipEnd;
Pos:=Pos+1;
{Successful}
Result:=True;
{Align Stream}
X.Position:=Pos+1;
SkipEnd:
except;end;
try;A.Free;C.Free;except;end;
end;
//## LoadFromStream ##
Procedure TTextPicture.LoadFromStream(X:TStream);
Label
     SkipEnd;
Var
   PalIntArray:TIntPalette;
   PalArray:TRGBPalette;
   Pal:TColorPalette;
   rBPP:Byte;
   W,H:Integer;
   ErrMsg:String;
begin
try
ErrMsg:=gecOutOfMemory;
Progress(Self,psStarting,0,False,Rect(0,0,Width,Height),'Loading');
{Setup Palette}
Pal.Items:=@PalArray;
Pal.IntItems:=@PalIntArray;
Pal.Count:=0;{empty}
{Update}
Update;
{Read Header}
If Not ReadHeader(X,rBPP,W,H,Pal) then
   begin
   ErrMsg:=gecUnknownFormat;
   Goto SkipEnd;
   end;//end of if
{Check Version}
If (rBPP<tpsbMinBPP) or (rBPP>tpsbMaxBPP) then
   begin
   ErrMsg:=gecUnexpectedError;
   Goto SkipEnd;
   end;//end of if
{Check W&H}
If (W<=0) or (H<=0) then
   begin
   ErrMsg:=gecUnexpectedError;
   Goto SkipEnd;
   end;//end of if
{Implement Header}
iImage.Width:=W;
iImage.Height:=H;
iImage.PixelFormat:=pf24bit;
{Clear}
iImage.Canvas.Brush.Color:=clWhite;
iImage.Canvas.FillRect(Rect(0,0,iImage.Width,iImage.Height));
{Data}
If Not AsciiReader(X,rBPP,iImage,Pal) then Goto SkipEnd;
{No Error}
ErrMsg:='';
SkipEnd:
except;end;
try;Progress(Self,psEnding,100,False,Rect(0,0,Width,Height),'Loading');except;end;
general.raiseerror(errmsg);
end;
//## StdPalette ##
Function TTextPicture.StdPalette(Var Pal:TColorPalette):Boolean;
Var
   MaxP,P:Integer;
begin
try
{Error}
Result:=False;
MaxP:=High(rpccPal8);
{Standard 8 Color Palette}
For P:=0 to (Pal.Count-1) Do
begin
Case (P<=MaxP) of
True:Pal.IntItems[P]:=rpccPal8[P];
False:Pal.IntItems[P]:=0;{black}
end;//end of case
Pal.Items[P]:=ccs.IntRGB(Pal.IntItems[P]);
end;//end of loop
{Successful}
Result:=True;
except;end;
end;
//## SaveToStream ##
Procedure TTextPicture.SaveToStream(X:TStream);
Label
     SkipEnd;
Var
   PalIntArray:TIntPalette;
   PalArray:TRGBPalette;
   Pal:TColorPalette;
   rStyle,rBPP:Byte;
   ErrMsg:String;
begin
try
ErrMsg:=gecOutOfMemory;
Progress(Self,psStarting,0,False,Rect(0,0,Width,Height),'Saving');
{rBPP}
rBPP:=iBPP;
rStyle:=Style;
{Update}
Update;
{Setup Palette}
Pal.Items:=@PalArray;
Pal.IntItems:=@PalIntArray;
Pal.Count:=0;{empty}
{Write Header - Version 1}
If Not WriteHeader(X,iImage,rBPP,Width,Height,Pal) then Goto SkipEnd;
{Data}
If Not AsciiWriter(X,rStyle,rBPP,iImage,Pal) then Goto SkipEnd;
{No Error}
ErrMsg:='';
SkipEnd:
except;end;
try;Progress(Self,psEnding,100,False,Rect(0,0,Width,Height),'Saving');except;end;
general.raiseerror(errmsg);
end;
//## ShowError ##
Procedure TTextPicture.ShowError;
begin
try;ShowError60(translate(iErrorMessage));except;end;
end;
//## Glyph ##
Function TTextPicture.Glyph(X:String):TBitmap;
begin
try
{Image}
Result:=TBitmap.Create;
{Load}
If LoadFromStr(X) then
   begin
   ccs.size(result,iimage.width,iimage.height);
   result.PixelFormat:=pf24bit;
   result.Canvas.Draw(0,0,iImage);
   end;//end of if
except;end;
end;

//#################### TXBitmap ################################################
//## Create ##
constructor TXBitmap.Create;
begin
inherited;
{iImage}
iImage:=nil;
iImage:=TBitmap.create;
Update;
end;
//## destroy ##
destructor TXBitmap.destroy;
begin
try
freeObj(@iimage);
//self
inherited;
except;end;
end;
//## Within ##
Function TXBitmap.Within(X:String;Var Y:String):Integer;
Var
   Lx,P,MaxP:Integer;
begin
try
{Not Found}
Result:=-1;
Lx:=Length(X);
MaxP:=Length(Y)-Lx+1;
For P:=1 to MaxP Do
begin
If (Copy(Y,P,Lx)=X) then
   begin
   Result:=P;
   break;
   end;//end of if
end;//end of loop
except;end;
end;
//## ReadHeader ##
Function TXBitmap.ReadHeader(X:TStream;Var W,H:Integer):Boolean;
Label
     ReDo;
Var
   A:TByteStream;
   P,Start,Finish,FindByte,FindP,Pos:Integer;
   Z:String;
   Ok:Boolean;
begin
try
{Error}
Result:=False;
W:=-1;
H:=-1;
A:=nil;
If (X=nil) then exit;
{A}
A:=TByteStream.Create;
A.Stream:=X;
{Continue}
Pos:=X.Position;
FindByte:=0;
Ok:=False;
ReDo:
{Read Width & Height}
If A.ReadLine(Pos,-1,Start,Finish,FindByte,FindP) then
   begin
   {As String}
   Z:=UpperCase(A.Str(Start,Finish));
   If (Copy(Z,1,xblcDefineLen)=xblcDefine) then
      begin
      {Width}
      If (W=-1) then
         begin
         P:=Within(xblcWidth,Z);
         If (P<>-1) then
            begin
            W:=strtoint(Copy(Z,P+xblcWidthLen,Finish-Start+1));
            Goto ReDo;
            end;//end of if
         end;
      {Height}
      If (H=-1) then
         begin
         P:=Within(xblcHeight,Z);
         If (P<>-1) then
            begin
            H:=strtoint(Copy(Z,P+xblcHeightLen,Finish-Start+1));
            X.Position:=Pos;
            Goto ReDo;
            end;//end of if
         end;
      end;//end of if
   {xblcStaticChar}
   If (W<>-1) and (H<>-1) and (Not Ok) and (Copy(Z,1,xblcStaticLen)=xblcStatic) then
      begin
      Ok:=True;
      end;
   {Loop}
   If Not Ok then Goto ReDo;
   end;//end of if
{Successful}
Result:=Ok;
except;end;
try;freeObj(@a);except;end;
end;
//## AsciiReader ##
Function TXBitmap.AsciiReader(X:TStream;Var Y:TBitmap):Boolean;
Label
     ReDo;
Var
   A:TByteStream;
   D,B:TByteBuffer;
   C:TByteImage;
   Ly,Count,MaxP,MaxW,P2,P,Start,Finish,FindByte,FindP,Pos:Integer;
   Z:TRGBColor;
   FactorOf8,sS,sF:Boolean;
begin
try
{Error}
Result:=False;
A:=nil;
If (X=nil) then exit;
{A}
A:=TByteStream.Create;
A.Stream:=X;
C:=TByteImage.Create;
C.Image:=Y;
{Continue}
Pos:=X.Position;
MaxP:=X.Size;
MaxW:=C.ZeroWidth;
FindByte:=0;
sS:=False;
sF:=False;
{Monochrome}
FactorOf8:=(((C.Width Div 8)*8)=C.Width);
Count:=0;
ReDo:
{Read Width & Height}
If A.ReadLine(Pos,-1,Start,Finish,FindByte,FindP) then
   begin
   Count:=Count+1;
   If (Count>=40) then
      begin
      {Progress}
      Progressing((Pos+1)*100 Div MaxP,'Loading');
      Count:=0;
      end;//end of if

   Case sS of
   False:begin
        P:=A.FindByte(xblcDataStart,Start,Finish);
        If (P<>-1) then
           begin
           sS:=True;
           Start:=P+1;
           end;//end of begin
        end;//end of begin
   True:begin
        P:=A.FindByte(xblcDataFinish,Start,Finish);
        If (P<>-1) then
           begin
           sF:=True;
           Finish:=P-1;
           end;//end of if
        end;//end of case
   end;//end of case
   {Extract Hex Values}
   B.Count:=0;
   If sS then
      begin
      If A.XHexToBinary(Start,Finish,255,B) then
         begin
         For P:=0 to (B.Count-1) Do
         begin
          //End of ScanLine Trigger
          D.Count:=0;
          C.ExpandBits(B.Items[P],D);
          For P2:=(D.Count-1) downTo 0 Do
          begin
          If (D.Items[P2]=0) then Z.R:=255 else Z.R:=0;
          Z.G:=Z.R;
          Z.B:=Z.R;
          Ly:=C.Y;
          If Not C.PushPixel(Z) then break;
          If (Ly<>C.Y) then break;{Normal -n.b No Special Rounding unlike normal Monochrome images}
          end;//end of loop
         end;//end of loop
         end;//end of if
      end;//end of if
   {Loop}
   If (Not sS) or (Not sF) then Goto ReDo;
   end;//end of loop
{Successful}
Result:=True;
except;end;
try;freeObj(@a);freeObj(@c);except;end;
end;
//## WriteHeader ##
Function TXBitmap.WriteHeader(X:TStream;W,H:Integer):Boolean;
Label
     SkipEnd;
Var
   A:TByteStream;
   P,Pos:Integer;
   Z:String;
begin
try
{Error}
Result:=False;
A:=nil;
If (X=nil) then exit;
{A}
A:=TByteStream.Create;
A.Stream:=X;
{Write Header Elements}
Z:='';
Z:=Z+'#define image_width '+inttostr(W)+RCode;
Z:=Z+'#define image_height '+inttostr(H)+RCode;
Z:=Z+'static char image_bits[] = {'+RCode;
Pos:=X.Position;
If Not A.PushStr(Pos,Z) then Goto SkipEnd;
{Align Stream for Data Read}
X.Position:=Pos;
{Successful}
Result:=True;
SkipEnd:
except;end;
try;freeObj(@a);except;end;
end;
//## AsciiWriter ##
Function TXBitmap.AsciiWriter(X:TStream;Var Y:TBitmap):Boolean;
Label
     SkipEnd,ReDo;
Var
   Row:PRGBColorRow;
   A:TByteStream;
   B:TByteBuffer;
   C:TByteImage;
   Val:Byte;
   ItemCount,Count,rX,rY,MaxX,MaxY,MaxW,P2,P,Start,Finish,FindByte,FindP,Pos:Integer;
   Z:TRGBColor;
   Ok,FactorOf8,sS,sF:Boolean;
begin
try
{Error}
Result:=False;
a:=nil;
c:=nil;
If (X=nil) then exit;
{A}
A:=TByteStream.Create;
A.Stream:=X;
C:=TByteImage.Create;
C.Image:=Y;
{Continue}
MaxW:=C.ZeroWidth;
Pos:=X.Position;
FindByte:=0;
sS:=False;
sF:=False;
Ok:=False;
{Monochrome}
FactorOf8:=(((C.Width Div 8)*8)=C.Width);
MaxY:=C.ZeroHeight;
MaxX:=C.ZeroWidth;
ItemCount:=0;
{Monochrome}
For rY:=0 to MaxY do
begin
{Progress}
Progressing((rY+1)*100 Div (MaxY+1),'Saving');
Row:=C.Row[rY];
Count:=0;
Val:=0;
 For rX:=0 to MaxX Do
 begin
 Z:=Row[rX];
 {Collect 8 Pixels}
 Case Count of
 0:If (Z.R=0) then Val:=Val+1;
 1:If (Z.R=0) then Val:=Val+2;
 2:If (Z.R=0) then Val:=Val+4;
 3:If (Z.R=0) then Val:=Val+8;
 4:If (Z.R=0) then Val:=Val+16;
 5:If (Z.R=0) then Val:=Val+32;
 6:If (Z.R=0) then Val:=Val+64;
 7:If (Z.R=0) then Val:=Val+128;
 end;//end of case
 Count:=Count+1;
 If (Count>7) or (rX=MaxX) then
    begin
    {Convert Val 0-255=>0x00-0xFF}
    B.Count:=0;
    If Not A.ByteToXHex(Val,B) then Goto SkipEnd;
    {Write 4 byte Hex Code}
    For P:=0 to (B.Count-1) Do
    begin
    If Not A.Put(Pos,B.Items[P]) then Goto SkipEnd;
    Pos:=Pos+1;
    end;//end of loo
    {Comma}
    If Not A.Put(Pos,44) then Goto SkipEnd;
    Pos:=Pos+1;
    {Space}
    If Not A.Put(Pos,32) then Goto SkipEnd;
    Pos:=Pos+1;
    Val:=0;
    Count:=0;
    ItemCount:=ItemCount+1;
    end;//end of if
 {Return Code}
 If (ItemCount>=10) then
    begin
    If Not A.Put(Pos,13) then Goto SkipEnd;
    Pos:=Pos+1;
    If Not A.Put(Pos,10) then Goto SkipEnd;
    Pos:=Pos+1;
    ItemCount:=0;
    end;//end of if
 end;//end of X loop
end;//end of Y loop

{Successful}
Result:=True;
SkipEnd:
except;end;
try;freeObj(@a);freeObj(@c);except;end;
end;
//## LoadFromStream ##
Procedure TXBitmap.LoadFromStream(X:TStream);
Label
     SkipEnd;
Var
   W,H:Integer;
   ErrMsg:String;
begin
try
ErrMsg:=gecOutOfMemory;
Progress(Self,psStarting,0,False,Rect(0,0,Width,Height),'Loading');
{Update}
Update;
{Read Header}
If Not ReadHeader(X,W,H) then
   begin
   ErrMsg:=gecUnknownFormat;
   Goto SkipEnd;
   end;//end of if
{Check W&H}
If (W<=0) or (H<=0) then
   begin
   ErrMsg:=gecIndexOutOfRange;
   Goto SkipEnd;
   end;//end of if
{Implement Header}
iImage.Width:=W;
iImage.Height:=H;
iImage.PixelFormat:=pf24bit;
{Clear}
iImage.Canvas.Brush.Color:=clWhite;
iImage.Canvas.FillRect(Rect(0,0,iImage.Width,iImage.Height));
{Data}
If Not AsciiReader(X,iImage) then Goto SkipEnd;
{No Error}
ErrMsg:='';
SkipEnd:
except;end;
try;Progress(Self,psEnding,100,False,Rect(0,0,Width,Height),'Loading');except;end;
general.raiseerror(errmsg);
end;
//## SaveToStream ##
Procedure TXBitmap.SaveToStream(X:TStream);
Label
     SkipEnd;
Var
   ErrMsg:String;
begin
try
ErrMsg:=gecOutOfMemory;
Progress(Self,psStarting,0,False,Rect(0,0,Width,Height),'Saving');
{Update}
Update;
{Write Header}
If Not WriteHeader(X,Width,Height) then Goto SkipEnd;
{Data}
If Not AsciiWriter(X,iImage) then Goto SkipEnd;
{No Error}
ErrMsg:='';
SkipEnd:
except;end;
try;Progress(Self,psEnding,100,False,Rect(0,0,Width,Height),'Saving');except;end;
general.raiseerror(errmsg);
end;
//## Draw ##
procedure TXBitmap.Draw(ACanvas: TCanvas; const Rect: TRect);
begin;ACanvas.StretchDraw(Rect,iImage);end;
//## GetEmpty ##
function TXBitmap.GetEmpty:Boolean;
begin;Result:=iImage.Empty;end;
//## GetHeight ##
function TXBitmap.GetHeight:Integer;
begin;Result:=iImage.Height;end;
//## GetWidth ##
function TXBitmap.GetWidth:Integer;
begin;Result:=iImage.Width;end;
//## SetHeight ##
procedure TXBitmap.SetHeight(Value:Integer);
begin;iImage.Height:=Value;Update;end;
//## SetWidth ##
procedure TXBitmap.SetWidth(Value:Integer);
begin;iImage.Width:=Value;Update;end;
//## LoadFromClipboardFormat ##
procedure TXBitmap.LoadFromClipboardFormat(AFormat:Word;AData:THandle;APalette:HPALETTE);
begin;iImage.LoadFromClipboardFormat(AFormat,AData,APalette);Update;end;
//## SaveToClipboardFormat ##
procedure TXBitmap.SaveToClipboardFormat(var Format: Word; var Data: THandle; var APalette: HPALETTE);
begin;iImage.SaveToClipboardFormat(Format,Data,APalette);Update;end;
//## Update ##
Procedure TXBitmap.Update;
begin
try;iImage.PixelFormat:=pf24bit;except;end;
end;
//## Progress ##
procedure TXBitmap.Progress(Sender: TObject;Stage:TProgressStage;PercentDone:Byte;RedrawNow:Boolean;const R:TRect;const Msg:string);
begin
try
iLastTimerIndex:=GetCurrentTime;
if Assigned(FOnProgress) then FOnProgress(Sender,Stage,PercentDone,RedrawNow,R,Msg);
except;end;
end;
//## Progressing ##
procedure TXBitmap.Progressing(PercentDone:Byte;const Msg:string);
begin
try
if Not Assigned(FOnProgress) then exit;
If ((GetCurrentTime-iLastTimerIndex)>=250) then
   begin
   Progress(Self,psRunning,PercentDone,False,Rect(0,0,Width,Height),Msg);
   iLastTimerIndex:=GetCurrentTime;
   end;//end of if
except;end;
end;
//## Assign ##
Procedure TXBitmap.Assign(Source: TPersistent);
Var
   A:TBitmap;
begin
If (Source is TXBitmap) then CopyFrom((Source as TXBitmap).Image)
else If (Source is TGraphic) then CopyFrom(Source as TGraphic)
else iImage.Assign(Source);
{Update}
Update;
end;
//## CopyFrom ##
Procedure TXBitmap.CopyFrom(X:TGraphic);
begin
try
{Size}
iImage.Width:=X.Width;
iImage.Height:=X.Height;
{Cls}
iImage.Canvas.Brush.Color:=clWhite;
iImage.Canvas.FillRect(Rect(0,0,iImage.Width,iImage.Height));
{Paint}
iImage.Canvas.Draw(0,0,X);
except;end;
end;
//## FreeImage ##
Procedure TXBitmap.FreeImage;
begin
try;iImage.FreeImage;except;end;
end;
//## Dormant ##
Procedure TXBitmap.Dormant;
begin
try;iImage.Dormant;except;end;
end;
//## LoadFromFile ##
Function TXBitmap.LoadFromFile(X:String):Boolean;
Var
   iStream:TStream;
begin
try
{Error}
Result:=False;
iStream:=nil;
iErrorMessage:=gecFileNotFound;
If Not FileExists(X) then exit;
iErrorMessage:=gecFileInUse;
{Open Stream}
iStream:=TFileStream.Create(X,fmOpenRead+fmShareDenyNone);
{LoadFromStream}
LoadFromStream(iStream);
{Successful}
Result:=True;
except;end;
try;freeObj(@istream);except;end;
end;
//## SaveToFile ##
Function TXBitmap.SaveToFile(X:String):Boolean;
Label
     SkipEnd;
Var
   iStream:TStream;
begin
try
{Error}
Result:=False;
iStream:=nil;
{Remove File}
iErrorMessage:=gecFileInUse;
If Not RemFile(X) then Goto SkipEnd;
{Create Stream}
iErrorMessage:=gecBadFileName;
iStream:=TFileStream.Create(X,fmCreate);
{SaveToStream}
SaveToStream(iStream);
{Successful}
Result:=True;
SkipEnd:
except;end;
try;freeObj(@istream);except;end;
end;
//## ShowError ##
Procedure TXBitmap.ShowError;
begin
try;ShowError60(translate(iErrorMessage));except;end;
end;

//################ TPortablePixelmap ###########################################
//## create ##
constructor TPortablePixelmap.create;
begin
inherited;
{iImage}
iImage:=TBitmap.Create;
Update;
end;
//## destroy ##
destructor TPortablePixelmap.destroy;
begin
try
freeObj(@iimage);
//self
inherited;
except;end;
end;
//## Draw ##
procedure TPortablePixelmap.Draw(ACanvas: TCanvas; const Rect: TRect);
begin;ACanvas.StretchDraw(Rect,iImage);end;
//## GetEmpty ##
function TPortablePixelmap.GetEmpty:Boolean;
begin;Result:=iImage.Empty;end;
//## GetHeight ##
function TPortablePixelmap.GetHeight:Integer;
begin;Result:=iImage.Height;end;
//## GetWidth ##
function TPortablePixelmap.GetWidth:Integer;
begin;Result:=iImage.Width;end;
//## SetHeight ##
procedure TPortablePixelmap.SetHeight(Value:Integer);
begin;iImage.Height:=Value;Update;end;
//## SetWidth ##
procedure TPortablePixelmap.SetWidth(Value:Integer);
begin;iImage.Width:=Value;Update;end;
//## LoadFromClipboardFormat ##
procedure TPortablePixelmap.LoadFromClipboardFormat(AFormat:Word;AData:THandle;APalette:HPALETTE);
begin;iImage.LoadFromClipboardFormat(AFormat,AData,APalette);Update;end;
//## SaveToClipboardFormat ##
procedure TPortablePixelmap.SaveToClipboardFormat(var Format: Word; var Data: THandle; var APalette: HPALETTE);
begin;iImage.SaveToClipboardFormat(Format,Data,APalette);Update;end;
//## GetAscii ##
Function TPortablePixelmap.GetAscii:Boolean;
begin
try;Result:=IsAscii(iStyle);except;end;
end;
//## SetAscii ##
Procedure TPortablePixelmap.SetAscii(X:Boolean);
begin
try
If (X=Ascii) then exit;
Case X of
True:Style:=Style+3;
False:Style:=Style-3;
end;//end of case
except;end;
end;
//## SetStyle ##
Procedure TPortablePixelmap.SetStyle(X:Integer);
begin
try;iStyle:=SafeStyle(X);except;end;
end;
//## CopyFrom ##
Procedure TPortablePixelmap.CopyFrom(X:TGraphic);
begin
try
{Size}
iImage.Width:=X.Width;
iImage.Height:=X.Height;
{Cls}
iImage.Canvas.Brush.Color:=clWhite;
iImage.Canvas.FillRect(Rect(0,0,iImage.Width,iImage.Height));
{Paint}
iImage.Canvas.Draw(0,0,X);
except;end;
end;
//## Assign ##
Procedure TPortablePixelmap.Assign(Source: TPersistent);
Var
   A:TBitmap;
begin
If (Source is TPortablePixelmap) then
   begin
   CopyFrom((Source as TPortablePixelmap).Image);
   Style:=(Source as TPortablePixelmap).Style;
   end
else If (Source is TGraphic) then CopyFrom(Source as TGraphic)
else iImage.Assign(Source);
{Update}
Update;
end;
//## LoadFromFile ##
Function TPortablePixelmap.LoadFromFile(X:String):Boolean;
Var
   iStream:TStream;
begin
try
{Error}
Result:=False;
iStream:=nil;
iErrorMessage:=gecFileNotFound;
If Not FileExists(X) then exit;
iErrorMessage:=gecFileInUse;
{Open Stream}
iStream:=TFileStream.Create(X,fmOpenRead+fmShareDenyNone);
{LoadFromStream}
LoadFromStream(iStream);
{Successful}
Result:=True;
except;end;
try;freeObj(@istream);except;end;
end;
//## SafeStyle ##
Function TPortablePixelmap.SafeStyle(X:Integer):Integer;
begin
try;Result:=FrcRange(X,pphsMin,pphsMax);except;end;
end;
//## IsAscii ##
Function TPortablePixelmap.IsAscii(X:Integer):Boolean;
begin
try;Result:=(X<=pphsAscii);except;end;
end;
//## ReadHeader ##
Function TPortablePixelmap.ReadHeader(X:TStream;Var Y:TPortablePixelmapHeader):Boolean;
Label
     SkipAll,ReDo2,ReDo,SkipEnd;
Var
   A:TByteStream;
   B:TWordBuffer;
   P,Count,Pos,Start,Finish,FindP:Integer;
   FindByte:Byte;
   Z:String;
begin
try
{Error}
Result:=False;
A:=nil;
If (X=nil) then exit;
{A}
A:=TByteStream.Create;
A.Stream:=X;
{Defaults}
Y.Width:=0;
Y.Height:=0;
Y.MaxColor:=0;
Y.Style:=pphsRGBA;
{Other}
Pos:=X.Position;
FindByte:=ppccComment;
Count:=0;
B.Count:=0;
{Scan}
ReDo:
//P1-P6
If A.ReadLine(Pos,-1,Start,Finish,FindByte,FindP) then
   begin
   If (FindP<>-1) then Finish:=FindP-1;
   {Str/Array}
   Case (Count=0) of
   True:Z:=A.Str(Start,Finish);
   False:If Not A.AsciiDecimalToBinary(Start,Finish,-1,B) then Goto ReDo;
   end;//end of case
ReDo2:
   If (Count>0) and (Not A.ReadWordValue(B,P)) then Goto ReDo;
   {Process}
   Case Count of
   0:begin{Style P1-P6}
     Z:=UpperCase(Copy(Z,1,2));
     If (Length(Z)<2) then Goto SkipEnd;
     If (Z[1]<>'P') then Goto SkipEnd;
     {Style Number}
     Y.Style:=SafeStyle(strtoint(Z[2]));
     Count:=Count+1;
     end;//end of begin
   1:begin{Width}
     If (P>0) then
        begin
        Y.Width:=P;
        Count:=Count+1;
        end;//end of begin
     end;//end of begin
   2:begin{Height}
     If (P>0) then
        begin
        Y.Height:=P;
        Count:=Count+1;
        end;//end of begin
     If (Y.Style=pphsMonoA) or (Y.Style=pphsMonoB) then
        begin
        Y.MaxColor:=1;
        X.Position:=Pos;
        Goto SkipAll;
        end;//end of if
     end;//end of begin
   3:begin{MaxColor}
     If (P>=0) then
        begin
        Y.MaxColor:=P;
        Count:=Count+1;
        {Align Stream for Data Read}
        X.Position:=Pos;
        end;//end of begin
     end;//end of begin
    end;//end of case
   {Successful}
   Result:=True;
   {Loop}
   Case Count of
   0:Goto ReDo;
   1..3:Goto ReDo2;
   end;//end of case
   end;//end of if
{Successful}
SkipAll:
Result:=True;
SkipEnd:
except;end;
try;freeObj(@a);except;end;
end;
//## AsciiReader ##
Function TPortablePixelmap.AsciiReader(X:TStream;Var Y:TBitmap;MaxColor:Integer):Boolean;
Label
     PreSkipEnd,SkipEnd,ReDo;
Var
   A:TByteStream;
   B:TWordBuffer;
   C:TByteImage;
   Count,MaxP,P,I,FindP,Start,Finish,Pos:Integer;
   FindByte:Byte;
   Z:TRGBColor;
begin
try
A:=nil;
C:=nil;
If (X=nil) then exit;
{A}
A:=TByteStream.Create;
C:=TByteImage.Create;
C.Image:=Y;
A.Stream:=X;
{Defaults}
Pos:=X.Position;
MaxP:=X.Size;
FindByte:=ppccComment;
B.Count:=0;
I:=0;
Count:=0;
ReDo:
If A.ReadLine(Pos,-1,Start,Finish,FindByte,FindP) then
   begin
   Count:=Count+1;
   If (Count>=40) then
      begin
      {Progress}
      Progressing((Pos+1)*100 Div MaxP,'Loading');
      Count:=0;
      end;//end of if
   If (FindP<>-1) then Finish:=FindP-1;
   {Process Pixels}
   B.Count:=0;
   If A.AsciiDecimalToBinary(Start,Finish,MaxColor,B) then
      begin
      {Mono}
      Case iStyle of
      pphsMonoA:begin
               For P:=(B.Count-1) downTo 0 Do
               begin
               If (B.Items[P]=0) then Z.R:=255 else Z.R:=0;
               Z.G:=Z.R;
               Z.B:=Z.R;
               If Not C.PushPixel(Z) then Goto PreSkipEnd;
               end;//end of loop
               end;//end of begin
      pphsGreyA:begin
               For P:=(B.Count-1) downTo 0 Do
               begin
               Z.R:=FrcMax(B.Items[P],MaxColor);
               Z.G:=Z.R;
               Z.B:=Z.R;
               If Not C.PushPixel(Z) then Goto PreSkipEnd;
               end;//end of loop
               end;//end of begin
      pphsRGBA:begin
               For P:=(B.Count-1) downTo 0 Do
               begin
               Case I of
               0:Z.R:=FrcMax(B.Items[P],MaxColor);
               1:Z.G:=FrcMax(B.Items[P],MaxColor);
               2:begin
                Z.B:=FrcMax(B.Items[P],MaxColor);
                {Push Pixel}
                If Not C.PushPixel(Z) then Goto PreSkipEnd;
                I:=-1;
                end;//end of begin
               end;//end of case
               I:=I+1;
               end;//end of loop
               end;//end of begin
      end;//end of case
      end;//end of if
   Goto ReDo;
   end;//end of if
PreSkipEnd:
{Successful}
Result:=True;
SkipEnd:
except;end;
try;freeObj(@a);freeObj(@c);except;end;
end;
//## BinaryReader ##
Function TPortablePixelmap.BinaryReader(X:TStream;Var Y:TBitmap;MaxColor:Integer):Boolean;
Label
     SkipEnd;
Var
   A:TByteStream;
   B:TByteBuffer;
   C:TByteImage;
   lY,Count,MaxP,MaxW,P2,P,I,Pos:Integer;
   Val:Byte;
   Z:TRGBColor;
   FactorOf8:Boolean;
begin
try
A:=nil;
C:=nil;
If (X=nil) then exit;
{A}
A:=TByteStream.Create;
C:=TByteImage.Create;
C.Image:=Y;
A.Stream:=X;
{Defaults}
Pos:=X.Position;
MaxP:=X.Size-1;
MaxW:=C.ZeroWidth;
Count:=0;
Case iStyle of
pphsMonoB:begin
         {Monochrome}
         FactorOf8:=(((C.Width Div 8)*8)=C.Width);
         //Process Pixels
         For P:=Pos to MaxP Do
         begin
         Count:=Count+1;
         If (Count>=10000) then
            begin
            {Progress}
            Progressing((P+1)*100 Div (MaxP+1),'Loading');
            Count:=0;
            end;//end of if

         Case A.Get(P,Val) of
         False:break;
         True:begin
             {Process Partial Scanline}
             B.Count:=0;
             C.ExpandBits(Val,B);{1byte"8bits" => 8x1byte(0 or 1)}
             For P2:=0 to (B.Count-1) Do
             begin{Round to nearest 8bits}
             If (B.Items[P2]=0) then Z.R:=255 else Z.R:=0;
             Z.G:=Z.R;
             Z.B:=Z.R;
             Ly:=C.Y;
             If Not C.PushPixel(Z) then break;{Special}
             If FactorOf8 and (C.X>=MaxW) then break;
             If (Ly<>C.Y) then break;{Normal}
             end;//end of loop
             end;//end of begin
         end;//end of case
         end;//end of loop
         end;//end of begin
pphsGreyB:begin{Greyscale}
         //Process Pixels
         For P:=Pos to MaxP Do
         begin
         Count:=Count+1;
         If (Count>=10000) then
            begin
            {Progress}
            Progressing((P+1)*100 Div (MaxP+1),'Loading');
            Count:=0;
            end;//end of if

         Case A.Get(P,Val) of
         False:break;
         True:begin
             {Process Partial Scanline}
             Z.R:=FrcMax(Val,MaxColor);
             Z.G:=Z.R;
             Z.B:=Z.R;
             If Not C.PushPixel(Z) then break;
             end;//end of begin
         end;//end of case
         end;//end of loop
         end;//end of begin
pphsRGBB:begin
         //Process Pixels
         I:=0;
         For P:=Pos to MaxP Do
         begin
         Count:=Count+1;
         If (Count>=50000) then
            begin
            {Progress}
            Progressing((P+1)*100 Div (MaxP+1),'Loading');
            Count:=0;
            end;//end of if

         Case A.Get(P,Val) of
         False:break;
         True:begin
             {Process Partial Scanline}
             Case I of
             0:Z.R:=FrcMax(Val,MaxColor);
             1:Z.G:=FrcMax(Val,MaxColor);
             2:begin
               Z.B:=FrcMax(Val,MaxColor);
               {Push Pixel}
               If Not C.PushPixel(Z) then break;
               I:=-1;
               end;//end of begin
             end;//end of case
             I:=I+1;
             end;//end of begin
         end;//end of case
         end;//end of loop
         end;//end of begin
end;//end of case
{Successful}
Result:=True;
SkipEnd:
except;end;
try;freeObj(@a);freeObj(@c);except;end;
end;
//## WriteHeader ##
Function TPortablePixelmap.WriteHeader(X:TStream;Var Y:TPortablePixelmapHeader):Boolean;
Label
     SkipEnd;
Var
   A:TByteStream;
   P,Pos:Integer;
   Z:String;
begin
try
{Error}
Result:=False;
A:=nil;
If (X=nil) then exit;
{A}
A:=TByteStream.Create;
A.Stream:=X;
{Write Header Elements}
Z:='P'+inttostr(Y.Style)+pphsNewLine+inttostr(Y.Width)+' '+inttostr(Y.Height)+pphsNewLine;
{Non-monochrome MaxColor element}
If (Y.Style<>pphsMonoA) and (Y.Style<>pphsMonoB) then Z:=Z+pphsNewLine+inttostr(Y.MaxColor)+pphsNewLine;
Pos:=X.Position;
If Not A.PushStr(Pos,Z) then Goto SkipEnd;
{Align Stream for Data Read}
X.Position:=Pos;
{Successful}
Result:=True;
SkipEnd:
except;end;
try;freeObj(@a);except;end;
end;
//## AsciiWriter ##
Function TPortablePixelmap.AsciiWriter(X:TStream;Var Y:TBitmap):Boolean;
Label
     SkipEnd;
Var
   A:TByteStream;
   C:TByteImage;
   MaxX,MaxY,S,V,rX,rY,Count,P,Pos:Integer;
   Val:Byte;
   B:String;
   Z:TRGBColor;
   Row:PRGBColorRow;
   E:Array[0..1] of Integer;
begin
try
A:=nil;
C:=nil;
If (X=nil) then exit;
{A}
A:=TByteStream.Create;
C:=TByteImage.Create;
C.Image:=Y;
A.Stream:=X;
{Defaults}
Pos:=X.Position;
Count:=0;
MaxY:=C.ZeroHeight;
MaxX:=C.ZeroWidth;

{Write Pixels}
Case iStyle of
pphsMonoA:begin{Monochrome}
         For rY:=0 to MaxY do
         begin
         {Progress}
         Progressing((rY+1)*100 Div (MaxY+1),'Saving');
         Row:=C.Row[rY];
          For rX:=0 to MaxX Do
          begin
          Z:=Row[rX];
          {Red Component}
          If (Z.R=0) then V:=1 else V:=0;
          A.Put(Pos,V+48);
          Pos:=Pos+1;
          A.Put(Pos,32);
          Pos:=Pos+1;
         {Return Code}
         Count:=Count+12;
         If (Count>=72) then
            begin
            Count:=0;
            If Not A.Put(Pos,13) then Goto SkipEnd;
            Pos:=Pos+1;
            If Not A.Put(Pos,10) then Goto SkipEnd;
            Pos:=Pos+1;
            end;//end of if
          end;//end of X loop
         end;//end of Y loop
         end;//end of begin
pphsGreyA:begin{Greyscale}
         For rY:=0 to MaxY do
         begin
         {Progress}
         Progressing((rY+1)*100 Div (MaxY+1),'Saving');
         Row:=C.Row[rY];
          For rX:=0 to MaxX Do
          begin
          Z:=Row[rX];
          {Red Component}
          V:=Z.R;
          {Split Binary 0-255 => Ascii 0-2,5,5}
          E[0]:=V Div 100;{100's}
          If (E[0]<>0) then
             begin
             A.Put(Pos,E[0]+48);
             Pos:=Pos+1;
             end;//end of if
          V:=V-E[0]*100;
          E[1]:=V Div 10;{10's}
          If (E[1]<>0) then
             begin
             A.Put(Pos,E[1]+48);
             Pos:=Pos+1;
             end;//end of if
          V:=V-E[1]*10;
          A.Put(Pos,V+48);
          Pos:=Pos+1;
          A.Put(Pos,32);
          Pos:=Pos+1;
         {Return Code}
         Count:=Count+12;
         If (Count>=72) then
            begin
            Count:=0;
            If Not A.Put(Pos,13) then Goto SkipEnd;
            Pos:=Pos+1;
            If Not A.Put(Pos,10) then Goto SkipEnd;
            Pos:=Pos+1;
            end;//end of if
          end;//end of X loop
         end;//end of Y loop
         end;//end of begin
pphsRGBA:begin{RGB}
         For rY:=0 to MaxY do
         begin
         {Progress}
         Progressing((rY+1)*100 Div (MaxY+1),'Saving');
         Row:=C.Row[rY];
          For rX:=0 to MaxX Do
          begin
          Z:=Row[rX];
          {Red/Green/Blue Component}
          For P:=1 to 3 Do
          begin
          Case P of
          1:V:=Z.R;
          2:V:=Z.G;
          3:V:=Z.B;
          end;//end of case
          {Split Binary 0-255 => Ascii 0-2,5,5}
          E[0]:=V Div 100;{100's}
          If (E[0]<>0) then
             begin
             A.Put(Pos,E[0]+48);
             Pos:=Pos+1;
             end;//end of if
          V:=V-E[0]*100;
          E[1]:=V Div 10;{10's}
          If (E[1]<>0) then
             begin
             A.Put(Pos,E[1]+48);
             Pos:=Pos+1;
             end;//end of if
          V:=V-E[1]*10;
          A.Put(Pos,V+48);
          Pos:=Pos+1;
          A.Put(Pos,32);
          Pos:=Pos+1;
          end;//end of loop
         {Return Code}
         Count:=Count+12;
         If (Count>=72) then
            begin
            Count:=0;
            If Not A.Put(Pos,13) then Goto SkipEnd;
            Pos:=Pos+1;
            If Not A.Put(Pos,10) then Goto SkipEnd;
            Pos:=Pos+1;
            end;//end of if
          end;//end of X loop
         end;//end of Y loop
         end;//end of begin
end;//end of case
{Successful}
Result:=True;
SkipEnd:
except;end;
try;freeObj(@a);freeObj(@c);except;end;
end;
//## BinaryWriter ##
Function TPortablePixelmap.BinaryWriter(X:TStream;Var Y:TBitmap):Boolean;
Label
     SkipEnd;
Var
   A:TByteStream;
   C:TByteImage;
   MaxX,MaxY,V,rX,rY,Count,P,Pos:Integer;
   Val:Byte;
   B:String;
   Z:TRGBColor;
   Row:PRGBColorRow;
   E:Array[0..1] of Integer;
   FactorOf8:Boolean;
begin
try
A:=nil;
C:=nil;
If (X=nil) then exit;
{A}
A:=TByteStream.Create;
C:=TByteImage.Create;
C.Image:=Y;
A.Stream:=X;
{Defaults}
Pos:=X.Position;
Count:=0;
Val:=0;
MaxX:=C.ZeroWidth;
MaxY:=C.ZeroHeight;
{Write Pixels}
Case iStyle of
pphsMonoB:begin{Monochrome}
         {Monochrome}
         FactorOf8:=(((C.Width Div 8)*8)=C.Width);
         For rY:=0 to MaxY do
         begin
         {Progress}
         Progressing((rY+1)*100 Div (MaxY+1),'Saving');
         Row:=C.Row[rY];
          Count:=0;
          Val:=0;
          For rX:=0 to MaxX Do
          begin
          Z:=Row[rX];
          {Collect 8 Pixels}
          Case Count of
          7:If (Z.R=0) then Val:=Val+1;
          6:If (Z.R=0) then Val:=Val+2;
          5:If (Z.R=0) then Val:=Val+4;
          4:If (Z.R=0) then Val:=Val+8;
          3:If (Z.R=0) then Val:=Val+16;
          2:If (Z.R=0) then Val:=Val+32;
          1:If (Z.R=0) then Val:=Val+64;
          0:If (Z.R=0) then Val:=Val+128;
          end;//end of case
          Count:=Count+1;
          If (Count>7) or (rX=MaxX) then
             begin
             If Not A.Put(Pos,Val) then Goto SkipEnd;
             Pos:=Pos+1;
             Val:=0;
             Count:=0;
             end;//end of if
          end;//end of X loop
         If FactorOf8 then
            begin
            If Not A.Put(Pos,Val) then Goto SkipEnd;
            Pos:=Pos+1;
            end;//end of if
         end;//end of Y loop
         end;//end of begin
pphsGreyB:begin{Greyscale}
         For rY:=0 to MaxY do
         begin
         {Progress}
         Progressing((rY+1)*100 Div (MaxY+1),'Saving');
         Row:=C.Row[rY];
          For rX:=0 to MaxX Do
          begin
          Z:=Row[rX];
          If Not A.Put(Pos,Z.R) then Goto SkipEnd;
          Pos:=Pos+1;
          end;//end of X loop
         end;//end of Y loop
         end;//end of begin
pphsRGBB:begin{RGB}
         For rY:=0 to MaxY do
         begin
         {Progress}
         Progressing((rY+1)*100 Div (MaxY+1),'Saving');
         Row:=C.Row[rY];
          For rX:=0 to MaxX Do
          begin
          Z:=Row[rX];
          If Not A.Put(Pos,Z.R) then Goto SkipEnd;
          Pos:=Pos+1;
          If Not A.Put(Pos,Z.G) then Goto SkipEnd;
          Pos:=Pos+1;
          If Not A.Put(Pos,Z.B) then Goto SkipEnd;
          Pos:=Pos+1;
          end;//end of X loop
         end;//end of Y loop
         end;//end of begin
end;//end of case
{Successful}
Result:=True;
SkipEnd:
except;end;
try;freeObj(@a);freeObj(@c);except;end;
end;
//## LoadFromStream ##
Procedure TPortablePixelmap.LoadFromStream(X:TStream);
Label
     SkipEnd;
Var
   A:TPortablePixelmapHeader;
   ErrMsg:String;
begin
try
ErrMsg:=gecOutOfMemory;
Progress(Self,psStarting,0,False,Rect(0,0,Width,Height),'Loading');
{Update}
Update;
{Write Header}
If Not ReadHeader(X,A) then
   begin
   ErrMsg:=gecUnknownFormat;
   Goto SkipEnd;
   end;//end of if
{Check W&H}
If (A.Width=0) or (A.Height<=0) then
   begin
   ErrMsg:=gecIndexOutOfRange;
   Goto SkipEnd;
   end;//end of if
{Implement Header}
iImage.Width:=A.Width;
iImage.Height:=A.Height;
iImage.PixelFormat:=pf24bit;
{Clear}
iImage.Canvas.Brush.Color:=clWhite;
iImage.Canvas.FillRect(Rect(0,0,iImage.Width,iImage.Height));
Style:=A.Style;
{Data}
Case IsAscii(A.Style) of
{Ascii Reader}
True:If Not AsciiReader(X,iImage,A.MaxColor) then Goto SkipEnd;
{Binary Reader}
False:If Not BinaryReader(X,iImage,A.MaxColor) then Goto SkipEnd;
end;//end of case
{No Error}
ErrMsg:='';
SkipEnd:
except;end;
try;Progress(Self,psEnding,100,False,Rect(0,0,Width,Height),'Loading');except;end;
general.raiseerror(errmsg);
end;
//## SaveToStream ##
Procedure TPortablePixelmap.SaveToStream(X:TStream);
Label
     SkipEnd;
Var
   A:TPortablePixelmapHeader;
   ErrMsg:String;
begin
try
ErrMsg:=gecOutOfMemory;
Progress(Self,psStarting,0,False,Rect(0,0,Width,Height),'Saving');
{Update}
Update;
{Set Header}
A.Width:=iImage.Width;
A.Height:=iImage.Height;
A.MaxColor:=255;
A.Style:=Style;
{Write Header}
If Not WriteHeader(X,A) then
   begin
   ErrMsg:=gecTaskFailed;
   Goto SkipEnd;
   end;//end of if
{Data}
Case IsAscii(A.Style) of
{Ascii Writer}
True:If Not AsciiWriter(X,iImage) then Goto SkipEnd;
{Binary Writer}
False:If Not BinaryWriter(X,iImage) then Goto SkipEnd;
end;//end of case
{No Error}
ErrMsg:='';
SkipEnd:
except;end;
try;Progress(Self,psEnding,100,False,Rect(0,0,Width,Height),'Saving');except;end;
general.raiseerror(errmsg);
end;
//## Update ##
Procedure TPortablePixelmap.Update;
begin
try;iImage.PixelFormat:=pf24bit;except;end;
end;
//## SaveToFile ##
Function TPortablePixelmap.SaveToFile(X:String):Boolean;
Label
     SkipEnd;
Var
   iStream:TStream;
begin
try
{Error}
Result:=False;
iStream:=nil;
{Remove File}
iErrorMessage:=gecFileInUse;
If Not RemFile(X) then Goto SkipEnd;
{Create Stream}
iErrorMessage:=gecBadFileName;
iStream:=TFileStream.Create(X,fmCreate);
{SaveToStream}
SaveToStream(iStream);
{Successful}
Result:=True;
SkipEnd:
except;end;
try;freeObj(@iStream);except;end;
end;
//## Progress ##
procedure TPortablePixelmap.Progress(Sender: TObject;Stage:TProgressStage;PercentDone:Byte;RedrawNow:Boolean;const R:TRect;const Msg:string);
begin
try
iLastTimerIndex:=GetCurrentTime;
if Assigned(FOnProgress) then FOnProgress(Sender,Stage,PercentDone,RedrawNow,R,Msg);
except;end;
end;
//## Progressing ##
procedure TPortablePixelmap.Progressing(PercentDone:Byte;const Msg:string);
begin
try
if Not Assigned(FOnProgress) then exit;
If ((GetCurrentTime-iLastTimerIndex)>=250) then
   begin
   Progress(Self,psRunning,PercentDone,False,Rect(0,0,Width,Height),Msg);
   iLastTimerIndex:=GetCurrentTime;
   end;//end of if
except;end;
end;
//## FreeImage ##
Procedure TPortablePixelmap.FreeImage;
begin
try;iImage.FreeImage;except;end;
end;
//## Dormant ##
Procedure TPortablePixelmap.Dormant;
begin
try;iImage.Dormant;except;end;
end;
//## ShowError ##
Procedure TPortablePixelmap.ShowError;
begin
try;ShowError60(translate(iErrorMessage));except;end;
end;

//#################### TOptimisedImage ############################################
//## Create ##
constructor TOptimisedImage.Create;
begin
inherited;
//iimage
iImage:=TBitmap.Create;
iStyle:=omicNil;
//update
update;
end;
//## destroy ##
destructor TOptimisedImage.destroy;
begin
try
freeObj(@iimage);
//self
inherited;
except;end;
end;
//## Draw ##
procedure TOptimisedImage.Draw(ACanvas: TCanvas; const Rect: TRect);
begin;ACanvas.StretchDraw(Rect,iImage);end;
//## GetEmpty ##
function TOptimisedImage.GetEmpty:Boolean;
begin;Result:=iImage.Empty;end;
//## GetHeight ##
function TOptimisedImage.GetHeight:Integer;
begin;Result:=iImage.Height;end;
//## GetWidth ##
function TOptimisedImage.GetWidth:Integer;
begin;Result:=iImage.Width;end;
//## SetHeight ##
procedure TOptimisedImage.SetHeight(Value:Integer);
begin;iImage.Height:=Value;Update;end;
//## SetWidth ##
procedure TOptimisedImage.SetWidth(Value:Integer);
begin;iImage.Width:=Value;Update;end;
//## LoadFromClipboardFormat ##
procedure TOptimisedImage.LoadFromClipboardFormat(AFormat:Word;AData:THandle;APalette:HPALETTE);
begin;iImage.LoadFromClipboardFormat(AFormat,AData,APalette);Update;end;
//## SaveToClipboardFormat ##
procedure TOptimisedImage.SaveToClipboardFormat(var Format: Word; var Data: THandle; var APalette: HPALETTE);
begin;iImage.SaveToClipboardFormat(Format,Data,APalette);Update;end;
//## Update ##
Procedure TOptimisedImage.Update;
begin
try;iImage.PixelFormat:=pf24bit;except;end;
end;
//## Progress ##
procedure TOptimisedImage.Progress(Sender: TObject;Stage:TProgressStage;PercentDone:Byte;RedrawNow:Boolean;const R:TRect;const Msg:string);
begin
try
iLastTimerIndex:=GetCurrentTime;
if Assigned(FOnProgress) then FOnProgress(Sender,Stage,PercentDone,RedrawNow,R,Msg);
except;end;
end;
//## Progressing ##
procedure TOptimisedImage.Progressing(PercentDone:Byte;const Msg:string);
begin
try
if Not Assigned(FOnProgress) then exit;
If ((GetCurrentTime-iLastTimerIndex)>=250) then
   begin
   Progress(Self,psRunning,PercentDone,False,Rect(0,0,Width,Height),Msg);
   iLastTimerIndex:=GetCurrentTime;
   end;//end of if
except;end;
end;
//## Assign ##
Procedure TOptimisedImage.Assign(Source: TPersistent);
Var
   A:TBitmap;
begin
If (Source is TOptimisedImage) then
   begin
   CopyFrom((Source as TOptimisedImage).Image);
   iStyle:=(Source as TOptimisedImage).Style;
   end
else If (Source is TGraphic) then CopyFrom(Source as TGraphic)
else iImage.Assign(Source);
//Update
Update;
end;
//## CopyFrom ##
Procedure TOptimisedImage.CopyFrom(X:TGraphic);
begin
try
//Size
iImage.Width:=X.Width;
iImage.Height:=X.Height;
//Cls
iImage.Canvas.Brush.Color:=clWhite;
iImage.Canvas.FillRect(Rect(0,0,iImage.Width,iImage.Height));
//Paint
iImage.Canvas.Draw(0,0,X);
except;end;
end;
//## FreeImage ##
Procedure TOptimisedImage.FreeImage;
begin
try;iImage.FreeImage;except;end;
end;
//## Dormant ##
Procedure TOptimisedImage.Dormant;
begin
try;iImage.Dormant;except;end;
end;
//## LoadFromFile ##
Function TOptimisedImage.LoadFromFile(X:String):Boolean;
Var
   iStream:TStream;
begin
try
//Error
Result:=False;
iStream:=nil;
//Open Stream
iErrorMessage:=gecFileNotFound;
If Not FileExists(X) then exit;
iErrorMessage:=gecFileInUse;
iStream:=TFileStream.Create(X,fmOpenRead+fmShareDenyNone);
//LoadFromStream
LoadFromStream(iStream);
//Successful
Result:=True;
except;end;
try;iStream.Free;except;end;
end;
//## SaveToFile ##
Function TOptimisedImage.SaveToFile(X:String):Boolean;
Label
     SkipEnd;
Var
   iStream:TStream;
begin
try
//Error
Result:=False;
iStream:=nil;
//Remove File
iErrorMessage:=gecFileInUse;
If Not RemFile(X) then Goto SkipEnd;
//Create Stream
iErrorMessage:=gecBadFileName;
iStream:=TFileStream.Create(X,fmCreate);
//SaveToStream
SaveToStream(iStream);
//Successful
Result:=True;
SkipEnd:
except;end;
try;iStream.Free;except;end;
end;
//## LoadFromStream ##
Procedure TOptimisedImage.LoadFromStream(X:TStream);
Label
     SkipEnd;
Var
   Z,ErrMsg:String;
   m:tstreamstr;
begin
try
ErrMsg:=gecOutOfMemory;
Progress(Self,psStarting,0,False,Rect(0,0,Width,Height),'Loading');
z:='';
m:=tstreamstr.create(@z);
//Process
//Load
m.CopyFrom(x,x.size-x.position);
//_SetData
If Not _SetData(Z) then
   begin
   ErrMsg:=iErrorMessage;
   Goto SkipEnd;
   end;//end of if
//No Error
ErrMsg:='';
SkipEnd:
except;end;
try;freeobj(@m);except;end;
try;Progress(Self,psEnding,100,False,Rect(0,0,Width,Height),'Loading');except;end;
general.raiseerror(errmsg);
end;
//## GetData ##
Function TOptimisedImage.GetData:String;
begin
try;_GetData(Result);except;end;
end;
//## WriteStrVal ##
Function TOptimisedImage.WriteStrVal(Var X,Val:String):Boolean;
begin
try
{Error}
Result:=False;
{Process}
X:=X+From32Bit(Length(Val))+Val;
{Successful}
Result:=True;
except;end;
end;
//## ReadStrVal ##
Function TOptimisedImage.ReadStrVal(Var Pos:Integer;Var X,Val:String):Boolean;
Var
   Len:Integer;
begin
try
{Error}
Result:=False;
{Prepare}
Len:=To32Bit(Copy(X,Pos,4));
If (Len<0) then exit;
{Process}
Val:=Copy(X,Pos+4,Len);
{Increment Pos}
Pos:=Pos+4+Len;
{Successful}
Result:=(Length(Val)=Len);
except;end;
end;
//## _GetData ##
Function TOptimisedImage._GetData(Var X:String):Boolean;
Label
     SkipEnd;
Var
   Z,Xstyle,ErrMsg:String;
begin
try
//Error
Result:=False;
iErrorMessage:=gecOutOfMemory;
X:='';
//Update
Update;
//Header
X:=omicOMIV1+#0;
//Comment
If Not WriteStrVal(X,iComment) then Goto SkipEnd;
//ExtraInfo1
If Not WriteStrVal(X,iExtraInfo1) then Goto SkipEnd;
//ExtraInfo2
If Not WriteStrVal(X,iExtraInfo2) then Goto SkipEnd;
//Smallest Image
If Not _SmallestImageStr(iImage,Z,Xstyle) then Goto SkipEnd;
//Style
If Not WriteStrVal(X,Xstyle) then Goto SkipEnd;
//Image
If Not WriteStrVal(X,Z) then Goto SkipEnd;
Z:='';
//Successful
Result:=True;
SkipEnd:
except;end;
try;If Not Result then X:='';except;end;
end;
//## SetData ##
Procedure TOptimisedImage.SetData(X:String);
begin
try;_SetData(X);except;end;
end;
//## Clear ##
Procedure TOptimisedImage.Clear;
begin
try
//Info
iStyle:=omicNil;
iComment:='';
iExtraInfo1:='';
iExtraInfo2:='';
//Cls
iImage.Width:=300;
iImage.Height:=300;
iImage.Canvas.Brush.Color:=clWhite;
iImage.Canvas.FillRect(Rect(0,0,iImage.Width,iImage.Height));
except;end;
end;
//## _SetData ##
Function TOptimisedImage._SetData(X:String):Boolean;
Label
     SkipEnd;
Var
   Pos,MaxP,P:Integer;
   Y,ErrMsg:String;
   A:TJpegImage;
   m:tstreamstr;
   C:TBitmap;
begin
try
//Error
Result:=False;
iErrorMessage:=gecOutOfMemory;
A:=nil;
C:=nil;
m:=nil;
//Update
Update;
//Prepare
Y:='';
MaxP:=Length(X);
For P:=1 to MaxP Do If (X[P]=#0) then
    begin
    Y:=Copy(X,1,P-1);
    X:=Copy(X,P+1,MaxP);
    break;
    end;//end of if
//Header
iErrorMessage:=gecUnknownFormat;
If (Y<>omicOMIV1) then Goto SkipEnd;
//Info
Pos:=1;
//Comment
If Not ReadStrVal(Pos,X,iComment) then Goto SkipEnd;
//ExtraInfo1
If Not ReadStrVal(Pos,X,iExtraInfo1) then Goto SkipEnd;
//ExtraInfo2
If Not ReadStrVal(Pos,X,iExtraInfo2) then Goto SkipEnd;
//Style
If Not ReadStrVal(Pos,X,iStyle) then Goto SkipEnd;
If Not ((iStyle=omicJPG) or (iStyle=omicBMP)) then Goto SkipEnd;
//Data
If Not ReadStrVal(Pos,X,Y) then Goto SkipEnd;
//Load
C:=TBitmap.Create;
//Bitmap
If (iStyle=omicBMP) then
   begin
   If Not UnzipStr(Y,iErrorMessage,false) then Goto SkipEnd;
   m:=tstreamstr.create(@y);
   m.Position:=0;
   C.LoadFromStream(m);
   end
//Jpeg
else If (iStyle=omicJPG) then
   begin
   m:=tstreamstr.create(@y);
   m.Position:=0;
   A:=TJpegImage.Create;
   A.LoadFromStream(m);
   C.Assign(A);//Must assign - paint failure otherwise
   end;//end of if
freeobj(@a);
freeobj(@m);
y:='';
//Set
iImage.Width:=C.Width;
iImage.Height:=C.Height;
iImage.Canvas.Draw(0,0,C);
freeobj(@c);
//Successful
Result:=True;
SkipEnd:
except;end;
try
freeobj(@a);
freeobj(@c);
freeobj(@m);
except;end;
try;If Not Result then Clear;except;end;
end;
//## SaveToStream ##
Procedure TOptimisedImage.SaveToStream(X:TStream);
Label
     SkipEnd;
Var
   Z,ErrMsg:String;
   m:tstreamstr;
begin
try
ErrMsg:=gecOutOfMemory;
Progress(Self,psStarting,0,False,Rect(0,0,Width,Height),'Saving');
Z:='';
m:=nil;
//Process
//_GetData
If Not _GetData(Z) then
   begin
   ErrMsg:=iErrorMessage;
   Goto SkipEnd;
   end;//end of if
//Save
m:=tstreamstr.create(@z);
X.CopyFrom(m,0);
freeobj(@m);
z:='';
//No Error
ErrMsg:='';
SkipEnd:
except;end;
try;freeobj(@m);except;end;
try;Progress(Self,psEnding,100,False,Rect(0,0,Width,Height),'Saving');except;end;
general.raiseerror(errmsg);
end;
//## _SmallestImageStr ##
Function TOptimisedImage._SmallestImageStr(X:TBitmap;Var Y,Ztype:String):Boolean;
Label
     ReDo,SkipEnd;
Const
     Zmin=20;
     Zmax=90;
     Zsize=12000;//12K
Var
   e,A,B:String;
   Alen,B1,B2,Z2,Z,Zpert:Integer;
begin
try
//Error
Result:=False;
iErrorMessage:=gecOutOfMemory;
Ztype:=omicNil;
//nil = Empty
Y:='';
If (X=nil) then
   begin
   Result:=True;
   exit;
   end;//end of if
//Process
//BMP
If Not ccs.bmpstr(X,A,e) then Goto SkipEnd;
If Not ZipStr(A,iErrorMessage,false) then Goto SkipEnd;
ALen:=Length(A);
//JPG - optimized
Zpert:=Zmin;
Z:=Zmin;
ReDo:
if not ccs.jpgstr(x,b,z,e) then goto skipend;
Case (Z=Zmin) of
True:begin
    B1:=Length(B);
    B2:=B1;
    end;//end of begin
False:B2:=Length(B);
end;//end of case
//Best Image - within 5KB of original sample (aslong as smaller than Zipped BMP
If ((Z=Zmin) or ((B2-B1)<=Zsize)) and (Z<Zmax) and (B1<ALen) and (B2<ALen) then
   begin
   Z:=FrcRange(Z+10,Zpert,ZMax);
   Goto ReDo;
   end;//end of if
//Decide
Case (Alen<Length(B)) of
True:begin
    Y:=A;
    Ztype:=omicBMP;
    end;//end of begin
False:begin
    Y:=B;
    Ztype:=omicJPG;
    end;//end of begin
end;//end of case
//Successful
Result:=True;
SkipEnd:
except;end;
end;
//## SaveJPG ##
function TOptimisedImage.SaveJPG(x:tbitmap;y:string;var e:string):boolean;
label
     redo, skipend;
const
     Zmin=20;
     Zmax=90;
     Zsize=12000;//12K
var
   b:string;
   B1,B2,Z2,Z,Zpert:Integer;
begin
try
//error
result:=false;
//check
e:=gecUnexpectedError;
if (x=nil) then exit;
//process
Zpert:=Zmin;
Z:=Zmin;
redo:
if not ccs.jpgstr(x,b,z,e) then goto skipend;
case (Z=Zmin) of
true:begin
    B1:=Length(B);
    B2:=B1;
    end;//end of begin
false:B2:=Length(B);
end;//end of case
//Best Image - within 5KB of original sample (aslong as smaller than Zipped BMP
if ((Z=Zmin) or ((B2-B1)<=Zsize)) and (Z<Zmax) then
   begin
   Z:=FrcRange(Z+10,Zpert,ZMax);
   goto redo;
   end;//end of if
//write
if not io.tofile(y,b,e) then goto skipend;
//successful
result:=true;
skipend:
except;end;
end;
//## ShowError ##
Procedure TOptimisedImage.ShowError;
begin
try;ShowError60(translate(iErrorMessage));except;end;
end;

//## tfilters ##################################################################
procedure fbinit;
var
   dx,dy,v,p:integer;
begin
try
//check
if fbinited then exit else fbinited:=true;
//get
//.fb255
for p:=low(fb255) to high(fb255) do
begin
v:=p;
if (p<0) then v:=0
else if (p>255) then v:=255;
fb255[p]:=byte(v);
end;//end of loop
//.fbwrap255
for p:=low(fbwrap255) to high(fbwrap255) do
begin
v:=p;
 repeat
 if (v>255) then dec(v,255)
 else if (v<0) then inc(v,255)
 until (v>=0) and (v<=255);
fbwrap255[p]:=byte(v);
end;//end of loop
except;end;
end;
//-- Basic ---------------------------------------------------------------------
//## fbNone ##
procedure fbNone(var r,g,b:byte);
begin
//nil
end;
//## fbWhite ##
procedure fbWhite(var r,g,b:byte);
begin
r:=255;
g:=255;
b:=255;
end;
//## fbBlack ##
procedure fbBlack(var r,g,b:byte);
begin
r:=0;
g:=0;
b:=0;
end;
//## fbGrey ##
procedure fbGrey(var r,g,b:byte);
begin
r:=128;
g:=128;
b:=128;
end;
//## fbBW ##
procedure fbBW(var r,g,b:byte);
var
   v:byte;
begin
//get
v:=r;
if (g>v) then v:=g;
if (b>v) then v:=b;
//set
if (v<=10) then
   begin
   r:=0;
   g:=0;
   b:=0;
   end
else
   begin
   r:=255;
   g:=255;
   b:=255;
   end;//end of if
end;
//## fbBW2 ##
procedure fbBW2(var r,g,b:byte);
var
   v:byte;
begin
//get
v:=r;
if (g>v) then v:=g;
if (b>v) then v:=b;
//set
if (v<=50) then
   begin
   r:=0;
   g:=0;
   b:=0;
   end
else
   begin
   r:=255;
   g:=255;
   b:=255;
   end;//end of if
end;
//## fbBW3 ##
procedure fbBW3(var r,g,b:byte);
var
   v:byte;
begin
//get
v:=r;
if (g>v) then v:=g;
if (b>v) then v:=b;
//set
if (v<=128) then
   begin
   r:=0;
   g:=0;
   b:=0;
   end
else
   begin
   r:=255;
   g:=255;
   b:=255;
   end;//end of if
end;
//## fbBW4 ##
procedure fbBW4(var r,g,b:byte);
var
   v:byte;
begin
//get
v:=r;
if (g>v) then v:=g;
if (b>v) then v:=b;
//set
if (v>=128) then
   begin
   r:=0;
   g:=0;
   b:=0;
   end
else
   begin
   r:=255;
   g:=255;
   b:=255;
   end;//end of if
end;
//## fbBW5 ##
procedure fbBW5(var r,g,b:byte);
var
   v:byte;
begin
//get
v:=r;
if (g>v) then v:=g;
if (b>v) then v:=b;
//set
if (v>=205) then
   begin
   r:=0;
   g:=0;
   b:=0;
   end
else
   begin
   r:=255;
   g:=255;
   b:=255;
   end;//end of if
end;
//## fbBW6 ##
procedure fbBW6(var r,g,b:byte);
var
   v:byte;
begin
//get
v:=r;
if (g>v) then v:=g;
if (b>v) then v:=b;
//set
if (v>=245) then
   begin
   r:=0;
   g:=0;
   b:=0;
   end
else
   begin
   r:=255;
   g:=255;
   b:=255;
   end;//end of if
end;
//## fbBW7 ##
procedure fbBW7(var r,g,b:byte);
begin
//get
if (r<251) or (g<251) or (b<251) then
   begin
   r:=0;
   g:=0;
   b:=0;
   end
else
   begin
   r:=255;
   g:=255;
   b:=255;
   end;//end of if
end;
//## fbBW8 ##
procedure fbBW8(var r,g,b:byte);
var
   v:byte;
begin
//get
v:=r;
if (g>v) then v:=g;
if (b>v) then v:=b;
//set
if (v<=50) or (v>=205) then
   begin
   r:=0;
   g:=0;
   b:=0;
   end
else
   begin
   r:=255;
   g:=255;
   b:=255;
   end;//end of if
end;
//## fbBW9 ##
procedure fbBW9(var r,g,b:byte);
var
   v:byte;
begin
//get
v:=(r+g+b) div 3;
//set
if (v<127) then
   begin
   r:=0;
   g:=0;
   b:=0;
   end
else
   begin
   r:=255;
   g:=255;
   b:=255;
   end;//end of if
end;
//## fbBW10 ##
procedure fbBW10(var r,g,b:byte);
var
   v:byte;
begin
//get
v:=(r+g+b) div 3;
//set
if (v>=127) then//inverse of "fbBW9"
   begin
   r:=0;
   g:=0;
   b:=0;
   end
else
   begin
   r:=255;
   g:=255;
   b:=255;
   end;//end of if
end;
//## fbGreyscale ##
procedure fbGreyscale(var r,g,b:byte);
var
   v:byte;
begin
//get
v:=r;
if (g>v) then v:=g;
if (b>v) then v:=b;
//set
r:=v;
g:=v;
b:=v;
end;
//## fbGreyscale2 ##
procedure fbGreyscale2(var r,g,b:byte);
var
   v:byte;
begin
//get
v:=(r+round(g*0.90)+round(b*0.75)) div 3;
if (v<20) then v:=20
else if (v>230) then v:=230;
//set
r:=v;
g:=v;
b:=v;
end;
//## fbGreyscale3 ##
procedure fbGreyscale3(var r,g,b:byte);
var
   v:byte;
begin
//get
v:=((r+g+b) div 3);
//set
r:=v;
g:=v;
b:=v;
end;
//## fbRed ##
procedure fbRed(var r,g,b:byte);
begin
g:=0;
b:=0;
end;
//## fbBlue ##
procedure fbBlue(var r,g,b:byte);
begin
r:=0;
g:=0;
end;
//## fbGreen ##
procedure fbGreen(var r,g,b:byte);
begin
r:=0;
b:=0;
end;
//## fbCyan ##
procedure fbCyan(var r,g,b:byte);
begin
r:=255-r;//c
b:=255;
g:=255;
end;
//## fbYellow ##
procedure fbYellow(var r,g,b:byte);
begin
r:=255;
b:=255-b;//y
g:=255;
end;
//## fbMagenta ##
procedure fbMagenta(var r,g,b:byte);
begin
r:=255;
b:=255;
g:=255-g;//m
end;
//## fbShift ##
procedure fbShift(var r,g,b:byte);
var
   tmpr:byte;
begin
tmpr:=r;
r:=b;
b:=g;
g:=tmpr;
end;
//## fbShift2 ##
procedure fbShift2(var r,g,b:byte);
var
   tmpr:byte;
begin
tmpr:=r;
r:=g;
g:=b;
b:=tmpr;
end;
//## fbInvert ##
procedure fbInvert(var r,g,b:byte);
begin
r:=255-r;
g:=255-g;
b:=255-b;
end;
//## fbLum ##
procedure fbLum(var r,g,b:byte);
const
   dv=0.4705882;//240/(255*2)
var
   vmax,vmin:byte;
begin
//get
//.max
vmax:=r;
if (g>vmax) then vmax:=g;
if (b>vmax) then vmax:=b;
//.min
vmin:=r;
if (g<vmin) then vmin:=g;
if (b<vmin) then vmin:=b;
//.lum
r:=fb255[round(vmax*dv+vmin*dv)];
g:=r;
b:=r;
end;
//## fbFlat ##
procedure fbFlat(var r,g,b:byte);
var
   v:byte;
begin
r:=127+(r div 5)+v-25;
g:=127+(g div 5)+v-25;
b:=127+(b div 5)+v-25;
end;
//## fbWarp ##
procedure fbWarp(var r,g,b:byte);
var
   v2,v:byte;
begin
//get
v:=r;
if (g>v) then v:=g;
if (b>v) then v:=b;
v2:=(r+g+b) div 3;
v:=fb255[v-v2];
//set
r:=fb255[r+v];
g:=fb255[g+v];
b:=fb255[b+v];
end;
//## fbTie ##
procedure fbTie(var r,g,b:byte);
var
   v:byte;
begin
//get
v:=r;
if (g>v) then v:=g;
if (b>v) then v:=b;
//set
r:=byte(v*r div 255);
g:=byte(v*g div 255);
b:=byte(v*b div 255);
end;
//## fbMix ##
procedure fbMix(var r,g,b:byte);
var
   sr,sg,sb:byte;
begin
sr:=byte(round(r*0.25)+round(g*0.50)+round(b*0.25));
sg:=byte(round(g*0.25)+round(b*0.50)+round(r*0.25));
sb:=byte(round(b*0.25)+round(r*0.50)+round(g*0.25));
r:=sr;
g:=sg;
b:=sb;
end;
//## fbFaded ##
procedure fbFaded(var r,g,b:byte);
var
   v:byte;
begin
//get
v:=r;
if (g>v) then v:=g;
if (b>v) then v:=b;
//set
r:=v;
g:=byte(round(v*0.90));
b:=byte(round(v*0.70));
end;
//## fbSepia ##
procedure fbSepia(var r,g,b:byte);
var//Sepia base color is "128,91,36"
   v1,v2,v3:integer;
begin
//get
v1:=128;
v2:=r;
if (g>v2) then v2:=g;
if (b>v2) then v2:=b;
v3:=v1-v2;
//set
r:=fb255[128-v3];
g:=fb255[91-v3];
b:=fb255[36-v3];
end;
//## fbSepia2 ##
procedure fbSepia2(var r,g,b:byte);
var//Sepia base color is "124,55,14"
   v1,v2,v3:integer;
begin
//get
v1:=77;
v2:=r;
if (g>v2) then v2:=g;
if (b>v2) then v2:=b;
v3:=v1-v2;
//set
r:=fb255[124-v3];
g:=fb255[55-v3];
b:=fb255[14-v3];
end;
//## fbSepia3 ##
procedure fbSepia3(var r,g,b:byte);
var//Sepia base color is "90,59,30"
   v1,v2,v3:integer;
begin
//get
v1:=90;
v2:=r;
if (g>v2) then v2:=g;
if (b>v2) then v2:=b;
v3:=v1-v2;
//set
r:=fb255[90-v3];
g:=fb255[59-v3];
b:=fb255[44-v3];
end;
//## fbSepia4 ##
procedure fbSepia4(var r,g,b:byte);
var
   v:byte;
begin
//get
v:=r;
if (g>v) then v:=g;
if (b>v) then v:=b;
//set
r:=v;
g:=byte(round(v*0.87));
b:=byte(round(v*0.30));
end;
//## fbSepia5 ##
procedure fbSepia5(var r,g,b:byte);//Microsoft's
var
   sr,sg,sb:byte;
begin
sr:=byte(round((r*0.393+g*0.769+b*0.189)/1.351));
sg:=byte(round((r*0.349+g*0.686+b*0.168)/1.203));
sb:=byte(round((r*0.272+g*0.534+b*0.131)/2.140));
r:=sr;
g:=sg;
b:=sb;
end;
//## fbShadowMore ##
procedure fbShadowMore(var r,g,b:byte);
var
   v:byte;
begin
//get
v:=r;
if (g>v) then v:=g;
if (b>v) then v:=b;
//set
if (v<=90) then
   begin
   v:=91-v;//1..20
   if (v>20) then v:=20;
   r:=fb255[r-v];
   g:=fb255[g-v];
   b:=fb255[b-v];
   end;//end of if
end;
//## fbShadowLess ##
procedure fbShadowLess(var r,g,b:byte);
var
   v:byte;
begin
//get
v:=r;
if (g>v) then v:=g;
if (b>v) then v:=b;
//set
if (v<=90) then
   begin
   v:=91-v;//1..20
   if (v>20) then v:=20;
   r:=fb255[r+v];
   g:=fb255[g+v];
   b:=fb255[b+v];
   end;//end of if
end;
//## fbHighlightMore ##
procedure fbHighlightMore(var r,g,b:byte);
var
   v:byte;
begin
//get
v:=r;
if (g>v) then v:=g;
if (b>v) then v:=b;
//set
if (v>=165) then
   begin
   v:=v-164;//1..20
   if (v>20) then v:=20;
   r:=fb255[r+v];
   g:=fb255[g+v];
   b:=fb255[b+v];
   end;//end of if
end;
//## fbHighlightLess ##
procedure fbHighlightLess(var r,g,b:byte);
var
   v:byte;
begin
//get
v:=r;
if (g>v) then v:=g;
if (b>v) then v:=b;
//set
if (v>=165) then
   begin
   v:=v-164;//1..20
   if (v>20) then v:=20;
   r:=fb255[r-v];
   g:=fb255[g-v];
   b:=fb255[b-v];
   end;//end of if
end;
//## fbMidtoneMore ##
procedure fbMidtoneMore(var r,g,b:byte);
var
   v:byte;
begin
//get
v:=r;
if (g>v) then v:=g;
if (b>v) then v:=b;
//set
if (v>90) and (v<165) then
   begin
   //range
   if (v<146) then
      begin
      v:=v-90;//1..20
      if (v>20) then v:=20;
      end
   else v:=20+(145-v);//20..1
   //set
   r:=fb255[r+v];
   g:=fb255[g+v];
   b:=fb255[b+v];
   end;//end of if
end;
//## fbMidtoneLess ##
procedure fbMidtoneLess(var r,g,b:byte);
var
   v:byte;
begin
//get
v:=r;
if (g>v) then v:=g;
if (b>v) then v:=b;
//set
if (v>90) and (v<165) then
   begin
   //range
   if (v<146) then
      begin
      v:=v-90;//1..20
      if (v>20) then v:=20;
      end
   else v:=20+(145-v);//20..1
   //set
   r:=fb255[r-v];
   g:=fb255[g-v];
   b:=fb255[b-v];
   end;//end of if
end;
//## fbBrighten ##
procedure fbBrighten(var r,g,b:byte);
begin
r:=fb255[round(r*1.1)];
g:=fb255[round(g*1.1)];
b:=fb255[round(b*1.1)];
end;
//## fbBrighten2 ##
procedure fbBrighten2(var r,g,b:byte);
begin
r:=fb255[round(r*1.25)];
g:=fb255[round(g*1.25)];
b:=fb255[round(b*1.25)];
end;
//## fbBrighten3 ##
procedure fbBrighten3(var r,g,b:byte);
begin
r:=fb255[round(r*1.5)];
g:=fb255[round(g*1.5)];
b:=fb255[round(b*1.5)];
end;
//## fbDarken ##
procedure fbDarken(var r,g,b:byte);
begin
r:=fb255[round(r*0.9)];
g:=fb255[round(g*0.9)];
b:=fb255[round(b*0.9)];
end;
//## fbDarken2 ##
procedure fbDarken2(var r,g,b:byte);
begin
r:=fb255[round(r*0.75)];
g:=fb255[round(g*0.75)];
b:=fb255[round(b*0.75)];
end;
//## fbDarken3 ##
procedure fbDarken3(var r,g,b:byte);
begin
r:=fb255[round(r*0.5)];
g:=fb255[round(g*0.5)];
b:=fb255[round(b*0.5)];
end;
//## fbNoise ##
procedure fbNoise(var r,g,b:byte);
var
   tmp:byte;
begin
tmp:=random(7);
r:=fb255[round(r+(tmp-3))];
g:=fb255[round(g+(tmp-3))];
b:=fb255[round(b+(tmp-3))];
end;
//## fbNoise2 ##
procedure fbNoise2(var r,g,b:byte);
var
   tmp:byte;
begin
tmp:=random(17);
r:=fb255[round(r+(tmp-8))];
g:=fb255[round(g+(tmp-8))];
b:=fb255[round(b+(tmp-8))];
end;
//## fbNoise3 ##
procedure fbNoise3(var r,g,b:byte);
var
   tmp:byte;
begin
tmp:=random(41);
r:=fb255[round(r+(tmp-20))];
g:=fb255[round(g+(tmp-20))];
b:=fb255[round(b+(tmp-20))];
end;
//## fbFudge ##
procedure fbFudge(var r,g,b:byte);
var
   v1,v2,v3:integer;
begin
v1:=90;
v2:=r;
if (g>v2) then v2:=g;
if (b>v2) then v2:=b;
v3:=v1-v2;
if (v3<0) then v3:=-v3;
//set
r:=fb255[r-v3];
g:=fb255[g-v3];
b:=fb255[b-v3];
end;
//## fbWrapUp ##
procedure fbWrapUp(var r,g,b:byte);
var
   v:integer;
begin
v:=r;
if (g>v) then v:=g;
if (b>v) then v:=b;
r:=fbwrap255[r+v];
g:=fbwrap255[g+v];
b:=fbwrap255[b+v];
end;
//## fbWrapDown ##
procedure fbWrapDown(var r,g,b:byte);
var
   v:integer;
begin
v:=r;
if (g>v) then v:=g;
if (b>v) then v:=b;
r:=fbwrap255[r-v];
g:=fbwrap255[g-v];
b:=fbwrap255[b-v];
end;
//## fbShades ##
procedure fbShades(var r,g,b:byte);
var
   v:byte;
begin
v:=25;
r:=(r div v)*v;
g:=(g div v)*v;
b:=(b div v)*v;
end;
//## fbShades2 ##
procedure fbShades2(var r,g,b:byte);
var
   v:byte;
begin
v:=70;
r:=(r div v)*v;
g:=(g div v)*v;
b:=(b div v)*v;
end;
//## fbShades3 ##
procedure fbShades3(var r,g,b:byte);
var
   v:byte;
begin
v:=120;
r:=(r div v)*v;
g:=(g div v)*v;
b:=(b div v)*v;
end;
//## fbShades4 ##
procedure fbShades4(var r,g,b:byte);
var
   v:byte;
begin
v:=150;
r:=(r div v)*v;
g:=(g div v)*v;
b:=(b div v)*v;
end;
//## fbStretchUp ##
procedure fbStretchUp(var r,g,b:byte);
var
   v:integer;
begin
//get
v:=r;
if (g>v) then v:=g;
if (b>v) then v:=b;
if (v<128) then v:=round((127-v)*1.2) else v:=round((v-128)*1.2);
//set
r:=fb255[r+v];
g:=fb255[g+v];
b:=fb255[b+v];
end;
//## fbStretchDown ##
procedure fbStretchDown(var r,g,b:byte);
var
   v:integer;
begin
//get
v:=r;
if (g>v) then v:=g;
if (b>v) then v:=b;
if (v<128) then v:=round((127-v)*1.2) else v:=round((v-128)*1.2);
//set
r:=fb255[r-v];
g:=fb255[g-v];
b:=fb255[b-v];
end;
//-- Action --------------------------------------------------------------------
//## faRGBchange ##
function faRGBchange(d:tbitmap;v1,v2:integer;var rtc:integer;var tc,stc:trgbcolor;var e:string):boolean;
begin
result:=true;
//nil - handled by caller
end;
//## faRotate ##
function faRotate(d:tbitmap;v1,v2:integer;var rtc:integer;var tc,stc:trgbcolor;var e:string):boolean;
begin
result:=ccs.rotateby(d,v1,e);
end;
//## faFlip ##
function faFlip(d:tbitmap;v1,v2:integer;var rtc:integer;var tc,stc:trgbcolor;var e:string):boolean;
begin
result:=ccs.flip(d,e);
end;
//## faMirror ##
function faMirror(d:tbitmap;v1,v2:integer;var rtc:integer;var tc,stc:trgbcolor;var e:string):boolean;
begin
result:=ccs.mirror(d,e);
end;
//## faTrim ##
function faTrim(d:tbitmap;v1,v2:integer;var rtc:integer;var tc,stc:trgbcolor;var e:string):boolean;
begin
result:=ccs.edgetrim(d,0,e);
end;
//## faZoom ##
function faZoom(d:tbitmap;v1,v2:integer;var rtc:integer;var tc,stc:trgbcolor;var e:string):boolean;
begin
result:=ccs.zoomex(d,v1,v2,e);
end;
//## faNoTrans ##
function faNoTrans(d:tbitmap;v1,v2:integer;var rtc:integer;var tc,stc:trgbcolor;var e:string):boolean;
begin
rtc:=clNone;
end;
//## faTrans ##
function faTrans(d:tbitmap;v1,v2:integer;var rtc:integer;var tc,stc:trgbcolor;var e:string):boolean;
begin
fs.rti(d,point(0,0),rtc,tc,stc);
end;
//## faTrans4 ##
function faTrans4(d:tbitmap;v1,v2:integer;var rtc:integer;var tc,stc:trgbcolor;var e:string):boolean;
begin
fs.rti(d,point(-1,-1),rtc,tc,stc);
end;
//## faTransColor ##
function faTransColor(d:tbitmap;v1,v2:integer;var rtc:integer;var tc,stc:trgbcolor;var e:string):boolean;
begin
rtc:=v1;
ccs.safetransinfo(rtc,tc,stc);
end;
//-- Reference -----------------------------------------------------------------
//## frStart ##
function frStart(d:tbitmap;var ref:tbitmap;var refmode:byte;var e:string):boolean;
begin
//defaults
result:=false;
//get
refmode:=0;
freeobj(@ref);
//set
e:=gecOutOfMemory;
ref:=ccs.newbmp(1,1);
result:=ccs.copybmp(ref,d);
if result then refmode:=1;//start
end;
//## frEnd ##
function frEnd(d:tbitmap;var ref:tbitmap;var refmode:byte;var e:string):boolean;
begin
result:=true;
refmode:=0;
end;
//## frUse ##
function frUse(d:tbitmap;var ref:tbitmap;var refmode:byte;var e:string):boolean;
begin
result:=true;
refmode:=0;
if (ref<>nil) then refmode:=2;
end;
//-- Matrix --------------------------------------------------------------------
//## fmMatrix3 ##
procedure fmMatrix3(var r,g,b:byte;var f:tfiltermatrixinfo;var fv:tfiltermatrixvals;var x:integer;pr:array of pdlRGB);
var//trgbcolor=raw(b,g,r)
   dx,px,p,dr,dg,db:integer;
begin
//get
dr:=0;
dg:=0;
db:=0;
px:=x*3;
//calc
//.top row
p:=longint(pr[0])+px;
if (f.v[0]<>0) then
   begin
   db:=db+fv[0][pbyte(p+0)^];
   dg:=dg+fv[0][pbyte(p+1)^];
   dr:=dr+fv[0][pbyte(p+2)^];
   end;
if (f.v[1]<>0) then
   begin
   db:=db+fv[1][pbyte(p+3)^];
   dg:=dg+fv[1][pbyte(p+4)^];
   dr:=dr+fv[1][pbyte(p+5)^];
   end;
if (f.v[2]<>0) then
   begin
   db:=db+fv[2][pbyte(p+6)^];
   dg:=dg+fv[2][pbyte(p+7)^];
   dr:=dr+fv[2][pbyte(p+8)^];
   end;
//.middle row
p:=longint(pr[1])+px;
if (f.v[3]<>0) then
   begin
   db:=db+fv[3][pbyte(p+0)^];
   dg:=dg+fv[3][pbyte(p+1)^];
   dr:=dr+fv[3][pbyte(p+2)^];
   end;
if (f.v[4]<>0) then
   begin
   db:=db+fv[4][pbyte(p+3)^];
   dg:=dg+fv[4][pbyte(p+4)^];
   dr:=dr+fv[4][pbyte(p+5)^];
   end;
if (f.v[5]<>0) then
   begin
   db:=db+fv[5][pbyte(p+6)^];
   dg:=dg+fv[5][pbyte(p+7)^];
   dr:=dr+fv[5][pbyte(p+8)^];
   end;
//.bottom row
p:=longint(pr[2])+px;
if (f.v[6]<>0) then
   begin
   db:=db+fv[6][pbyte(p+0)^];
   dg:=dg+fv[6][pbyte(p+1)^];
   dr:=dr+fv[6][pbyte(p+2)^];
   end;
if (f.v[7]<>0) then
   begin
   db:=db+fv[7][pbyte(p+3)^];
   dg:=dg+fv[7][pbyte(p+4)^];
   dr:=dr+fv[7][pbyte(p+5)^];
   end;
if (f.v[8]<>0) then
   begin
   db:=db+fv[8][pbyte(p+6)^];
   dg:=dg+fv[8][pbyte(p+7)^];
   dr:=dr+fv[8][pbyte(p+8)^];
   end;
//set - Note: faster to use "if else if then" then to use a large lookup array of 128K items or more
dr:=(dr div f.vdiv)+f.vbias;
dg:=(dg div f.vdiv)+f.vbias;
db:=(db div f.vdiv)+f.vbias;
if (dr<0) then dr:=0 else if (dr>255) then dr:=255;
if (dg<0) then dg:=0 else if (dg>255) then dg:=255;
if (db<0) then db:=0 else if (db>255) then db:=255;
r:=byte(dr);
g:=byte(dg);
b:=byte(db);
end;
//## fmMatrix5 ##
procedure fmMatrix5(var r,g,b:byte;var f:tfiltermatrixinfo;var fv:tfiltermatrixvals;var x:integer;pr:array of pdlRGB);
const
   rowoffset=1;
var//trgbcolor=raw(b,g,r)
   dx,px,p,dr,dg,db:integer;
begin
//get
dr:=0;
dg:=0;
db:=0;
px:=x*3;
//calc
//.row0
p:=longint(pr[0])+px;
if (f.v[0]<>0) then
   begin
   db:=db+fv[0][pbyte(p+0)^];
   dg:=dg+fv[0][pbyte(p+1)^];
   dr:=dr+fv[0][pbyte(p+2)^];
   end;
if (f.v[1]<>0) then
   begin
   db:=db+fv[1][pbyte(p+3)^];
   dg:=dg+fv[1][pbyte(p+4)^];
   dr:=dr+fv[1][pbyte(p+5)^];
   end;
if (f.v[2]<>0) then
   begin
   db:=db+fv[2][pbyte(p+6)^];
   dg:=dg+fv[2][pbyte(p+7)^];
   dr:=dr+fv[2][pbyte(p+8)^];
   end;
if (f.v[3]<>0) then
   begin
   db:=db+fv[3][pbyte(p+9)^];
   dg:=dg+fv[3][pbyte(p+10)^];
   dr:=dr+fv[3][pbyte(p+11)^];
   end;
if (f.v[4]<>0) then
   begin
   db:=db+fv[4][pbyte(p+12)^];
   dg:=dg+fv[4][pbyte(p+13)^];
   dr:=dr+fv[4][pbyte(p+14)^];
   end;
//.row1
p:=longint(pr[1])+px;
if (f.v[5]<>0) then
   begin
   db:=db+fv[5][pbyte(p+0)^];
   dg:=dg+fv[5][pbyte(p+1)^];
   dr:=dr+fv[5][pbyte(p+2)^];
   end;
if (f.v[6]<>0) then
   begin
   db:=db+fv[6][pbyte(p+3)^];
   dg:=dg+fv[6][pbyte(p+4)^];
   dr:=dr+fv[6][pbyte(p+5)^];
   end;
if (f.v[7]<>0) then
   begin
   db:=db+fv[7][pbyte(p+6)^];
   dg:=dg+fv[7][pbyte(p+7)^];
   dr:=dr+fv[7][pbyte(p+8)^];
   end;
if (f.v[8]<>0) then
   begin
   db:=db+fv[8][pbyte(p+9)^];
   dg:=dg+fv[8][pbyte(p+10)^];
   dr:=dr+fv[8][pbyte(p+11)^];
   end;
if (f.v[9]<>0) then
   begin
   db:=db+fv[9][pbyte(p+12)^];
   dg:=dg+fv[9][pbyte(p+13)^];
   dr:=dr+fv[9][pbyte(p+14)^];
   end;
//.row2
p:=longint(pr[2])+px;
if (f.v[10]<>0) then
   begin
   db:=db+fv[10][pbyte(p+0)^];
   dg:=dg+fv[10][pbyte(p+1)^];
   dr:=dr+fv[10][pbyte(p+2)^];
   end;
if (f.v[11]<>0) then
   begin
   db:=db+fv[11][pbyte(p+3)^];
   dg:=dg+fv[11][pbyte(p+4)^];
   dr:=dr+fv[11][pbyte(p+5)^];
   end;
if (f.v[12]<>0) then
   begin
   db:=db+fv[12][pbyte(p+6)^];
   dg:=dg+fv[12][pbyte(p+7)^];
   dr:=dr+fv[12][pbyte(p+8)^];
   end;
if (f.v[13]<>0) then
   begin
   db:=db+fv[13][pbyte(p+9)^];
   dg:=dg+fv[13][pbyte(p+10)^];
   dr:=dr+fv[13][pbyte(p+11)^];
   end;
if (f.v[14]<>0) then
   begin
   db:=db+fv[14][pbyte(p+12)^];
   dg:=dg+fv[14][pbyte(p+13)^];
   dr:=dr+fv[14][pbyte(p+14)^];
   end;
//.row3
p:=longint(pr[3])+px;
if (f.v[15]<>0) then
   begin
   db:=db+fv[15][pbyte(p+0)^];
   dg:=dg+fv[15][pbyte(p+1)^];
   dr:=dr+fv[15][pbyte(p+2)^];
   end;
if (f.v[16]<>0) then
   begin
   db:=db+fv[16][pbyte(p+3)^];
   dg:=dg+fv[16][pbyte(p+4)^];
   dr:=dr+fv[16][pbyte(p+5)^];
   end;
if (f.v[17]<>0) then
   begin
   db:=db+fv[17][pbyte(p+6)^];
   dg:=dg+fv[17][pbyte(p+7)^];
   dr:=dr+fv[17][pbyte(p+8)^];
   end;
if (f.v[18]<>0) then
   begin
   db:=db+fv[18][pbyte(p+9)^];
   dg:=dg+fv[18][pbyte(p+10)^];
   dr:=dr+fv[18][pbyte(p+11)^];
   end;
if (f.v[19]<>0) then
   begin
   db:=db+fv[19][pbyte(p+12)^];
   dg:=dg+fv[19][pbyte(p+13)^];
   dr:=dr+fv[19][pbyte(p+14)^];
   end;
//.row4
p:=longint(pr[4])+px;
if (f.v[20]<>0) then
   begin
   db:=db+fv[20][pbyte(p+0)^];
   dg:=dg+fv[20][pbyte(p+1)^];
   dr:=dr+fv[20][pbyte(p+2)^];
   end;
if (f.v[21]<>0) then
   begin
   db:=db+fv[21][pbyte(p+3)^];
   dg:=dg+fv[21][pbyte(p+4)^];
   dr:=dr+fv[21][pbyte(p+5)^];
   end;
if (f.v[22]<>0) then
   begin
   db:=db+fv[22][pbyte(p+6)^];
   dg:=dg+fv[22][pbyte(p+7)^];
   dr:=dr+fv[22][pbyte(p+8)^];
   end;
if (f.v[23]<>0) then
   begin
   db:=db+fv[23][pbyte(p+9)^];
   dg:=dg+fv[23][pbyte(p+10)^];
   dr:=dr+fv[23][pbyte(p+11)^];
   end;
if (f.v[24]<>0) then
   begin
   db:=db+fv[24][pbyte(p+12)^];
   dg:=dg+fv[24][pbyte(p+13)^];
   dr:=dr+fv[24][pbyte(p+14)^];
   end;
//set - Note: faster to use "if else if then" then to use a large lookup array of 128K items or more
dr:=(dr div f.vdiv)+f.vbias;
dg:=(dg div f.vdiv)+f.vbias;
db:=(db div f.vdiv)+f.vbias;
if (dr<0) then dr:=0 else if (dr>255) then dr:=255;
if (dg<0) then dg:=0 else if (dg>255) then dg:=255;
if (db<0) then db:=0 else if (db>255) then db:=255;
r:=byte(dr);
g:=byte(dg);
b:=byte(db);
end;

//## create ##
constructor tfilters.create;
var
   tszoomhorz,tszoomvert,tszoom:string;
begin
//self
inherited;
//init
fbinit;
//vars
icount:=0;
tszoom:=ntranslate('zoom');
tszoomhorz:=ntranslate('zoom horizontal');
tszoomvert:=ntranslate('zoom vertical');

//BASIC
addbasic('none',ntranslate('none'),fbnone);
addbasic('faded',ntranslate('faded'),fbfaded);
addbasic('sepia',ntranslate('sepia'),fbsepia);
addbasic('sepia',ntranslate('sepia'),fbsepia2);
addbasic('sepia',ntranslate('sepia'),fbsepia3);
addbasic('sepia',ntranslate('sepia'),fbsepia4);
addbasic('sepia',ntranslate('sepia'),fbsepia5);
addbasic('greyscale',ntranslate('greyscale'),fbgreyscale);
addbasic('greyscale',ntranslate('greyscale'),fbgreyscale2);
addbasic('greyscale',ntranslate('greyscale'),fbgreyscale3);
addbasic('luminosity',ntranslate('luminosity'),fblum);
addbasic('red',ntranslate('red channel'),fbred);
addbasic('blue',ntranslate('blue channel'),fbblue);
addbasic('green',ntranslate('green channel'),fbgreen);
addbasic('cyan',ntranslate('cyan channel'),fbcyan);
addbasic('yellow',ntranslate('yellow channel'),fbyellow);
addbasic('magenta',ntranslate('magenta channel'),fbmagenta);
addbasic('shift',ntranslate('shift channels by 1'),fbshift);
addbasic('shift2',ntranslate('shift channels by 2'),fbshift2);
addbasic('invert',ntranslate('invert'),fbinvert);
addbasic('brighten',ntranslate('brighten'),fbbrighten);
addbasic('brighten',ntranslate('brighten'),fbbrighten2);
addbasic('brighten',ntranslate('brighten'),fbbrighten3);
addbasic('darken',ntranslate('darken'),fbdarken);
addbasic('darken',ntranslate('darken'),fbdarken2);
addbasic('darken',ntranslate('darken'),fbdarken3);
addbasic('highlightmore',ntranslate('highlight increase'),fbhighlightmore);
addbasic('highlightless',ntranslate('highlight decrease'),fbhighlightless);
addbasic('midtonemore',ntranslate('midtone increase'),fbmidtonemore);
addbasic('midtoneless',ntranslate('midtone decrease'),fbmidtoneless);
addbasic('shadowmore',ntranslate('shadow increase'),fbshadowmore);
addbasic('shadowless',ntranslate('shadow decrease'),fbshadowless);
addbasic('noise',ntranslate('noise'),fbnoise);
addbasic('noise',ntranslate('noise'),fbnoise2);
addbasic('noise',ntranslate('noise'),fbnoise3);
addbasic('mix',ntranslate('mix'),fbmix);
addbasic('tie',ntranslate('tie'),fbtie);
addbasic('flat',ntranslate('flat'),fbflat);
addbasic('warp',ntranslate('warp'),fbwarp);
addbasic('wrapup',ntranslate('wrap up'),fbwrapup);
addbasic('wrapdown',ntranslate('wrap down'),fbwrapdown);
addbasic('shades',ntranslate('shades'),fbshades);
addbasic('shades',ntranslate('shades'),fbshades2);
addbasic('shades',ntranslate('shades'),fbshades3);
addbasic('shades',ntranslate('shades'),fbshades4);
addbasic('stretchup',ntranslate('stretch up'),fbstretchup);
addbasic('stretchdown',ntranslate('stretch down'),fbstretchdown);
addbasic('fudge',ntranslate('fudge'),fbfudge);
addbasic('bw',ntranslate('b/w'),fbBW);
addbasic('bw',ntranslate('b/w'),fbBW2);
addbasic('bw',ntranslate('b/w'),fbBW3);
addbasic('bw',ntranslate('b/w'),fbBW4);
addbasic('bw',ntranslate('b/w'),fbBW5);
addbasic('bw',ntranslate('b/w'),fbBW6);
addbasic('bw',ntranslate('b/w'),fbBW7);
addbasic('bw',ntranslate('b/w'),fbBW8);
addbasic('bw',ntranslate('b/w'),fbBW9);
addbasic('bw',ntranslate('b/w'),fbBW10);
//REFERENCE
addreference('buildref',ntranslate('build reference'),frStart);
addreference('useref',ntranslate('use reference'),frUse);
addreference('endref',ntranslate('end reference'),frEnd);
//ACTIONS
addaction('transt',ntranslate('transparency - top/left'),0,0,faTrans);
addaction('trans4',ntranslate('transparency - 4 corner'),0,0,faTrans4);
addaction('transwhite',ntranslate('transparency white'),rgb(255,255,255),0,faTransColor);
addaction('transblack',ntranslate('transparency black'),0,0,faTransColor);
addaction('transred',ntranslate('transparency red'),rgb(255,0,0),0,faTransColor);
addaction('notrans',ntranslate('no transparency'),0,0,faNoTrans);
addaction('rr90',ntranslate('rotate right 90'),90,0,faRotate);
addaction('rr180',ntranslate('rotate right 180'),180,0,faRotate);
addaction('rr270',ntranslate('rotate right 270'),270,0,faRotate);
addaction('rl90',ntranslate('rotate left 90'),270,0,faRotate);
addaction('rl180',ntranslate('rotate left 180'),180,0,faRotate);
addaction('rl270',ntranslate('rotate left 270'),90,0,faRotate);
addaction('flip',ntranslate('flip vertical'),0,0,faFlip);
addaction('mirror',ntranslate('mirror horizontal'),0,0,faMirror);
addaction('trim',ntranslate('trim'),0,0,faTrim);
addaction('redonly',ntranslate('red only'),1,0,faRGBchange);
addaction('greenonly',ntranslate('green only'),2,0,faRGBchange);
addaction('blueonly',ntranslate('blue only'),3,0,faRGBchange);
addaction('all',ntranslate('red/green/blue'),0,0,faRGBchange);
//.zoom
addaction('zoom1',tszoom+' 1%',1,1,faZoom);
addaction('zoom5',tszoom+' 5%',5,5,faZoom);
addaction('zoom10',tszoom+' 10%',10,10,faZoom);
addaction('zoom25',tszoom+' 25%',25,25,faZoom);
addaction('zoom50',tszoom+' 50%',50,50,faZoom);
addaction('zoom75',tszoom+' 75%',75,75,faZoom);
addaction('zoom125',tszoom+' 125%',125,125,faZoom);
addaction('zoom150',tszoom+' 150%',150,150,faZoom);
addaction('zoom175',tszoom+' 175%',175,175,faZoom);
addaction('zoom200',tszoom+' 200%',200,200,faZoom);
//.zoom horz
addaction('zoomhorz25',tszoomhorz+' 25%',25,100,faZoom);
addaction('zoomhorz50',tszoomhorz+' 50%',50,100,faZoom);
addaction('zoomhorz75',tszoomhorz+' 75%',75,100,faZoom);
addaction('zoomhorz125',tszoomhorz+' 125%',125,100,faZoom);
addaction('zoomhorz150',tszoomhorz+' 150%',150,100,faZoom);
addaction('zoomhorz175',tszoomhorz+' 175%',175,100,faZoom);
addaction('zoomhorz200',tszoomhorz+' 200%',200,100,faZoom);
//.zoom vert
addaction('zoomvert25',tszoomvert+' 25%',100,25,faZoom);
addaction('zoomvert50',tszoomvert+' 50%',100,50,faZoom);
addaction('zoomvert75',tszoomvert+' 75%',100,75,faZoom);
addaction('zoomvert125',tszoomvert+' 125%',100,125,faZoom);
addaction('zoomvert150',tszoomvert+' 150%',100,150,faZoom);
addaction('zoomvert175',tszoomvert+' 175%',100,175,faZoom);
addaction('zoomvert200',tszoomvert+' 200%',100,200,faZoom);

//MATRIX
addmatrix('enhance',ntranslate('enhance'),'d6|0 -1 0|-1 10 -1|0 -1 0');
addmatrix('enhance',ntranslate('enhance'),'d8|0 0 -1 0 0|0 0 -1 0 0|-1 -1 16 -1 -1|0 0 -1 0 0|0 0 -1 0 0');
addmatrix('soften',ntranslate('soften'),'d38|1 1 1|1 30 1|1 1 1');
addmatrix('soften',ntranslate('soften'),'d18|1 1 1|1 10 1|1 1 1');
addmatrix('blur',ntranslate('blur'),'d9|1 1 1|1 1 1|1 1 1');//3x3
addmatrix('blur',ntranslate('blur'),'d25|1 1 1 1 1|1 1 1 1 1|1 1 1 1 1|1 1 1 1 1|1 1 1 1 1');//5x5
addmatrix('edges',ntranslate('edges'),'d1|0 255 0|255 0 -255|0 -255 0');
addmatrix('edges',ntranslate('edges'),'d1|0 0 255 0 0|0 0 255 0 0|255 255 0 -255 -255|0 0 -255 0 0|0 0 -255 0 0');
addmatrix('edges',ntranslate('edges'),'d1|0 -255 0|-255 0 255|0 255 0');
addmatrix('edges',ntranslate('edges'),'d1|0 0 -255 0 0|0 0 -255 0 0|-255 -255 0 255 255|0 0 255 0 0|0 0 255 0 0');
addmatrix('horzedges',ntranslate('horizontal edges'),'d1|0 255 0|0 0 0|0 -255 0');
addmatrix('horzedges',ntranslate('horizontal edges'),'d1|0 0 255 0 0|0 0 255 0 0|0 0 0 0 0|0 0 -255 0 0|0 0 -255 0 0');
addmatrix('vertedges',ntranslate('vertical edges'),'d1|0 0 0|255 0 -255|0 0 0');
addmatrix('vertedges',ntranslate('vertical edges'),'d1|0 0 0 0 0|0 0 0 0 0|255 255 0 -255 -255|0 0 0 0 0|0 0 0 0 0');
addmatrix('grow',ntranslate('grow'),'d1|255 255 255|255 255 255|255 255 255');
addmatrix('grow',ntranslate('grow'),'d1|255 255 255 255 255|255 255 255 255 255|255 255 255 255 255|255 255 255 255 255|255 255 255 255 255');
addmatrix('spreadhorz',ntranslate('grow horizontally'),'d1|0 0 0|255 255 255|0 0 0');
addmatrix('spreadhorz',ntranslate('grow horizontally'),'d1|0 0 0 0 0|0 0 0 0 0|255 255 255 255 255|0 0 0 0 0|0 0 0 0 0');
addmatrix('spreadvert',ntranslate('grow vertically'),'d1|0 255 0|0 255 0|0 255 0');
addmatrix('spreadvert',ntranslate('grow vertically'),'d1|0 0 255 0 0|0 0 255 0 0|0 0 255 0 0|0 0 255 0 0|0 0 255 0 0');
addmatrix('misc',ntranslate('misc'),'d26|5 2 1|5 5 1|5 2 1');
addmatrix('misc',ntranslate('misc'),'d1|0 0 0|0 -1 4|0 0 0');
addmatrix('misc',ntranslate('misc'),'d1|0 0 0|0 -1 2|0 0 0');
addmatrix('misc',ntranslate('misc'),'d1|0 0 0|1 0 -1|0 0 0');
addmatrix('misc',ntranslate('misc'),'d1|0 0 0|5 0 -5|0 0 0');
addmatrix('misc',ntranslate('misc'),'d2|0 0 0|5 0 -5|0 0 0');
addmatrix('misc',ntranslate('misc'),'d1|0 5 0|0 1 0|0 -5 0');
addmatrix('misc',ntranslate('misc'),'d2|0 5 0|0 1 0|0 -5 0');
addmatrix('misc',ntranslate('misc'),'d1|0 5 0|-5 3 5|0 -5 0');
addmatrix('misc',ntranslate('misc'),'d2|0 5 0|-5 3 5|0 -5 0');
addmatrix('misc',ntranslate('misc'),'d7|99 9 -99|-9 9 9|-99 9 99');
addmatrix('misc',ntranslate('misc'),'d99|99 9 99|9 99 9|99 9 99');
end;
//## destroy ##
destructor tfilters.destroy;
begin
try
//controls
//yyyyyyyyyyyyyyyyyy
//self
inherited;
except;end;
end;
//## readmatrix ##
function tfilters.readmatrix(x:string;var y:tfiltermatrixinfo;var e:string):boolean;
const
   maxv=9999;
var//Note:
   //1. dXXX=division number default of "1"
   //2. vXXX=pixel level number of "0", can also be specified without "v" (range of -255...255)
   //3. end=stop reading data at this point
   //4. //<comment goes here>
   a:tstringlist;
   v1,v2,vlen,p:integer;
   v:string;
begin
try
//defaults
result:=false;
e:=gecUnknownFormat;
a:=nil;
fillchar(y,sizeof(y),0);
y.vdiv:=1;
//check
if (x='') then exit;
//init
a:=tstringlist.create;
a.text:=x;
//.remove comments
for p:=(a.count-1) downto 0 do if (copy(a.strings[p],1,2)='//') then a.delete(p);
x:=a.text;
//.clean
general.swapchars(x,#32,#10);
general.swapchars(x,#160,#10);
general.swapchars(x,',',#10);
general.swapchars(x,'|',#10);
a.text:=lowercase(x);
//get
for p:=0 to (a.count-1) do
begin
v:=a.strings[p];
vlen:=length(v);
if (vlen<>0) then
   begin
   //get
   v1:=frcrange(strint(v),-maxv,maxv);
   v2:=frcrange(strint(copy(v,2,vlen)),-maxv,maxv);
   //set
   if (v[1]='d') then//divider
      begin
      if (v2=0) then v2:=1;
      y.vdiv:=v2;
      end
   else if (v[1]='b') then//bias - add/sub. from final pixel value
      begin
      y.vbias:=v2;
      end
   else //"v" or "undefined"
      begin
      y.v[y.count]:=general.aorb(v1,v2,(v[1]='v'));
      inc(y.count);
      if (y.count>high(y.v)) then break;
      end;//end of if
   end;//end of if
end;//end of loop
//rows
if (y.count<=9) then
   begin//3x3 =. 0, [1], 2
   y.rows:=3;
   y.radius:=1;
   end
else
   begin//5x5 => 0, 1, [2], 3 ,4
   y.rows:=5;
   y.radius:=2;
   end;//end of if
//successful
result:=true;
except;end;
try;freeobj(@a);except;end;
end;
//## filter ##
function tfilters.filter(d:tbitmap;var rtc:integer;filterlist:string;var e:string):boolean;
label
   skipone,skipend;
var
   img:tbitmap;//pointer only
   maxy,maxx,flmax,v,i,p,tmpx,dx,dy:integer;
   ra,rb,rc,rd,re:tdynamicrgb;
   pr:array[0..5] of pdlRGB;//pointers only
   pc:array[0..5] of tdynamicrgb;//pointers only
   //list of tasks
   iref:array[0..99] of integer;
   //current task
   basic:tfilterbasic;
   action:tfilteraction;
   matrix:tfiltermatrix;
   reference:tfilterreference;
   fm:pfiltermatrixinfo;//pointer only
   fv:tfiltermatrixvals;
   a:tstringlist;
   ref:tbitmap;
   //colors
   cr,cg,cb:byte;
   tr,tg,tb:byte;//transparent color
   str,stg,stb:byte;//safe transparent color
   toff,ton:boolean;//transparent color state
   //on's
   bon:boolean;
   aon:boolean;
   mon:boolean;
   ron:boolean;
   refmode:byte;//0=none, 1=start, 2=use
   uron:boolean;
   uroff:boolean;//use ref off
   rcol,gcol,bcol:boolean;
   //information
   v1,v2:integer;
   rref,r:integer;//row
   tmpc,tmpc2:trgbcolor;
begin
try
//defaults
result:=false;
e:=gecUnexpectedError;
a:=nil;
ref:=nil;
ra:=nil;
rb:=nil;
rc:=nil;
rd:=nil;
re:=nil;
ton:=false;
toff:=not ton;
rtc:=clNone;
refmode:=0;
uron:=false;
uroff:=not uron;
rcol:=true;
gcol:=true;
bcol:=true;
//check
if (d=nil) then exit;
if (filterlist='') then
   begin
   result:=true;
   exit;
   end;//end of if
//init
e:=gecOutOfMemory;
//.filter list
a:=tstringlist.create;
a.text:=filterlist;
flmax:=-1;
for p:=0 to (a.count-1) do if find(a.strings[p],v) and (v>=1) then
   begin
   //set
   inc(flmax);
   iref[flmax]:=v;
   //limit - max of 100 filters (0..99)
   if (flmax>=high(iref)) then break;
   end;//end of if
if (flmax<0) then
   begin
   result:=true;
   goto skipend;
   end;//end of if
//.24bit
if not ccs.valid24(d) then
   begin
   e:=gecOutOfMemory;
   goto skipend;
   end;//end of if
//get
for p:=0 to flmax do
begin
//decide
i:=iref[p];
basic:=iitems[i].basic;
action:=iitems[i].action;
matrix:=iitems[i].matrix;
reference:=iitems[i].reference;
bon:=assigned(basic);
aon:=assigned(action);
mon:=assigned(matrix);
ron:=assigned(reference);
if mon then fm:=@iitems[i].mi;
v1:=iitems[i].v1;
v2:=iitems[i].v2;
ton:=(rtc<>clNone);
toff:=not ton;

//ACTION
if aon then
   begin
   //set
   if not action(d,v1,v2,rtc,tmpc,tmpc2,e) then goto skipend;
   if (@action=@faRgbchange) then
      begin
      rcol:=false;
      gcol:=false;
      bcol:=false;
      case v1 of
      1:rcol:=true;
      2:gcol:=true;
      3:bcol:=true;
      else//0
         begin
         rcol:=true;
         gcol:=true;
         bcol:=true;
         end;//end of begin
      end;//end of case
      end;//end of if
   //update transparent information
   ton:=(rtc<>clNone);
   toff:=not ton;
   tr:=tmpc.r;
   tg:=tmpc.g;
   tb:=tmpc.b;
   str:=tmpc2.r;
   stg:=tmpc2.g;
   stb:=tmpc2.b;
   end;//end of if
//REFERENCE
if ron then
   begin
   if not reference(d,ref,refmode,e) then goto skipend;
   uron:=(refmode=2);
   uroff:=not uron;
   end;//end of if
//.ensure "ref" dimensions are same as "d"
if (ref<>nil) and ((ref.width<>d.width) or (ref.height<>d.height)) then
   begin
   ref.width:=d.width;
   ref.height:=d.height;
   end;//end of if

//BASIC or MATRIX
//init
maxx:=d.width-1;
maxy:=d.height-1;
if (maxx<0) or (maxy<0) then goto skipone;
if (not bon) and (not mon) then goto skipone;
//.ref - 0=none, 1=start (all in/output is on ref), 2=use ref
if (refmode=1) then img:=ref else img:=d;
//matrix init
if mon then
   begin
   //3x3
   ra:=tdynamicrgb.create;
   rb:=tdynamicrgb.create;
   rc:=tdynamicrgb.create;
   pc[0]:=ra;
   pc[1]:=rb;
   pc[2]:=rc;
   //5x5
   if (fm.rows=5) then
      begin
      rd:=tdynamicrgb.create;
      re:=tdynamicrgb.create;
      pc[3]:=rd;
      pc[4]:=re;
      end;//end of if
   //values
   for dx:=0 to frcmax(((fm.rows*fm.rows)-1),high(fv)) do for dy:=0 to 255 do fv[dx][dy]:=fm.v[dx]*dy;
   end;//end of if
//scan
for dy:=0 to maxy do
begin
r:=longint(img.scanline[dy]);
if uron then rref:=longint(ref.scanline[dy]);
//.matrix row cache
if mon then
   begin
   //set
   if (dy=0) then
      begin
      for i:=0 to (fm.rows-1) do//item5 is temp for swap purposes
      begin
      pc[i].readfromex(img,dy+i-fm.radius,fm.radius,fm.radius,clNone);
      pr[i]:=pc[i].core;
      end;//end of loop
      end
   //shift up one
   else
      begin
      pc[high(pc)]:=pc[0];
      for i:=0 to (fm.rows-2) do pc[i]:=pc[i+1];
      pc[fm.rows-1]:=pc[high(pc)];
      pc[fm.rows-1].readfromex(img,dy+fm.radius,fm.radius,fm.radius,clNone);
      for i:=0 to (fm.rows-1) do pr[i]:=pc[i].core;
      end;//end of if
   end;//end of if
//.filter row
 for dx:=0 to maxx do
 begin
 //get
 cb:=pbyte(r+0)^;
 cg:=pbyte(r+1)^;
 cr:=pbyte(r+2)^;
 //calc
 if (toff or (not ((cr=tr) and (cg=tg) and (cb=tb)))) and
    (uroff or ((pbyte(rref+0)^>0) or (pbyte(rref+1)^>0) or (pbyte(rref+2)^>0))) then
    begin
    //basic filter
    if bon then basic(cr,cg,cb);
    //matrix filter
    if mon then matrix(cr,cg,cb,fm^,fv,dx,pr);
    //transparency check - filter output color must be shifted slightly if it's equal to "_tc"
    if ton and (cr=tr) and (cg=tg) and (cb=tb) then
       begin
       cr:=str;
       cg:=stg;
       cb:=stb;
       end;//end of if
    //set
    if bcol then pbyte(r+0)^:=cb;
    if gcol then pbyte(r+1)^:=cg;
    if rcol then pbyte(r+2)^:=cr;
    end;//end of if
 //inc
 inc(r,3);
 inc(rref,3);
 end//end of loop - dx
end;//end of loop - dy
skipone:
//.free ra...rc
freeobj(@ra);
freeobj(@rb);
freeobj(@rc);
freeobj(@rd);
freeobj(@re);
end;//end of loop - p
//successful
result:=true;
skipend:
except;end;
try
freeobj(@a);
freeobj(@ref);
freeobj(@ra);
freeobj(@rb);
freeobj(@rc);
freeobj(@rd);
freeobj(@re);
except;end;
end;
//## rti ##
procedure tfilters.rti(x:tbitmap;xy:tpoint;var tc:integer;var rgbTC,rgbsafeTC:trgbcolor);//read transparent information
begin
try
//defaults
tc:=clNone;
//get
if (x<>nil) and ccs.valid24(x) then
   begin
   if (xy.x>=0) and (xy.y>=0) and (xy.x<x.width) and (xy.y<x.height) then tc:=ccs.pixels[x,xy.x,xy.y]
   else tc:=ccs.edgecolor(x);
   end;//end of if
//set
ccs.safetransinfo(tc,rgbTC,rgbsafeTC);
except;end;
end;
//## find ##
function tfilters.find(_rawname:string;var _index:integer):boolean;
var
   p:integer;
begin
try
//defaults
result:=false;
_index:=-1;
//scan
//.rawname
for p:=0 to (icount-1) do if (comparetext(iitems[p].rawname,_rawname)=0) then
   begin
   _index:=p;
   result:=true;
   break;
   end;//end of if
//.name - translated name
if not result then for p:=0 to (icount-1) do if (comparetext(iitems[p].name,_rawname)=0) then
   begin
   _index:=p;
   result:=true;
   break;
   end;//end of if
except;end;
end;
//## range ##
function tfilters.range(var _rawname,_name:string):boolean;
var
   tmp:string;
begin
try
result:=(icount<high(iitems)) and (_name<>'') and (_rawname<>'');
if result then
   begin
   //set
   _rawname:=lowercase(_rawname);
   if (ilastrawname=_rawname) then inc(ilastcount)
   else
      begin
      ilastrawname:=_rawname;
      ilastcount:=0;
      end;//end of if
   _name:=general.asname(_name);
   //extra
   if (ilastcount>=1) then
      begin
      tmp:=inttostr(ilastcount+1);
      _rawname:=_rawname+tmp;
      _name:=_name+#32+tmp;
      end;//end of if
   //clear
   clear(icount);
   end;//end of if
except;end;
end;
//## clear ##
procedure tfilters.clear(x:integer);
begin
try
if (x>=0) and (x<=high(iitems)) then
   begin
   with iitems[icount] do
   begin
   rawname:='';
   name:='';
   basic:=nil;
   action:=nil;
   matrix:=nil;
   fillchar(mi,sizeof(mi),0);
   v1:=0;
   v2:=0;
   end;//end of with
   end;//end of if
except;end;
end;
//## addbasic ##
procedure tfilters.addbasic(_rawname,_name:string;_event:tfilterbasic);
begin
try
//check
if (@_event=nil) then exit;
if not range(_rawname,_name) then exit;
//set
with iitems[icount] do
begin
rawname:=_rawname;
name:=_name;
basic:=_event;
end;//end of with
inc(icount);
except;end;
end;
//## addaction ##
procedure tfilters.addaction(_rawname,_name:string;_v1,_v2:integer;_event:tfilteraction);
begin
try
//check
if (@_event=nil) then exit;
if not range(_rawname,_name) then exit;
//set
with iitems[icount] do
begin
rawname:=_rawname;
name:=_name;
action:=_event;
v1:=_v1;
v2:=_v2;
end;//end of with
inc(icount);
except;end;
end;
//## addreference ##
procedure tfilters.addreference(_rawname,_name:string;_event:tfilterreference);
begin
try
//check
if (@_event=nil) then exit;
if not range(_rawname,_name) then exit;
//set
with iitems[icount] do
begin
rawname:=_rawname;
name:=_name;
reference:=_event;
end;//end of with
inc(icount);
except;end;
end;
//## addmatrix ##
procedure tfilters.addmatrix(_rawname,_name,_mi:string);
var
   e:string;
begin
try
//check
if not range(_rawname,_name) then exit;
//set
with iitems[icount] do
begin
if not readmatrix(_mi,mi,e) then exit;
if (mi.count<=9) then matrix:=fmMatrix3
else if (mi.count<=25) then matrix:=fmMatrix5
else exit;
rawname:=_rawname;
name:=_name;
end;//end of with
inc(icount);
except;end;
end;
//## names ##
function tfilters.names(sol,eol:string;rawname:boolean):string;
var
   p:integer;
begin//Note: sol=start of line, eol=end of line
try
//defaults
result:='';
//get
for p:=0 to (icount-1) do result:=result+sol+general.aorbstr(iitems[p].name,iitems[p].rawname,rawname)+eol;
except;end;
end;
//## valid ##
function tfilters.valid(x:integer):boolean;
begin
try;result:=(x>=0) and (x<icount);except;end;
end;
//## getrawname ##
function tfilters.getrawname(x:integer):string;
begin
try;if valid(x) then result:=iitems[x].rawname else result:='';except;end;
end;
//## getitem ##
function tfilters.getitem(x:integer):tfilteritem;
begin
try
if valid(x) then result:=iitems[x]
else
   begin
   result.name:='';
   result.rawname:='';
   result.basic:=nil;
   result.action:=nil;
   result.matrix:=nil;
   result.v1:=0;
   result.v2:=0;
   end;//end of if
except;end;
end;

//## taudioswap ################################################################
//## create ##
constructor taudioswap.create;
begin
init(20,5,100);
end;
//## init ##
procedure taudioswap.init(_length,_switch,_vallimit:integer);
begin
try
ivallimit:=frcmin(_vallimit,1);
ilength:=frcmin(_length,0);
iswitch:=frcmin(_switch,1);
iswitchstep:=ivallimit/iswitch;
ivalref1:=ivallimit;
ivalref2:=0;
ival1:=ivallimit;
ivalref1:=ival1;
ival2:=0;
ivalref2:=ival2;
ipos:=-1;
idown:=true;
except;end;
end;
//## next ##
procedure taudioswap.next;
begin
try
//inc
inc(ipos);
//check
if (ilength<=0) or (ipos<=ilength) then exit;
//get
if (ipos>(ilength+iswitch)) then
   begin
   ipos:=-1;
   idown:=not idown;
   exit;
   end;//end of if
//set - within "switch mode"
if idown then
   begin
   //1
   ivalref1:=ivalref1-iswitchstep;
   if (ivalref1<0) then ivalref1:=0;
   ival1:=round(ivalref1);
   //2
   ivalref2:=ivalref2+iswitchstep;
   if (ivalref2>ivallimit) then ivalref2:=ivallimit;
   ival2:=round(ivalref2);
   end
else
   begin
   //2
   ivalref2:=ivalref2-iswitchstep;
   if (ivalref2<0) then ivalref2:=0;
   ival2:=round(ivalref2);
   //1
   ivalref1:=ivalref1+iswitchstep;
   if (ivalref1>ivallimit) then ivalref1:=ivallimit;
   ival1:=round(ivalref1);
   end;//end of if
except;end;
end;

//## taudio ####################################################################
//-- Basic ---------------------------------------------------------------------
//## abSafe ##
function abSafe(x:integer):smallint;
begin
try
//range
if (x<-32767) then x:=-32767 else if (x>32767) then x:=32767;
//set
result:=x;
except;end;
end;
//## abVal ##
function abVal(x,ysize:integer;y:pdlSMINT):smallint;
begin//return nearest value if "x" exceeds range
if (ysize=0) then result:=0
else if (x<0) then result:=y[0]
else if (x>=ysize) then result:=y[ysize-1]
else result:=y[x];
end;
//## abMspk ##
function abMspk(ms:integer):integer;//convert "milliseconds" to "number-of-sound-packets"
begin//Note: 44,100 packets per channel per second => 1ms=44.1 packets
try  //Aslo: 1 second=[44,100Hz]x[1 packet=16bit=2bytes]x[2 channels]=176,000 bytes
//get - always shifts by "4" packets, since alternating packets are "4-,4+,4-,4+"
result:=(round(44.1*ms) div 4)*4;
except;end;
end;
//## abPkms ##
function abPkms(x:integer):integer;//convert "milliseconds" to "number-of-sound-packets"
begin//Note: 44,100 packets per channel per second => 1ms=44.1 packets
try  //Aslo: 1 second=[44,100Hz]x[1 packet=16bit=2bytes]x[2 channels]=176,000 bytes
//get - always shifts by "4" packets, since alternating packets are "4-,4+,4-,4+"
result:=round(x/44.1);
except;end;
end;
//## abNone ##
procedure abNone(var val:smallint);
begin
//nil
end;
//## abSilence ##
procedure abSilence(var val:smallint);
begin
val:=0;
end;
//## abShades ##
procedure abShades(var val:smallint);
begin
val:=abSafe(val div 25)*25;
end;
//## abShades2 ##
procedure abShades2(var val:smallint);
begin
val:=abSafe(val div 50)*50;;
end;
//## abShades3 ##
procedure abShades3(var val:smallint);
begin
val:=abSafe(val div 70)*70;;
end;
//## abScale ##
procedure abScale(var val:smallint);
begin
val:=abSafe((val div 500)*(val div 500));
end;
//## abScale2 ##
procedure abScale2(var val:smallint);
begin
val:=abSafe((val div 100)*(val div 100));
end;
//## abScale3 ##
procedure abScale3(var val:smallint);
begin
val:=abSafe((val div 50)*(val div 50));
end;
//## abVol1 ##
procedure abVol1(var val:smallint);
begin
val:=abSafe(round(integer(val)*0.01));
end;
//## abVol5 ##
procedure abVol5(var val:smallint);
begin
val:=abSafe(round(integer(val)*0.05));
end;
//## abVol10 ##
procedure abVol10(var val:smallint);
begin
val:=abSafe(round(integer(val)*0.10));
end;
//## abVol25 ##
procedure abVol25(var val:smallint);
begin
val:=abSafe(round(integer(val)*0.25));
end;
//## abVol50 ##
procedure abVol50(var val:smallint);
begin
val:=abSafe(round(integer(val)*0.5));
end;
//## abVol75 ##
procedure abVol75(var val:smallint);
begin
val:=abSafe(round(integer(val)*0.75));
end;
//## abVol125 ##
procedure abVol125(var val:smallint);
begin
val:=abSafe(round(integer(val)*1.25));
end;
//## abVol150 ##
procedure abVol150(var val:smallint);
begin
val:=abSafe(round(integer(val)*1.5));
end;
//## abVol175 ##
procedure abVol175(var val:smallint);
begin
val:=abSafe(round(integer(val)*1.75));
end;
//## abVol200 ##
procedure abVol200(var val:smallint);
begin
val:=abSafe(round(integer(val)*2));
end;
//-- Actions -------------------------------------------------------------------
//## aaEcho ##
function aaEcho(var pos:integer;v1,v2:integer;var dl,dr:tdynamicsmallint;l,r:tdynamicsmallint;var e:string):boolean;
begin
result:=true;
inc(pos,-abMspk(v1));
end;
//## aaSwapLR ##
function aaSwapLR(var pos:integer;v1,v2:integer;var dl,dr:tdynamicsmallint;l,r:tdynamicsmallint;var e:string):boolean;
begin
result:=true;
dl:=r;
dr:=l;
end;
//-- Matrix --------------------------------------------------------------------
//## amMatrix3 ##
procedure amMatrix3(var val:smallint;pos,ysize:integer;y:pdlSMINT;var m:taudiomatrixinfo);
var
   tmp:integer;
begin
//get
tmp:=integer(val);
//calc
if (m.v[0]<>0) then tmp:=tmp+m.v[0]*abVal(pos-1,ysize,y);
if (m.v[1]<>0) then tmp:=tmp+m.v[1]*val;
if (m.v[2]<>0) then tmp:=tmp+m.v[2]*abVal(pos+1,ysize,y);
//set - Note: faster to use "if else if then" then to use a large lookup array of 128K items or more
tmp:=(tmp div m.vdiv)+m.vbias;
if (tmp<-32768) then tmp:=-32768 else if (tmp>32767) then tmp:=32767;
val:=smallint(tmp);
end;
//## amMatrix5 ##
procedure amMatrix5(var val:smallint;pos,ysize:integer;y:pdlSMINT;var m:taudiomatrixinfo);
var
   tmp:integer;
begin
//get
tmp:=integer(val);
//calc
if (m.v[0]<>0) then tmp:=tmp+m.v[0]*abVal(pos-2,ysize,y);
if (m.v[1]<>0) then tmp:=tmp+m.v[1]*abVal(pos-1,ysize,y);
if (m.v[2]<>0) then tmp:=tmp+m.v[2]*val;
if (m.v[3]<>0) then tmp:=tmp+m.v[3]*abVal(pos+1,ysize,y);
if (m.v[4]<>0) then tmp:=tmp+m.v[4]*abVal(pos+2,ysize,y);
//set - Note: faster to use "if else if then" then to use a large lookup array of 128K items or more
tmp:=(tmp div m.vdiv)+m.vbias;
if (tmp<-32768) then tmp:=-32768 else if (tmp>32767) then tmp:=32767;
val:=smallint(tmp);
end;
//## amMatrix7 ##
procedure amMatrix7(var val:smallint;pos,ysize:integer;y:pdlSMINT;var m:taudiomatrixinfo);
var
   tmp:integer;
begin
//get
tmp:=integer(val);
//calc
if (m.v[0]<>0) then tmp:=tmp+m.v[0]*abVal(pos-3,ysize,y);
if (m.v[1]<>0) then tmp:=tmp+m.v[1]*abVal(pos-2,ysize,y);
if (m.v[2]<>0) then tmp:=tmp+m.v[2]*abVal(pos-1,ysize,y);
if (m.v[3]<>0) then tmp:=tmp+m.v[3]*val;
if (m.v[4]<>0) then tmp:=tmp+m.v[4]*abVal(pos+1,ysize,y);
if (m.v[5]<>0) then tmp:=tmp+m.v[5]*abVal(pos+2,ysize,y);
if (m.v[6]<>0) then tmp:=tmp+m.v[6]*abVal(pos+3,ysize,y);
//set - Note: faster to use "if else if then" then to use a large lookup array of 128K items or more
tmp:=(tmp div m.vdiv)+m.vbias;
if (tmp<-32768) then tmp:=-32768 else if (tmp>32767) then tmp:=32767;
val:=smallint(tmp);
end;
//## amMatrix9 ##
procedure amMatrix9(var val:smallint;pos,ysize:integer;y:pdlSMINT;var m:taudiomatrixinfo);
var
   tmp:integer;
begin
//get
tmp:=integer(val);
//calc
if (m.v[0]<>0) then tmp:=tmp+m.v[0]*abVal(pos-4,ysize,y);
if (m.v[1]<>0) then tmp:=tmp+m.v[1]*abVal(pos-3,ysize,y);
if (m.v[2]<>0) then tmp:=tmp+m.v[2]*abVal(pos-2,ysize,y);
if (m.v[3]<>0) then tmp:=tmp+m.v[3]*abVal(pos-1,ysize,y);
if (m.v[4]<>0) then tmp:=tmp+m.v[4]*val;
if (m.v[5]<>0) then tmp:=tmp+m.v[5]*abVal(pos+1,ysize,y);
if (m.v[6]<>0) then tmp:=tmp+m.v[6]*abVal(pos+2,ysize,y);
if (m.v[7]<>0) then tmp:=tmp+m.v[7]*abVal(pos+3,ysize,y);
if (m.v[8]<>0) then tmp:=tmp+m.v[8]*abVal(pos+4,ysize,y);
//set - Note: faster to use "if else if then" then to use a large lookup array of 128K items or more
tmp:=(tmp div m.vdiv)+m.vbias;
if (tmp<-32768) then tmp:=-32768 else if (tmp>32767) then tmp:=32767;
val:=smallint(tmp);
end;

//## create ##
constructor taudio.create;
var
   p:integer;
begin
//self
inherited;
//controls
iswap:=taudioswap.create;
ileft:=tdynamicsmallint.create;
iright:=tdynamicsmallint.create;
for p:=0 to aoeMaxtrack do itemp[p]:=tdynamicsmallint.create;
itempleft:=tdynamicsmallint.create;
itempright:=tdynamicsmallint.create;

//BASIC
addbasic('none',ntranslate('none'),abnone);
addbasic('silence',ntranslate('silence'),absilence);
addbasic('shades',ntranslate('shades'),abshades);
addbasic('shades',ntranslate('shades'),abshades2);
addbasic('shades',ntranslate('shades'),abshades3);
addbasic('scale',ntranslate('scale'),abScale);
addbasic('scale',ntranslate('scale'),abScale2);
addbasic('scale',ntranslate('scale'),abScale3);
addbasic('vol1',ntranslate('vol')+' 1%',abvol1);
addbasic('vol5',ntranslate('vol')+' 5%',abvol5);
addbasic('vol10',ntranslate('vol')+' 10%',abvol10);
addbasic('vol25',ntranslate('vol')+' 25%',abvol25);
addbasic('vol50',ntranslate('vol')+' 50%',abvol50);
addbasic('vol75',ntranslate('vol')+' 75%',abvol75);
addbasic('vol125',ntranslate('vol')+' 125%',abvol125);
addbasic('vol150',ntranslate('vol')+' 150%',abvol150);
addbasic('vol175',ntranslate('vol')+' 175%',abvol175);
addbasic('vol200',ntranslate('vol')+' 200%',abvol200);
//ACTIONS
addaction('echo1',ntranslate('echo')+' +1ms',1,0,aaEcho);
addaction('echo2',ntranslate('echo')+' +2ms',2,0,aaEcho);
addaction('echo3',ntranslate('echo')+' +3ms',3,0,aaEcho);
addaction('echo4',ntranslate('echo')+' +4ms',4,0,aaEcho);
addaction('echo5',ntranslate('echo')+' +5ms',5,0,aaEcho);
addaction('echo6',ntranslate('echo')+' +6ms',6,0,aaEcho);
addaction('echo7',ntranslate('echo')+' +7ms',7,0,aaEcho);
addaction('echo8',ntranslate('echo')+' +8ms',8,0,aaEcho);
addaction('echo9',ntranslate('echo')+' +9ms',9,0,aaEcho);
addaction('echo10',ntranslate('echo')+' +10ms',10,0,aaEcho);
addaction('echo20',ntranslate('echo')+' +20ms',20,0,aaEcho);
addaction('echo30',ntranslate('echo')+' +30ms',30,0,aaEcho);
addaction('echo40',ntranslate('echo')+' +40ms',40,0,aaEcho);
addaction('echo50',ntranslate('echo')+' +50ms',50,0,aaEcho);
addaction('echo60',ntranslate('echo')+' +60ms',60,0,aaEcho);
addaction('echo70',ntranslate('echo')+' +70ms',70,0,aaEcho);
addaction('echo80',ntranslate('echo')+' +80ms',80,0,aaEcho);
addaction('echo90',ntranslate('echo')+' +90ms',90,0,aaEcho);
addaction('echo100',ntranslate('echo')+' +100ms',100,0,aaEcho);
addaction('echo200',ntranslate('echo')+' +200ms',200,0,aaEcho);
addaction('echo300',ntranslate('echo')+' +300ms',300,0,aaEcho);
addaction('echo400',ntranslate('echo')+' +400ms',400,0,aaEcho);
addaction('echo500',ntranslate('echo')+' +500ms',500,0,aaEcho);
addaction('echo600',ntranslate('echo')+' +600ms',600,0,aaEcho);
addaction('echo700',ntranslate('echo')+' +700ms',700,0,aaEcho);
addaction('echo800',ntranslate('echo')+' +800ms',800,0,aaEcho);
addaction('echo900',ntranslate('echo')+' +900ms',900,0,aaEcho);
addaction('echo1000',ntranslate('echo')+' +1,000ms',1000,0,aaEcho);
addaction('echo2000',ntranslate('echo')+' +2,000ms',2000,0,aaEcho);
addaction('echo3000',ntranslate('echo')+' +3,000ms',3000,0,aaEcho);
addaction('echo4000',ntranslate('echo')+' +4,000ms',4000,0,aaEcho);
addaction('echo5000',ntranslate('echo')+' +5,000ms',5000,0,aaEcho);
addaction('echo10000',ntranslate('echo')+' +10,000ms',10000,0,aaEcho);
addaction('echo20000',ntranslate('echo')+' +20,000ms',20000,0,aaEcho);
addaction('swaplr',ntranslate('swap left/right'),0,0,aaSwapLR);
//MATRIX
addmatrix('enhance',ntranslate('enhance'),'d8|-1 10 -1');
addmatrix('enhance',ntranslate('enhance'),'d6|-1 -1 -1 12 -1 -1 -1');
addmatrix('enhance',ntranslate('enhance'),'d8|-1 -1 -1 -1 16 -1 -1 -1 -1');
addmatrix('soften',ntranslate('soften'),'d5|1 3 1');
addmatrix('blur',ntranslate('blur'),'d5|1 1 1 1 1');
addmatrix('blur',ntranslate('blur'),'d7|1 1 1 1 1 1 1');
addmatrix('blur',ntranslate('blur'),'d9|1 1 1 1 1 1 1 1 1');
end;
//## destroy ##
destructor taudio.destroy;
var
   p:integer;
begin
try
//controls
freeobj(@iswap);
freeobj(@ileft);
freeobj(@iright);
for p:=0 to aoeMaxtrack do freeobj(@itemp[p]);
freeobj(@itempleft);
freeobj(@itempright);
//self
inherited;
except;end;
end;
//## getpackets ##
function taudio.getpackets:integer;
begin
try;result:=ileft.size;except;end;
end;
//## bytesleft ##
function taudio.bytesleft:integer;
begin
try;result:=(ileft.size*2);except;end;
end;
//## bytesright ##
function taudio.bytesright:integer;
begin
try;result:=(iright.size*2);except;end;
end;
//## getfiltercount ##
function taudio.getfiltercount:integer;
begin
try;result:=high(ifilters)+1;except;end;
end;
//## getfilter ##
function taudio.getfilter(x:integer):string;
begin
try;if (x>=0) and (x<filtercount) then result:=ifilters[x] else result:='';except;end;
end;
//## setfilter ##
procedure taudio.setfilter(x:integer;y:string);
begin
try;if (x>=0) and (x<filtercount) then ifilters[x]:=y;except;end;
end;
//## getenabled ##
function taudio.getenabled(x:integer):boolean;
begin
try;if (x>=0) and (x<filtercount) then result:=ienabled[x] else result:=false;except;end;
end;
//## setenabled ##
procedure taudio.setenabled(x:integer;y:boolean);
begin
try;if (x>=0) and (x<filtercount) then ienabled[x]:=y;except;end;
end;
//## settrailer ##
procedure taudio.settrailer(x:integer);
begin
try;itrailer:=frcmin(x,0);except;end;
end;
//## setautoboost ##
procedure taudio.setautoboost(x:integer);
begin
try;iautoboost:=frcmin(x,0);except;end;
end;
//## setswaplength ##
procedure taudio.setswaplength(x:integer);//ms
begin
try;iswaplength:=frcmin(x,0);except;end;
end;
//## setswapswitch ##
procedure taudio.setswapswitch(x:integer);
begin
try;iswapswitch:=frcmin(x,0);except;end;
end;
//## find ##
function taudio.find(_rawname:string;var _index:integer):boolean;
var
   p:integer;
begin
try
//defaults
result:=false;
_index:=-1;
//scan
//.rawname
for p:=0 to (icount-1) do if (comparetext(iitems[p].rawname,_rawname)=0) then
   begin
   _index:=p;
   result:=true;
   break;
   end;//end of if
//.name - translated name
if not result then for p:=0 to (icount-1) do if (comparetext(iitems[p].name,_rawname)=0) then
   begin
   _index:=p;
   result:=true;
   break;
   end;//end of if
except;end;
end;
//## range ##
function taudio.range(var _rawname,_name:string):boolean;
var
   tmp:string;
begin
try
result:=(icount<high(iitems)) and (_name<>'') and (_rawname<>'');
if result then
   begin
   //set
   _rawname:=lowercase(_rawname);
   if (ilastrawname=_rawname) then inc(ilastcount)
   else
      begin
      ilastrawname:=_rawname;
      ilastcount:=0;
      end;//end of if
   _name:=general.asname(_name);
   //extra
   if (ilastcount>=1) then
      begin
      tmp:=inttostr(ilastcount+1);
      _rawname:=_rawname+tmp;
      _name:=_name+#32+tmp;
      end;//end of if
   //clear
   clear(icount);
   end;//end of if
except;end;
end;
//## clear ##
procedure taudio.clear(x:integer);
begin
try
if (x>=0) and (x<=high(iitems)) then
   begin
   with iitems[icount] do
   begin
   rawname:='';
   name:='';
   basic:=nil;
   action:=nil;
   matrix:=nil;
   fillchar(mi,sizeof(mi),0);
   v1:=0;
   v2:=0;
   end;//end of with
   end;//end of if
except;end;
end;
//## addbasic ##
procedure taudio.addbasic(_rawname,_name:string;_event:taudiobasicevent);
begin
try
//check
if (@_event=nil) then exit;
if not range(_rawname,_name) then exit;
//set
with iitems[icount] do
begin
rawname:=_rawname;
name:=_name;
basic:=_event;
end;//end of with
inc(icount);
except;end;
end;
//## addaction ##
procedure taudio.addaction(_rawname,_name:string;_v1,_v2:integer;_event:taudioaction);
begin
try
//check
if (@_event=nil) then exit;
if not range(_rawname,_name) then exit;
//set
with iitems[icount] do
begin
rawname:=_rawname;
name:=_name;
action:=_event;
v1:=_v1;
v2:=_v2;
end;//end of with
inc(icount);
except;end;
end;
//## addmatrix ##
procedure taudio.addmatrix(_rawname,_name,_mi:string);
var
   e:string;
begin
try
//check
if not range(_rawname,_name) then exit;
//set
with iitems[icount] do
begin
if not readmatrix(_mi,mi,matrix,e) then exit;
rawname:=_rawname;
name:=_name;
end;//end of with
inc(icount);
except;end;
end;
//## names ##
function taudio.names(sol,eol:string;rawname:boolean):string;
var
   p:integer;
begin//Note: sol=start of line, eol=end of line
try
//defaults
result:='';
//get
for p:=0 to (icount-1) do result:=result+sol+general.aorbstr(iitems[p].name,iitems[p].rawname,rawname)+eol;
except;end;
end;
//## valid ##
function taudio.valid(x:integer):boolean;
begin
try;result:=(x>=0) and (x<icount);except;end;
end;
//## getrawname ##
function taudio.getrawname(x:integer):string;
begin
try;if valid(x) then result:=iitems[x].rawname else result:='';except;end;
end;
//## getitem ##
function taudio.getitem(x:integer):taudioitem;
begin
try
if valid(x) then result:=iitems[x]
else
   begin
   result.name:='';
   result.rawname:='';
   result.basic:=nil;
   result.action:=nil;
   result.matrix:=nil;
   result.v1:=0;
   result.v2:=0;
   end;//end of if
except;end;
end;
//## readmatrix ##
function taudio.readmatrix(x:string;var y:taudiomatrixinfo;var yevent:taudiomatrix;var e:string):boolean;
const
   maxv=500;//-500..+500
var//Note:
   //1. dXXX=division number default of "1"
   //2. vXXX=pixel level number of "0", can also be specified without "v" (range of -500...500)
   //3. end=stop reading data at this point
   //4. //<comment goes here>
   a:tstringlist;
   v1,v2,v3,vlen,p:integer;
   v:string;
begin
try
//defaults
result:=false;
e:=gecUnknownFormat;
a:=nil;
fillchar(y,sizeof(y),0);
y.vdiv:=1;
yevent:=nil;
//check
if (x='') then exit;
//init
a:=tstringlist.create;
a.text:=x;
//.remove comments
for p:=(a.count-1) downto 0 do if (copy(a.strings[p],1,2)='//') then a.delete(p);
x:=a.text;
//.clean
general.swapchars(x,#32,#10);
general.swapchars(x,#160,#10);
general.swapchars(x,',',#10);
general.swapchars(x,'|',#10);
a.text:=lowercase(x);
//get
for p:=0 to (a.count-1) do
begin
v:=a.strings[p];
vlen:=length(v);
if (vlen<>0) then
   begin
   //get
   v1:=frcrange(strint(v),-maxv,maxv);
   v2:=frcrange(strint(copy(v,2,vlen)),-maxv,maxv);
   v3:=frcrange(strint(copy(v,2,vlen)),-32768,32767);
   //set
   if (v[1]='d') then//divider - full range
      begin
      if (v3=0) then v3:=1;
      y.vdiv:=v3;
      end
   else if (v[1]='b') then//bias - full range - add/sub. from final pixel value
      begin
      y.vbias:=v3;
      end
   else //"v" or "undefined"
      begin
      y.v[y.count]:=general.aorb(v1,v2,(v[1]='v'));
      inc(y.count);
      if (y.count>high(y.v)) then break;
      end;//end of if
   end;//end of if
end;//end of loop
//finalise
if (y.count>=1) and general.iseven(y.count) then dec(y.count);//odd
//event
case y.count of
3:yevent:=amMatrix3;
5:yevent:=amMatrix5;
7:yevent:=amMatrix7;
9:yevent:=amMatrix9;
end;//end of case
//successful
result:=(@yevent<>nil);
except;end;
try;freeobj(@a);except;end;
end;
//## pullinit ##
function taudio.pullinit(var pos:integer;var info:taudiopullinfo;filterlist:string;right:boolean):boolean;
var
   tmpl,tmpr:tdynamicsmallint;
   a:tstringlist;
   p,v:integer;
   e:string;
begin
try
//defaults
result:=false;
a:=nil;
fillchar(info,sizeof(info),0);
if (pos<0) then pos:=0;
//init
case right of
false:begin
   info.left:=ileft;
   info.right:=iright;
   end;//end of begin
true:begin
   info.right:=ileft;
   info.left:=iright;
   end;//end of begin
end;//end of case
//filter list
a:=tstringlist.create;
a.text:=filterlist;
for p:=0 to (a.count-1) do if find(a.strings[p],v) and (v>=1) then
   begin
   //set
   //.action
   if assigned(iitems[v].action) and (info.ac<=high(info.a)) then
      begin
      info.a[p]:=iitems[v].action;
      info.v1[p]:=iitems[v].v1;
      info.v2[p]:=iitems[v].v2;
      info.aon:=true;
      inc(info.ac);
      end;
   //.filters
   if assigned(iitems[v].basic) or assigned(iitems[v].matrix) then
      begin
      if assigned(iitems[v].basic) then
         begin
         info.b[p]:=iitems[v].basic;
         info.bon[p]:=true;
         end;//end of if
      if assigned(iitems[v].matrix) then
         begin
         info.m[p]:=iitems[v].matrix;
         info.mi[p]:=@iitems[v].mi;
         info.mon[p]:=true;
         end;//end of if
      info.fon:=true;
      inc(info.fc);
      end;//end of if
   end;//end of if
//actions
if info.aon then for p:=0 to (info.ac-1) do
   begin
   tmpl:=info.left;
   tmpr:=info.right;
   info.a[p](pos,info.v1[p],info.v2[p],info.left,info.right,tmpl,tmpr,e);
   end;//end of loop
//successful
//Note: if "pos=minint" then channel is disabled (ie aaOff)
result:=(pos>minint);
except;end;
try;freeobj(@a);except;end;
end;
//## pull ##
procedure taudio.pull(var pos:integer;var info:taudiopullinfo;var data:tdynamicsmallint;var count:integer);
var
   dlSize,drSize,ocount,dlen,i,minp,maxp,p:integer;
   v:smallint;
   tmpl,tmpr:tdynamicsmallint;//pointers only
   dl,dr:pdlSMINT;
begin
try
//defaults
ocount:=count;
count:=0;
dlen:=0;
dl:=info.left.core;
dr:=info.right.core;
dlSize:=info.left.size;
drSize:=info.right.size;
if (ocount<1) then exit;
//check - channel is disabled
if (dl=nil) or (dr=nil) or (data=nil) or (ocount<1) then exit;
//range
if (ocount>data.size) then data.setparams(ocount,ocount,0);
//scan
minp:=pos;
maxp:=pos+ocount-1;
for p:=minp to maxp do
begin
//check
if (info.packetcount>=ipacketlimit) then break;
//get
v:=abVal(pos,dlSize,dl);
//filters
if info.fon then for i:=0 to (info.fc-1) do
   begin
   if info.bon[i] then info.b[i](v);
   if info.mon[i] then info.m[i](v,pos,dlsize,dl,info.mi[i]^);
   end;//end of if
//set
data.items[count]:=v;
//inc
inc(pos);
inc(info.packetcount);
inc(count);
if (count>=ocount) then break;
end;//end of loop
except;end;
end;
//## readclear ##
procedure taudio.readclear;
var
   p:integer;
begin
try
ileftratio:=1;
irightratio:=1;
ipacketlimit:=-1;
ibytes:=0;
idata:='';
ileftcount:=0;
irightcount:=0;
for p:=0 to aoeMaxTrack do
begin
itemp[p].clear;
ipos[p]:=0;
iuse[p]:=false;
imaster[p]:=false;
fillchar(iinfo[p],sizeof(iinfo[p]),0);
end;//end of loop
imaster[aoeMasterLeft]:=true;
imaster[aoeMasterRight]:=true;
itempleft.clear;
itempright.clear;
iswap.init(round(iswaplength*44.1),round(iswapswitch*44.1),1000);//ms to packets
except;end;
end;
//## readstart ##
function taudio.readstart(var data,e:string):boolean;
label
   skipend;
var
   v,maxpos,p:integer;
   right:boolean;
   c,b,a:tint4;
begin
try
//defaults
result:=false;
e:=gecUnexpectedError;
//check
if ireading then exit else ireading:=true;
//init
e:=gecOutOfMemory;
readclear;
maxpos:=0;
//get
for p:=0 to aoeMaxtrack do
begin
right:=(p>aoeLeft);
if ienabled[p] and pullinit(ipos[p],iinfo[p],ifilters[p],right) then
   begin
   v:=general.posn(ipos[p]);
   if (v>maxpos) then maxpos:=v;
   iuse[p]:=true;
   if right then inc(irightcount) else inc(ileftcount);
   end;//end of if
end;//end of if
//check
if (ileftcount=0) and (irightcount=0) then
   begin
   e:=gecEmpty;
   readclear;
   ireading:=false;
   goto skipend;
   end;//end of if
//vars                           //44 sammples = 1 ms
ipacketlimit:=ileft.size+maxpos+(itrailer*44);//extend length of song by "maxpos" when "aaEcho" has been used
ibytes:=58+(ipacketlimit*4);
//header
a.val:=ibytes-8;
b.val:=ipacketlimit;
c.val:=b.val*2*2;//v3: "total samples" x "number of channels" x "bytes per sample" [55..58]
data:=
#82#73#70#70+
a.chars[0]+a.chars[1]+a.chars[2]+a.chars[3]+//v1: filesize-8 [5..8]
#87#65#86#69#102#109#116+
#32#18#0#0#0+
//.wave sub header [21..34..36 = 14+2 = 16 bytes]
#1#0+//PCM format
#2#0+//Number of channels
#68#172#0#0+//Samples per second
#16#177#2#0+//Ave. bytes per second
#4#0+//Block align
#16#0+//16 bits per sample
//.other main RIFF header information
#0#0#102+//[37..39]
#97#99#116#4#0#0#0+//[40..46]
b.chars[0]+b.chars[1]+b.chars[2]+b.chars[3]+//v2: total samples [47..50]
#100#97#116#97+//[51..54]
c.chars[0]+c.chars[1]+c.chars[2]+c.chars[3];//v3: "total samples" x "number of channels" x "bytes per sample" [55..58]
//successful
result:=true;
skipend:
except;end;
end;
//## readpull ##
function taudio.readpull(var data,e:string):boolean;
label
   skipend;
const
   normaliselimit=2;//Tested above 2 (upto 4 and distortion occurs, 2 is OK - 13JUN2007)
var
   tmp:array[0..aoeMaxTrack] of string;
   left,right:tdynamicsmallint;
   c,_leftcount,_rightcount,i,p,count:integer;
   a,b:twrd2;
   vol,vor,vl,vr,v0,v1,v2,v3,v4,v5,v6,v7:pdlSMINT;
   vn0,vn1,vn2,vn3,vn4,vn5,vn6,vn7:boolean;
   tmpv,lmax2,rmax2,lmax,rmax:smallint;
   ratio:extended;
begin//Appends new content to "data"
try
//defaults
result:=false;
data:='';
e:=gecOutOfMemory;
//check
if not ireading then
   begin
   e:=gecUnexpectedError;
   exit;
   end;//end of if
//init
_leftcount:=frcmin(ileftcount,1);
_rightcount:=frcmin(irightcount,1);
//size
count:=1000;
if (count>itempleft.size) then itempleft.setparams(count,count,0);
if (count>itempright.size) then itempright.setparams(count,count,0);
for p:=0 to aoeMaxTrack do if (count>itemp[p].size) then itemp[p].setparams(count,count,0);
//get
for p:=0 to aoeMaxTrack do if iuse[p] and (not imaster[p]) then
   begin
   pull(ipos[p],iinfo[p],itemp[p],count);
   //no more data to read
   if (count=0) then goto skipend;
   end;//end of if
vol:=ileft.core;
vor:=iright.core;
vl:=itempleft.core;
vr:=itempright.core;
v0:=itemp[1].core;
v1:=itemp[2].core;
v2:=itemp[3].core;
v3:=itemp[4].core;
v4:=itemp[6].core;
v5:=itemp[7].core;
v6:=itemp[8].core;
v7:=itemp[9].core;
//0=master left
vn0:=iuse[1];
vn1:=iuse[2];
vn2:=iuse[3];
vn3:=iuse[4];
//5=master right
vn4:=iuse[6];
vn5:=iuse[7];
vn6:=iuse[8];
vn7:=iuse[9];
c:=0;
//set
for p:=0 to (count-1) do
begin
vl[p]:=smallint((v0[p]+v1[p]+v2[p]+v3[p]) div _leftcount);
vr[p]:=smallint((v4[p]+v5[p]+v6[p]+v7[p]) div _rightcount);
end;//end of loop
//normalise
if inormalise then
   begin
   lmax:=0;
   rmax:=0;
   lmax2:=0;
   rmax2:=0;
   for p:=0 to (count-1) do
   begin
   //.left
   tmpv:=vl[p];
   if (tmpv<0) then tmpv:=-tmpv;
   if (tmpv>lmax) then lmax:=tmpv;
   tmpv:=v0[p];//v1=first used track
   if (tmpv<0) then tmpv:=-tmpv;
   if (tmpv>lmax2) then lmax2:=tmpv;
   //.right
   tmpv:=vr[p];
   if (tmpv<0) then tmpv:=-tmpv;
   if (tmpv>rmax) then rmax:=tmpv;
   tmpv:=v4[p];//v5=first used track
   if (tmpv<0) then tmpv:=-tmpv;
   if (tmpv>rmax2) then rmax2:=tmpv;
   end;//end of if
   //.set L
   if (lmax<1) then lmax:=1;
   if (lmax2<1) then lmax2:=1;
   ratio:=lmax2/lmax;
   if (ratio>normaliselimit) then ratio:=normaliselimit;
   if (ratio>1) then for p:=0 to (count-1) do vl[p]:=smallint(round(vl[p]*ratio));
   //.set R
   if (rmax<1) then rmax:=1;
   if (rmax2<1) then rmax2:=1;
   ratio:=rmax2/rmax;
   if (ratio>normaliselimit) then ratio:=normaliselimit;
   if (ratio>1) then for p:=0 to (count-1) do vr[p]:=smallint(round(vr[p]*ratio));
   end;//end of if
//swap
if (iswap.length>=1) then for p:=0 to (count-1) do
   begin
   //get
   iswap.next;
   a.si:=vl[p];
   b.si:=vr[p];
   //set
   vl[p]:=smallint(((integer(a.si)*iswap.val1)+(integer(b.si)*iswap.val2)) div 1000);
   vr[p]:=smallint(((integer(b.si)*iswap.val1)+(integer(a.si)*iswap.val2)) div 1000);
   end;//end of loop
//autoboost
if (iautoboost>=1) then
   begin
   lmax:=0;
   rmax:=0;
   for p:=0 to (count-1) do
   begin
   //.left
   tmpv:=vl[p];
   if (tmpv<0) then tmpv:=-tmpv;
   if (tmpv>lmax) then lmax:=tmpv;
   //.right
   tmpv:=vr[p];
   if (tmpv<0) then tmpv:=-tmpv;
   if (tmpv>rmax) then rmax:=tmpv;
   end;//end of if
   if (lmax>=1) then
      begin
      ratio:=(32767/lmax);
      if (ratio>iautoboost) then ratio:=iautoboost;
      ileftratio:=(ileftratio*5+ratio)/6;//adjust ratio slightly
      if (ileftratio>1) then for p:=0 to (count-1) do vl[p]:=smallint(round(vl[p]*ratio));
      end;//end of if
   if (rmax>=1) then
      begin
      ratio:=(32767/rmax);
      if (ratio>iautoboost) then ratio:=iautoboost;
      irightratio:=(irightratio*5+ratio)/6;//adjust ratio slightly
      if (irightratio>1) then for p:=0 to (count-1) do vr[p]:=smallint(round(vr[p]*ratio));
      end;//end of if
   end;//end of if
//filter - master left/right
p:=aoeMasterLeft;
if iuse[p] then
   begin
   count:=itempleft.size;
   ipos[p]:=0;
   iinfo[p].left:=itempleft;
   iinfo[p].right:=itempright;
   pull(ipos[p],iinfo[p],itempleft,count);
   end;//end of if
p:=aoeMasterRight;
if iuse[p] then
   begin
   count:=itempleft.size;
   ipos[p]:=0;
   iinfo[p].left:=itempright;
   iinfo[p].right:=itempleft;
   pull(ipos[p],iinfo[p],itempright,count);
   end;//end of if
//write - convert array to string
setlength(data,count*4);
i:=1;
for p:=0 to (count-1) do
begin
//get
a.si:=vl[p];
b.si:=vr[p];
//set
data[i+0]:=a.chars[aoeByte0];//left
data[i+1]:=a.chars[aoeByte1];
data[i+2]:=b.chars[aoeByte0];//right
data[i+3]:=b.chars[aoeByte1];
//inc
inc(i,4);
end;//end of loop
//successful
result:=true;
skipend:
except;end;
end;
//## readfinish ##
procedure taudio.readfinish;
begin
try
if ireading then
   begin
   readclear;
   ireading:=false;
   end;//end of if
except;end;
end;
//## tofile ##
function taudio.tofile(x:string;var e:string):boolean;
label
   skipend;
var
   pos,dlen:integer;
   tmp,data:string;
begin
try
//defaults
result:=false;
data:='';
tmp:='';
dlen:=0;
e:=gecUnexpectedError;
if ireading then exit;
//header
doprogress(0,false);
if not readstart(tmp,e) then goto skipend;
e:=gecFileInUse;
if not remfile(x) then goto skipend;
if not io.toFILEAPPEND(x,tmp,e) then goto skipend;
pos:=length(tmp);
tmp:='';
//scan
e:=gecOutOfMemory;
while true do
begin
//get
if not readpull(tmp,e) then break;
pushb(dlen,data,tmp);
if (dlen>=1000000) then//1Mb
   begin
   //finalise
   pushb(dlen,data,'');
   //write
   if not io.toFILEAPPEND(x,data,e) then goto skipend;
   inc(pos,dlen);
   data:='';
   dlen:=0;
   end;//end of if
doprogress(general.cpercentage(pos,ibytes),false);
end;//end of loop
//finalise
if (dlen>=1) then
   begin
   //finalise
   pushb(dlen,data,'');
   //write
   if not io.toFILEAPPEND(x,data,e) then goto skipend;
   data:='';
   dlen:=0;
   end;//end of if
//successful
result:=true;
skipend:
except;end;
try
doprogress(0,true);
readfinish;
except;end;
end;
//## fromfile ##
function taudio.fromfile(x:string;var e:string):boolean;
label
   skipend;
const
   hdrsize=58;
var
   c,fsize,yp,i,p,pos:integer;
   fdate:tdatetime;
   y:string;
   a,b:twrd2;
begin
try
//defaults
result:=false;
e:=gecUnexpectedError;
//check
if ireading then exit;
//header
pos:=0;
if not io.fromFILEb(x,y,e,fsize,pos,hdrsize,fdate) then goto skipend;
e:=gecUnknownFormat;
if (length(y)<>hdrsize) then goto skipend;
//size
c:=(fsize-hdrsize) div 4;//[2channels]*[2bytes per packet]
ileft.clear;
iright.clear;
ileft.setparams(c,c,0);
iright.setparams(c,c,0);
//data
doprogress(0,false);
e:=gecOutOfMemory;
i:=0;
while io.fromFILEb(x,y,e,fsize,pos,1000000,fdate) and (y<>'') do
begin
yp:=1;
for p:=1 to (length(y) div 4) do
begin
//get
a.chars[aoeByte0]:=y[yp+0];//left
a.chars[aoeByte1]:=y[yp+1];
b.chars[aoeByte0]:=y[yp+2];//right
b.chars[aoeByte1]:=y[yp+3];
//set
ileft.items[i]:=a.si;
iright.items[i]:=b.si;
//inc
inc(yp,4);
inc(i);
end;//end of loop
doprogress(general.cpercentage(pos,fsize),false);
end;//end of loop
//successful
result:=true;
skipend:
except;end;
try;doprogress(0,true);except;end;
end;
//## doprogress ##
procedure taudio.doprogress(pert:extended;finished:boolean);
begin
try
//range
if (pert<0) then pert:=0
else if (pert>100) then pert:=100;
//event
if assigned(onprogress) then onprogress(self,round(pert),pert,finished);
except;end;
end;

//## thashtable ################################################################
//## hashkey ##
function hashkey(key:longint):smallint;
begin
try
result:=smallint(((Key SHR (GIFCodeBits-8)) XOR Key) MOD HashSize);
except;end;
end;
//## nexthashkey ##
function nexthashkey(hkey:smallint):smallint;
var
  disp:smallint;
begin
try
//defaults
result:=0;
//secondary hash (after G. Knott)
disp:=HashSize-HKey;
if (HKey=0) then disp:=1;
//disp := 13;		// disp should be prime relative to HashSize, but
			// it doesn't seem to matter here...
dec(HKey,disp);
if (HKey<0) then inc(HKey,HashSize);
Result:=HKey;
except;end;
end;
//## create ##
constructor thashtable.create;
begin//longInt($FFFFFFFF) = -1, 'TGIFImage implementation assumes $FFFFFFFF = -1');
inherited create;
getmem(hashtable,sizeof(thasharray));
clear;
end;
//## destroy ##
destructor thashtable.destroy;
begin
try
freemem(hashtable);
inherited destroy;
except;end;
end;
//## clear ##
procedure thashtable.clear;
begin
try;fillchar(hashtable^,sizeof(thasharray),$FF);except;end;
end;
//## insert  ##
procedure thashtable.insert(key:longint;code:smallint);
var
   hkey:smallint;
begin
try
//Create hash key from prefix string
hkey:=hashkey(key);
//Scan for empty slot
//while (HashTable[HKey] SHR GIFCodeBits <> HashEmpty) do { Unoptimized }
while (hashtable[hkey] and (hashempty shl gifcodebits)<>(hashempty shl gifcodebits)) do hkey:=nexthashkey(hkey);
//Fill slot with key/value pair
hashtable[hkey]:=(key shl gifcodebits) or (code and gifcodemask);
except;end;
end;
//## lookup ##
function thashtable.lookup(key:longInt):smallint;
var
// Search for key in hash table.
// Returns value if found or -1 if not
  hkey:smallint;
  htkey:longInt;
begin
try
// Create hash key from prefix string
HKey := HashKey(Key);
// Scan table for key
// HTKey := HashTable[HKey] SHR GIFCodeBits; { Unoptimized }
Key := Key SHL GIFCodeBits; { Optimized }
HTKey := HashTable[HKey] AND (HashEmpty SHL GIFCodeBits); { Optimized }
// while (HTKey <> HashEmpty) do { Unoptimized }
while (HTKey <> HashEmpty SHL GIFCodeBits) do { Optimized }
begin
if (Key = HTKey) then
   begin
   // Extract and return value
   Result := HashTable[HKey] AND GIFCodeMask;
   exit;
   end;
// Try next slot
HKey := NextHashKey(HKey);
// HTKey := HashTable[HKey] SHR GIFCodeBits; { Unoptimized }
HTKey := HashTable[HKey] AND (HashEmpty SHL GIFCodeBits); { Optimized }
end;//end of loop
// Found empty slot - key doesn't exist
Result := -1;
except;end;
end;

//## tccs ######################################################################
//## create ##
constructor tccs.create;
begin
//self
inherited;
//vars
icanprinttimeref:=ms64-10000;
ilastcanprint:=false;
//patches
patchsinit;
end;
//## destroy ##
destructor tccs.destroy;
begin
try
//delete print temp file
remfile(bvfportable(bvfTemp)+lowercase(programname+'-printimage.bmp'));
//self
inherited;
except;end;
end;
//## reducecolors ##
function tccs.reducecolors(x:tbitmap;colorlimit:integer;fast:boolean;var colorsused:integer;var e:string):boolean;//15SEP2007
var
   a:array[0..1023] of trgbcolor;
begin
try;result:=reducecolorsex(x,colorlimit,true,a,colorsused,e);except;end;
end;
//## reducecolorsex ##
function tccs.reducecolorsex(x:tbitmap;colorlimit:integer;fast:boolean;var a:array of trgbcolor;var acount:integer;var e:string):boolean;//15SEP2007
label//colorlimit=2..1024
   redo,skipdone;
var
   i,alimit,p,w,h,dy,dx:integer;
   dv:byte;
   r:prgbcolorrow;
   zc:trgbcolor;
begin
try
//defaults
result:=false;
e:=gecUnexpectedError;
acount:=0;
//check
if not nonempty24(x) then exit;
if (low(a)<>0) and (high(a)<1) then exit;
e:=gecOutOfMemory;
//INIT
w:=x.width;
h:=x.height;
fillchar(a,sizeof(a),0);
dv:=1;//divide color element by facter, increases in color limit is reached, to reduce colors gradually
//.first color is WHITE - transparent color (wether it's used or not)
a[0].r:=255;
a[0].g:=255;
a[0].b:=255;
alimit:=frcrange(colorlimit,2,high(a)+1);
//GET
redo:
acount:=1;
//y
for dy:=0 to (h-1) do
begin
r:=x.scanline[dy];
//x
for dx:=0 to (w-1) do
begin
//get
zc:=r[dx];
//filter - only non-transparent colors
if (dv>=2) and (not((zc.r=255) and (zc.g=255) and (zc.b=255))) then
   begin
   zc.r:=byte((zc.r div dv)*dv);
   zc.g:=byte((zc.g div dv)*dv);
   zc.b:=byte((zc.b div dv)*dv);
   end;//end of if
//scan - look in palette to see if we already have this color
i:=-1;
for p:=0 to (acount-1) do if (a[p].r=zc.r) and (a[p].g=zc.g) and (a[p].b=zc.b) then
   begin
   i:=p;
   break;
   end;//end of if
//add color
if (i=-1) then
   begin
   //palette is full
   if (acount>=alimit) then
      begin
      if fast then inc(dv,10) else inc(dv);
      //reduce color resolution
      if (dv<=200) then goto redo//retry
      else goto skipdone;
      end;//end of if
   //set
   a[acount]:=zc;
   inc(acount);
   end;//end of loop
end;//end of loop - x
end;//end of loop - y
//adjust image colors (dv>=2)
if (dv>=2) then
   begin
   for dy:=0 to (h-1) do
   begin
   r:=x.scanline[dy];
   for dx:=0 to (w-1) do
   begin
   //get
   zc:=r[dx];
   //filter - exclude transparent color "WHITE"
   if not((zc.r=255) and (zc.g=255) and (zc.b=255)) then
      begin
      zc.r:=byte((zc.r div dv)*dv);
      zc.g:=byte((zc.g div dv)*dv);
      zc.b:=byte((zc.b div dv)*dv);
      //set
      r[dx]:=zc;
      end;//end of if
   end;//end of loop - x
   end;//end of loop - y
   end;//end of if
skipdone:
//successful
result:=true;
except;end;
end;
//## palfind ##
function tccs.palfind(var a:array of trgbcolor;acount:integer;var z:trgbcolor):byte;
var//assumes "a is 0..X"
   p:integer;
begin
try
//defaults
result:=0;
//scan - Note: r/b are swapped
for p:=0 to (acount-1) do if (a[p].r=z.r) and (a[p].g=z.g) and (a[p].b=z.b) then
   begin
   result:=p;
   break;
   end;//end of if
except;end;
end;
//## gridtest ##
function tccs.gridtest(d:tbitmap;dpi:integer;vert:boolean;var e:string):boolean;//17JUN2007
label
   skipend;
var
   a:tbitmap;
   r:prgbcolorrow;
   tmp2,tmp,dy,dy2,dx,dx2,climit,c,i,p:integer;
   z,col1,col2:trgbcolor;
   ok:boolean;
begin
try
//defaults
result:=false;
e:=gecUnexpectedError;
a:=nil;
if (d=nil) or (not valid24(d)) then exit;
//range
dpi:=frcmin(dpi,1);
//init
e:=gecOutOfMemory;
a:=newbmp(dpi div 2,dpi);
c:=0;
climit:=dpi div 10;
col1:=intrgb(rgb(255,255,255));
col2:=intrgb(0);
z:=col2;
ok:=true;
//.scan
for p:=0 to (dpi-1) do
begin
//.draw
r:=a.scanline[p];
for i:=0 to (a.width-1) do r[i]:=z;
//.inc
if (c>=climit) then
   begin
   ok:=not ok;
   if ok then z:=col2 else z:=col1;
   c:=0;
   end;//end of if
inc(c);
end;//end of loop
if (not vert) and (not rotateby(a,-90,e)) then goto skipend;
e:=gecOutOfMemory;
//FRAME
d.canvas.brush.color:=clLime;
d.canvas.framerect(rect(0,0,d.width,d.height));
d.canvas.framerect(rect(1,1,d.width-1,d.height-1));

//VERTICAL (top->bottom)
if vert then
   begin
   //draw
   tmp:=(d.width-a.width) div 2;
   dx:=tmp-(a.width div 4);
   dx2:=tmp+(a.width div 4);
   ok:=false;
   //.base
   tmp:=tmp+(a.width div 2);
   tmp2:=(a.width div 3)+2;
   d.canvas.brush.color:=clRed;
   d.canvas.fillrect(rect(tmp-tmp2,0,tmp+tmp2,d.height));
   //.grid
   for p:=0 to ((d.height div a.height)+1) do
   begin
   d.canvas.draw(general.aorb(dx,dx2,ok),p*a.height,a);
   ok:=not ok;
   end;//end of if
   end
//HORIZONTAL (left->right)
else
   begin
   tmp:=(d.height-a.height) div 2;
   dy:=tmp-(a.height div 4);
   dy2:=tmp+(a.height div 4);
   ok:=false;
   //.base
   tmp:=tmp+(a.height div 2);
   tmp2:=(a.height div 3)+2;
   d.canvas.brush.color:=clRed;
   d.canvas.fillrect(rect(0,tmp-tmp2,d.width,tmp+tmp2));
   //.grid
   for p:=0 to ((d.width div a.width)+1) do
   begin
   d.canvas.draw(p*a.width,general.aorb(dy,dy2,ok),a);
   ok:=not ok;
   end;//end of if
   end;//end of if
//successful
result:=true;
skipend:
except;end;
try;freeobj(@a);except;end;
end;
//## gridlines ##
function tccs.gridlines(d:tbitmap;jump:integer;vertcolor,horzcolor:integer;var e:string):boolean;//13JUL2007
begin
try;result:=gridlinesex(d,rect(0,0,maxint,maxint),jump,jump,vertcolor,horzcolor,e);except;end;
end;
//## gridlinesex ##
function tccs.gridlinesex(d:tbitmap;drect:trect;vjump,hjump:integer;vertcolor,horzcolor:integer;var e:string):boolean;//07MAR2008
label//drect=non-zero just like "stretchdraw"
   skipend;
var
   leftoverx,dx:integer;
begin
try
//defaults
result:=false;
e:=gecUnexpectedError;
if (d=nil) or (not valid24(d)) then exit;
if (vertcolor=clnone) and (horzcolor=clnone) then
   begin
   e:=gecOK;
   exit;
   end;//end of if
//range
vjump:=frcmin(vjump,0);
hjump:=frcmin(hjump,0);
drect:=saferect(d,drect);
//get
e:=gecOutOfMemory;
//VERTICAL (top->bottom) - draw vertical lines
if (vertcolor<>clnone) and (vjump>=2) then
   begin
   dx:=drect.left+vjump;
   leftoverx:=(drect.right-drect.left);
   leftoverx:=leftoverx-((leftoverx div vjump)*vjump);
   d.canvas.pen.color:=vertcolor;
   d.canvas.pen.style:=psSolid;
   if (dx<=drect.bottom) then
      begin
      repeat
      d.canvas.moveto(dx,drect.top);
      d.canvas.lineto(dx,drect.bottom);
      inc(dx,vjump+general.insint(1,leftoverx>=1));
      dec(leftoverx);
      until (dx>=drect.right);
      end;//end of if
   end;//end of if
//HORIZONTAL (left->right)
if (horzcolor<>clnone) and (hjump>=2) then
   begin
   dx:=drect.top+hjump;
   leftoverx:=(drect.bottom-drect.top);
   leftoverx:=leftoverx-((leftoverx div hjump)*hjump);
   d.canvas.pen.color:=horzcolor;
   d.canvas.pen.style:=psSolid;
   if (dx<=drect.right) then
      begin
      repeat
      d.canvas.moveto(drect.left,dx);
      d.canvas.lineto(drect.right,dx);
      inc(dx,hjump+general.insint(1,leftoverx>=1));
      dec(leftoverx);
      until (dx>=drect.bottom);
      end;//end of if
   end;//end of if
//successful
result:=true;
skipend:
except;end;
end;
//## gridspaces ##
function tccs.gridspaces(d:tbitmap;vspacecount,hspacecount:integer;vertcolor,horzcolor:integer;var e:string):boolean;//07MAR2008
begin
try;result:=gridspacesex(d,rect(0,0,maxint,maxint),vspacecount,hspacecount,vertcolor,horzcolor,e);except;end;
end;
//## gridspacesex ##
function tccs.gridspacesex(d:tbitmap;drect:trect;vspacecount,hspacecount:integer;vertcolor,horzcolor:integer;var e:string):boolean;//07MAR2008
var
   vjump,hjump:integer;
begin
try
//defaults
result:=false;
e:=gecUnexpectedError;
if (d=nil) or (not valid24(d)) then exit;
drect:=saferect(d,drect);
//get
if (vspacecount=0) then vjump:=0 else vjump:=frcmin((drect.right-drect.left) div vspacecount,0);
if (hspacecount=0) then hjump:=0 else hjump:=frcmin((drect.bottom-drect.top) div hspacecount,0);
//set
result:=gridlinesex(d,drect,vjump,hjump,vertcolor,horzcolor,e);
except;end;
end;
//## tile ##
function tccs.tile(dr:trect;d,s:tbitmap;deg:integer;var e:string):boolean;//29MAY2007
label
   skipend;
var
   a:tbitmap;
   ry,rx:tdynamicinteger;
   xmap:pdlINTEGER;
   maxc,c,x,y:integer;
   rd,rs:prgbcolorrow;
   z:trgbcolor;
begin
try
//defaults
result:=false;
e:=gecUnexpectedError;
rx:=nil;
ry:=nil;
a:=s;
//check
if (d=nil) or (a=nil) or (dr.right<dr.left) or (dr.bottom<dr.top) or (not valid24(d)) or (not valid24(a)) then exit;
if (dr.left<0) or (dr.right>=d.width) or (dr.top<0) or (dr.bottom>=d.height) then
   begin
   e:=gecIndexOutOfRange;
   exit;
   end;//end of if
//ignore - source image is empty
if (s.width=0) or (s.height=0) then
   begin
   result:=true;
   exit;
   end;//end of if
//init
e:=gecOutOfMemory;
//get
if (deg<>0) then
   begin
   a:=newbmp(1,1);
   if not copybmp(a,s) then goto skipend;
   if not rotateby(a,deg,e) then goto skipend;
   end;//end of if
rx:=tdynamicinteger.create;
ry:=tdynamicinteger.create;
//.rx
c:=0;
maxc:=a.width-1;
rx.setparams(dr.right-dr.left+1,dr.right-dr.left+1,0);
for x:=dr.left to dr.right do
begin
rx.items[x-dr.left]:=c;
inc(c);
if (c>maxc) then c:=0;
end;//end of loop
xmap:=rx.core;
//.ry
c:=0;
maxc:=a.height-1;
ry.setparams(dr.bottom-dr.top+1,dr.bottom-dr.top+1,0);
for y:=dr.top to dr.bottom do
begin
ry.items[y-dr.top]:=c;
inc(c);
if (c>maxc) then c:=0;
end;//end of loop
//set
for y:=dr.top to dr.bottom do
begin
rd:=d.scanline[y];
rs:=a.scanline[ry.items[y-dr.top]];
 for x:=dr.left to dr.right do
 begin
 z:=rs[xmap[x-dr.left]];
 rd[x]:=z;
 end;//end of loop
end;//end of loop
//successful
result:=true;
skipend:
except;end;
try
freeobj(@rx);
freeobj(@ry);
if (a<>s) then freeobj(@a);
except;end;
end;
//## zoom ##
function tccs.zoom(x:tbitmap;by:integer;var e:string):boolean;
begin
try;result:=zoomex(x,by,by,e);except;end;
end;
//## zoomex ##
function tccs.zoomex(x:tbitmap;wby,hby:integer;var e:string):boolean;
label
   skipend;
var
   y:tbitmap;
begin
try
//defaults
result:=false;
e:=gecOutOfMemory;
y:=nil;
//range
if not valid24(x) then exit;
wby:=frcmin(wby,1);
hby:=frcmin(hby,1);
//init
y:=newbmp(
 frcmin(round(x.width*(wby/100)),1),
 frcmin(round(x.height*(hby/100)),1)
 );
//get
if not stretchdraw(rect(0,0,y.width,y.height),y,x,clNone) then goto skipend;
//set
if not copybmp(x,y) then goto skipend;
//successful
result:=true;
skipend:
except;end;
try;freeobj(@y);except;end;
end;
//## mirror ##
function tccs.mirror(x:tbitmap;var e:string):boolean;//mirror horizontally
begin
try;result:=mirrorex(x,rect(0,0,maxint,maxint),e);except;end;
end;
//## mirrorex ##
function tccs.mirrorex(x:tbitmap;xrect:trect;var e:string):boolean;//mirror horizontally
var
   r:prgbcolorrow;
   tmp:tdynamicrgb;
   maxx,dx,dy:integer;
   z:trgbcolor;
begin
try
//defaults
result:=false;
e:=gecOutOfMemory;
tmp:=nil;
//range
if not valid24(x) then exit;
//init
xrect:=saferect(x,xrect);
tmp:=tdynamicrgb.create;
tmp.setparams(x.width,x.width,0);
maxx:=xrect.right-xrect.left;
//get
for dy:=xrect.top to xrect.bottom do
begin
r:=x.scanline[dy];
//read
for dx:=xrect.left to xrect.right do tmp.indirect[dx]:=r[dx];
//write
for dx:=xrect.left to xrect.right do r[xrect.right+(xrect.left-dx)]:=tmp.indirect[dx];
end;//end of loop
//successful
result:=true;
except;end;
try;freeobj(@tmp);except;end;
end;
//## saferect ##
function tccs.saferect(x:tbitmap;xrect:trect):trect;
begin
try
//defaults
result:=xrect;
//get
if nonempty24(x) then
   begin
   result.left:=frcrange(xrect.left,0,x.width-1);
   result.top:=frcrange(xrect.top,0,x.height-1);
   result.right:=frcrange(xrect.right,result.left,x.width-1);
   result.bottom:=frcrange(xrect.bottom,result.top,x.height-1);
   end;//end of if
except;end;
end;
//## flip ##
function tccs.flip(x:tbitmap;var e:string):boolean;//flip vertical
begin
try;result:=flipex(x,rect(0,0,maxint,maxint),e);except;end;
end;
//## flipex ##
function tccs.flipex(x:tbitmap;xrect:trect;var e:string):boolean;//flip vertical
var
   r,r2:prgbcolorrow;
   tmp:tdynamicrgb;
   c,maxy,halfy,dx,oy,dy:integer;
   z:trgbcolor;
begin
try
//defaults
result:=false;
e:=gecOutOfMemory;
tmp:=nil;
//range
if not valid24(x) then exit;
//init
xrect:=saferect(x,xrect);
tmp:=tdynamicrgb.create;
tmp.setparams(x.width,x.width,0);
maxy:=xrect.bottom;
oy:=xrect.top;
halfy:=frcmin(((xrect.bottom-xrect.top+1) div 2)-1,0);
//get
for dy:=xrect.top to (xrect.top+halfy) do
begin
r:=x.scanline[dy];
r2:=x.scanline[maxy+(xrect.top-dy)];
//#1 - read
for dx:=xrect.left to xrect.right do tmp.indirect[dx]:=r[dx];
//#2 - [r2->r] and [tmp->r2]
for dx:=xrect.left to xrect.right do
begin
z:=r2[dx];
r[dx]:=z;
r2[dx]:=tmp.indirect[dx];
end;//end of if
end;//end of loop
//successful
result:=true;
except;end;
try;freeobj(@tmp);except;end;
end;
//## rotateby ##
function tccs.rotateby(x:tbitmap;deg:integer;var e:string):boolean;
begin
try
//defaults
result:=false;
e:=gecOutOfMemory;
//range
if not valid24(x) then exit;
{Rotate Image:
              +/- 0,90,180,270 Degrees
              + = Right - Clockwise
              - = Left - AntiClockwise}
case deg of
-359..-270,1..90:result:=rotate90(x,false,e);
-269..-180,91..180:if flip(x,e) then result:=mirror(x,e);
-174..-90,181..270:result:=rotate90(x,true,e);
-89..0,-360,360:result:=true;{nil 0 or 360}
else
   e:=gecIndexOutOfRange;
end;//end of case
except;end;
end;
//## rotate90 ##
function tccs.rotate90(x:tbitmap;left:boolean;var e:string):boolean;
label
   skipend;
var
   a:tbitmap;
begin
try
//defaults
result:=false;
a:=nil;
//check
e:=gecUnexpectedError;
if not valid24(x) then exit;
//get
e:=gecOutOfMemory;
a:=newbmp(1,1);
if not copybmp(a,x) then goto skipend;
//set
if not rotate90ex(x,a,left,e) then goto skipend;
//successful
result:=true;
skipend:
except;end;
try;freeobj(@a);except;end;
end;
//## rotate90ex ##
function tccs.rotate90ex(dest,source:tbitmap;left:boolean;var e:string):boolean;
label//Rotates images right90 or left90, uses an image buffer (ie. 2xRAM) to rotate.
     //High capacity - no height restriction, since we don't use "trgbcolorrows" which is restricted to ~131K height pixels
   skipend;
var
   r:prgbcolorrow;
   _sr:tdynamicpointer;
   sr:pdlPOINTER;
   dx,dy,maxx,maxy:integer;
begin
try
//defaults
result:=false;
e:=gecOutOfMemory;
_sr:=nil;
//check
e:=gecUnexpectedError;
if (not valid24(dest)) or (not valid24(source)) then exit;
//get
dest.width:=source.height;
dest.height:=source.width;
_sr:=tdynamicpointer.create;
_sr.setparams(source.height,source.height,0);
for dy:=0 to (source.height-1) do _sr.items[dy]:=source.scanline[dy];
//set - rotate
sr:=_sr.core;
maxx:=dest.width-1;
maxy:=dest.height-1;
case left of
false:begin//right +90
   for dy:=0 to maxy do
   begin
   r:=dest.scanline[dy];
   for dx:=0 to maxx do r[dx]:=prgbcolorrow(sr[maxx-dx])[dy];
   end;//end of loop
   end;//end of begin
true:begin//left -90
   for dy:=0 to maxy do
   begin
   r:=dest.scanline[dy];
   for dx:=0 to maxx do r[dx]:=prgbcolorrow(sr[dx])[maxy-dy];
   end;//end of loop
   end;//end of begin
end;//end of case
//successful
result:=true;
skipend:
except;end;
try;freeobj(@_sr);except;end;
end;
//## patchsinit ##
procedure tccs.patchsinit;
var
   a,b:hrgn;
   ar,br:trect;
begin
try
//init
a:=createroundrectrgn(1,1,10,10,viCornerA,viCornerB);
b:=createrectrgn(1,1,10,10);
//get
getrgnbox(a,ar);
getrgnbox(b,br);
delrgn(a);
delrgn(b);
//set
ipatch_rrw:=(ar.right-ar.left)<>(br.right-br.left);
ipatch_rrh:=(ar.bottom-ar.top)<>(br.bottom-br.top);
except;end;
end;
//## newrgn ##
function tccs.newrgn(x,y,x2,y2:integer;rounded:boolean):hrgn;
begin//Stable now for Linux and Windows (Note: Linux is 100% correct, but
try  //Windows is out by 1w x 1h pixels on createroundrectrgn which is now patched)
//process
if rounded then
   begin
   //.patch
   if ipatch_rrw then inc(x2);
   if ipatch_rrh then inc(y2);
   //.set
   result:=createroundrectrgn(x,y,x2,y2,viCornerA,viCornerB);
   end
else result:=createrectrgn(x,y,x2,y2);
except;end;
end;
//## delrgn ##
procedure tccs.delrgn(var x:hrgn);
begin
try
if (x<>nullregion) then
   begin
   deleteobject(x);
   x:=nullregion;
   end;
except;end;
end;
//## edgefill ##
function tccs.edgefill(x:tbitmap;replacecolor:integer):boolean;
begin
try;result:=edgefillex(x,replacecolor,200);except;end;
end;
//## edgefillex ##
function tccs.edgefillex(x:tbitmap;replacecolor:integer;sc:byte):boolean;
var
   dx,dy,maxw,maxh:integer;
   xyr:trgbcolorrows;
   tmp,rc:trgbcolor;
begin//Scans for shades of white (250 or higher).
try  //Replaces with color "c".
//defaults
result:=false;
//check
if (x=nil) or (not valid24(x)) or (replacecolor=clNone) then exit;
//init
maxw:=x.width-1;
maxh:=x.height-1;
rc:=intrgb(replacecolor);
//process
//FILL
for dy:=0 to maxh do xyr[dy]:=x.scanline[dy];
//VERTICAL
for dx:=0 to maxw do
begin
//.down
for dy:=0 to maxh do
   begin
   tmp:=xyr[dy][dx];
   if (not ((tmp.r=rc.r) and (tmp.g=rc.g) and (tmp.b=rc.b))) then
      begin
      if (tmp.r>=sc) and (tmp.g>=sc) and (tmp.b>=sc) then xyr[dy][dx]:=rc
      else
         begin
         tmp.r:=(tmp.r+rc.r) div 2;
         tmp.g:=(tmp.g+rc.g) div 2;
         tmp.b:=(tmp.b+rc.b) div 2;
         xyr[dy][dx]:=tmp;
         break;
         end;//end of if
      end;//end of if
   end;//end of loop
//.up
for dy:=maxh downto 0 do
   begin
   tmp:=xyr[dy][dx];
   if (not ((tmp.r=rc.r) and (tmp.g=rc.g) and (tmp.b=rc.b))) then
      begin
      if (tmp.r>=sc) and (tmp.g>=sc) and (tmp.b>=sc) then xyr[dy][dx]:=rc
      else
         begin
         tmp.r:=(tmp.r+rc.r) div 2;
         tmp.g:=(tmp.g+rc.g) div 2;
         tmp.b:=(tmp.b+rc.b) div 2;
         xyr[dy][dx]:=tmp;
         break;
         end;//end of if
      end;//end of if
   end;//end of loop
end;//end of loop
//HORIZONTAL
for dy:=0 to maxh do
begin
//.left
for dx:=0 to maxw do
   begin
   tmp:=xyr[dy][dx];
   if (not ((tmp.r=rc.r) and (tmp.g=rc.g) and (tmp.b=rc.b))) then
      begin
      if (tmp.r>=sc) and (tmp.g>=sc) and (tmp.b>=sc) then xyr[dy][dx]:=rc
      else
         begin
         tmp.r:=(tmp.r+rc.r) div 2;
         tmp.g:=(tmp.g+rc.g) div 2;
         tmp.b:=(tmp.b+rc.b) div 2;
         xyr[dy][dx]:=tmp;
         break;
         end;//end of if
      end;//end of if
   end;//end of loop
//.right
for dx:=maxw downto 0 do
   begin
   tmp:=xyr[dy][dx];
   if (not ((tmp.r=rc.r) and (tmp.g=rc.g) and (tmp.b=rc.b))) then
      begin
      if (tmp.r>=sc) and (tmp.g>=sc) and (tmp.b>=sc) then xyr[dy][dx]:=rc
      else
         begin
         tmp.r:=(tmp.r+rc.r) div 2;
         tmp.g:=(tmp.g+rc.g) div 2;
         tmp.b:=(tmp.b+rc.b) div 2;
         xyr[dy][dx]:=tmp;
         break;
         end;//end of if
      end;//end of if
   end;//end of loop
end;//end of loop
except;end;
end;
//## asgrey ##
function tccs.asgrey(x:tbitmap;shadelimit:integer;var e:string):boolean;//greyscale
var//Shadelimit defines maximum number of grey shades allowed, range 1..256
   p,dy,maxy,dx,maxx:integer;
   r:prgbcolorrow;
   c:trgbcolor;
   v:byte;
   vref:array[0..255] of trgbcolor;
begin
try
//defaults
result:=false;
e:=gecUnexpectedError;
if (x=nil) or (x.width<1) or (x.height<1) then exit;
//24bit
if not valid24(x) then
   begin
   e:=gecOutOfMemory;
   exit;
   end;//end of if
//init
maxx:=x.width-1;
maxy:=x.height-1;
shadelimit:=frcrange(257-shadelimit,1,256);
//vref
for p:=0 to 255 do
begin
v:=byte(frcrange((p div shadelimit)*shadelimit,0,255));
vref[p].r:=v;
vref[p].g:=v;
vref[p].b:=v;
end;//end of loop
//process
//Y
for dy:=0 to maxy do
begin
r:=x.scanline[dy];
 //X
 for dx:=0 to maxx do
 begin
 //.get
 c:=r[dx];
 //.level
 v:=c.r;
 if (c.g>v) then v:=c.g;
 if (c.b>v) then v:=c.b;
 //.set
 r[dx]:=vref[v];//0..255
 end;//end of loop
end;//end of loop
//successful
result:=true;
except;end;
end;
//## sc ##
function tccs.sc(sc,dc,pert:integer):integer;//shift color
begin
try
//range
pert:=frcrange(pert,0,100);
//process
//.get
result:=sc;
sc:=colortorgb(sc);
dc:=colortorgb(dc);
//.set
result:=general.colsplice(pert,dc,sc);
except;end;
end;
//## shadevex ##
function tccs.shadevex(x:tobject;c,up,dn:integer;flip:boolean;var e:string):boolean;//shade color vertically
var
   c1,c2:integer;
begin
try
//defaults
result:=false;
e:=gecUnexpectedError;
//range
up:=frcmin(up,0);
dn:=frcmin(dn,0);
//get
c1:=sc(c,clwhite,up);
c2:=sc(c,clblack,dn);
if flip then swapint(c1,c2);
//set
result:=shadev(x,c1,c2,e);
except;end;
end;
//## shadev ##
function tccs.shadev(x:tobject;c1,c2:integer;var e:string):boolean;//shade color vertically
var
   a:tbitmap;
   b:tcanvas;
   dy,maxy,dx,maxx:integer;
   r:prgbcolorrow;
   c:trgbcolor;
   i4:tint4;
begin
try
//defaults
result:=false;
e:=gecUnexpectedError;
a:=nil;
b:=nil;
if (x=nil) then exit
else if (x is tbitmap) then
   begin
   a:=(x as tbitmap);
   if (a.width<1) or (a.height<1) then exit;
   //24bit
   if not valid24(a) then
      begin
      e:=gecOutOfMemory;
      exit;
      end;//end of if
   end
else if (x is tcanvas) then b:=(x as tcanvas)
else exit;
//process
//.range
if (c1=clNone) then c1:=clWhite;
if (c2=clNone) then c2:=clGray;
//.init
c1:=colortorgb(c1);
c2:=colortorgb(c2);
//BITMAP
if (a<>nil) then
   begin
   maxx:=a.width-1;
   maxy:=a.height-1;
   end
else
   begin
   maxx:=b.cliprect.right;
   maxy:=b.cliprect.bottom;
   end;//end of if
//.draw
for dy:=0 to maxy do
begin
//..get
i4.val:=general.colsplice((dy*100) div maxy,c2,c1);
c.r:=i4.r;
c.g:=i4.g;
c.b:=i4.b;
//..x
if (a<>nil) then
   begin
   r:=a.scanline[dy];
   for dx:=0 to maxx do r[dx]:=c;
   end
else
   begin
   b.pen.color:=i4.val;
   b.moveto(0,dy);
   b.lineto(maxx+1,dy);
   end;//end of if
end;//end of loop
//successful
result:=true;
except;end;
end;
//## shadetexthb ##
function tccs.shadetexthb(x:tbitmap;t:string;c,up,dn,depth,dx,dy,xstep,ystep:integer;var e:string):boolean;//shade text horizontally
var
   c1,c2:integer;
begin
try
//defaults
result:=false;
e:=gecUnexpectedError;
//range
up:=frcmin(up,0);
dn:=frcmin(dn,0);
//get
c1:=sc(c,clblack,dn);
c2:=sc(c,clwhite,up);
//set
result:=ccs.shadetexth(x,t,c1,c2,depth,dx,dy,xstep,ystep,e);
except;end;
end;
//## shadetexth ##
function tccs.shadetexth(x:tbitmap;t:string;c1,c2,depth,dx,dy,xstep,ystep:integer;var e:string):boolean;//shade text horizontally
var
   w,h:integer;
begin
try;result:=shadetextextenth(x,t,c1,c2,depth,dx,dy,xstep,ystep,w,h,false,e);except;end;
end;
//## shadetextextenth ##
function tccs.shadetextextenth(x:tbitmap;t:string;c1,c2,depth,dx,dy,xstep,ystep:integer;var w,h:integer;calcwh:boolean;var e:string):boolean;//shade text horizontally
const
   depthlimit=1024;
var
   ob:tbrushstyle;
   tmp,p,d,th,oy:integer;
   a:tstringlist;
   z:string;
begin
try
//defaults
result:=false;
e:=gecUnexpectedError;
a:=nil;
w:=0;
h:=0;
//check
if (x=nil) or (x.width<1) or (x.height<1) then exit;
//24bit
if not valid24(x) then
   begin
   e:=gecOutOfMemory;
   exit;
   end;//end of if
//process
//.range
depth:=frcrange(depth,0,depthlimit);
if (c1=clNone) then c1:=clBlack;
if (c2=clNone) then c2:=clGray;
//.init
c1:=colortorgb(c1);
c2:=colortorgb(c2);
a:=tstringlist.create;
a.text:=t;
th:=x.canvas.textheight('W#');
//..brush
ob:=x.canvas.brush.style;
x.canvas.brush.style:=bsClear;
//TEXT
for d:=0 to depth do
begin
//.color
if not calcwh then
   begin
   if (depth<=0) then x.canvas.font.color:=c1
   else x.canvas.font.color:=general.colsplice((d*100) div depth,c1,c2);
   end;//end of if
//.draw
oy:=0;
for p:=0 to (a.count-1) do
begin
if calcwh then
   begin
   //.height
   tmp:=dy+oy+th;
   if (tmp>h) then h:=tmp;
   //.width
   tmp:=dx+x.canvas.textwidth(a.strings[p]+#32+#32);
   if (tmp>w) then w:=tmp;
   end
else x.canvas.textout(dx,dy+oy,a.strings[p]+#32+#32);
//.inc
general.iroll(oy,th);
end;//end of loop
//.inc
general.iroll(dx,xstep);
general.iroll(dy,ystep);
//.check
if (xstep=0) and (ystep=0) then break;
end;//end of loop
//successful
result:=true;
//restore brush style
x.canvas.brush.style:=ob;
except;end;
try;freeobj(@a);except;end;
end;
//## dvmb ##
function tccs.dvmb(dest:tbitmapenhanced;img:string;var grey,greylast,e:string;s,t:integer;showthumb,showgraph,cycle,toggle:boolean;datetime:string;var tcount:integer):boolean;//detect video motion
begin
try;result:=dvm(dest,img,grey,greylast,e,s,t,showthumb,showgraph,cycle,toggle,datetime,tcount);except;end;
end;
//## dvm ##
function tccs.dvm(dest:tbitmapenhanced;var img,grey,greylast,e:string;s,t:integer;showthumb,showgraph,cycle,toggle:boolean;datetime:string;var tcount:integer):boolean;//detect video motion
label//Detection scans at a fixed resolution of 176x144=25,344 pixels (72ms @ 200Mhz)
   skipend;
const
   ls=4;//level bar size
   vsp=2;
   //scan dimensions - fixed at 176x144 => 25,344 pixels
   sw=176;
   sh=144;
   sw2=sw div 2;
   sh2=sh div 2;
   smaxX2=(sw div 2)-1;
   smaxX=sw-1;
   smaxY=sh-1;
   ssize=sw*sh;
var
   //reference lookup arays
   srx2:array[0..smaxX2] of byte;
   srx:array[0..smaxX] of integer;
   sry:array[0..smaxY] of integer;
   //misc
   r:prgbcolorrow;
   c:trgbcolor;
   sline:string;//grey detection image (1/5th of original)
   v,v2:byte;
   sox,th,hc,c2,p,dy,dx,i,w,h:integer;
   mok,detectok,destfree:boolean;
begin//s=sensitivity (s=0-least..100-most), t=trigger(number of pixels needed to trigger, >=1)
try  //img=input image, if blank (img='') then "dest" is assumed as the input image
//defaults
result:=false;
destfree:=false;
e:=gecUnexpectedError;
tcount:=0;
//range
//.s
if (s<=0) then s:=78;
s:=100-frcrange(s,0,100);//0..100 => 100..0
//.t
if (t<=0) then t:=200;
t:=frcmin(t,1);
//check
if (img='') and (dest=nil) then exit;
//setup
destfree:=(dest=nil);
if destfree then dest:=tbitmapenhanced.create;
hc:=rgb(100,100,100);
//process
//INIT
dest.canvas.brush.style:=bsSolid;

//RAW FRAME
//.get
if (img<>'') and (not ccs.fromdata(dest,img,e)) then goto skipend;
ccs.valid24(dest);
w:=dest.width;
h:=dest.height;

//GREY FRAME
//.size
setlength(grey,ssize);
setlength(sline,sw);//same ratio as "grey" - 176w
//.init
//..y
for dy:=0 to smaxY do
begin
i:=round(dy*(h/sh));
if (i>=h) then dec(i);
sry[dy]:=i;
end;//end of loop
//..x
for dx:=0 to smaxX do
begin
i:=round(dx*(w/sw));
if (i>=w) then dec(i);
srx[dx]:=i;
end;//end of loop
//..x2
for dx:=0 to smaxX2 do
begin
i:=round(dx*(sw/sw2));
if (i>=sw) then dec(i);
srx2[dx]:=byte(i);
end;//end of loop
sox:=frcmin(w-sw2-1,0);
//.fill
detectok:=(ssize=length(greylast));
for dy:=0 to smaxY do
begin
r:=dest.scanline[sry[dy]];
i:=dy*sw;
 for dx:=0 to smaxX do
 begin
 //.get
 inc(i);
 c:=r[srx[dx]];
 //.calc
 v:=c.r;
 if (c.g>v) then v:=c.g;
 if (c.b>v) then v:=c.b;
 if (v=255) then v:=254;//force range to 0..254, 255 reserved
 //.set
 grey[i]:=char(v);
 //.detect
 if detectok then
    begin
    v2:=byte(greylast[i]);
    if ((v>v2) and (v>(v2+s))) or
       ((v<v2) and (v<(v2-s))) then
       begin
       v:=255;//trigger mark
       inc(tcount);
       end;//end of if
    end;//end of if
 //.sline
 sline[dx+1]:=char(v);
 end;//end of loop
//.thumb
if showthumb and (((dy div 2)*2)=dy) then
   begin
   r:=dest.scanline[dy div 2];
   for dx:=0 to smaxX2 do
   begin
   //.get
   v:=byte(sline[srx2[dx]+1]);
   if (v=255) then
      begin
      c.r:=0;
      c.g:=255;
      c.b:=0;
      end
   else
      begin
      c.r:=v;
      c.g:=v;
      c.b:=v;
      end;//end of if
   r[sox+dx]:=c;
   end;//end of loop
   end;//end of if
end;//end of loop - dy

//.motion detection indicator
if showthumb then
   begin
   dest.canvas.brush.color:=hc;
   dest.canvas.framerect(rect(sox-1,-1,sox+sw2+1,sh2+0+general.insint(ls,showgraph)));
   dest.canvas.framerect(rect(sox-2,-2,sox+sw2+2,sh2+1+general.insint(ls,showgraph)));
   dest.canvas.framerect(rect(sox-3,-3,sox+sw2+3,sh2+2+general.insint(ls,showgraph)));
   end;//end of if
if showgraph then
   begin
   //.vertical offset
   if not showthumb then i:=0 else i:=sh2;
   //..background
   dest.canvas.brush.color:=general.aorb(hc,clBlack,toggle);
   dest.canvas.fillrect(rect(sox,i,sox+sw2,i+ls-1));
   //..progress
   p:=round((frcrange(tcount,0,t)/t)*sw2);
   case round(general.ipercentage(tcount,t)) of
   0..74:c2:=clLime;
   75..99:c2:=clYellow;
   100:c2:=clRed;
   else c2:=clLime;
   end;//end of case
   dest.canvas.brush.color:=c2;
   dest.canvas.fillrect(rect(sox,i,sox+p,i+ls-1));
   //.over trigger indicator (x1..x10)
   if (c2=clRed) then
      begin
      p:=round((frcrange(tcount div 10,0,t)/t)*sw2);
      if (p>=1) then
         begin
         dest.canvas.brush.color:=clWhite;
         dest.canvas.fillrect(rect(sox,i,sox+p,i+ls-1));
         end;//end of if
      end;//end of if
   end;//end of if
//.greylast
if cycle then greylast:=grey;

//DETAILS
if (datetime<>'') then
   begin
   //.init
   with dest do
   begin
   canvas.font.size:=10;
   canvas.font.name:='courier new';
   canvas.font.color:=clWhite;
   th:=canvas.textheight('#');
   end;//end of with
   //.range
   if (datetime[1]='*') then datetime:=dates.toFILEDATEb(dates.dtzero(now),'',', ','-',':','.')+copy(datetime,2,length(datetime));
   datetime:=tsDate+': '+datetime;
   //.size/cls
   dest.height:=dest.height+(th)+(2*vsp);
   dest.canvas.brush.color:=clBlack;
   dest.canvas.fillrect(rect(0,h,w,dest.height));
   //.text
   dest.canvas.brush.style:=bsClear;
   dest.canvas.textout(0,h+vsp,datetime);
   end;//end of if
//successful
result:=true;
skipend:
except;end;
try;if destfree then freeobj(@dest);except;end;
end;
//## copygraphic ##
function tccs.copygraphic(dest:tbitmap;source:tgraphic):boolean;
begin
try;result:=copygraphicex(dest,source,clWhite);except;end;
end;
//## copygraphicex ##
function tccs.copygraphicex(dest:tbitmap;source:tgraphic;color:integer):boolean;//13SEP2007
begin
try
//defaults
result:=false;
//check
if (dest=nil) or (source=nil) then exit;
//size
dest.width:=frcmin(source.width,1);
dest.height:=frcmin(source.height,1);
if not valid24(dest) then exit;
//cls
if (color<>clNone) then cls(dest,color,'');
//draw
dest.canvas.draw(0,0,source);
//info
if (dest is tbitmapenhanced) and (source is tbitmapenhanced) then (dest as tbitmapenhanced).ai:=(source as tbitmapenhanced).ai;
//successful
result:=true;
except;end;
end;
//## isgraphic ##
function tccs.isgraphic(var x:string):boolean;
var
   format:string;
   binary:boolean;
begin
try;result:=findformat(x,format,binary);except;end;
end;
//## supportformat ##
function tccs.supportformat(filenameorext:string):boolean;
var
   e:string;
begin
try
//defaults
result:=false;
//get
e:=readfileext('.'+filenameorext,true);
//decide
result:=
(e='BMP') or (e='WMF') or (e='EMF') or (e='JPG') or (e='JIF') or
(e='JPGT') or (e='ICO') or (e='PPM') or (e='PGM') or (e='PBM') or
(e='TEP') or (e='ATEP') or (e='ANM') or (e='SAN') or (e='EAN') or
(e='OMI') or (e='XBM') or (e='GIF') or (e='HTM') or (e='HTML');
except;end;
end;
//## supportformatstr ##
function tccs.supportformatstr(filenameorext:string):boolean;//some formats only work with a filename, this one is with strings
var//Does not support "htm or html"
   e:string;
begin
try
//defaults
result:=false;
//get
e:=readfileext('.'+filenameorext,true);
//decide
result:=
(e='BMP') or (e='WMF') or (e='EMF') or (e='JPG') or (e='JIF') or
(e='JPGT') or (e='ICO') or (e='PPM') or (e='PGM') or (e='PBM') or
(e='TEP') or (e='ATEP') or (e='ANM') or (e='SAN') or (e='EAN') or
(e='OMI') or (e='XBM') or (e='GIF');
except;end;
end;
//## supportcells ##
function tccs.supportcells(filenameorext:string):boolean;
var//TRUE=format supports multiple cells (animation), else FALSE=still (single cell)
   e:string;
begin
try
//defaults
result:=false;
//get
e:=readfileext('.'+filenameorext,true);
//decide
result:=(e='ATEP') or (e='ANM') or (e='SAN') or (e='EAN') or (e='GIF');
except;end;
end;
//## supportflip ##
function tccs.supportflip(filenameorext:string):boolean;
var//TRUE=format supports virtual "flip" (ie. flips on paint, raw image is not flipped e.g. "san or ean")
   e:string;
begin
try
//defaults
result:=false;
//get
e:=readfileext('.'+filenameorext,true);
//decide
result:=(e='ATEP') or (e='ANM') or (e='SAN') or (e='EAN');
except;end;
end;
//## supportmirror ##
function tccs.supportmirror(filenameorext:string):boolean;
var//TRUE=format supports virtual "flip" (ie. flips on paint, raw image is not flipped e.g. "san or ean")
   e:string;
begin
try
//defaults
result:=false;
//get
e:=readfileext('.'+filenameorext,true);
//decide
result:=(e='ATEP') or (e='ANM') or (e='SAN') or (e='EAN');
except;end;
end;
//## supporttransparency ##
function tccs.supporttransparency(filenameorext:string):boolean;
var
   e:string;
begin
try
//defaults
result:=false;
//get
e:=readfileext('.'+filenameorext,true);
//decide
result:=
(e='JPGT') or (e='ICO') or (e='ATEP') or (e='ANM') or (e='SAN') or (e='EAN') or (e='GIF');
except;end;
end;
//## findformat ##
function tccs.findformat(var x,format:string;var binary:boolean):boolean;
var
   z2,zu,z,zlast:string;
begin
try
//defaults
result:=false;
binary:=true;
format:='';
z2:=copy(x,1,2);
z:=copy(x,1,10);
zu:=uppercase(z);
zlast:=copy(x,frcmin(length(x)-9,1),10);//last 10 bytes of "x"
//process
//.get
if (copy(zu,1,2)='BM') then format:='BMP'
else if (copy(z,1,4)=#215#205#198#154) then format:='WMF'
else if (copy(z,1,4)=#1#0#0#0) then format:='EMF'
else if (copy(z,1,6)=#0#0#1#0#1#0) then format:='ICO'
else if (copy(zu,1,2)='P3') then
   begin
   format:='PPM';
   binary:=false;
   end
else if (copy(zu,1,2)='P6') then format:='PPM'
else if (copy(zu,1,2)='P2') then
   begin
   format:='PGM';
   binary:=false;
   end
else if (copy(zu,1,2)='P5') then format:='PGM'
else if (copy(zu,1,2)='P1') then
   begin
   format:='PBM';
   binary:=false;
   end
else if (copy(zu,1,2)='P4') then format:='PBM'
else if (copy(zu,1,7)='#DEFINE') then
   begin
   format:='XBM';
   binary:=false;
   end
else if (length(zu)>=3) and (zu[1]='T') and (zu[2]>='1') and (zu[2]<='6') and (general.findchardown(zlast,'#')>=1) then//15SEP2007
   begin
   format:='TEP';
   binary:=false;
   end
else if (copy(zu,1,4)='ANM:') then
   begin
   format:='ANM';
   binary:=false;
   end
else if (copy(zu,1,4)='B64:') then//04MAR2008
   begin
   format:='B64';
   binary:=false;
   end
else if (copy(zu,1,9)=('TPF0'+#4+'TSAN')) then format:='SAN'
else if (copy(zu,1,3)='OMI') then format:='OMI'
else if (copy(zu,7,4)='JFIF') then format:='JPG'
else if (copy(zu,1,4)='JPGT') then format:='JPGT'//transparent jpeg
else if (copy(zu,1,3)=#255#216#255) then format:='JPG'//for ALL jpegs FF,D8,FF = first 3 reliably identical bytes
else if (z2=#120#218) or (z2=#120#1) or (z2=#120#94) or (z2=#120#156) then format:='ZIP'
else if (copy(zu,1,3)='C!1') then format:='IOC'//compressed
else if (copy(zu,1,3)='C!0') then format:='IOR'//raw (not compressed)
else if (copy(zu,1,3)='GIF') then format:='GIF';//Note: format not yet supported by reader/writers
//successful
result:=(format<>'');
except;end;
end;
//## convertdata ##
function tccs.convertdata(var data:string;dformat,dsubformat:string;var e:string):boolean;
var
   a:tbitmapenhanced;
begin
try
//defaults
result:=false;
e:=gecOutOfMemory;
//setup
a:=tbitmapenhanced.create;
//process
//.get
if fromdata(a,data,e) then
   begin
   //.set
   if (comparetext(a.ai.format,dformat)<>0) or (comparetext(a.ai.subformat,dsubformat)<>0) then
      begin
      a.ai.format:=dformat;
      a.ai.subformat:=dsubformat;
      result:=todata(a,data,e);
      end
   else result:=true;//already in requested format
   end;//end of if
except;end;
try;freeobj(@a);except;end;
end;
//## fromdata ##
function tccs.fromdata(a:tbitmap;var data,e:string):boolean;
label
   redo,skipend;
var
   ea:tbitmapenhanced;//pointer only
   tmpai:tanimationinformation;
   mem:tstreamstr;
   wmf:tmetafile;
   jpg:tjpegimage;
   ppm:tportablepixelmap;
   xbm:txbitmap;
   tep:ttextpicture;
   omi:toptimisedimage;
   zof:tzof;
   format,tmp,n,vs:string;
   p,pw,pos,vi:integer;
   binary,useVI:boolean;
begin
try
//defaults
result:=false;
e:=gecUnexpectedError;
ea:=nil;
mem:=nil;
wmf:=nil;
jpg:=nil;
ppm:=nil;
xbm:=nil;
tep:=nil;
omi:=nil;
zof:=nil;
//check
if (a=nil) then goto skipend;
if (a is tbitmapenhanced) then ea:=(a as tbitmapenhanced);
//process
//.clear
if (ea<>nil) then
   begin
   aiClear(ea.ai);
   ea.ai.transparent:=(a as tbitmapenhanced).dtransparent;
   end;//end of if
//.find format
redo:
if not findformat(data,format,binary) then
   begin
   e:=gecUnknownFormat;
   goto skipend;
   end;//end of if
//.get
e:=gecOutOfMemory;
if (format='BMP') then
   begin
   mem:=tstreamstr.create(@data);
   mem.position:=0;
   a.loadfromstream(mem);
   if not valid24(a) then goto skipend;
   end
else if (format='ZIP') then//Delphi ZIP
   begin
   //.get
   zof:=tzof.create;
   //.unzip
   if not zof.zof(data,e,false) then goto skipend;
   //.free
   freeobj(@zof);
   //.loop
   goto redo;
   end
else if (format='B64') then//base64 encoded - 04MAR2008
   begin
   //get
   e:=gecUnknownFormat;
   data:=io.fromb64b(copy(data,5,length(data)));//skip over "B64:" header
   if (data='') then goto skipend;
   //store
   if (ea<>nil) then ea.ai.readB64:=true;
   //loop
   goto redo;
   end
else if (format='IOC') or (format='IOR') then//io-compressed or io-raw(not compressed)
   begin
   //.uncompress
   if not io.fromc(data,e) then goto skipend;
   //.loop
   goto redo;
   end
else if (format='WMF') or (format='EMF') then
   begin
   mem:=tstreamstr.create(@data);
   mem.position:=0;
   wmf:=tmetafile.create;
   wmf.loadfromstream(mem);
   if not copygraphic(a,wmf) then goto skipend;
   end
else if (format='JPG') or (format='JIF') then
   begin
   mem:=tstreamstr.create(@data);
   mem.position:=0;
   jpg:=tjpegimage.create;
   jpg.loadfromstream(mem);
   if not copygraphic(a,jpg) then goto skipend;
   end
else if (format='JPGT') then//transparent jpeg
   begin
   if not fromjpgt(a,data,e) then goto skipend;
   end
else if (format='ICO') then
   begin
   if not fromico(a,data,e) then goto skipend;
   end
else if (format='PPM') or (format='PGM') or (format='PBM') then
   begin
   mem:=tstreamstr.create(@data);
   mem.position:=0;
   ppm:=tportablepixelmap.create;
   ppm.loadfromstream(mem);
   if not copygraphic(a,ppm) then goto skipend;
   end
else if (format='XBM') then
   begin
   mem:=tstreamstr.create(@data);
   mem.position:=0;
   xbm:=txbitmap.create;
   xbm.loadfromstream(mem);
   if not copygraphic(a,xbm) then goto skipend;
   end
else if (format='TEP') then
   begin
   tep:=ttextpicture.create;
   tmp:=data;
   //.filter out "return codes|+|'|;|"
   general.rcrb(tmp,#10#13#39#43#59);
   //.load
   if not tep.loadfromstr(tmp) then goto skipend;
   if not copygraphic(a,tep) then goto skipend;
   end
else if (format='ANM') then
   begin
   //.read
   aiRead(data,tmpai);
   //.read sub-format
   tmp:=copy(data,tmpai.iosplit+1,length(data));
   //.get
   if not fromdata(a,tmp,e) then goto skipend;
   if (ea<>nil) then
      begin
      //store image format
      tmpai.subformat:=ea.ai.format;
      ea.ai:=tmpai;
      ea.ai.count:=frcmin(ea.ai.count,1);
      ea.ai.cellwidth:=frcmin(a.width div ea.ai.count,1);
      ea.ai.cellheight:=a.height;
      end;//end of if
   end
else if (format='OMI') then
   begin
   mem:=tstreamstr.create(@data);
   mem.position:=0;
   omi:=toptimisedimage.create;
   omi.loadfromstream(mem);
   if not copygraphic(a,omi) then goto skipend;
   end
else if (format='SAN')then
   begin
   //.get
   zof:=tzof.create;
   pw:=maxint;
   pos:=1;
   //.read
   while misc.dobRead(pos,data,n,vs,vi,useVI) do
   begin
   n:=uppercase(n);
   //..image
   if (n='PI') then
      begin
      //.unzip
      if not zof.zof(vs,e,false) then goto skipend;
      //.string -> bitmap
      if not asbmp(a,vs) then goto skipend;
      //.bitmap -> 24bit bitmap
      if not valid24(a) then goto skipend;
      end
   else if (ea<>nil) then
      begin
      if (n='PW') then pw:=vi//finalise after
      else if (n='PD') then ea.ai.delay:=frcmin(vi,0)
      else if (n='PT') then ea.ai.transparent:=(vi<>0)
      else if (n='PFV') then ea.ai.flip:=(vi<>0)
      else if (n='PFH') then ea.ai.mirror:=(vi<>0);//end of if
      end;//end of if
   end;//end of with
   //.finalise
   if (ea<>nil) then
      begin
      pw:=frcmin(pw,1);
      ea.ai.count:=frcmin(a.width div pw,1);//0..(X-1)
      ea.ai.cellwidth:=frcmin(a.width div ea.ai.count,1);
      ea.ai.cellheight:=a.height;
      ea.ai.subformat:='ZIP';
      end;//end of if
   end
else if (format='EAN') then
   begin
   //.read
   aiRead(data,tmpai);
   //.read sub-format
   tmp:=copy(data,tmpai.iosplit+1,length(data));
   //.get
   if not fromdata(a,tmp,e) then goto skipend;
   if (ea<>nil) then
      begin
      //store image format
      tmpai.subformat:=ea.ai.format;
      ea.ai:=tmpai;
      ea.ai.count:=frcmin(ea.ai.count,1);
      ea.ai.cellwidth:=frcmin(a.width div ea.ai.count,1);
      ea.ai.cellheight:=a.height;
      end;//end of if
   end
else if (format='GIF') then
   begin
   if not fromgif(a,data,e) then goto skipend;
   end
else
   begin
   e:=gecUnknownFormat;
   goto skipend;
   end;//end of if
//successful
e:='';
skipend:
//.info
if (ea<>nil) then
   begin
   ea.ai.format:=uppercase(format);//always uppercase
   ea.ai.filename:='';
   ea.ai.binary:=binary;
   end;//end of if
except;end;
try
result:=(e='');
freeobj(@mem);
freeobj(@wmf);
freeobj(@jpg);
freeobj(@ppm);
freeobj(@xbm);
freeobj(@tep);
freeobj(@omi);
freeobj(@zof);
if not result then
   begin
   a.width:=1;
   a.height:=1;
   end;//end of if
except;end;
end;
//## copytoclipboard ##
function tccs.copytoclipboard(s:tobject;allcells,syncwithBEC:boolean;var e:string):boolean;
label//syncwithBEC=sync with Blaiz Enterprises file Clipboard
   skipend;
var
   a:tbitmapenhanced;
begin
try
//defaults
result:=false;
e:=gecOutOfMemory;
a:=nil;
a:=tbitmapenhanced.create;
//get
if not tobmpex(a,s,allcells,true,e) then goto skipend;
//set
e:=gecTaskFailed;
clipboard.assign(a);
//BE clipboard
if syncwithBEC and (not savetoBEC(a,e)) then goto skipend;
//successful
result:=true;
skipend:
except;end;
try;freeobj(@a);except;end;
end;
//## savetoBEC ##
function tccs.savetoBEC(a:tbitmapenhanced;var e:string):boolean;
label
   skipend;
var
   z:string;
begin
try
//defaults
result:=false;
e:=gecUnexpectedError;
//check
if (a=nil) then goto skipend;
//convert
a.ai.format:='SAN';
a.ai.subformat:='';
if not todata(a,z,e) then goto skipend;
//save
if not io.tofile(clipfile('SAN'),z,e) then goto skipend;
//successful
result:=true;
skipend:
except;end;
end;
//## copyfiletoclipboard ##
function tccs.copyfiletoclipboard(f:string;allcells,syncwithBEC:boolean;var e:string):boolean;
label//Note: removevirtuals=TRUE (convert flip/mirror to physical data)
   skipend;
var
   a:tbitmapenhanced;
begin
try
//defaults
result:=false;
e:=gecFileNotFound;
a:=nil;
//check
if (f='') or (not fileexists(f)) then goto skipend;
//get
e:=gecOutOfMemory;
a:=tbitmapenhanced.create;
if not fromfile(a,f,e) then goto skipend;
//check
e:=gecOutOfMemory;
if not nonempty24(a) then goto skipend;
//trim
if (not allcells) and (a.ai.count>=2) then a.width:=frcmin(a.ai.cellwidth,1);
//copy
e:=gecTaskFailed;
clipboard.assign(a);
//BE clipboard
if syncwithBEC and (not savetoBEC(a,e)) then goto skipend;
//successful
result:=true;
skipend:
except;end;
try;freeobj(@a);except;end;
end;
//## tobmp ##
function tccs.tobmp(dest:tbitmap;source:tobject;allcells:boolean;var e:string):boolean;
begin
try;result:=tobmpex(dest,source,allcells,false,e);except;end;
end;
//## tobmpex ##
function tccs.tobmpex(dest:tbitmap;source:tobject;allcells,convertvirtuals:boolean;var e:string):boolean;
label
   skipend;
var
   s:tvirtualbitmap;//pointer only
   a:tvirtualbitmapanimated;//pointer only
   ai:tanimationinformation;
   dx,dy,w,h:integer;
   sr,dr:prgbcolorrow;
   zc:trgbcolor;
begin
try
//defaults
result:=false;
e:=gecOutOfMemory;
//check
if (not valid24(dest)) or (source=nil) then
   begin
   e:=gecUnexpectedError;
   exit;
   end;//end of if
//init
aiClear(ai);
//get
if (source is tvirtualbitmap) then
   begin
   //init
   s:=(source as tvirtualbitmap);
   w:=s.width;
   h:=s.height;
   //size
   if not size(dest,w,h) then goto skipend;
   //get
   for dy:=0 to (h-1) do
   begin
   sr:=s.scanline[dy];
   dr:=dest.scanline[dy];
    for dx:=0 to (w-1) do
    begin
    zc:=sr[dx];
    dr[dx]:=zc;
    end;//end of loop - x
   end;//end of loop - y
   end
else if (source is tvirtualbitmapanimated) then
   begin
   //init
   a:=(source as tvirtualbitmapanimated);
   ai:=a.ai;
   if (not allcells) and (a.ai.count>=2) then
      begin
      w:=a.ai.cellwidth;
      h:=a.ai.cellheight;
      end
   else
      begin
      w:=a.img.width;
      h:=a.img.height;
      end;//end of if
   //range
   w:=frcrange(w,1,a.img.width);
   h:=frcrange(h,1,a.img.height);
   //size
   if not size(dest,w,h) then goto skipend;
   //get
   for dy:=0 to (h-1) do
   begin
   sr:=a.img.scanline[dy];
   dr:=dest.scanline[dy];
    for dx:=0 to (w-1) do
    begin
    zc:=sr[dx];
    dr[dx]:=zc;
    end;//end of loop - x
   end;//end of loop - y
   end
else if (source is tbitmap) or (source is tbitmapenhanced) then
   begin
   if not copybmp(dest,source as tbitmap) then goto skipend;
   end
else if (source=clipboard) then
   begin
   e:=gecTaskFailed;
   if not clipboard.hasformat(cf_bitmap) then goto skipend;
   dest.assign(clipboard);
   end;//end of if
//flip/mirror cells - for those formats that can't support "virtual flip/mirror" as "san or ean" do e.g. "gif"
if convertvirtuals then
   begin
   //convert "virtual" to "physical"
   if not cellsflipmirror(dest,ai.flip,ai.mirror,e) then goto skipend;
   //reset virtual states
   ai.flip:=false;
   ai.mirror:=false;
   end;//end of if
//info
if (dest is tbitmapenhanced) then
   begin
   (dest as tbitmapenhanced).ai:=ai;
   if not allcells then
      begin
      (dest as tbitmapenhanced).ai.count:=1;
      (dest as tbitmapenhanced).ai.delay:=0;
      end;//end of if
   end;//end of if
//successful
result:=true;
skipend:
except;end;
end;
//## todata ##
function tccs.todata(x:tbitmap;var data,e:string):boolean;
begin
try;result:=todataex(x,true,data,e);except;end;
end;
//## todataex ##
function tccs.todataex(x:tbitmap;checkcells:boolean;var data,e:string):boolean;
label//Defaults to "BMP" if no format is specified
   redo,skipend;
var
   enhanced:boolean;
   a:tbitmapenhanced;
   tmpai:tanimationinformation;
   mem:tstreamstr;
   wmf:tmetafile;
   wmfc:tmetafilecanvas;
   bmpeh:tbitmapenhanced;
   bmp:tbitmap;
   jpg:tjpegimage;
   ppm:tportablepixelmap;
   xbm:txbitmap;
   omi:toptimisedimage;
   subformat,format,tmp2,tmp,n,vs:string;
   len,p,pw,pos,vi:integer;
   binary,useVI:boolean;
begin
try
//defaults
result:=false;
enhanced:=false;
binary:=false;
data:='';
e:=gecUnexpectedError;
a:=nil;
bmpeh:=nil;
bmp:=nil;
mem:=nil;
wmf:=nil;
wmfc:=nil;
jpg:=nil;
ppm:=nil;
xbm:=nil;
omi:=nil;
//check
if (x=nil) then goto skipend;
//init
e:=gecOutOfMemory;
a:=tbitmapenhanced.create;
if not copybmp(a,x) then goto skipend;
//.format
format:='BMP';
subformat:='';
if (x is tbitmapenhanced) then
   begin
   enhanced:=true;
   a.ai:=(x as tbitmapenhanced).ai;
   a.dtransparent:=(x as tbitmapenhanced).dtransparent;
   if (a.ai.format<>'') then
      begin
      format:=uppercase(a.ai.format);
      subformat:=uppercase(a.ai.subformat);
      end;//end of if
   end
else aiClear(a.ai);
//.trim from "multi-cell" to "single-cell"
if checkcells and (a.ai.count>=2) and (not supportcells(format)) then
   begin
   a.width:=frcmin(a.width div a.ai.count,1);
   a.ai.cellwidth:=a.width;
   a.ai.count:=1;
   end;//end of if
//.flip/mirror cells - for those formats that can't support "virtual flip/mirror" as "san or ean" do e.g. "gif"
if checkcells and ( (not supportflip(format)) or (not supportmirror(format)) ) then
   begin
   //convert "virtual" to "physical"
   if not cellsflipmirror(a,a.ai.flip,a.ai.mirror,e) then goto skipend;
   //reset virtual states
   a.ai.flip:=false;
   a.ai.mirror:=false;
   end;//end of if
//process
redo:
//.get
e:=gecOutOfMemory;
if (format='BMP') then
   begin
   mem:=tstreamstr.create(@data);
   if not valid24(a) then goto skipend;
   a.savetostream(mem);
   end
else if (format='ZIP')then//Delphi ZIP
   begin
   if not aszip(a,data,e) then goto skipend;
   end
else if (format='WMF') then
   begin
   //.convert
   e:=gecOutOfMemory;
   wmf:=tmetafile.create;
   wmf.width:=frcmin(a.width,1);
   wmf.height:=frcmin(a.height,1);
   wmfc:=tmetafilecanvas.create(wmf,0);
   wmfc.draw(0,0,a);
   freeobj(@wmfc);
   wmf.enhanced:=false;
   wmf.inch:=72;
   wmf.width:=frcmin(a.width,1);
   wmf.height:=frcmin(a.height,1);
   //.save
   mem:=tstreamstr.create(@data);
   wmf.savetostream(mem);
   //.clear
   freeobj(@wmf);
   end
else if (format='EMF') then
   begin
   //.convert
   e:=gecOutOfMemory;
   wmf:=tmetafile.create;
   wmf.width:=frcmin(a.width-1,1);
   wmf.height:=frcmin(a.height-1,1);
   wmf.enhanced:=true;
   wmfc:=tmetafilecanvas.create(wmf,0);
   wmfc.draw(0,0,a);
   freeobj(@wmfc);
   //.save
   mem:=tstreamstr.create(@data);
   wmf.savetostream(mem);
   //.clear
   freeobj(@wmf);
   end
else if (format='JPG') then//optimised jpeg
   begin
   if not asjpg(a,data,e) then goto skipend;
   end
else if (format='JIF') then//standard jpeg
   begin
   //.convert
   e:=gecOutOfMemory;
   jpg:=tjpegimage.create;
   jpg.assign(a);
   //.save
   mem:=tstreamstr.create(@data);
   jpg.savetostream(mem);
   //.clear
   freeobj(@jpg);
   end
else if (format='JPGT') then//transparent jpeg
   begin
   if not tojpgt(a,data,e) then goto skipend;
   end
else if (format='ICO') then
   begin
   if not toico(a,data,e) then goto skipend;
   end
else if (format='PPM') and (not binary) then//PPM - ASCII //14SEP2007
   begin
   if not toppm(a,data,e) then goto skipend;
   end
else if (format='PGM') and (not binary) then//PGM - ASCII //14SEP2007
   begin
   if not topgm(a,data,e) then goto skipend;
   end
else if (format='PBM') and (not binary) then//PBM - ASCII //14SEP2007
   begin
   if not topbm(a,data,e) then goto skipend;
   end
else if (format='PPM') or (format='PGM') or (format='PBM') then
   begin
   //.convert
   e:=gecOutOfMemory;
   ppm:=tportablepixelmap.create;
   if (format='PPM') then ppm.style:=general.aorb(pphsRGBA,pphsRGBB,binary)
   else if (format='PGM') then ppm.style:=general.aorb(pphsGreyA,pphsGreyB,binary)
   else if (format='PBM') then ppm.style:=general.aorb(pphsMonoA,pphsMonoB,binary);
   ppm.assign(a);
   //.save
   mem:=tstreamstr.create(@data);
   ppm.savetostream(mem);
   //.clear
   freeobj(@ppm);
   end
else if (format='XBM') then
   begin
   //.convert
   e:=gecOutOfMemory;
   xbm:=txbitmap.create;
   xbm.assign(a);
   //.save
   mem:=tstreamstr.create(@data);
   xbm.savetostream(mem);
   //.clear
   freeobj(@xbm);
   end
else if (format='TEP') then
   begin
   if not totep(a,data,e) then goto skipend;
   end
else if (format='ANM') or (format='ATEP') then
   begin
   //.information
   if enhanced then tmpai:=a.ai
   else
      begin
      //.treat as a single cell animation
      tmpai.count:=1;
      tmpai.delay:=0;
      tmpai.transparent:=false;
      tmpai.flip:=false;
      tmpai.mirror:=false;
      end;//end of if
   //.clear
   data:='';
   //.image - Note: if ATEP, then ANM:...TEP (use TEP as image format, instead of requested alternative specified in "ea.ai.subformat")
   if enhanced then
      begin
      a.ai.format:=general.aorbstr(a.ai.subformat,'TEP',(format='ATEP'));
      a.ai.subformat:='';
      end;//end of if
   if not todataex(a,false,tmp,e) then goto skipend;
   //.header
   aiWrite(data,tmpai);
   //.image
   data:=data+tmp;
   tmp:='';
   end
else if (format='OMI') then
   begin
   //.convert
   e:=gecOutOfMemory;
   omi:=toptimisedimage.create;
   omi.assign(a);
   //.save
   mem:=tstreamstr.create(@data);
   omi.savetostream(mem);
   //.clear
   freeobj(@omi);
   end
else if (format='SAN')then//Requires extended information to save as "san"
   begin
   //.information
   if enhanced then tmpai:=a.ai
   else
      begin
      //.treat as a single cell animation
      tmpai.delay:=0;
      tmpai.cellwidth:=frcrange(a.width,1,1090);//Note: 1090 is max cell width for a SAN - refer to Animator v1.00.478 (21-JUN-2006)
      tmpai.cellheight:=a.height;
      tmpai.transparent:=false;
      tmpai.flip:=false;
      tmpai.mirror:=false;
      end;//end of if
   //.range - compatible with old programs 08NOV2007
   if (tmpai.delay<>0) then tmpai.delay:=frcrange(tmpai.delay,50,1000);//20..1 fps
   //.image
   if not aszip(a,tmp,e) then goto skipend;
   //.tsan - delphi object structure
   misc.dobHead(len,data,'TSAN',true);
   misc.dobInteger(len,data,'pW',tmpai.cellwidth);
   misc.dobInteger(len,data,'pD',tmpai.delay);
   misc.dobString(len,data,'pI',tmp);
   tmp:='';
   misc.dobBoolean(len,data,'pT',tmpai.transparent);
   misc.dobBoolean(len,data,'pFV',tmpai.flip);
   misc.dobBoolean(len,data,'pFH',tmpai.mirror);
   misc.dobInteger(len,data,'pF',0);
   misc.dobInteger(len,data,'pSH',0);
   misc.dobInteger(len,data,'pSV',0);
   misc.dobEnd(len,data);
   end
else if (format='EAN') then
   begin
   //.information
   if enhanced then tmpai:=a.ai
   else
      begin
      //.treat as a single cell animation
      tmpai.count:=1;
      tmpai.delay:=0;
      tmpai.transparent:=false;
      tmpai.flip:=false;
      tmpai.mirror:=false;
      end;//end of if
   //.clear
   data:='';
   //.image - Note: if ATEP, then ANM:...TEP (use TEP as image format, instead of requested alternative specified in "ea.ai.subformat")
   if enhanced then
      begin
      //.transparent jpeg
      a.ai.format:='JPGT';
      a.ai.subformat:='';
      if not todataex(a,false,tmp2,e) then goto skipend;
      //.transparent zip (like san)
      a.ai.format:='ZIP';
      a.ai.subformat:='';
      if not todataex(a,false,tmp,e) then goto skipend;
      //.decide
      if (length(tmp2)<length(tmp)) then
         begin
         a.ai.format:='JPGT';
         a.ai.subformat:='';
         tmp:=tmp2;
         tmp2:='';
         end;//end of if
      end
   else if not todataex(a,false,tmp,e) then goto skipend;
   //.header
   aiWrite(data,tmpai);
   //.image
   data:=data+tmp;
   tmp:='';
   end
else if (format='GIF') then//GIF requires a "tbitmapenhanced"
   begin
   //uses and modifies "a", so "a" must be a copy of "x"
   if not togif(a,data,e) then goto skipend;
   end
else
   begin
   a.width:=1;
   a.height:=1;
   e:=gecUnknownFormat;
   goto skipend;
   end;//end of if
//finalise
if a.ai.writeB64 and (data<>'') then data:='B64:'+io.tob64b(data,0);
//successful
e:='';
skipend:
except;end;
try
result:=(e='');
freeobj(@a);
freeobj(@mem);
freeObj(@wmfc);//wmf.canvas
freeobj(@wmf);
freeobj(@jpg);
freeobj(@ppm);
freeobj(@xbm);
freeobj(@omi);
freeobj(@bmp);
freeobj(@bmpeh);
except;end;
end;
//## fromfile ##
function tccs.fromfile(a:tbitmap;x:string;var e:string):boolean;//20SEP2007
var
   ext,x2,tmp:string;
begin
try
//defaults
result:=false;
e:=gecOutOfMemory;
//process
//.html - special case
ext:=readfileext(x,true);
if (ext='HTM') or (ext='HTML') then
   begin
   x:=general.remlastext(x)+'.JPG';
   x2:=general.remlastext(x)+'.GIF';
   if fileexists(x2) then x:=x2;
   end;//end of if
//.get
if io.fromfile(x,tmp,e) then result:=fromdata(a,tmp,e);
except;end;
end;
//## tofile ##
function tccs.tofile(a:tbitmap;x:string;var e:string):boolean;
var
   ea:tbitmapenhanced;//pointer only
   tmpai:tanimationinformation;
   zhtm,ox,ext,tmp:string;
   _repeat,html:boolean;
begin
try
//defaults
result:=false;
html:=false;
_repeat:=false;
//check
e:=gecUnexpectedError;
if (a=nil) then exit;
//setup
e:=gecOutOfMemory;
if (a is tbitmapenhanced) then
   begin
   ea:=(a as tbitmapenhanced);
   tmpai:=ea.ai;
   end
else ea:=nil;//23MAY2007
//process
//.get
ext:=readfileext(x,true);
ox:=x;
//.html - special case
if (ext='HTM') or (ext='HTML') then
   begin
   if (ea<>nil) and (ea.ai.transparent or (ea.ai.count>=2)) then
      begin
      ext:='GIF';
      _repeat:=true;
      end
   else ext:='JPG';
   x:=general.remlastext(x)+'.'+ext;
   html:=true;
   end;//end of if
//.format check - requires "ea" for any "non-BMP" format
if (ea=nil) then
   begin
   if (ext<>'BMP') then
      begin
      showerror60(ntranslate(gecTaskFailed));
      exit;
      end;//end of if
   end
else ea.ai.format:=ext;
//.set
if todata(a,tmp,e) and io.tofile(x,tmp,e) then
   begin
   //20SEP2007 - now supports local filename (no path or folder just filename)
   if html then
      begin
      //get
      zhtm:=
      '<html>'+rcode+
      '<head>'+rcode+
      '<style>'+rcode+
      'body {'+rcode+
      'font-family: Aharoni;'+rcode+
      'font-size: 10pt;'+rcode+
      'color: 000000;'+rcode+
      'background-position: top left;'+rcode+
      'background-repeat: '+general.aorbstr('no-repeat','repeat',_repeat)+rcode+
      '}'+rcode+
      '</style>'+rcode+
      '</head>'+rcode+
      '<body background="'+general.swapcharsb(extractfilename(x),'\','/')+'">'+rcode+
      '</body>'+rcode+
      '</html>'+rcode;
      //set
      result:=io.tofile(ox,zhtm,e);
      end
   else result:=true;
   end;//end of if
//.restore
if (ea<>nil) then ea.ai:=tmpai;
except;end;
end;
//## fromobject ##
function tccs.fromobject(a:tbitmap;x:tobject;var e:string):boolean;
label
   skipend;
var
   c:tgraphicclass;
begin
try
//defaults
result:=false;
e:=gecUnexpectedError;
//check
if (a=nil) then exit;
//process
//.get
e:=gecOutOfMemory;
if (x=nil) then
   begin
   a.width:=1;
   a.height:=1;
   if not valid24(a) then goto skipend;
   end
else if (x=clipboard) and clipboard.hasformat(cf_bitmap) then
   begin
   a.assign(clipboard);
   a.width:=frcmin(a.width,1);
   a.height:=frcmin(a.height,1);
   if not valid24(a) then goto skipend;
   end
else if (x is tpicture) then
   begin
   a.width:=frcmin((x as tpicture).width,1);
   a.height:=frcmin((x as tpicture).height,1);
   if not valid24(a) then goto skipend;
   a.canvas.draw(0,0,(x as tpicture).graphic);
   end
else if (x is tgraphic) then
   begin
   //.get
   if (x is tbitmap) then c:=tbitmap
   else if (x is tmetafile) then c:=tmetafile
   else if (x is tjpegimage) then c:=tjpegimage
   else if (x is ticon) then c:=ticon
   else if (x is tportablepixelmap) then c:=tportablepixelmap
   else if (x is txbitmap) then c:=txbitmap
   else if (x is ttextpicture) then c:=ttextpicture
   else if (x is toptimisedimage) then c:=toptimisedimage
   else
      begin
      e:=gecUnknownFormat;
      goto skipend;
      end;//end of if
   //.set
   if not copygraphic(a,x as c) then goto skipend;
   end
else
   begin
   e:=gecUnknownFormat;
   goto skipend;
   end;//end of if
//successful
e:='';
skipend:
except;end;
try;result:=(e='');except;end;
end;
//## printexe ##
function tccs.printexe(var f:string):boolean;
var
   z,tmp:string;
begin
try
//defaults
result:=false;
f:='';
//get
tmp:=bvfportableex(bvfImageTools,false);
//set
//1 - portable version first - portable version of "image printer" and will NOT place itself on start button
//. "source folder/blaiz enterprises/image tools/*.exe"
z:=tmp+'image printer~.exe';
if fileexists(z) then
   begin
   f:=z;
   result:=true;
   exit;
   end;//end of if
//2 - portable
//. "source folder/*.exe"
z:=programportablepath+'image printer~.exe';
if fileexists(z) then
   begin
   f:=z;
   result:=true;
   exit;
   end;//end of if
//3 - start button version 2nd - "image printer" will automatically place itself on start button when run
//. "start button/blaiz enterprises/image tools/*.exe"
z:=tmp+'image printer.exe';
if fileexists(z) then
   begin
   f:=z;
   result:=true;
   exit;
   end;//end of if
except;end;
end;
//## canprint ##
function tccs.canprint:boolean;
var
   f:string;
begin
try
//get - check every 10 seconds
if ((ms64-icanprinttimeref)>=10000) then
   begin
   icanprinttimeref:=ms64;
   ilastcanprint:=printexe(f);
   end;//end of if
//set
result:=ilastcanprint;
except;end;
end;
//## printfile ##
procedure tccs.printfile(x,y:string);
label
   skipend;
var
   a:tbitmap;
   e:string;
begin
try
//defaults
a:=nil;
e:=gecOutOfMemory;
a:=newbmp(1,1);
//process
//.get
case (x<>'') of
true:if not fromfile(a,x,e) then goto skipend;
false:if not misc.openimagedlg(a,'',x) then
         begin
         e:='';
         goto skipend;
         end;//end of if
end;//end of case
//.set
e:='';
print(a,y);
skipend:
except;end;
try;freeobj(@a);except;end;
try;general.iferror(e);except;end;
end;
//## print ##
procedure tccs.print(x:tobject;y:string);
label
   skipend;
var
   a:tbitmap;
   e,fbmp,fexe:string;
   t:integer;
begin
try
//defaults
e:=gecUnexpectedError;
a:=nil;
fexe:='';
fbmp:='';
//filter
//.title - make safe and restrict length to no more than 40 chars
y:=general.safefilename(copy(y,1,40),false);
//process
if canprint then
   begin
   e:=gecOutOfMemory;
   //.image
   a:=ccs.newbmp(1,1);
   if not ccs.fromobject(a,x,e) then goto skipend;
   //.get
   e:=gecOutOfMemory;
   if not printexe(fexe) then
      begin
      e:=gecUnexpectedError;
      goto skipend;
      end;
   fbmp:=bvfportable(bvfTemp)+lowercase(programname+'-printimage.bmp');
   //.set
   if not remfile(fbmp) then
      begin
      e:=gecFileInUse;
      goto skipend;
      end;//end of if
   a.savetofile(fbmp);
   //.run
   case print_usingoldimp of
   true:run(fexe,'"'+fbmp+'" "'+y+'"');//<image filename> + <page title>
   false:run(fexe,'"temp:'+fbmp+'" "title:'+y+'"');//<image filename> + <page title>
   end;//end of case
   //.wait - image printer must delete files that begin "temp:???" (located in .. System > Critical > Temp)
   if not print_usingoldimp then
      begin
      t:=gettickcount;
      repeat
      if not fileexists(fbmp) then break;
      sleep(250);
      until ((gettickcount-t)>=30000);
      //.delete - image printer failed to run or delete file
      if fileexists(fbmp) then
         begin
         remfile(fbmp);
         e:=gecTaskFailed;
         goto skipend;
         end;//end of if
      end;//end of if
   //successful
   e:='';
   end;//end of if
skipend:
except;end;
try;freeobj(@a);except;end;
try;general.iferror(e);except;end;
end;
//## scaledown ##
procedure tccs.scaledown(maxw,maxh,w,h:integer;var dw,dh:integer);
begin
try
//range
w:=frcmin(w,1);
h:=frcmin(h,1);
dw:=w;
dh:=h;
//process
if (w>maxw) then
   begin
   h:=round(h*(maxw/w));
   w:=maxw;
   end;//end of if
if (h>maxh) then
   begin
   w:=round(w*(maxh/h));
   h:=maxh;
   end;//end of if
//return result
dw:=w;
dh:=h;
except;end;
end;
//## scaleup ##
procedure tccs.scaleup(maxw,maxh,w,h:integer;var dw,dh:integer);
begin
try
//range
w:=frcmin(w,1);
h:=frcmin(h,1);
dw:=w;
dh:=h;
//up
if (w<maxw) then
   begin
   h:=round(h*(maxw/w));
   w:=maxw;
   end;//end of if
if (h<maxh) then
   begin
   w:=round(w*(maxh/h));
   h:=maxh;
   end;//end of if
//return result
scaledown(maxw,maxh,w,h,dw,dh);
except;end;
end;
//## scale ##
procedure tccs.scale(pw,ph,w,h:integer;var dw,dh:integer);
var
   r1,r2:extended;
begin
try
//range
w:=frcmin(w,1);
h:=frcmin(h,1);
dw:=w;
dh:=h;
//get
r1:=pw/w;
if (r1<=0) then r1:=1;
r2:=ph/h;
if (r2<=0) then r2:=1;
if (r2<r1) then r1:=r2;
//set
dw:=round(w*r1);
dh:=round(h*r1);
except;end;
end;
//## tojpgt ##
function tccs.tojpgt(s:tbitmap;var y,e:string):boolean;//to transparent jpeg
label//Note: reduces bleeding for transparent pixels to near zero, by using "WHITE" for all transparent color in JPEG,
     //      and shifting and existing white pixel to and offwhite (254,254,254). Transparent color are restored upon
     //      opening transparent jpeg.
   skipend;
var
   a:tbitmapenhanced;
   zof:tzof;
   m:tdynamicbit;
   mc:tdynamicinteger;
   hoff,dy,dx,cc,minx,maxx,iw,ih,cw,p,px,count,len:integer;
   tmp:string;
   xr:prgbcolorrow;
   white,offwhite,c2,c:trgbcolor;
   i:tint4;
   shiftwhite,enhanced,ok:boolean;
begin
try
//defaults
result:=false;
e:=gecUnexpectedError;
len:=0;
y:='';
a:=nil;
zof:=nil;
m:=nil;
mc:=nil;
count:=1;
cw:=1;
//.white
white.r:=255;
white.g:=255;
white.b:=255;
//.offwhite
offwhite.r:=254;
offwhite.g:=254;
offwhite.b:=254;
//check
if (s=nil) then exit;
e:=gecOutOfMemory;
//copy
a:=tbitmapenhanced.create;
if not copygraphic(a,s) then goto skipend;
enhanced:=(s is tbitmapenhanced);
//setup
iw:=a.width;
ih:=a.height;
//process
//24bit
if not valid24(a) then exit;
//COLORS
//.setup
mc:=tdynamicinteger.create;
if enhanced then
   begin
   count:=frcmin(a.ai.count,1);
   cw:=frcmin(iw div count,1);
   end;//end of if
//.scan
if (iw>=1) and (ih>=1) then
   begin
   xr:=a.scanline[0];
   mc.setparams(count,count,0);
   for p:=1 to count do
   begin
   px:=(p-1)*cw;
   if (px>=0) and (px<iw) then mc.items[p-1]:=rgbint(xr[px]);
   end;//end of loop
   end;//end of if
//MASK
m:=tdynamicbit.create;
m.size:=frcmin(iw*ih,1);
//.scan all cells
if (iw>=1) and (ih>=1) then
   begin
   cc:=0;
   minx:=0;
   maxx:=minx+cw-1;
   repeat
   //.cell transparent color
   c:=intrgb(mc.value[cc]);
   shiftwhite:=(c.r<>255) or (c.g<>255) or (c.b<>255);
   //.scan cell (left->right, top->bottom)
   dy:=0;
   repeat
   xr:=a.scanline[dy];
   hoff:=dy*iw;
   dx:=minx;
    repeat
     c2:=xr[dx];
     //.mark pixel as being transparent
     if (c2.r=c.r) and (c2.g=c.g) and (c2.b=c.b) then
        begin
        m.value[dx+hoff]:=true;
        //.change pixel color to white - won't bleed as much
        if shiftwhite then xr[dx]:=white;
        end
     //.shift white - all white must be shifted down 1 shade, to make room for transparent pixels using pure-white
     else if (c2.r=255) and (c2.g=255) and (c2.b=255) and shiftwhite then xr[dx]:=offwhite;
     //.inc dx
     inc(dx);
     until (dx>maxx);
    //.inc dy
    inc(dy);
    until (dy>=ih);
   //.inc minx
   inc(minx,cw);
   maxx:=minx+cw-1;
   inc(cc);
   until (maxx>=iw) or (cc>=count);
   end;//end of if
//WRITE
//..JPEG
pushb(len,y,'JPGT');
if not asjpg(a,tmp,e) then goto skipend;
//.*size
pushb(len,y,from32bit(length(tmp)));
//.*jpeg
push(len,y,tmp);
tmp:='';
//..COLORS
//*size
tmp:=mc.text;
pushb(len,y,from32bit(length(tmp)));
//*colors
if (tmp<>'') then
   begin
   push(len,y,tmp);
   tmp:='';
   end;//end of if
//..MASK
//.zip
tmp:=m.text;
freeobj(@m);
zof:=tzof.create;
if not zof.zof(tmp,e,true) then goto skipend;
//.*size
pushb(len,y,from32bit(length(tmp)));
//.*mask
if (tmp<>'') then
   begin
   push(len,y,tmp);
   tmp:='';
   end;//end of if
//.finalise
pushb(len,y,'');
//successful
result:=true;
skipend:
except;end;
try
freeobj(@a);
freeobj(@m);
freeobj(@mc);
freeobj(@zof);
except;end;
end;
//## fromjpgt ##
function tccs.fromjpgt(x:tbitmap;var y,e:string):boolean;//from transparent jpeg - 17SEP2007
label
   skipend;
var
   mem:tstreamstr;
   jpg:tjpegimage;
   zof:tzof;
   m:tdynamicbit;
   mc:tdynamicinteger;
   pos,hoff,dy,dx,cc,minx,maxx,iw,ih,cw,p,px,count,len:integer;
   tmp:string;
   xr:prgbcolorrow;
   c:trgbcolor;
begin
try
//defaults
result:=false;
e:=gecUnexpectedError;
zof:=nil;
m:=nil;
mc:=nil;
mem:=nil;
jpg:=nil;
count:=1;
//check
if (x=nil) then exit;
e:=gecOutOfMemory;
//process
//24bit
if not valid24(x) then exit;
//HEADER
pos:=1;
if (uppercase(copy(y,pos,4))<>'JPGT') then
   begin
   e:=gecUnknownFormat;
   goto skipend;
   end;//end of if
inc(pos,4);
//JPEG
//.size
len:=to32bit(copy(y,pos,4));
if (len<0) then
   begin
   e:=gecDataCorrupt;
   goto skipend;
   end;//end of if
inc(pos,4);
//.jpeg
mem:=tstreamstr.create(@y);
mem.position:=pos-1;
jpg:=tjpegimage.create;
jpg.loadfromstream(mem);
freeobj(@mem);
if not copygraphic(x,jpg) then goto skipend;
freeobj(@jpg);
iw:=x.width;
ih:=x.height;
cw:=iw;
inc(pos,len);
if (iw<=0) or (ih<=0) then goto skipend;
//COLORS
//.size
len:=to32bit(copy(y,pos,4));
if (len<0) then
   begin
   e:=gecDataCorrupt;
   goto skipend;
   end;//end of if
inc(pos,4);
//.colors
mc:=tdynamicinteger.create;
mc.text:=copy(y,pos,len);
count:=frcmin(len div 4,1);//determine number of cells by number of colors (1 color per cell)
cw:=frcmin(iw div count,1);
if (count>mc.count) then mc.setparams(count,count,0);
inc(pos,len);
//MASK
//.size
len:=to32bit(copy(y,pos,4));
if (len<0) then
   begin
   e:=gecDataCorrupt;
   goto skipend;
   end;//end of if
inc(pos,4);
//.set & unzip
m:=tdynamicbit.create;
tmp:=copy(y,pos,len);
zof:=tzof.create;
if not zof.zof(tmp,e,false) then goto skipend;
m.text:=tmp;
tmp:='';
inc(pos,len);
//.apply
cc:=0;
minx:=0;
maxx:=minx+cw-1;
repeat
//.cell transparent color
c:=intrgb(mc.value[cc]);
//.scan cell (left->right, top->bottom)
dy:=0;
repeat
xr:=x.scanline[dy];
hoff:=dy*iw;
dx:=minx;
 repeat
 //.set pixel to current cell's transparent color
 if m.value[dx+hoff] then xr[dx]:=c;
 //.inc dx
 inc(dx);
 until (dx>maxx);
//.inc dy
inc(dy);
until (dy>=ih);
//.inc minx
inc(minx,cw);
maxx:=minx+cw-1;
inc(cc);
until (maxx>=iw) or (cc>=count);
//info
if (x is tbitmapenhanced) then
   begin
   count:=frcmin(count,1);
   (x as tbitmapenhanced).ai.count:=count;
   (x as tbitmapenhanced).ai.cellwidth:=frcmin(x.width div count,1);
   (x as tbitmapenhanced).ai.cellheight:=x.height;
   (x as tbitmapenhanced).ai.transparent:=true;
   end;//end of if
//successful
result:=true;
skipend:
except;end;
try
freeobj(@mem);
freeobj(@jpg);
freeobj(@m);
freeobj(@mc);
freeobj(@zof);
except;end;
end;
//## decompress ##
procedure tccs.decompress(var x:string);//11SEP2007
var
   p:integer;
   z:string;
begin
try
//init
p:=1;
z:='';
//get
decompressex(p,x,z,0,0,false);
//set
x:=z;
except;end;
end;
//## decompressex ##
procedure tccs.decompressex(var xlenpos:integer;var x,imgdata:string;_width,_height:integer;interlaced:boolean);//11SEP2007
const
  GIFCodeBits=12;// Max number of bits per GIF token code
  GIFCodeMax=(1 SHL GIFCodeBits)-1;//Max GIF token code,12 bits=4095
  StackSize=(2 SHL GIFCodeBits);//Size of decompression stack
  TableSize=(1 SHL GIFCodeBits);//Size of decompression table
var
   tmprow,xlen:integer;
   table0:array[0..TableSize-1] of integer;
   table1:array[0..TableSize-1] of integer;
   firstcode,oldcode:integer;
   buf:array[0..257] of BYTE;
   v,xpos,ypos,pass:integer;
   stack:array[0..StackSize-1] of integer;
   Source:^integer;
   BitsPerCode:integer;//number of CodeTableBits/code
   InitialBitsPerCode:BYTE;
   MaxCode,MaxCodeSize,ClearCode,EOFCode,step,i,StartBit,LastBit,LastByte:integer;
   get_done,return_clear,ZeroBlock:boolean;
   ClearValue:BYTE;

//## read ##
function read(a:pointer;len:integer):integer;
var
   b:pdlByte;
   i:integer;
begin
try
//defaults
result:=0;
//init
b:=a;
//process
for i:=1 to len do if (xlenpos<=xlen) then
   begin
   b[result]:=ord(x[xlenpos]);
   inc(result);
   inc(xlenpos);
   end
else break;
except;end;
end;
//## nextCode ##
function nextCode(BitsPerCode: integer): integer;
const
   masks:array[0..15] of integer=($0000,$0001,$0003,$0007,$000f,$001f,$003f,$007f,$00ff,$01ff,$03ff,$07ff,$0fff,$1fff,$3fff,$7fff);
var
   p2,StartIndex,EndIndex,ret,EndBit:integer;
   count:BYTE;
begin
try
//defaults
result:=-1;
//check
if return_clear then
   begin
   return_clear:=false;
   result:=ClearCode;
   exit;
   end;//end of if
//get
EndBit:=StartBit+BitsPerCode;
if (EndBit>=LastBit) then
   begin
   if get_done then
      begin
      if (StartBit>=LastBit) then result:=-1;
      exit;
      end;//end of if
   buf[0]:=buf[LastByte-2];
   buf[1]:=buf[LastByte-1];
   //.count
   if (xlenpos>xlen) then
      begin
      result:=-1;
      exit;
      end
   else
      begin
      count:=byte(x[xlenpos]);
      inc(xlenpos);
      end;//end of if
   //.check
   if (count=0) then
      begin
      ZeroBlock:=True;
      get_done:=TRUE;
      end
   else
      begin
      //handle premature end of file
      if ((1+xlen-xlenpos)<count) then
         begin
         //Not enough data left - Just read as much as we can get
         Count:=xlen-xlenpos+1;
         end;//end of if
      if (Count<>0) and (read(@buf[2],count)<>count) then exit;//out of data
      end;//end of if
   LastByte:=2+count;
   StartBit:=(StartBit-LastBit)+16;
   LastBit:=LastByte*8;
   EndBit:=StartBit+BitsPerCode;
   end;//end of if
//set
EndIndex:=EndBit div 8;
StartIndex:=StartBit div 8;
//check
if (startindex>high(buf)) then exit;//out of range
if (StartIndex=EndIndex) then ret:=buf[StartIndex]
else if ((StartIndex+1)=EndIndex) then ret:=buf[StartIndex] or (buf[StartIndex+1] shl 8)
else ret:=buf[StartIndex] or (buf[StartIndex+1] shl 8) or (buf[StartIndex+2] shl 16);
ret:=(ret shr (StartBit and $0007)) and masks[BitsPerCode];
inc(StartBit,BitsPerCode);
result:=ret;
except;end;
end;
//## NextLZW ##
function NextLZW:integer;
var
   code,incode,i:integer;
   b:byte;
begin
try
//defaults
result:=-1;
//scan
code:=nextCode(BitsPerCode);
while (code>=0) do
begin
if (code=ClearCode) then
   begin
   //check
   if (clearcode>tablesize) then exit;//out of range
   for i:=0 to (ClearCode-1) do
   begin
   table0[i]:=0;
   table1[i]:=i;
   end;//end of loop

   for i:=ClearCode to (TableSize-1) do
   begin
   table0[i]:=0;
   table1[i]:=0;
   end;//end of loop
   BitsPerCode:=InitialBitsPerCode+1;
   MaxCodeSize:=2*ClearCode;
   MaxCode:=ClearCode+2;
   Source:=@stack;

   repeat
   firstcode:=nextCode(BitsPerCode);
   oldcode:=firstcode;
   until (firstcode<>ClearCode);
   Result := firstcode;
   exit;
   end;//end of if
//.eof
if (code=EOFCode) then
   begin
   Result:=-2;
   if ZeroBlock then exit;
   //eat blank data (all 0's)
   //--ignore
   exit;
   end;//end of if

incode:=code;
if (code>=MaxCode) then
   begin
   Source^:=firstcode;
   Inc(Source);
   code:=oldcode;
   end;//end of if
//check
if (Code>TableSize) then exit;//out of range

 while (code>=ClearCode) do
 begin
 Source^:=table1[code];
 Inc(Source);
 //check
 if (code=table0[code]) then exit;//error
 code:=table0[code];
 //check
 if (Code>TableSize) then exit;
 end;//end of loop

firstcode:=table1[code];
Source^:=firstcode;
Inc(Source);
code:=MaxCode;
if (code<=GIFCodeMax) then
   begin
   table0[code]:=oldcode;
   table1[code]:=firstcode;
   Inc(MaxCode);
   if ((MaxCode>=MaxCodeSize) and (MaxCodeSize<=GIFCodeMax)) then
      begin
      MaxCodeSize:=MaxCodeSize*2;
      Inc(BitsPerCode);
      end;//end of if
   end;//end of if
oldcode:=incode;
if (longInt(Source)>longInt(@stack)) then
   begin
   Dec(Source);
   Result:=Source^;
   exit;
   end
end;//end of loop
Result:=code;
except;end;
end;
//## readLZW ##
function readLZW:integer;
begin
try
if (longInt(Source)>longInt(@stack)) then
   begin
   Dec(Source);
   Result:=Source^;
   end
else Result:=NextLZW;
except;end;
end;

//START
begin
try
//init
xlen:=length(x);
imgdata:='';
if (xlenpos<1) or (xlenpos>xlen) then exit;
//get
if (xlenpos>xlen) then exit;
InitialBitsPerCode:=byte(x[xlenpos]);
inc(xlenpos);
setlength(imgdata,_width*_height);
//Initialize the Compression routines
BitsPerCode:=InitialBitsPerCode+1;
ClearCode:=1 shl InitialBitsPerCode;
EOFCode:=ClearCode+1;
MaxCodeSize:=2*ClearCode;
MaxCode:=ClearCode+2;
StartBit:=0;
LastBit:=0;
LastByte:=2;
ZeroBlock:=false;
get_done:=false;
return_clear:=true;
Source:=@stack;
try
if interlaced then
   begin
   ypos:=0;
   pass:=0;
   step:=8;
   for i:=0 to (_Height-1) do
   begin
   tmprow:=_width*ypos;
    for xpos:=0 to (_width-1) do
    begin
    v:=readLZW;
    if (v<0) then exit;
    imgdata[1+tmprow+xpos]:=char(byte(v));
    end;//end of loop
   //inc
   Inc(ypos,step);
   if (ypos>=_height) then
      begin
      repeat
      if (pass>0) then step:=step div 2;
      Inc(pass);
      ypos := step DIV 2;
      until (ypos < _height);
      end;//end of if
   end;//end of loop
   end
else
   begin
   if (_width>=1) and (_height>=1) then
      begin
      for ypos:=0 to ((_height*_width)-1) do
      begin
      v:=readLZW;
      if (v<0) then exit;
      imgdata[1+ypos]:=char(byte(v));
      end;//end of loop
      end
   else
      begin//decompress raw data string (width and height are not used
      tmprow:=0;
      while true do
      begin
      v:=readLZW;
      if (v<0) then
         begin
         //finalise
         pushb(tmprow,imgdata,'');
         exit;
         end;//end of if
      pushb(tmprow,imgdata,char(byte(v)));
      end;//end of loop
      end;//end of if
   end;//end of if
except;end;
//too much data
if (readLZW>=0) then
   begin
   //ignore
   end;//end of if
except;end;
end;
//## gifpalinit ##
procedure tccs.gifpalinit(var x:tgifpal);
var
   p:integer;
   r,g,b:byte;
begin
try
//check
if x.init then exit else x.init:=true;
//swap
for p:=0 to high(x.c) do
   begin
   //get
   r:=x.c[p].r;
   g:=x.c[p].g;
   b:=x.c[p].b;
   //set - swap r/b elements
   x.c[p].r:=b;
   x.c[p].g:=g;
   x.c[p].b:=r;
   end;//end of loop
except;end;
end;
//## nonwhite ##
function tccs.nonwhite(x:trgbcolor):trgbcolor;//make sure color is never white
begin
//get
result:=x;
//filter
if (result.r=255) and (result.g=255) and (result.b=255) then
   begin
   result.r:=254;
   result.g:=254;
   result.b:=254;
   end;//end of if
end;
//## fromgif ##
function tccs.fromgif(x:tbitmap;var y,e:string):boolean;//20SEP2007
label//Important Note: WHITE is only ever used for transparent pixels, all other colors are allowed
   skipone,skipend;
const
   //main flags
   pfGlobalColorTable	= $80;		{ set if global color table follows L.S.D. }
   pfColorResolution	= $70;		{ Color resolution - 3 bits }
   pfSort		= $08;		{ set if global color table is sorted - 1 bit }
   pfColorTableSize	= $07;		{ size of global color table - 3 bits }
   //local - image des
   idLocalColorTable	= $80;    { set if a local color table follows }
   idInterlaced		= $40;    { set if image is interlaced }
   idSort		= $20;    { set if color table is sorted }
   idReserved		= $0C;    { reserved - must be set to $00 }
   idColorTableSize	= $07;    { size of color table as above }
var
   imgdata,tmp:string;
   imglimit,imgcount,nx,ny,offx,len,dy,dx,trans,delay,loops,i,p,tmp2,ylen,pos:integer;
   alltrans,ok,wait,v87a,v89a:boolean;
   lastdispose,dispose,bgcolor,ci,v2,v:byte;
   s:tgifscreen;
   lp,gp:tgifpal;//global color palette
   pal:pgifpal;//pointer to current palette for image to use
   id:tgifimgdes;
   r:prgbcolorrow;
   yc,zc,tc:trgbcolor;
   lastrect:trect;
//START
begin//Note: xe=points to an animation structure for storing timing/framecount information, and is optional
try
//defaults
result:=false;
e:=gecUnexpectedError;
if (x=nil) then exit;
//INIT
ylen:=length(y);
if (ylen<6) then exit;
imgcount:=0;
imglimit:=0;
alltrans:=false;
offx:=0;
pos:=1;
loops:=0;
delay:=0;
pal:=@gp;
dispose:=0;
lastdispose:=0;
//.static transparent color of "WHITE"
tc.r:=255;
tc.g:=255;
tc.b:=255;
//.control items
bgcolor:=0;
trans:=-1;//not in use
wait:=false;
//GET
//header sig (GIF)
if (comparetext(copy(y,pos,3),'GIF')<>0) then
   begin
   e:=gecUnknownFormat;
   goto skipend;
   end;//end of if
inc(pos,3);
e:=gecDataCorrupt;
//version
tmp:=copy(y,pos,3);
inc(pos,3);
v87a:=(comparetext(tmp,'87a')=0);
v89a:=(comparetext(tmp,'89a')=0);
if (not v87a) and (not v89a) then goto skipend;
//screen info
if ((pos+sizeof(s)-1)>ylen) then goto skipend;
tostrucb(@s,sizeof(s),copy(y,pos,sizeof(s)));
inc(pos,sizeof(s));
//.range
s.w:=frcmin(s.w,1);
s.h:=frcmin(s.h,1);
imglimit:=21000 div s.w;//safe number of frames (tbitmap.width=22000+ crashes)
//.global color palette - always empty, since we may have to use it even when we shouldn't be
fillchar(gp,sizeof(gp),0);
if ((s.pf and pfGlobalColorTable)=pfGlobalColorTable) then
   begin
   //get
   gp.count:=2 shl (s.pf and pfColorTableSize);
   if (gp.count<2) or (gp.count>256) then
      begin
      e:=gecIndexOutOfRange;
      goto skipend;
      end;//end of if
   //set
   tmp2:=gp.count*sizeof(trgbcolor);
   if ((pos+tmp2-1)>ylen) then goto skipend;
   tostrucb(@gp.c,tmp2,copy(y,pos,tmp2));
   inc(pos,tmp2);
   end;//end of if
//init
gifpalinit(gp);
//IMAGES
if (pos>ylen) then goto skipend;
repeat
v:=byte(y[pos]);
//scan
if (v=59) then break//terminator
else if (v<>0) then
   begin
   //init
   inc(pos);
   if (pos<=ylen) then v2:=byte(y[pos]) else v2:=0;
   //blocks
   if (v=33) then
      begin
      //get - multi-length sub-parts (ie. text blocks etc)
      inc(pos);
      tmp:='';
      while true do
      begin
      if (pos<=ylen) then
         begin
         tmp2:=byte(y[pos]);
         tmp:=tmp+copy(y,pos+1,tmp2);
         if (tmp2=0) then break else inc(pos,1+tmp2);
         end
      else break;
      end;//end of loop
      if (tmp='') then goto skipone;
      //set
      case v2 of
      249:begin//control - for image handling
         if (length(tmp)<4) then goto skipone;
         tmp2:=byte(tmp[1]);
         //.defaults
         bgcolor:=0;
         trans:=-1;//not in use
         wait:=false;
         dispose:=0;
         //.dispose mode
         dispose:=byte(frcrange((tmp2 shl 27) shr 29,0,7));
         //.wait
         if (((tmp2 shl 30) shr 31)>=1) then wait:=true;
         //.bgcolor
         bgcolor:=byte(tmp[4]);
         //.transparent
         if (((tmp2 shl 31) shr 31)>=1) then trans:=bgcolor;
         //.delay
         inc(delay,frcmin(to16bit(copy(tmp,2,2),true),0));
         end;//end of begin
      255:begin//loop
         loops:=to16bit(copy(tmp,length(tmp)-1,2),true);
         end;//end of begin
      254:begin//comment
         //ignore
         end;//end of begin
      1:begin//plain text - displayed on image
         //ignore
         end;//end of begin
      end;//end of case
      end
   else if (v=44) then//image
      begin
      //get
      dec(pos);
      tostrucb(@id,sizeof(id),copy(y,pos,sizeof(id)));
      inc(pos,sizeof(id));
      //range
      id.dx:=frcrange(id.dx,0,s.w);
      id.dy:=frcrange(id.dy,0,s.h);
      id.w:=frcrange(id.w,1,s.w);
      id.h:=frcrange(id.h,1,s.h);
      fillchar(lp,sizeof(lp),0);
      //local palette
      if ((id.pf and idLocalColorTable)=idLocalColorTable) then
         begin
         //get
         lp.count:=2 shl (id.pf and idColorTableSize);
         if (lp.count<2) or (lp.count>256) then
            begin
            e:=gecIndexOutOfRange;
            goto skipend;
            end;//end of if
         //set
         tmp2:=lp.count*sizeof(trgbcolor);
         if ((pos+tmp2-1)>ylen) then goto skipend;
         tostrucb(@lp.c,tmp2,copy(y,pos,tmp2));
         inc(pos,tmp2);
         //init
         gifpalinit(lp);
         end;//end of if
      if (lp.count=0) then pal:=@gp else pal:=@lp;
      //decompress image
      decompressex(pos,y,imgdata,id.w,id.h,((id.pf and idInterlaced)<>0));
      //transparency check - if transparent color index is not used, then turn it off!
      ok:=false;
      if (trans>=0) then
         begin
         //check
         v:=byte(trans);
         for p:=1 to length(imgdata) do if (v=byte(imgdata[p])) then
            begin
            ok:=true;
            break;
            end;//end of if
         if not ok then trans:=-1;
         //image is transparent - therefore entire image is transparent
         if (imgcount=0) and (trans>=0) then alltrans:=true;
         end;//end of if
      //size
      inc(imgcount);
      if ((imgcount*s.w)>x.width) or (x.height<>s.h) then
         begin//size ahead by 5 cells
         x.width:=frcmax(((x.width div s.w)+5),imglimit)*s.w;
         if not ccs.valid24(x) then
            begin
            e:=gecOutOfMemory;
            goto skipend;
            end;//end of if
         if (x.height<>s.h) then x.height:=s.h;
         end;//end of if
      //cls
      if (imgcount<=1) then
         begin
         if (trans>=0) then zc:=tc else zc:=nonwhite(pal.c[bgcolor]);
         for dy:=0 to (s.h-1) do
         begin
         r:=x.scanline[dy];
         for dx:=0 to (s.w-1) do r[offx+dx]:=zc;
         end;//end of loop
         end
      else
         begin
         //init
         if (trans>=0) then zc:=tc else zc:=nonwhite(pal.c[bgcolor]);
         //get
         for dy:=0 to (s.h-1) do
         begin
         r:=x.scanline[dy];
          for dx:=0 to (s.w-1) do
          begin
          case lastdispose of
          0,1:begin//graphic left in place
             yc:=r[offx-s.w+dx];
             r[offx+dx]:=yc;
             end;//end of begin
          2:begin//restore background color - area used by image
             if (dy>=lastrect.top) and (dy<=lastrect.bottom) and (dx>=lastrect.left) and (dx<=lastrect.right) then r[offx+dx]:=zc
             else
                begin
                yc:=r[offx-s.w+dx];
                r[offx+dx]:=yc;
                end;//end of if
             end;//end of begin
          3:begin//restore to previous image - area used by image
             yc:=r[offx-s.w+dx];
             r[offx+dx]:=yc;
             end;//end of begin
          end;//end of case
          end;//end of loop
         end;//end of loop
         end;//end of if
      //draw
      p:=1;
      len:=length(imgdata);
      for dy:=0 to (id.h-1) do
      begin
      ny:=dy+id.dy;
      if (ny>=0) and (ny<s.h) then
         begin
         r:=x.scanline[ny];
         for dx:=0 to (id.w-1) do
          begin
          nx:=dx+id.dx;
          if (nx>=0) and (nx<s.w) then
             begin
             ci:=byte(imgdata[p]);
             if (trans=-1) then r[offx+nx]:=pal.c[ci]//important: must maintain original image data if not transparent - special white/offwhite image cases, any rounding down will cause white+offwhite=>all offwhite which will cause entire area of both colors to be transparent if the "transparent" option is then used - 17SEP2007
             else if (ci<>trans) then r[offx+nx]:=nonwhite(pal.c[ci]);
             end;//end of if
          //inc
          inc(p);
          //quit
          if (p>len) then break;
          end;//end of loop
         end;//end of if
      if (p>len) then break;
      end;//end of loop
      //enforce top-left corner transparency (only if entire animation is transparent)
      if alltrans and (trans>=0) then
         begin
         r:=x.scanline[0];
         r[offx]:=tc;
         end;//end of if
      //inc
      inc(offx,s.w);
      dec(pos);
      //last
      lastdispose:=dispose;
      lastrect:=rect(id.dx,id.dy,frcmax(id.dx+id.w-1,s.w-1),frcmax(id.dy+id.h-1,s.h-1));
      //frame limit
      if (imgcount>=imglimit) then break;//safe number of frames
      end
   else if (v=59) then break//terminator
   else break;//unknown
   end;//end of if
skipone:
//inc
inc(pos);
until (pos>ylen);
//trim
if (imgcount<>0) and (x<>nil) then x.width:=(imgcount*s.w);
//info
if (x is tbitmapenhanced) then
   begin
   //range - max. number of frames-per-second=50 (20ms)...[delay=0=>20ms or 50fps]
   if (imgcount>=1) then
      begin
      delay:=frcmin((delay div imgcount)*10,0);//ave. units => ave. ms
      //.default is 100ms
      if (delay<=0) then delay:=100;
      end;//end of if
   //set
   (x as tbitmapenhanced).ai.delay:=frcmin(delay,20);//no faster than 50fps(20ms=2units)
   (x as tbitmapenhanced).ai.count:=imgcount;
   (x as tbitmapenhanced).ai.cellwidth:=s.w;
   (x as tbitmapenhanced).ai.cellheight:=s.h;
   (x as tbitmapenhanced).ai.transparent:=alltrans;
   end;//end of if
//successful
result:=true;
skipend:
except;end;
end;
//## compress ##
function tccs.compress(var x,e:string):boolean;//12SEP2007
var
   z:string;
begin
try
//defaults
result:=false;
//get
if compressex(x,z,e) then
   begin
   x:=z;
   //successful
   result:=true;
   end;//end of if
except;end;
end;
//## compressex ##
function tccs.compressex(var x,imgdata,e:string):boolean;//12SEP2007
label
   skipend;
const
   EndBlockByte=$00;			// End of block marker
var
   h:thashtable;
   NewCode,Prefix,FreeEntry:smallint;
   NewKey:longint;
   Color:char;
   ClearFlag:boolean;
   MaxCode,EOFCode,BaseCode,ClearCode:smallint;
   maxcolor,xlen,xpos,BitsPerCode,OutputBits,OutputBucket,imglen:longint;
   BitsPerPixel,InitialBitsPerCode:byte;
   buf:string;

//## MaxCodesFromBits ##
function MaxCodesFromBits(bits:integer):smallint;
begin
try;result:=(smallint(1) shl bits)-1;except;end;
end;
//## writechar ##
procedure writechar(x:string);//15SEP2007
begin//"x=nil" => flush
try
//get
buf:=buf+x;
//set
if (length(buf)>=255) or ((x='') and (buf<>'')) then
   begin
   pushb(imglen,imgdata,char(length(buf))+buf);
   buf:='';
   end;//end of if
except;end;
end;
//## output ##
procedure output(value:integer);
const
  BitBucketMask: array[0..16] of longInt =
    ($0000,
     $0001, $0003, $0007, $000F,
     $001F, $003F, $007F, $00FF,
     $01FF, $03FF, $07FF, $0FFF,
     $1FFF, $3FFF, $7FFF, $FFFF);
begin
try
//get
if (OutputBits > 0) then OutputBucket := (OutputBucket AND BitBucketMask[OutputBits]) OR (longInt(Value) SHL OutputBits)
else OutputBucket := Value;
inc(OutputBits, BitsPerCode);
//set
while (OutputBits >= 8) do
begin
writechar(char(OutputBucket and $FF));
OutputBucket:=OutputBucket shr 8;
dec(OutputBits,8);
end;//end of loop
//check
if (Value = EOFCode) then
   begin
   // At EOF, write the rest of the buffer.
   while (OutputBits > 0) do
   begin
   writechar(char(OutputBucket and $FF));
   OutputBucket := OutputBucket shr 8;
   dec(OutputBits, 8);
   end;//end of loop
   end;//end of if
// If the next entry is going to be too big for the code size,
// then increase it, if possible.
if (FreeEntry > MaxCode) or (ClearFlag) then
   begin
   if (ClearFlag) then
      begin
      BitsPerCode := InitialBitsPerCode;
      MaxCode := MaxCodesFromBits(BitsPerCode);
      ClearFlag := False;
      end
   else
      begin
      inc(BitsPerCode);
      if (BitsPerCode=GIFCodeBits) then MaxCode:=GIFTableMaxMaxCode
      else MaxCode:=MaxCodesFromBits(BitsPerCode);
      end;//end of if
   end;//end of if
except;end;
end;

begin
try
//defaults
result:=false;
h:=nil;
imglen:=0;
imgdata:='';
e:=gecUnexpectedError;
//init
buf:='';
xlen:=length(x);
xpos:=1;
if (xlen<=2) then exit;
h:=thashtable.create;
maxcolor:=256;
BitsPerPixel:=8;//bits per pixel - fixed at 8, don't go below 2
InitialBitsPerCode:=BitsPerPixel+1;
BitsPerCode:=InitialBitsPerCode;
MaxCode:=MaxCodesFromBits(BitsPerCode);
ClearCode:=(1 SHL (InitialBitsPerCode-1));
EOFCode:=ClearCode+1;
BaseCode:=EOFCode+1;
//.clear bit bucket
OutputBucket:=0;
OutputBits:=0;
pushb(imglen,imgdata,char(BitsPerPixel));
//clear - hash table and sync decoder
clearflag:=true;
output(clearcode);
h.clear;
freeentry:=clearcode+2;
//get
prefix:=smallint(x[xpos]);
if (Prefix>=MaxColor) then
   begin
   e:=gecIndexOutOfRange;
   goto skipend;
   end;//end of if
while true do
begin
//.inc
inc(xpos);
if (xpos>xlen) then break;
//.get
color:=x[xpos];
if (byte(color)>=maxcolor) then
   begin
   e:=gecIndexOutOfRange;
   goto skipend;
   end;//end of if
//append postfix to prefix and lookup in table...
NewKey := (longint(Prefix) SHL 8) OR byte(Color);
NewCode := h.lookup(NewKey);
if (NewCode >= 0) then
   begin
   // ...if found, get next pixel
   prefix:=newcode;
   //skip to next item
   continue;
   end;//end of if
// ...if not found, output and start over
output(prefix);
prefix:=smallint(color);
if (FreeEntry < GIFTableMaxFill) then
   begin
   h.insert(NewKey, FreeEntry);
   inc(FreeEntry);
   end
else
   begin
   //clear
   clearflag:=true;
   output(clearcode);
   h.clear;
   freeentry:=clearcode+2;
   end;//end of if
end;//end of loop
output(prefix);
skipend:
//finalise - 15SEP2007
output(EOFCode);
writechar('');
pushb(imglen,imgdata,char(EndBlockByte));
pushb(imglen,imgdata,'');
//successful
result:=true;
except;end;
try;freeobj(@h);except;end;
end;
//## togif ##
function tccs.togif(x:tbitmap;var y,e:string):boolean;//11SEP2007
label//writes v89a GIF's
   skipend;
const
   //main flags
   pfGlobalColorTable	= $80;		{ set if global color table follows L.S.D. }
   pfColorResolution	= $70;		{ Color resolution - 3 bits }
   pfSort		= $08;		{ set if global color table is sorted - 1 bit }
   pfColorTableSize	= $07;		{ size of global color table - 3 bits }
   //local - image des
   idLocalColorTable	= $80;    { set if a local color table follows }
   idInterlaced		= $40;    { set if image is interlaced }
   idSort		= $20;    { set if color table is sorted }
   idReserved		= $0C;    { reserved - must be set to $00 }
   idColorTableSize	= $07;    { size of color table as above }
var
   z,e2:string;
   ylen,ccount,cw,ch,nx,ny,offx,len,dy,dx,delay,loops,i,p,tmp2,pos:integer;
   flags:byte;
   s:tgifscreen;
   gp:tgifpal;//global color palette
   id:tgifimgdes;
   r:prgbcolorrow;
   yc,zc,tc:trgbcolor;
   lastrect:trect;
   xe:tbitmapenhanced;
   trans:boolean;
begin
try
//defaults
result:=false;
e:=gecUnexpectedError;
y:='';
ylen:=0;
flags:=0;
delay:=0;
trans:=false;
xe:=nil;
if (x=nil) then exit;
if (x is tbitmapenhanced) then
   begin
   xe:=(x as tbitmapenhanced);
   delay:=frcmin(xe.ai.delay div 10,2);//20ms or larger (50fps)
   if xe.ai.transparent then
      begin
      inc(flags);//1=transparent
      trans:=true;
      end;//end of if
   inc(flags,8);//remove-by background
   end;//end of if
//init
ccount:=1;
cw:=x.width;
ch:=x.height;
if (xe<>nil) then
   begin
   ccount:=frcmin(xe.ai.count,1);
   cw:=cw div ccount;
   end;//end of if
cw:=frcmin(cw,1);
ch:=frcmin(ch,1);
if (x.width=0) or (x.height=0) or (ccount<=0) then exit;
//INIT
//.enforces transparent color as "WHITE", do this even if the image is not transparent - keep consistent
if trans and (not transwhite(x,e)) then goto skipend;
if not gifpalfill(x,gp,e) then goto skipend;
//HEADER
pushb(ylen,y,'GIF89a');
//screen info
fillchar(s,sizeof(s),0);
s.w:=cw;
s.h:=ch;
s.pf:=183;//183=256PAL,NOT-SORTED [247=SORTED]
pushb(ylen,y,fromstruc(@s,sizeof(s)));
//global palette - fixed at 256 colors
pushb(ylen,y,fromstruc(@gp.c,sizeof(gp.c)));
//LOOP       //unknown code block [78..3..1]                       //0=loop forever
if (ccount>=2) then pushb(ylen,y,#33#255#11#78#69#84#83#67#65#80#69#50#46#48#3#1+from16bit(0,true)+#0);
//IMAGES
for p:=1 to ccount do
begin
//img-control [ext,imgctrl,4bytes]+[trans=v1,wait=v2,(dispose=v0..3used, v4..7 resv)
//dispose modes(0=nothing=>0, 1=leave-as-is=>4, 2=background=>8, 3=previous-image=>12
//.value=transparent1 and/or background8 = 1,8 or 9
                      //flags + delay + transparent-color-index (fixed at ZERO for us)+#0terminator
pushb(ylen,y,#33#249#4+char(flags)+from16bit(delay,true)+#0#0);
//img-des - Note: pf=0 (no local color table, not interlaced, not sorted)
fillchar(id,sizeof(id),0);
id.sep:=44;
id.w:=cw;
id.h:=ch;
pushb(ylen,y,fromstruc(@id,sizeof(id)));
//IMAGE DATA
setlength(z,cw*ch);
i:=1;
offx:=(p-1)*s.w;
for dy:=0 to (ch-1) do
begin
r:=x.scanline[dy];
 for dx:=0 to (cw-1) do
 begin
 zc:=r[dx+offx];
 z[i]:=char(gifpalfind(gp,zc));//r-b elements are reversed in pal items
 inc(i);
 end;//end of loop
end;//end of loop
//compressed image data
if not compress(z,e2) then
   begin
   e:=e2;
   goto skipend;
   end;//end of if
pushb(ylen,y,z);
z:='';
end;//end of if
//terminator
pushb(ylen,y,#0#59);
//finalise
pushb(ylen,y,'');
//successful
result:=true;
skipend:
except;end;
end;
//## gifpalfill ##
function tccs.gifpalfill(x:tbitmap;var y:tgifpal;var e:string):boolean;//12SEP2007
label//Automatically handles "to many colors" problem by reducing gradually reducing color resolution
   redo,skipdone;
var
   i,maxp,p,w,h,dy,dx:integer;
   dv:byte;
   r:prgbcolorrow;
   zc:trgbcolor;
begin
try
//defaults
result:=false;
e:=gecUnexpectedError;
//check
if not nonempty24(x) then exit;
e:=gecOutOfMemory;
//INIT
w:=x.width;
h:=x.height;
fillchar(y,sizeof(y),0);
dv:=1;//divide color element by facter, increases in color limit is reached, to reduce colors gradually
//.first color is WHITE - transparent color (wether it's used or not)
y.c[0].r:=255;
y.c[0].g:=255;
y.c[0].b:=255;
maxp:=high(y.c);
//GET
redo:
y.count:=1;//leaves 255 colors
//y
for dy:=0 to (h-1) do
begin
r:=x.scanline[dy];
//x
for dx:=0 to (w-1) do
begin
//get
zc:=r[dx];
//filter - only non-transparent colors
if (dv>=2) and (not((zc.r=255) and (zc.g=255) and (zc.b=255))) then
   begin
   zc.r:=byte((zc.r div dv)*dv);
   zc.g:=byte((zc.g div dv)*dv);
   zc.b:=byte((zc.b div dv)*dv);
   end;//end of if
//scan - look in palette to see if we already have this color
i:=-1;
for p:=0 to (y.count-1) do if (y.c[p].r=zc.r) and (y.c[p].g=zc.g) and (y.c[p].b=zc.b) then
   begin
   i:=p;
   break;
   end;//end of if
//add color
if (i=-1) then
   begin
   //palette is full
   if (y.count>=maxp) then
      begin
      inc(dv);
      //reduce color resolution
      if (dv<200) then goto redo//retry
      else goto skipdone;
      end;//end of if
   //set
   y.c[y.count]:=zc;
   inc(y.count);
   end;//end of loop
end;//end of loop - x
end;//end of loop - y
//adjust image colors (dv>=2)
if (dv>=2) then
   begin
   for dy:=0 to (h-1) do
   begin
   r:=x.scanline[dy];
   for dx:=0 to (w-1) do
   begin
   //get
   zc:=r[dx];
   //filter - exclude transparent color "WHITE"
   if not ((zc.r=255) and (zc.g=255) and (zc.b=255)) then
      begin
      zc.r:=byte((zc.r div dv)*dv);
      zc.g:=byte((zc.g div dv)*dv);
      zc.b:=byte((zc.b div dv)*dv);
      //set
      r[dx]:=zc;
      end;//end of if
   end;//end of loop - x
   end;//end of loop - y
   end;//end of if
skipdone:
//swap r-b
gifpalinit(y);
//successful
result:=true;
except;end;
end;
//## gifpalfind ##
function tccs.gifpalfind(var y:tgifpal;var z:trgbcolor):byte;
var
   p:integer;
begin
try
//defaults
result:=0;
//scan - Note: r/b are swapped
for p:=0 to (y.count-1) do if (y.c[p].r=z.b) and (y.c[p].g=z.g) and (y.c[p].b=z.r) then
   begin
   result:=p;
   break;
   end;//end of if
except;end;
end;
//## cellsflipmirror ##
function tccs.cellsflipmirror(x:tbitmap;_flip,_mirror:boolean;var e:string):boolean;//prepare a multi-cell imagestrip, ensuring all [0,0] pixel corners are "black" if transparent and all black must be [1,1,1] or higher
label
   skipend;
var//Note: White is reserved for transparent information
   xe:tbitmapenhanced;
   p,offx,cw,ch,ccount:integer;
   tc:trgbcolor;
   r:prgbcolorrow;
   xrect:trect;
   trans:boolean;
begin
try
//defaults
result:=false;
e:=gecUnexpectedError;
xe:=nil;
ccount:=1;
trans:=false;
//check
if not nonempty24(x) then exit;
if (x is tbitmapenhanced) then xe:=(x as tbitmapenhanced);
//.nothing to do
if (not _flip) and (not _mirror) then
   begin
   result:=true;
   exit;
   end;//end of if
//init
//.other
cw:=x.width;
ch:=x.height;
if (xe<>nil) then
   begin
   ccount:=frcmin(xe.ai.count,1);
   cw:=cw div ccount;
   trans:=xe.ai.transparent;
   end;//end of if
cw:=frcmin(cw,1);
ch:=frcmin(ch,1);
//ADJUST
e:=gecOutOfMemory;
r:=x.scanline[0];
for p:=1 to ccount do
begin
offx:=(p-1)*cw;
//get - top/left color for "transparency" before adjust cell
if trans then tc:=r[offx];
//set
xrect:=rect(offx,0,offx+cw-1,ch-1);
if _flip and (not flipex(x,xrect,e)) then goto skipend;
if _mirror and (not mirrorex(x,xrect,e)) then goto skipend;
//restore transparent color
if trans then r[offx]:=tc;
end;//end of loop - p (all cells)
//successful
result:=true;
skipend:
except;end;
end;
//## transwhite ##
function tccs.transwhite(x:tbitmap;var e:string):boolean;//prepare a multi-cell imagestrip, ensuring all [0,0] pixel corners are "black" if transparent and all black must be [1,1,1] or higher
var//Note: White is reserved for transparent information
   xe:tbitmapenhanced;
   p,dy,dx,offx,cw,ch,ccount:integer;
   zc,tc,white,offwhite:trgbcolor;
   r:prgbcolorrow;
begin
try
//defaults
result:=false;
e:=gecUnexpectedError;
xe:=nil;
ccount:=1;
//check
if not nonempty24(x) then exit;
if (x is tbitmapenhanced) then xe:=(x as tbitmapenhanced);
//init
//.white
white.r:=255;
white.g:=255;
white.b:=255;
//.offwhite
offwhite.r:=254;
offwhite.g:=254;
offwhite.b:=254;
//.other
cw:=x.width;
ch:=x.height;
if (xe<>nil) then
   begin
   ccount:=frcmin(xe.ai.count,1);
   cw:=cw div ccount;
   end;//end of if
cw:=frcmin(cw,1);
ch:=frcmin(ch,1);
//get
e:=gecOutOfMemory;
for p:=1 to ccount do
begin
offx:=(p-1)*cw;
//y
for dy:=0 to (ch-1) do
begin
r:=x.scanline[dy];
if (dy=0) then
   begin
   tc:=r[offx];
   //transparent color is already WHITE, so there is nothing to do
   if (tc.r=white.r) and (tc.g=white.g) and (tc.b=white.b) then break;
   end;//end of if
//get
for dx:=0 to (cw-1) do
begin
zc:=r[offx+dx];
//.swap pixel to transparent color (as defined by 0,0 pixel of cell)
if (zc.r=tc.r) and (zc.g=tc.g) and (zc.b=tc.b) then zc:=white
//.pixel is white, but not transparent - swap to offwhite (non-transparent white)
else if (zc.r=white.r) and (zc.g=white.g) and (zc.b=white.b) then zc:=offwhite;
//.set
r[offx+dx]:=zc;
end;//end of loop - x
end;//end of loop - y
end;//end of loop - p (all cells)
//successful
result:=true;
except;end;
end;
//## transpotfill ##
function tccs.transpotfill(x:tbitmap;tol:byte;var e:string):boolean;//20SEP2007
label
   skipend;
var//Creates transparent cells by pot filling white in top-left corner
   //Note: all white is first converted to offwhite before pot fill occurs
   xe:tbitmapenhanced;
   p,dy,dx,offx,w,h,cw,ch,ccount:integer;
   zc,tc,white,offwhite:trgbcolor;
   r:prgbcolorrow;
begin
try
//defaults
result:=false;
e:=gecUnexpectedError;
xe:=nil;
ccount:=1;
//check
if not nonempty24(x) then exit;
if (x is tbitmapenhanced) then xe:=(x as tbitmapenhanced);
//init
//.white
white.r:=255;
white.g:=255;
white.b:=255;
//.offwhite
offwhite.r:=254;
offwhite.g:=254;
offwhite.b:=254;
//.other
w:=x.width;
h:=x.height;
cw:=w;
ch:=h;
if (xe<>nil) then
   begin
   ccount:=frcmin(xe.ai.count,1);
   cw:=cw div ccount;
   end;//end of if
cw:=frcmin(cw,1);
ch:=frcmin(ch,1);
//filter - all "white" shifted to "offwhite"
for dy:=0 to (h-1) do
begin
r:=x.scanline[dy];
 for dx:=0 to (w-1) do
 begin
 zc:=r[dx];
 if (zc.r=white.r) and (zc.g=white.g) and (zc.b=white.b) then r[dx]:=offwhite;
 end;//end of loop - x
end;//end of loop - y
//set - pot fill each cell separatly converting top-left corner to white
e:=gecOutOfMemory;
for p:=1 to ccount do
begin
offx:=(p-1)*cw;
//.top-left
if not potfillex(x,rect(offx,0,offx+cw-1,ch-1),offx,0,white,tol,e) then goto skipend;
//.top-right
if not potfillex(x,rect(offx,0,offx+cw-1,ch-1),offx+cw-1,0,white,tol,e) then goto skipend;
//.bottom-left
if not potfillex(x,rect(offx,0,offx+cw-1,ch-1),offx,ch-1,white,tol,e) then goto skipend;
//.bottom-right
if not potfillex(x,rect(offx,0,offx+cw-1,ch-1),offx+cw-1,ch-1,white,tol,e) then goto skipend;
end;//end of loop - p (all cells)
//successful
result:=true;
skipend:
except;end;
end;
//## transtrim ##
function tccs.transtrim(x:tbitmap;var e:string):boolean;//03OCT2007 - Automatically trims all cells
label
   skipend;
var
   xe:tbitmapenhanced;
   b:tbitmap;
   tmpl,tmpr,tmpt,tmpb,spL,spR,spT,spB:integer;
   p,dy,dx,soffx,doffx,w,h,dw,dh,cw,ch,ccount:integer;
   zc,tc:trgbcolor;
   dr,sr:prgbcolorrow;
   tok:boolean;
begin
try
//defaults
result:=false;
e:=gecUnexpectedError;
b:=nil;
xe:=nil;
tok:=false;
ccount:=1;
tmpl:=0;
tmpr:=0;
tmpt:=0;
tmpb:=0;
spL:=maxint;
spR:=maxint;
spT:=maxint;
spB:=maxint;
//check
if not nonempty24(x) then exit;
if (x is tbitmapenhanced) then xe:=(x as tbitmapenhanced);
//init
//.other
w:=x.width;
h:=x.height;
cw:=w;
ch:=h;
if (xe<>nil) then
   begin
   ccount:=frcmin(xe.ai.count,1);
   cw:=cw div ccount;
   tok:=xe.ai.transparent;
   end;//end of if
cw:=frcmin(cw,1);
ch:=frcmin(ch,1);
//scan each cell
e:=gecOutOfMemory;
for p:=1 to ccount do
begin
//.get
soffx:=(p-1)*cw;
if not trimscan(x,rect(soffx,0,soffx+cw-1,ch-1),tmpl,tmpt,tmpr,tmpb,e) then goto skipend;
//.set
if (tmpl<spL) then spL:=tmpl;
if (tmpr<spR) then spR:=tmpr;
if (tmpt<spT) then spT:=tmpt;
if (tmpb<spB) then spB:=tmpb;
end;//end of loop - p (all cells)
//set
dw:=frcmin(cw-spL-spR,1);
dh:=frcmin(ch-spT-spB,1);
if (dw<>cw) or (dh<>ch) then
   begin
   //draw new cells
   e:=gecOutOfMemory;
   b:=newbmp(dw*ccount,dh);
   for p:=1 to ccount do
   begin
   soffx:=(p-1)*cw;
   doffx:=(p-1)*dw;
   for dy:=0 to (dh-1) do
   begin
   sr:=x.scanline[dy+spT];
   dr:=b.scanline[dy];
    for dx:=0 to (dw-1) do
    begin
    zc:=sr[soffx+dx+spL];
    dr[doffx+dx]:=zc;
    end;//end of loop - x
   //.restore transparent information
   if tok and (dy=0) then
      begin
      sr:=x.scanline[0];
      zc:=sr[soffx];
      dr[doffx]:=zc;
      end;//end of if
   end;//end of loop - y
   end;//end of loop - p
   //size and copy
   x.width:=b.width;
   x.height:=b.height;
   if not copybmp(x,b) then goto skipend;
   //info
   if (xe<>nil) then
      begin
      xe.ai.cellwidth:=dw;
      xe.ai.cellheight:=dh;
      end;//end of if
   end;//end of if
//successful
result:=true;
skipend:
except;end;
try;freeobj(@b);except;end;
end;
//## trimscan ##
function tccs.trimscan(x:tbitmap;xarea:trect;var spL,spT,spR,spB:integer;var e:string):boolean;
label
   skipbottom,skiptop,skipright,skipleft;
var
   dx,dy,w,h:integer;
   rows:tdynamicpointer;
   pr:prgbcolorrows;
   refc,zc:trgbcolor;
begin
try
//defaults
result:=false;
e:=gecUnexpectedError;
rows:=nil;
spL:=0;
spT:=0;
spR:=0;
spB:=0;
//check
if not nonempty24(x) then exit;
//range
w:=x.width;
h:=x.height;
xarea.left:=frcrange(xarea.left,0,w-1);
xarea.right:=frcrange(xarea.right,xarea.left,w-1);
xarea.top:=frcrange(xarea.top,0,h-1);
xarea.bottom:=frcrange(xarea.bottom,xarea.top,h-1);
//.rows
rows:=tdynamicpointer.create;
rows.setparams(h,h,0);
for dy:=0 to (h-1) do rows.items[dy]:=x.scanline[dy];
pr:=rows.core;
//SCAN
//left
refc:=pr[xarea.top][xarea.left];
for dx:=xarea.left to xarea.right do for dy:=xarea.top to xarea.bottom do
   begin
   zc:=pr[dy][dx];
   if (zc.r<>refc.r) or (zc.g<>refc.g) or (zc.b<>refc.b) then
      begin
      spL:=dx-xarea.left;
      goto skipleft;
      end;//end of if
   end;//end of loop
skipleft:
//right
refc:=pr[xarea.top][xarea.right];
for dx:=xarea.right downto xarea.left do for dy:=xarea.top to xarea.bottom do
   begin
   zc:=pr[dy][dx];
   if (zc.r<>refc.r) or (zc.g<>refc.g) or (zc.b<>refc.b) then
      begin
      spR:=xarea.right-dx;
      goto skipright;
      end;//end of if
   end;//end of loop
skipright:
//top
refc:=pr[xarea.top][xarea.left];
for dy:=xarea.top to xarea.bottom do for dx:=xarea.left to xarea.right do
   begin
   zc:=pr[dy][dx];
   if (zc.r<>refc.r) or (zc.g<>refc.g) or (zc.b<>refc.b) then
      begin
      spT:=dy-xarea.top;
      goto skiptop;
      end;//end of if
   end;//end of loop
skiptop:
//bottom
refc:=pr[xarea.bottom][xarea.left];
for dy:=xarea.bottom downto xarea.top do for dx:=xarea.left to xarea.right do
   begin
   zc:=pr[dy][dx];
   if (zc.r<>refc.r) or (zc.g<>refc.g) or (zc.b<>refc.b) then
      begin
      spB:=xarea.bottom-dy;
      goto skipbottom;
      end;//end of if
   end;//end of loop
skipbottom:
//successful
result:=true;
except;end;
try;freeobj(@rows);except;end;
end;
//## potfill ##
function tccs.potfill(x:tbitmap;sx,sy:integer;c:trgbcolor;tol:byte;var e:string):boolean;
begin
try
//defaults
result:=false;
e:=gecUnexpectedError;
//set
if nonempty24(x) then result:=potfillex(x,rect(0,0,x.width-1,x.height-1),sx,sy,c,tol,e);
except;end;
end;
//## potfillex ##
function tccs.potfillex(x:tbitmap;xarea:trect;sx,sy:integer;c:trgbcolor;tol:byte;var e:string):boolean;
label
   skipdone,skipend,redo;
var//Xarea.left/right=0..(width-1) and Xarea.top/bottom=0..(height-1)
   //Tol=0 (exact color match), else Tol=1..255 (close color shade of +/- by tol)
   rs:tdynamicpointer;
   ix,iy:tdynamicinteger;
   idmap,ir:tdynamicbyte;
   ip,dx,dy,w,h:integer;
   sc,zc:trgbcolor;
   ps:prgbcolorrows;
   r:prgbcolorrow;
   tmp,ar,ag,ab,br,bg,bb:byte;
begin
try
//defaults
result:=false;
e:=gecUnexpectedError;
rs:=nil;
ix:=nil;//cached Xpos
iy:=nil;//cached Ypos
ir:=nil;//cached Rotation pos
idmap:=nil;//done map
//check
if not nonempty24(x) then exit;
//init
w:=x.width;
h:=x.height;
xarea.left:=frcrange(xarea.left,0,w-1);
xarea.right:=frcrange(xarea.right,xarea.left,w-1);
xarea.top:=frcrange(xarea.top,0,h-1);
xarea.bottom:=frcrange(xarea.bottom,xarea.top,h-1);
sx:=frcrange(sx,xarea.left,xarea.right);
sy:=frcrange(sy,xarea.top,xarea.bottom);
rs:=tdynamicpointer.create;
rs.setparams(h,h,0);
//.position caching
ix:=tdynamicinteger.create;
ix.incsize:=1000;
iy:=tdynamicinteger.create;
iy.incsize:=1000;
ir:=tdynamicbyte.create;
ir.incsize:=1000;
ip:=-1;//none
idmap:=tdynamicbyte.create;
idmap.setparams(w*h,w*h,0);
//.rows
for dy:=0 to (h-1) do rs.items[dy]:=x.scanline[dy];
ps:=rs.core;
sc:=ps[sy][sx];
//.tol
ar:=byte(frcrange(sc.r-tol,0,255));
ag:=byte(frcrange(sc.g-tol,0,255));
ab:=byte(frcrange(sc.b-tol,0,255));
br:=byte(frcrange(sc.r+tol,0,255));
bg:=byte(frcrange(sc.g+tol,0,255));
bb:=byte(frcrange(sc.b+tol,0,255));
//get
dx:=sx;
dy:=sy;
redo:
//SCAN
//get
if (ip>=0) then
   begin
   dx:=ix.items[ip];
   dy:=iy.items[ip];
   tmp:=ir.items[ip];
   case tmp of
   0:begin//0
      dx:=ix.items[ip]+1;
      dy:=iy.items[ip];
      end;//end of begin
   1:begin//90
      dx:=ix.items[ip];
      dy:=iy.items[ip]-1;
      end;//end of begin
   2:begin//180
      dx:=ix.items[ip]-1;
      dy:=iy.items[ip];
      end;//end of begin
   3:begin//270
      dx:=ix.items[ip];
      dy:=iy.items[ip]+1;
      end;//end of begin
   4:begin//finished - move BACK to previous item
      dec(ip);
      if (ip<=-1) then goto skipdone else goto redo;
      end;//end of begin
   end;//end of case
   //inc r
   if (ip>=0) then ir.items[ip]:=ir.items[ip]+1;
   //check
   if (dx<xarea.left) or (dx>xarea.right) or (dy<xarea.top) or (dy>xarea.bottom) then goto redo;
   if (idmap.items[(dy*w)+dx]=1) then
      begin
      if (tmp<4) then goto redo
      else
         begin
         dec(ip);
         if (ip<=-1) then goto skipdone else goto redo;
         end;//end of if
      end;//end of if
   end;//end of if
//decide
if (idmap.items[(dy*w)+dx]=0) then
   begin
   idmap.items[(dy*w)+dx]:=1;
   zc:=ps[dy][dx];
   //get
   if (zc.r>=ar) and (zc.r<=br) and
      (zc.g>=ag) and (zc.g<=bg) and
      (zc.b>=ab) and (zc.b<=bb) then
      begin
      //set
      ps[dy][dx]:=c;
      //cache
      if (ip=-1) or ((ix.items[ip]<>dx) or (ix.items[ip]<>dy)) then
         begin
         inc(ip);
         ix.value[ip]:=dx;
         iy.value[ip]:=dy;
         ir.value[ip]:=0;
         end;//end of if
      end;//end of if
   end;//end of if
if (ip>=0) then goto redo;
//successful
skipdone:
result:=true;
skipend:
except;end;
try
freeobj(@rs);
freeobj(@ix);
freeobj(@iy);
freeobj(@ir);
freeobj(@idmap);
except;end;
end;
//## toppm ##
function tccs.toppm(x:tbitmap;var y,e:string):boolean;//14SEP2007
label//writes "Portable Pixel Map" - 24bit RGB ASCII, replaces "tportablepixelmap.savetostream" which has color corruption
   skipend;
var
   c,w,h,ylen,dy,dx:integer;
   r:prgbcolorrow;
   z:trgbcolor;
begin
try
//defaults
result:=false;
e:=gecUnexpectedError;
y:='';
ylen:=0;
//check
if not nonempty24(x) then exit;
e:=gecOutOfMemory;
w:=x.width;
h:=x.height;
c:=0;
//header
pushb(ylen,y,'P3'+rcode);//PPM ASCII
pushb(ylen,y,inttostr(w)+#32+inttostr(h)+rcode);//width height
pushb(ylen,y,'255'+rcode);//max color (255 for 8bit pixel element depths (rgb))
//get
for dy:=0 to (h-1) do
begin
r:=x.scanline[dy];
 for dx:=0 to (w-1) do
 begin
 //inc
 inc(c);
 //get
 z:=r[dx];
 //set
 pushb(ylen,y,inttostr(z.r)+#32+inttostr(z.g)+#32+inttostr(z.b)+#32+general.insstr(rcode,c>=8));
 //check
 if (c>=8) then c:=0;
 end;//end of loop - y
end;//end of loop - y
//finalise
pushb(ylen,y,'');
//successful
result:=true;
skipend:
except;end;
end;
//## topgm ##
function tccs.topgm(x:tbitmap;var y,e:string):boolean;//14SEP2007
label//writes "Portable Grey Map" - 8bit Grey ASCII
   skipend;
var
   c,w,h,ylen,dy,dx:integer;
   r:prgbcolorrow;
   z:trgbcolor;
   v:byte;
begin
try
//defaults
result:=false;
e:=gecUnexpectedError;
y:='';
ylen:=0;
//check
if not nonempty24(x) then exit;
e:=gecOutOfMemory;
w:=x.width;
h:=x.height;
c:=0;
//header
pushb(ylen,y,'P2'+rcode);//PGM ASCII
pushb(ylen,y,inttostr(w)+#32+inttostr(h)+rcode);//width height
pushb(ylen,y,'255'+rcode);//max color (255 for 8bit pixel element depths (rgb))
//get
for dy:=0 to (h-1) do
begin
r:=x.scanline[dy];
 for dx:=0 to (w-1) do
 begin
 //inc
 inc(c);
 //get
 z:=r[dx];
 //calc
 v:=z.r;
 if (z.g>v) then v:=z.g;
 if (z.b>v) then v:=z.b;
 //set
 pushb(ylen,y,inttostr(v)+#32+general.insstr(rcode,c>=24));
 //check
 if (c>=24) then c:=0;
 end;//end of loop - y
end;//end of loop - y
//finalise
pushb(ylen,y,'');
//successful
result:=true;
skipend:
except;end;
end;
//## topbm ##
function tccs.topbm(x:tbitmap;var y,e:string):boolean;//14SEP2007
label//writes "Portable Bitmap Map" - 1bit Monochome ASCII
   skipend;
var
   c,w,h,ylen,dy,dx:integer;
   r:prgbcolorrow;
   z:trgbcolor;
   v:byte;
begin
try
//defaults
result:=false;
e:=gecUnexpectedError;
y:='';
ylen:=0;
//check
if not nonempty24(x) then exit;
e:=gecOutOfMemory;
w:=x.width;
h:=x.height;
c:=0;
//header
pushb(ylen,y,'P1'+rcode);//PBM ASCII
pushb(ylen,y,inttostr(w)+#32+inttostr(h)+rcode);//width height
//get
for dy:=0 to (h-1) do
begin
r:=x.scanline[dy];
 for dx:=0 to (w-1) do
 begin
 //inc
 inc(c);
 //get
 z:=r[dx];
 //calc
 v:=z.r;
 if (z.g>v) then v:=z.g;
 if (z.b>v) then v:=z.b;
 if (v>=128) then v:=1 else v:=0;
 //set
 pushb(ylen,y,inttostr(v)+#32+general.insstr(rcode,c>=36));
 //check
 if (c>=36) then c:=0;
 end;//end of loop - y
end;//end of loop - y
//finalise
pushb(ylen,y,'');
//successful
result:=true;
skipend:
except;end;
end;
//## totep ##
function tccs.totep(x:tbitmap;var y,e:string):boolean;//15SEP2007
label
   skipend;
var
   pal:array[0..63] of trgbcolor;
   pix:array[0..5] of byte;//palette pointers
   w,h,dx,dy,palcount,p,ylen:integer;
   pixlimit,pixcount,v,bpp:byte;
   zc:trgbcolor;
   r:prgbcolorrow;
   a:tint4;
   //## encByte64 ##
   function encByte64(x:byte):char;//range 0..63
   begin
   try
   //get
   case x of
   0..9:x:=x+48;//0-9=10 "0..9"
   10..35:x:=x+55;//10-35=26 "A..Z"
   36..61:x:=x+61;//36-61=26 "a..z"
   62..63:x:=x-22;//62-63=2 "(..)"
   else x:=48;//default safe value
   end;//end of case
   //return result
   result:=char(x);
   except;end;
   end;
   //## encInt64 ##
   function encInt64(x:integer;full:boolean):string;//range 0..262,143
   const
      a3=64*64*64;
      a2=64*64;
      a1=64;
   var
      v:integer;
   begin
   try
   //defaults
   result:=#48#48#48+general.insstr(#48,full);//zero by default
   //get
   //.4
   if full then
      begin
      v:=x div a3;
      result[4]:=encByte64(byte(v));
      dec(x,v*a3);
      end;//end of if
   //.3
   if (x>=1) then
      begin
      v:=x div a2;
      result[3]:=encByte64(byte(v));
      dec(x,v*a2);
      //.2
      if (x>=1) then
         begin
         v:=x div a1;
         result[2]:=encByte64(byte(v));
         dec(x,v*a1);
         //.1
         if (x>=1) then result[1]:=encByte64(byte(x));
         end;//end of if
      end;//end of if
   except;end;
   end;
   //## packpixels ##
   function packpixels:char;
   var//output range: is 0..63 (this is shifted by encbyte64)
      v:byte;
   begin
   try
   //defaults
   result:=#48;//0 by default
   v:=0;
   case bpp of
   //16/32/64 color : (0-63)
   4..6:v:=pix[0];
   //8 color : (0-7) + (0-7)*8
   3:v:=pix[0]+pix[1]*8;
   //4 color : (0-3) + (0-3)*4 + (0-3)*16
   2:v:=pix[0]+pix[1]*4+pix[2]*16;
   //2 color : (0-1) + (0-1)*2 + (0-1)*4 + (0-1)*8 + (0-1)*16 + (0-1)*32
   1:v:=pix[0]+pix[1]*2+pix[2]*4+pix[3]*8+pix[4]*16+pix[5]*32;
   end;//end of case
   //return result
   result:=encByte64(v);
   pixcount:=0;
   except;end;
   end;
//START
begin
try
//defaults
result:=false;
e:=gecUnexpectedError;
y:='';
ylen:=0;
if not nonempty24(x) then exit;
e:=gecOutOfMemory;
//colors - reduce colors to 64 or less and build palette
if not reducecolorsex(x,high(pal)+1,false,pal,palcount,e) then goto skipend;
//init
w:=x.width;
h:=x.height;
pixcount:=0;
palcount:=frcrange(palcount,2,64);
//HEADER
//color depth 1-6 bit color depth
case palcount of
33..64:begin//64 colors
   bpp:=6;
   pixlimit:=1;
   end;//end of begin
17..32:begin//32 colors
   bpp:=5;
   pixlimit:=1;
   end;//end of begin
9..16:begin//16 colors
   bpp:=4;
   pixlimit:=1;
   end;//end of begin
5..8:begin//8 colors
   bpp:=3;
   pixlimit:=2;
   end;//end of begin
3..4:begin//4 colors
   bpp:=2;
   pixlimit:=3;
   end;//end of begin
0..2:begin//2 colors
   bpp:=1;
   pixlimit:=5;
   end;//end of begin
else
   begin
   e:=gecIndexOutOfRange;
   goto skipend;
   end;//end of begin
end;//end of case
//write
pushb(ylen,y,'T'+encByte64(bpp)+encInt64(w,false)+encInt64(h,false));
//PALETTE
for p:=0 to (palcount-1) do
begin
a.r:=pal[p].r;
a.g:=pal[p].g;
a.b:=pal[p].b;
a.t:=0;
pushb(ylen,y,encInt64(a.val,true));
end;
//.terminator
pushb(ylen,y,'~');
//IMAGE
//scan
for dy:=0 to (h-1) do
begin
r:=x.scanline[dy];
 for dx:=0 to (w-1) do
 begin
 //get
 zc:=r[dx];
 pix[pixcount]:=palfind(pal,palcount,zc);
 inc(pixcount);
 //decide
 if (pixcount>=pixlimit) then pushb(ylen,y,packpixels);
 end;//end of loop - x
end;//end of loop - y
//finalise
if (pixcount>=1) then pushb(ylen,y,packpixels);
//end-of-file
pushb(ylen,y,'#');
pushb(ylen,y,'');//finalise
//successful
result:=true;
skipend:
except;end;
end;
//## toico ##
function tccs.toico(x:tbitmap;var y,e:string):boolean;//15SEP2007
label//Adjusts input image "x"
   skipcrop,skipend;
var
   a:tcoloricon;
   b:tstreamstr;
   c:tbitmap;
   dw,dh,z,tc,s:integer;
   darea:trect;
begin
try
//defaults
result:=false;
e:=gecUnexpectedError;
a:=nil;
b:=nil;
c:=nil;
y:='';
//check
if not nonempty24(x) then exit;
e:=gecOutOfMemory;
//get
//.convert
a:=tcoloricon.create;
a.readimage(x);
a.transparentxy:=point(0,0);//top-left corner
tc:=pixels[x,0,0];
//.transparent
if (x is tbitmapenhanced) then
   begin
   a.transparent:=(x as tbitmapenhanced).ai.transparent;
   end;//end of if
//CROP
s:=a.size;
if (x.width=s) and (x.height=s) then goto skipcrop;
//cls - background color is transparent (top-left) by default
c:=newbmp(s,s);
cls(c,tc,'');
//area
//.center small images on screen
if (x.width<=s) or (x.height<=s) then
   begin
   darea.left:=(s-x.width) div 2;
   darea.top:=(s-x.height) div 2;
   darea.right:=darea.left+s-1;
   darea.bottom:=darea.top+s-1;
   end
else
   begin
   scaledown(s,s,x.width,x.height,dw,dh);
   darea.left:=(s-dw) div 2;
   darea.top:=(s-dh) div 2;
   darea.right:=darea.left+dw-1;
   darea.bottom:=darea.top+dh-1;
   end;//end of if
//copy
if not stretchdraw(darea,c,x,clNone) then goto skipend;
//reload
a.readimage(c);
//free
freeobj(@c);
skipcrop:
//SAVE
b:=tstreamstr.create(@y);
a.savetostream(b);
//successful
result:=true;
skipend:
except;end;
try
freeobj(@a);
freeobj(@b);
freeobj(@c);
except;end;
end;
//## fromico ##
function tccs.fromico(x:tbitmap;var y,e:string):boolean;
label
   skipend;
var
   mem:tstreamstr;
   ico:ticon;
   a:tbitmap;
   ar,xr:prgbcolorrow;
   w,h,dy,dx:integer;
   ac,xc:trgbcolor;
   trans:boolean;
begin
try
//defaults
result:=false;
e:=gecUnexpectedError;
a:=nil;
mem:=nil;
ico:=nil;
trans:=false;
//check
if (x=nil) then exit;
if (y='') then
   begin
   e:=gecUnknownFormat;
   exit;
   end;//end of if
//read
e:=gecOutOfMemory;
mem:=tstreamstr.create(@y);
mem.position:=0;
ico:=ticon.create;
e:=gecUnknownFormat;
ico.loadfromstream(mem);
freeobj(@mem);
//copy - two instances (white/black backgrounds so we can detect transparent pixels)
e:=gecOutOfMemory;
a:=newbmp(1,1);
if not copygraphicex(a,ico,rgb(0,0,0)) then goto skipend;
//.background is by default transparent WHITE
if not copygraphicex(x,ico,rgb(255,255,255)) then goto skipend;
w:=a.width;
h:=a.height;
//set
for dy:=0 to (h-1) do
begin
ar:=a.scanline[dy];
xr:=x.scanline[dy];
 for dx:=0 to (w-1) do
 begin
 //get
 ac:=ar[dx];
 xc:=xr[dx];
 //decide
 if (ac.r=xc.r) and (ac.g=xc.g) and (ac.b=xc.b) then xr[dx]:=nonwhite(xc)
 else trans:=true;
 end;//end of loop - x
end;//end of loop - y
//finalise - top/left corner must be same as transparent color
if trans then
   begin
   xc.r:=255;
   xc.g:=255;
   xc.b:=255;
   xr:=x.scanline[0];
   xr[0]:=xc;
   end;//end of if
//info
if (x is tbitmapenhanced) then
   begin
   (x as tbitmapenhanced).ai.transparent:=trans;
   end;//end of if
//successful
result:=true;
skipend:
except;end;
try
freeobj(@a);
freeobj(@mem);
freeobj(@ico);
except;end;
end;
//## aszip ##
function tccs.aszip(x:tbitmap;var y,e:string):boolean;
var
   mem:tstreamstr;
   zof:tzof;
begin
try
//defaults
result:=false;
e:=gecUnexpectedError;
mem:=nil;
zof:=nil;
y:='';
//check
if (x=nil) then exit;
//process
e:=gecOutOfMemory;
//.set
if valid24(x) then
   begin
   //.bmp
   mem:=tstreamstr.create(@y);
   x.savetostream(mem);
   freeobj(@mem);
   //.zip
   zof:=tzof.create;
   result:=zof.zof(y,e,true);
   end;//end of if
except;end;
try
if not result then y:='';
freeobj(@mem);
freeobj(@zof);
except;end;
end;
//## bmpstr ##
function tccs.bmpstr(x:tbitmap;var y,e:string):boolean;
var
   m:tstreamstr;
begin
try
//defaults
result:=false;
e:=gecUnexpectedError;
m:=nil;
y:='';
//process
if (x<>nil) then
   begin
   e:=gecOutOfMemory;
   m:=tstreamstr.create(@y);
   x.savetostream(m);
   //successful
   result:=true;
   end;//end of if
except;end;
try;freeobj(@m);except;end;
end;
//## asbmp ##
function tccs.asbmp(x:tbitmap;var y:string):boolean;//Updated: 20-JUN-2006
var
   a:tjpegimage;
   b:tstreamstr;
   ok:boolean;
begin
try
//defaults
result:=false;
ok:=false;
a:=nil;
b:=nil;
//check
if (x=nil) then exit;
//process
//.get
b:=tstreamstr.create(@y);
//.bitmap
if not ok then
   begin
   try
   b.position:=0;
   x.loadfromstream(b);
   ok:=true;
   except;end;
   end;//end of if
//.jpeg
if not ok then
   begin
   try
   //.get
   b.position:=0;
   a:=tjpegimage.create;
   a.loadfromstream(b);
   //.set
   x.assign(a);
   ok:=true;
   except;end;
   end;//end of if
//return result
result:=ok;
except;end;
try
freeObj(@a);
freeObj(@b);
except;end;
end;
//## asimage ##
function tccs.asimage(rawdata:string;var image:string;var imagewidth,imageheight:integer;ignorebad:boolean):boolean;
var
   a:tbitmap;
   e,tmp:string;
begin
try
//defaults
result:=false;
a:=nil;
a:=ccs.newbmp(1,1);
//setup
if not ignorebad then
   begin
   imagewidth:=0;
   imageheight:=0;
   image:='';
   end;//end of if
//process
//.get
if asbmp(a,rawdata) and asjpg(a,tmp,e) then
   begin
   //.set
   image:=tmp;
   imagewidth:=a.width;
   imageheight:=a.height;
   //successful
   result:=true;
   end;//end of if
except;end;
try;freeObj(@a);except;end;
end;
//## asthumb ##
function tccs.asthumb(rawdata:string;var thumb:string;var thumbwidth,thumbheight:integer;ignorebad:boolean):boolean;
var
   b,a:tbitmap;
   e,tmp:string;
   w,h:integer;
begin
try
//defaults
result:=false;
a:=nil;
b:=nil;
a:=ccs.newbmp(1,1);
//setup
if not ignorebad then
   begin
   thumbwidth:=0;
   thumbheight:=0;
   thumb:='';
   end;//end of if
//process
//.get
if asbmp(a,rawdata) then
   begin
   //.scale down image to fit "maxwidth" specifications
   w:=frcmin(a.width,1);
   h:=frcmin(a.height,1);
   scaledown(64,64,w,h,w,h);
   //.copy
   b:=ccs.newbmp(1,1);
   b.width:=w;
   b.height:=h;
   b.canvas.stretchdraw(rect(0,0,b.width,b.height),a);
   //.jpg
   if asjpg(b,tmp,e) then
      begin
      //.set
      thumb:=tmp;
      thumbwidth:=b.width;
      thumbheight:=b.height;
      //successful
      result:=true;
      end;//end of if
   end;//end of if
except;end;
try;freeObj(@a);freeObj(@b);except;end;
end;
//## jpgstr ##
function tccs.jpgstr(x:tbitmap;var y:string;z:byte;var e:string):boolean;
var
   c:tjpegimage;
   m:tstreamstr;
begin
try
//defaults
result:=false;
e:=gecUnexpectedError;
y:='';
c:=nil;
m:=nil;
//check
if (x=nil) then exit;
//Process
//x -> c
c:=tjpegimage.create;
c.assign(x);
c.compressionquality:=frcrange(z,1,100);
c.compress;
//c -> y
m:=tstreamstr.create(@y);
c.savetostream(m);
freeobj(@c);
//successful
result:=true;
except;end;
try
freeobj(@c);
freeobj(@m);
except;end;
end;
//## asjpg ##
function tccs.asjpg(x:tbitmap;var jpg,e:string):boolean;
label//Note: Now supports adaptive ratioing, small pictures are small,
     //      large pictures are larger in size.
     //Date: 10-DEC-2006 (rebuilt)
   skipend;
const
   delta=500;//500 bytes is close enough to target to be acceptable
var
   tmp:string;
   tmplen,target,p:integer;
begin
try
//defaults
result:=false;
e:=gecUnexpectedError;
//check
if (x=nil) then exit;
//init
target:=round((x.width*x.height)/5);//5 pixels = 1 byte (target ratio)
jpg:='';
tmp:='';
tmplen:=0;
//process
//.middle scan
if not jpgstr(x,tmp,50,e) then goto skipend;
tmplen:=length(tmp);
//.50% - ok
if general.nrw(tmplen,target,delta) then
   begin
   //nil
   end
//.40% .. 10%, Too big make smaller - 10% = low quality, smallest
else if (tmplen>target) then
   begin
   for p:=4 downto 1 do if jpgstr(x,tmp,(p*10),e) then
      begin
      tmplen:=length(tmp);
      if (tmplen<=target) or general.nrw(tmplen,target,delta) then break;
      end
      else goto skipend;//end of if
   end
//.60% .. 90%, Too small make larger - 90% = high quality, largest
else if (tmplen<target) then
   begin
   for p:=6 downto 9 do if jpgstr(x,tmp,(p*10),e) then
      begin
      tmplen:=length(tmp);
      if (tmplen>=target) or general.nrw(tmplen,target,delta) then break;
      end
      else goto skipend;//end of if
   end;//end of if
//successful
result:=true;
jpg:=tmp;
skipend:
except;end;
end;
//## findtop ##
function tccs.findtop(a:tbitmap;c,emax:integer;up:boolean):integer;
var
   r:prgbcolorrow;
   ec,i,maxx,maxy,x,y:integer;
   tmp,z:trgbcolor;
   ok:boolean;
begin
try
//defaults
result:=-1;
if (a=nil) then exit;
if (c=clNone) then exit;
if (a.pixelformat<>pf24bit) then exit;
//setup
z:=intrgb(c);
maxx:=a.width-1;
maxy:=a.height-1;
if (emax<0) then emax:=10;
//process
//.scan
for y:=0 to maxy do
begin
if up then i:=maxy-y else i:=y;
r:=a.scanline[i];
ok:=true;
ec:=0;
  for x:=0 to maxx do
  begin
  tmp:=r[x];
  if (tmp.r<>z.r) or (tmp.g<>z.g) or (tmp.b<>z.b) then
     begin
     inc(ec);
     if (ec>=emax) then
        begin
        ok:=false;
        break;
        end;//end of if
     end;//end of if
   end;//end of loop
if ok then
   begin
   result:=i;
   if up then dec(result) else inc(result);
   end
else break;
end;//end of loop
except;end;
end;
//## findleft ##
function tccs.findleft(a:tbitmap;c,emax:integer;right:boolean):integer;
var
   r:trgbcolorrows;
   ec,i,maxx,maxy,x,y:integer;
   tmp,z:trgbcolor;
   ok:boolean;
begin
try
//defaults
result:=-1;
if (a=nil) then exit;
if (c=clNone) then exit;
if (a.pixelformat<>pf24bit) then exit;
//setup
z:=intrgb(c);
maxx:=a.width-1;
maxy:=a.height-1;
if (emax<0) then emax:=0;
//process
//.pre-scan
for y:=0 to maxy do r[y]:=a.scanline[y];
//.scan
for x:=0 to maxx do
begin
if right then i:=maxx-x else i:=x;
ok:=true;
ec:=0;
  for y:=0 to maxy do
  begin
  tmp:=r[y][i];
  if (tmp.r<>z.r) or (tmp.g<>z.g) or (tmp.b<>z.b) then
     begin
     inc(ec);
     if (ec>=emax) then
        begin
        ok:=false;
        break;
        end;//end of if
     end;//end of if
   end;//end of loop
if ok then
   begin
   result:=i;
   if right then dec(result) else inc(result);
   end
else break;
end;//end of loop
except;end;
end;
//## autotrim ##
function tccs.autotrim(a:tbitmap;c:integer;var e:string):boolean;
var
   tmp:tbitmap;
   d:trect;
begin
try
//defaults
result:=false;
e:=gecUnexpectedError;
tmp:=nil;
if (c=clNone) or (a=nil) or (not valid24(a)) then exit;
e:=gecOutOfMemory;
//process
//.top
d.top:=findtop(a,c,2,false);
if (d.top=-1) then d.top:=0;
//.bottom
d.bottom:=findtop(a,c,2,true);
if (d.bottom=-1) then d.bottom:=a.height-1;
//.left
d.left:=findleft(a,c,2,false);
if (d.left=-1) then d.left:=0;
//.right
d.right:=findleft(a,c,2,true);
if (d.right=-1) then d.right:=a.width-1;
//.remember
tmp:=newbmp(d.right-d.left+1,d.bottom-d.top+1);
tmp.canvas.draw(-d.left,-d.top,a);
//.return result
a.width:=frcmin(tmp.width,1);
a.height:=frcmin(tmp.height,1);
draw(0,0,a,tmp,clNone);
//successful
result:=true;
except;end;
try;freeObj(@tmp);except;end;
end;
//## autotrimAB ##
function tccs.autotrimAB(a:tbitmap;c1,c2:integer;var e:string):boolean;
begin
try
result:=
  ccs.autotrim(a,c1,e) and
  ccs.autotrim(a,c2,e) and
  ccs.autotrim(a,c1,e) and
  ccs.autotrim(a,c2,e);
except;end;
end;
//## edgetrim ##
function tccs.edgetrim(a:tbitmap;limit:integer;var e:string):boolean;
label//Trims an edge down till no change
     //Limit: <=0=no limit, 1..X=restrict number of scans
   skipend,redo;
var
   p,count,w,h,c:integer;
begin
try
//defaults
result:=false;
e:=gecUnexpectedError;
if (a=nil) or (not valid24(a)) then exit;
count:=0;
p:=0;
//get
redo:
e:=gecOutOfMemory;
w:=a.width;
h:=a.height;
inc(count);
case p of
0:c:=pixels[a,0,0];//top-left
1:c:=pixels[a,a.width-1,0];//top-right
2:c:=pixels[a,a.width-1,a.height-1];//bottom-right
3:c:=pixels[a,0,a.height-1];//bottom-left
else goto skipend;
end;//end of case
//set
case autotrim(a,c,e) of
true:begin
   if ((limit<=0) or (count<limit)) and (a.width>=1) and (a.height>=1) and ((w<>a.width) or (h<>a.height)) then goto redo
   else
      begin
      inc(p);
      count:=0;
      if (p<=3) then goto redo;
      end;//end of if
   end;//end of begin
false:goto skipend;
end;//end of case
//successful
result:=true;
skipend:
except;end;
end;
//## srr ##
procedure tccs.srr(x:twincontrol;rounded,redraw:boolean);//set rounded region, stable, 18-JAN-2007
begin
try;if general.controlstable(x) then setwindowrgn(x.handle,newrgn(0,0,x.width,x.height,rounded),redraw);except;end;
end;
//## sir ##
procedure tccs.sir(a:twincontrol;img:tbitmap;redraw:boolean);//set image region
var
   b:tdynamicinteger;
   r:prgbcolorrow;
   c,tc:trgbcolor;
   rgnnew:hrgn;
   count,v,maxx,x,y,sx,w,h:integer;
   ok:boolean;
begin
try
//defaults
count:=0;
b:=nil;
//check
if (img=nil) or (not general.controlstable(a)) then exit;
if not valid24(img) then exit;
//init
w:=img.width;
h:=img.height;
maxx:=w-1;
v:=(sizeof(trgndataheader) div 4);
b:=tdynamicinteger.create;
b.setparams(v,v,0);
//.region data header
with prgndata(b.core).rdh do
begin
dwsize:=sizeof(trgndataheader);
itype:=RDH_RECTANGLES;
ncount:=0;//number of rectangles contained
nrgnsize:=0;//size of rgn-data (set to "0" if unknown)
rcbound:=rect(0,0,w,h);
end;//end of with

//Y
for y:=0 to (h-1) do
begin
r:=img.scanline[y];
sx:=0;
if (y=0) then tc:=r[0];
//X
ok:=false;
sx:=0;
for x:=0 to (w-1) do
begin
c:=r[x];
//.start
if (not ok) and ((tc.r<>c.r) or (tc.g<>c.g) or (tc.b<>c.b)) then
   begin
   ok:=true;
   sx:=x;
   end;//end of if
//.end
if ok and (((tc.r=c.r) and (tc.g=c.g) and (tc.b=c.b)) or (x=maxx)) then
   begin
   b.value[b.count]:=sx;//left
   b.value[b.count]:=y;//top
   b.value[b.count]:=x;//right
   b.value[b.count]:=y+1;//bottom
   inc(count);
   ok:=false;
   end;//end of if
end;//end of loop x
end;//end of loop y
//set
prgndata(b.core).rdh.ncount:=count;
rgnnew:=extcreateregion(nil,b.count*4,prgndata(b.core)^);
setwindowrgn(a.handle,rgnnew,redraw);
except;end;
try;freeobj(@b);except;end;
end;
//## fittext ##
function tccs.fittext(a:tcanvas;_maxwidth:integer;_text,_marker:string;_right:boolean):string;
var
   i,mw,len,p:integer;
begin
try
//defaults
result:='';
//check
if (a=nil) then exit;
//prepare
len:=length(_text);
if (len=0) then exit;
mw:=a.textwidth(_marker);
_maxwidth:=frcmin(_maxwidth-mw,0);
i:=0;
//process
if _right then
   begin//right-left
   //.get
   for p:=len downto 1 do if (a.textwidth(copy(_text,p,len))<_maxwidth) then i:=p else break;
   //.set
   if (i>=1) then result:=_marker+copy(_text,i,len)
   else result:=_marker;
   end
   else//left-right
   begin
   //.get
   for p:=1 to len do if (a.textwidth(copy(_text,1,p))<_maxwidth) then i:=p else break;
   //.set
   if (i=len) then result:=_text+_marker
   else result:=copy(_text,1,i)+_marker;
   end;//end of if
except;end;
end;
//## screencapture ##
function tccs.screencapture(d:tbitmap):boolean;//17-JAN-2007
begin
try;result:=screencaptureex(-1,-1,-1,-1,-1,-1,-1,-1,d);except;end;
end;
//## screencaptureex ##
function tccs.screencaptureex(dx,dy,dw,dh,sx,sy,sw,sh:integer;d:tbitmap):boolean;//17-JAN-2007
var//Stabilised and verified 09-FEB-2007
   c:tcanvas;
   h:hwnd;
   dc:hdc;
begin
try
//defaults
result:=false;
c:=nil;
h:=0;
//range
if (d=nil) then exit;
//.s
if (sx<0) then sx:=0;
if (sx<0) then sy:=0;
if (sw<0) then sw:=screen.width;
if (sh<0) then sh:=screen.height;
inc(sw,sx);
inc(sh,sy);
//.d
if (dx<0) then dx:=0;
if (dx<0) then dy:=0;
if (dw<0) then dw:=screen.width;
if (dh<0) then dh:=screen.height;
d.width:=dw;
d.height:=dh;
inc(dw,dx);
inc(dh,dy);
//init
h:=getdesktopwindow;
dc:=getwindowdc(h);
//get
c:=tcanvas.create;
c.handle:=dc;
d.canvas.copyrect(rect(dx,dy,dw,dh),c,rect(sx,sy,sw,sh));
//clear
c.handle:=0;
releasedc(h,dc);
//successful
result:=true;
except;end;
try;freeobj(@c);except;end;
end;
//## screencolor ##
function tccs.screencolor(x,y:integer):integer;//17-JAN-2007
var
   a:tbitmap;
begin
try
//defaults
a:=nil;
//init
a:=tbitmap.create;
a.pixelformat:=pf24bit;
//get
screencaptureex(0,0,1,1,x,y,1,1,a);
//set
a.pixelformat:=pf24bit;
result:=a.canvas.pixels[0,0];
except;end;
try;freeobj(@a);except;end;
end;
//## cursorcolor ##
function tccs.cursorcolor:integer;
var
   a:tpoint;
begin
try;getcursorpos(a);result:=screencolor(a.x,a.y);except;end;
end;
//## iconstr
function tccs.iconstr(x:ticon):string;
var
   m:tstreamstr;
begin
try
//defaults
m:=nil;
result:='';
//process
if (x<>nil) and (not x.empty) then
   begin
   m:=tstreamstr.create(@result);
   x.savetostream(m);
   end;//end of if
except;end;
try;freeObj(@m);except;end;
end;
//## iconex ##
function tccs.iconex(x:string;txy:tpoint):ticon;
var
   a:tbitmap;
   e:string;
begin
try
//defaults
result:=nil;
//init
a:=nil;
a:=tbitmap.create;
//get
fromdata(a,x,e);
except;end;
try
//set
result:=icon(a,txy);
//free
freeobj(@a);
except;end;
end;
//## icon ##
function tccs.icon(x:tbitmap;txy:tpoint):ticon;
var//txy=transparent point (txy.x<0 or txy.y<0 = not transparent)
   a:tcoloricon;
   b:tmemorystream;
begin
try
//defaults
a:=nil;
b:=nil;
result:=ticon.create;
a:=tcoloricon.create;
//process
//.blank
if (x=nil) then
   begin
   a.size:=32;
   a.image:=nil;
   txy:=point(0,0);
   end
else
   begin
   a.size:=(a.width+a.height) div 2;
   a.image:=x;
   end;//end of if
a.transparentxy:=txy;
a.transparent:=(txy.x>=0) and (txy.y>=0);
//.set
b:=tmemorystream.create;
a.savetostream(b);
//return result
b.position:=0;
result.loadfromstream(b);
except;end;
try;freeObj(@a);freeObj(@b);except;end;
end;
//## istep ##
function tccs.istep(var x:string):boolean;
begin
try;result:=(length(x)>=3) and (x[1]='T') and (x[2]>='1') and (x[2]<='6') and (x[length(x)]='#');except;end;
end;
//## asanimationb ##
function tccs.asanimationb(cells,delay:integer;tep:string):string;
begin
try;result:=asanimation(cells,delay,tep);except;end;
end;
//## asanimation ##
function tccs.asanimation(cells,delay:integer;var tep:string):string;
begin
try;result:='ANM:c'+inttostr(frcmin(cells,1))+',d'+inttostr(frcmin(delay,0))+'#'+tep;except;end;
end;
//## aiClear ##
procedure tccs.aiClear(var x:tanimationinformation);
begin
try
with x do
begin
binary:=true;
format:='';
subformat:='';
filename:='';
transparent:=false;
flip:=false;
mirror:=false;
delay:=0;
itemindex:=0;
count:=1;
bpp:=24;
//final
readb64:=false;
writeb64:=false;
//internal
iosplit:=0;//none
cellwidth:=0;
cellheight:=0;
end;//end of with
except;end;
end;
//## aiRead ##
function tccs.aiRead(var x:string;var y:tanimationinformation):boolean;
var
   p:integer;
   v,tmp:string;
begin
try
//defaults
result:=false;
tmp:='';
//process
//.clear
aiClear(y);
//.get
if (0=comparetext(copy(x,1,4),'ANM:')) then
   begin
   for p:=5 to length(x) do if (x[p]=#0) or (x[p]='#') then
      begin
      y.iosplit:=p;
      tmp:=copy(x,5,p-5);
      //successful
      result:=true;
      break;
      end;//end of if
   if (tmp='') then exit;
   //.set
   general.swapchars(tmp,',',#10);
   p:=1;
   while general.nextline(p,tmp,v) do if (v<>'') then
   begin
   if (v[1]='c') or (v[1]='C')      then y.count:=frcmin(strint(copy(v,2,length(v))),0)
   else if (v[1]='d') or (v[1]='D') then y.delay:=frcmin(strint(copy(v,2,length(v))),0)
   else if (v[1]='t') or (v[1]='T') then y.transparent:=nb(copy(v,2,1))
   else if (v[1]='f') or (v[1]='F') then y.flip:=nb(copy(v,2,1))
   else if (v[1]='m') or (v[1]='M') then y.mirror:=nb(copy(v,2,1));
   end;//end of if
   end;//end of if
except;end;
end;
//## aiWrite ##
function tccs.aiWrite(var x:string;var y:tanimationinformation):boolean;
var
   xlen:integer;
begin
try
//defaults
result:=false;
xlen:=length(x);
//process
//.header
pushb(xlen,x,'ANM:');
pushb(xlen,x,'c'+inttostr(y.count)+',');
pushb(xlen,x,'d'+inttostr(y.delay)+',');
pushb(xlen,x,'t'+bn(y.transparent)+',');
pushb(xlen,x,'f'+bn(y.flip)+',');
pushb(xlen,x,'m'+bn(y.mirror)+'#');//terminator
//.finalise
pushb(xlen,x,'');
//successful
result:=true;
except;end;
end;
//## aiRewrite ##
function tccs.aiRewrite(var x:string;var y:tanimationinformation):boolean;
var
   tmp:tanimationinformation;
   h:string;
begin
try
//defaults
result:=false;
//get
if aiRead(x,tmp) then
   begin
   if aiWrite(h,y) then
      begin
      x:=h+copy(x,tmp.iosplit+1,length(x));
      result:=true;
      end;//end of if
   end;//end of if
except;end;
end;
//## astep ##
function tccs.astep(x:tobject;maxw,maxh:integer):string;
var
   a:tbitmap;
   b:ttextpicture;
   e:string;
begin
try
//defaults
result:='';
a:=nil;
b:=nil;
//range
maxw:=frcmin(maxw,1);
maxh:=frcmin(maxh,1);
//setup
a:=newbmp(1,1);
//process
if fromobject(a,x,e) then
   begin
   //.size
   a.width:=frcmax(a.width,maxw);
   a.height:=frcmax(a.height,maxh);
   //.tep
   b:=ttextpicture.create;
   b.copyfrom(a);
   //.get
   b.savetostr(result);
   end;//end of if
except;end;
try;freeobj(@a);freeobj(@b);except;end;
end;
//## glyph ##
function tccs.glyph(x:string):tbitmap;
var
   A:TTextPicture;
begin
try
{Error}
Result:=nil;
A:=nil;
A:=TTextPicture.Create;
{Successful}
Result:=A.Glyph(X);
except;end;
try;A.Free;except;end;
end;
//## intrgb ##
function tccs.intrgb(x:integer):trgbcolor;
var
   a:tint4;
begin
try
//get
a.val:=x;
//set
result.r:=a.r;
result.g:=a.g;
result.b:=a.b;
except;end;
end;
//## rgbint ##
function tccs.rgbint(x:trgbcolor):integer;
var
   a:tint4;
begin
try
//get
a.r:=x.r;
a.g:=x.g;
a.b:=x.b;
a.t:=0;
//set
result:=a.val;
except;end;
end;
//## ColorsAsBPP ##
Function tccs.ColorsAsBPP(X:Integer):Byte;
begin
try
Case X of
0..2:Result:=1;
3..4:Result:=2;
5..8:Result:=3;
9..16:Result:=4;
17..32:Result:=5;
33..64:Result:=6;
65..128:Result:=7;
129..256:Result:=8;
257..512:Result:=9;
513..1024:Result:=10;
1025..2048:Result:=11;
2049..4096:Result:=12;
4097..8192:Result:=13;
8193..16384:Result:=14;
16385..32768:Result:=15;
32769..65536:Result:=16;
65537..131072:Result:=17;
131073..262144:Result:=18;
262145..524288:Result:=19;
524289..1048576:Result:=20;
1048577..2097152:Result:=21;
2097153..4194304:Result:=22;
4194305..8388608:Result:=23;
8388609..16777216:Result:=24;
else
Result:=1;{1 bit default}
end;//end of case
except;end;
end;
//## BuildPalette ##
Function tccs.BuildPalette(Var X:TBitmap;Var Pal:TColorPalette;MaxCount:Integer):Boolean;
Label
     SkipEnd;
Var
   C:TByteImage;
   MaxX,MaxY,rX,rY,pI,P,MaxP:Integer;
begin
try
{Error}
Result:=False;
If (X=nil) then exit;
C:=nil;
Pal.Count:=0;
If (MaxCount>(rpccMax+1)) then MaxCount:=rpccMax+1;
{Construct custom palette upto "MaxP" items}
C:=TByteImage.Create;
C.Image:=X;
MaxX:=C.ZeroWidth;
MaxY:=C.ZeroHeight;
For rY:=0 to MaxY Do
begin
 For rX:=0 to MaxX Do
 begin
 pI:=AddRGBToPalette(Pal,C.Pixels[rX,rY]);{max of 256 colors}
 If (pI=-1) or (Pal.Count>=MaxCount) then Goto SkipEnd;
 end;//end of loop
end;//end of loop
SkipEnd:
{Successful}
Result:=True;
except;end;
try;C.Free;except;end;
end;
//## rgbequal ##
Function tccs.rgbequal(Var X,Y:TRGBColor):Boolean;
begin
try;Result:=(X.R=Y.R) and (X.G=Y.G) and (X.B=Y.B);except;end;
end;
//## FindPaletteColor ##
Function tccs.FindPaletteColor(Var X:TColorPalette;Y:Integer):Integer;
Var
   MaxP,P:Integer;
begin
try
{Not Found}
Result:=-1;
MaxP:=X.Count-1;
For P:=0 to MaxP Do
begin
If (Y=X.IntItems[P]) then
   begin
   Result:=P;
   break;
   end;//end of loop
end;//end of loop
except;end;
end;
//## FindPaletteRGB ##
Function tccs.FindPaletteRGB(Var X:TColorPalette;Y:TRGBColor):Integer;
Var
   MaxP,P:Integer;
   Z:TRGBColor;
begin
try
{Not Found}
Result:=-1;
MaxP:=X.Count-1;
For P:=0 to MaxP Do
begin
Z:=X.Items[P];
If (Y.R=Z.R) and (Y.G=Z.G) and (Y.B=Z.B) then
   begin
   Result:=P;
   break;
   end;//end of loop
end;//end of loop
except;end;
end;
//## AddRGBToPalette ##
Function tccs.AddRGBToPalette(Var X:TColorPalette;Y:TRGBColor):Integer;
Var
   Add:Boolean;
   P:Integer;
begin{Z=Max Palette Item ie 1-8}
try
{Error}
Result:=-1;
Case (X.Count=0) of
True:P:=-1;
False:P:=FindPaletteRGB(X,Y);
end;//end of case
{Add}
If (P=-1) and (X.Count<=rpccMax) then
   begin
   P:=X.Count;
   X.IntItems[P]:=RGB(Y.R,Y.G,Y.B);
   X.Items[P]:=Y;
   X.Count:=P+1;
   end;//end of if
{Return Result}
Result:=P;
except;end;
end;
//## sV ##
function tccs.sV(v:integer):integer;//safe value
begin//no error handler - ultra fast
if (v<0) then v:=0 else if (v>255) then v:=255;
result:=v;
end;
//## sRGB ##
procedure tccs.sRGB(var r,g,b:integer);//safe r,g,b
begin
try
if (r<0) then r:=0 else if (r>255) then r:=255;
if (g<0) then g:=0 else if (g>255) then g:=255;
if (b<0) then b:=0 else if (b>255) then b:=255;
except;end;
end;
//## rgbMIN ##
function tccs.rgbMIN(r,g,b:integer):integer;
begin
try
result:=r;
if (g<result) then result:=g;
if (b<result) then result:=b;
except;end;
end;
//## rgbMAX ##
function tccs.rgbMAX(r,g,b:integer):integer;
begin
try
result:=r;
if (g>result) then result:=g;
if (b>result) then result:=b;
except;end;
end;
//## ccv ##
function tccs.ccv(x,y:byte;by:integer):boolean;//color channel visible
begin
try
//range
if (by<0) then by:=30;
//process
result:=(general.posn(x-y)>=by);
except;end;
end;
//## cv ##
function tccs.cv(col,bgcolor:integer;by:integer):boolean;//color visible
var
   c,b:tint4;
begin
try
//defaults
result:=false;
//process
//.get
c.val:=col;
b.val:=bgcolor;
//return result
result:=
 ccv(c.bytes[0],b.bytes[0],by) or
 ccv(c.bytes[1],b.bytes[1],by) or
 ccv(c.bytes[2],b.bytes[2],by);
except;end;
end;
//## ecv ##
function tccs.ecv(col,bgcolor:integer;by:integer):integer;//ensure color visible
begin
try
//defaults
result:=col;
//process
if not cv(result,bgcolor,by) then result:=invcolor(result,true);
except;end;
end;
//## toLUMb ##
function tccs.toLUMb(x:integer):integer;
var
   a:tint4;
begin
try;a.val:=x;result:=toLUM(a.r,a.g,a.b);except;end;
end;
//## toLUM ##
function tccs.toLUM(r,g,b:integer):integer;//luminosity 13-SEP-2004
const
     dv=0.4705882;//240/(255*2)
begin
try;result:=round(rgbMAX(r,g,b)*dv+rgbMIN(r,g,b)*dv);except;end;
end;
//## toYUV ##
procedure tccs.toYUV(r,g,b:integer;var y,u,v:integer);//"PAL"
begin
try
y:=round(0.299*r+0.587*g+0.114*b);
u:=round(-0.147*r-0.289*g+0.437*b);
v:=round(0.615*r-0.515*g-0.100*b);
except;end;
end;
//## fromYUV ##
procedure tccs.fromYUV(var r,g,b:integer;y,u,v:integer);//"PAL"
begin
try
r:=round(y+1.403*v);
g:=round(y-0.344*u-0.714*v);
b:=round(y+1.773*u);
//sRGB
sRGB(r,g,b);
except;end;
end;
//## toYIQ ##
procedure tccs.toYIQ(r,g,b:integer;var y,i,q:integer);//"NTSC"
begin
try
y:=round(0.299*r+0.587*g+0.114*b);
i:=round(0.596*r-0.274*g-0.322*b);
q:=round(0.211*r-0.523*g-0.312*b);
except;end;
end;
//## fromYIQ ##
procedure tccs.fromYIQ(var r,g,b:integer;y,i,q:integer);//"NTSC"
begin
try
r:=round(y+0.956*i+0.621*q);
g:=round(y-0.272*i-0.647*i);
b:=round(y-1.105*i+1.702*q);
//sRGB
sRGB(r,g,b);
except;end;
end;
//## toCYM ##
procedure tccs.toCYM(r,g,b:integer;var c,y,m:integer);//"Cyan,Yellow,Magenta"
begin
try
c:=255-r;//c
y:=255-b;//y
m:=255-g;//m
except;end;
end;
//## fromCYM ##
procedure tccs.fromCYM(var r,g,b:integer;c,y,m:integer);//"Cyan,Yellow,Magenta"
begin
try
r:=255-c;//c
b:=255-y;//y
g:=255-m;//m
//sRGB
sRGB(r,g,b);
except;end;
end;
//## bpp ##
function tccs.bpp(i:tbitmap;_colors:integer):byte;//bits per pixel
begin
try
//.get
if (_colors<=0) then _colors:=lcc(i,257);
//.set
case _colors of
0..2:result:=1;
3..16:result:=4;
17..256:result:=8;
else
 result:=24;
end;//end of case
except;end;
end;
//## lcc ##
function tccs.lcc(i:tbitmap;_limit:integer):integer;//limited color count 21-SEP-2004
label
     skipone,skipok;
var
   a:prgbcolorrow;
   x:array[word] of trgbcolor;
   p,count,rx,ry,maxx,maxy:integer;
   lc,z:trgbcolor;
   ok,lcok:boolean;
begin
try
//defaults
result:=0;
//check
if not valid24(i) then exit;
//prepare
count:=0;
_limit:=frcmax(_limit-1,high(x));
maxx:=i.width-1;
maxy:=i.height-1;
lcok:=false;
//process
for ry:=0 to maxy do
begin
  a:=i.scanline[ry];
  if (count>_limit) then break;
  for rx:=0 to maxx Do
  begin
  z:=a[rx];
  //check
  if lcok and (lc.r=z.r) and (lc.g=z.g) and (lc.b=z.b) then goto skipone;
  //scan
  ok:=true;
  for p:=0 to (count-1) do if (x[p].r=z.r) and (x[p].g=z.g) and (x[p].b=z.b) then
      begin
      ok:=false;
      break;
      end;//end of if
  //add
  if ok then
      begin
      x[count]:=z;
      count:=count+1;
      if (count>_limit) then goto skipok;
      end;//end of if
skipone:
  lc:=z;
  lcok:=true;
  end;//end of loop
end;//end of loop
skipok:
//return result
result:=count;
except;end;
end;
//## countcolors ##
function tccs.countcolors(i:tbitmap):integer;//full color count
var//~580ms for a 1152x864 [24bit] with 362,724 colors
   //Warning: requires "max stack size" to be atleast "$00500000"
   p,ci,ip,rx,ry,maxx,maxy:integer;
   a:prgbcolorrow;
   z:trgbcolor;
   ics:array[0..2097152] of set of 0..7;
   c2:set of 0..7;
begin
try
//defaults
result:=0;
//check
if not valid24(i) then exit;
//prepare
for rx:=0 to high(ics) do ics[rx]:=[];
maxx:=i.width-1;
maxy:=i.height-1;
//process
for ry:=0 to maxy do
begin
a:=i.scanline[ry];
  for rx:=0 to maxx do
  begin
  //.get
  z:=a[rx];
  p:=z.r+z.g*256+z.b*65536;//0..16,777,215 -> 0..2,097,152
  ip:=p div 8;
  ci:=p-ip*8;
  //.set
  if not (ci in ics[ip]) then include(ics[ip],ci);
  end;//end of loop
end;//end of loop
//return result
for rx:=0 to high(ics) do
begin
c2:=ics[rx];
if (byte(c2)>=1) then//25ms faster than "(c2<>[])"
   begin
   if (0 in c2) then result:=result+1;//faster than a loop
   if (1 in c2) then result:=result+1;
   if (2 in c2) then result:=result+1;
   if (3 in c2) then result:=result+1;
   if (4 in c2) then result:=result+1;
   if (5 in c2) then result:=result+1;
   if (6 in c2) then result:=result+1;
   if (7 in c2) then result:=result+1;
   end;//end of if
end;//end of loop
except;end;
end;
//## getpixel ##
function tccs.getpixel(i:tbitmap;x,y:integer):integer;
var
   a:prgbcolorrow;
   z:trgbcolor;
begin
try
//defaults
result:=clnone;
//check
if not valid24(i) then exit;
if (x<0) or (x>=i.width) or (y<0) or (y>=i.height) then exit;
//process
a:=i.scanline[y];
z:=a[x];
result:=z.r+z.g*256+z.b*65536;
except;end;
end;
//## setpixel ##
procedure tccs.setpixel(i:tbitmap;x,y,c:integer);
var
   a:prgbcolorrow;
   b:tint4;
   z:trgbcolor;
begin
try
//check
if (c=clnone) or (not valid24(i)) then exit;
if (x<0) or (x>=i.width) or (y<0) or (y>=i.height) then exit;
//process
b.val:=c;
z.r:=b.r;
z.g:=b.g;
z.b:=b.b;
a:=i.scanline[y];
a[x]:=z;
except;end;
end;
//## safetransinfo ##
function tccs.safetransinfo(tc:integer;var rgbTC,rgbsafeTC:trgbcolor):boolean;//safe transparency information
begin
try
//defaults
result:=false;
fillchar(rgbTC,sizeof(rgbTC),0);
fillchar(rgbSafeTC,sizeof(rgbSafeTC),0);
//get
if (tc<>clNone) then
   begin
   rgbTC:=ccs.intrgb(tc);
   rgbsafeTC:=rgbTC;
   //.create a new color just below "transparent color" which if any filters procedure
   // can be substituted for "_tcsafe" - leaving "_tc" instact through all filtering.
   if (rgbsafeTC.r=0) and (rgbsafeTC.g=0) and (rgbsafeTC.b=0) then rgbsafeTC:=ccs.intrgb(rgb(1,1,1))
   else
      begin
      if (rgbsafeTC.r>0) then dec(rgbsafeTC.r);
      if (rgbsafeTC.g>0) then dec(rgbsafeTC.g);
      if (rgbsafeTC.b>0) then dec(rgbsafeTC.b);
      end;//end of if
   //successful
   result:=true;
   end;//end of if
except;end;
end;
//## transparentcolor ##
function tccs.transparentcolor(i:tbitmap;x,y:integer;_transparent:boolean):integer;
begin
try;result:=clnone;if _transparent then result:=pixels[i,x,y];except;end;
end;
//## edgecolor ##
function tccs.edgecolor(i:tbitmap):integer;
var//Scans all four image corner pixels, and returns color that occurs most often or top-left
   a,c:array[0..3] of integer;
   v,p2,p:integer;
begin
try
//defaults
result:=clNone;
//check
if (i=nil) then exit;
//init
for p:=0 to high(c) do c[p]:=0;
//get
a[0]:=pixels[i,0,0];//top-left
a[1]:=pixels[i,i.width-1,0];//top-right
a[2]:=pixels[i,i.width-1,i.height-1];//bottom-right
a[3]:=pixels[i,0,i.height-1];//bottom-left
//decide
for p:=0 to high(a) do
begin
v:=a[p];
 for p2:=0 to high(a) do
 begin
 if (v=a[p2]) then inc(c[p]);
 end;//end of loop
end;//end of loop
//set
v:=0;
p2:=0;
for p:=0 to high(c) do if (c[p]>v) then
   begin
   p2:=p;
   v:=c[p];
   end;//end of if
result:=a[p2];
except;end;
end;
//## swaprgb ##
procedure tccs.swaprgb(var a,b:trgbcolor);
var
   z:trgbcolor;
begin
try
z:=a;
a:=b;
b:=z;
except;end;
end;
//## rr8 ##
function tccs.rr8(var a:trows8;i:tbitmap):boolean;//read rows 8bit
var
   p:integer;
begin
try
result:=false;
if valid8(i) then
   begin
   for p:=0 to (i.height-1) do a[p]:=i.scanline[p];
   result:=true;
   end;//end of if
except;end;
end;
//## rr24 ##
function tccs.rr24(var a:trgbcolorrows;i:tbitmap):boolean;//read rows 24bit
var
   p:integer;
begin
try
result:=false;
if valid24(i) then
   begin
   for p:=0 to (i.height-1) do a[p]:=i.scanline[p];
   result:=true;
   end;//end of if
except;end;
end;
//## fpe ##
procedure tccs.fpe(_pal:PLogPalette;_index,_color:integer);//fill palette entry
var
   a:tint4;
begin
try
//prepare
a.val:=_color;
//process
with _pal.palPalEntry[_index] do
begin
peRed:=a.r;
peGreen:=a.g;
peBlue:=a.b;
peFlags:=0;//must be set else "peGreen" destabilises
end;//end of with
except;end;
end;
//## rectgrow ##
function tccs.rectgrow(x:trect;by:integer):trect;
begin
try
with result do
begin
left:=x.left-by;
top:=x.top-by;
right:=x.right+by;
bottom:=x.bottom+by;
end;//end of with
except;end;
end;
//## dsymbolsize ##
function tccs.dsymbolsize(x:tcanvas):integer;
begin
try;result:=general.evenn(smallest(x.textwidth('#'),x.textheight('#')));except;end;
end;
//## dsymbol ##
procedure tccs.dsymbol(x:tcanvas;y:trect;fc,bc:integer;_symbol:string);//draw symbol
var
   a:trect;
   s:byte;
   r,fw,fh,xw,yh,wd:integer;
begin
try
//process
if (length(_symbol)<2) then exit
else s:=byte(_symbol[2]);
//.rotate
fh:=y.bottom-y.top;
fw:=y.right-y.left;
wd:=smallest(fw,fh);
//.special - evenly formatted triangle
if (s>=1) and (s<=4) then wd:=general.evenn(wd);
xw:=wd;
yh:=wd;
if (s=1) then
   begin
   r:=0;
   xw:=wd div 2;
   end
else if (s=2) then
   begin
   r:=90;
   yh:=wd div 2;
   end
else if (s=3) then
   begin
   r:=180;
   xw:=wd div 2;
   end
else if (s=4) then
   begin
   r:=270;
   yh:=wd div 2;
   end
else if (s=7) then yh:=wd div 2
else if (s=8) then xw:=wd div 2;
//.color/area
a:=rect(y.left,y.top,y.left+xw,y.top+yh);
//.center within a single "text character area"
a:=ccs.rectalign(a,y,rtaCenterVertical);
a:=ccs.rectalign(a,y,rtaCenterHorizontal);
//SYMBOLS
//..triangle (half height)
if (s>=1) and (s<=4) then ccs.dtri(x,a,fc,bc,r)
//..square
else if (s=5) then ccs.drect(x,a,fc,bc,false)
else if (s=6) then ccs.drect(x,a,fc,clNone,false)
//..rectangle
else if (s>=7) and (s<=8) then ccs.drect(x,a,fc,bc,false)
//..circle (small)
else if (s=9) then ccs.drect(x,a,fc,bc,true)
else if (s=14) then ccs.drect(x,a,fc,clNone,true);
except;end;
end;
//## dtri ##
procedure tccs.dtri(x:tcanvas;y:trect;fc,bc,_rotate:integer);//draw triangle
var
   xd,yd:integer;
   d1,d2,d3:tpoint;
begin
try
//check
if (x=nil) then exit;
{prepare}
xd:=y.right-y.left;
yd:=y.bottom-y.top;
case _rotate of
90:begin
    d1:=point(y.left+(xd div 2),y.top);
    d2:=point(y.right,y.bottom);
    d3:=point(y.left,y.bottom);
    end;//end of begin
180:begin
    d1:=point(y.left,y.top+(yd div 2));
    d2:=point(y.right,y.top);
    d3:=point(y.right,y.bottom);
    end;//end of begin
270:begin
    d1:=point(y.left+(xd div 2),y.bottom);
    d2:=point(y.left,y.top);
    d3:=point(y.right,y.top);
    end;//end of begin
else{0/360}
    begin
    d1:=point(y.right,y.top+(yd div 2));
    d2:=point(y.left,y.bottom);
    d3:=point(y.left,y.top);
    end;//end of begin
end;//end of case
//colors
x.pen.color:=bc;
x.brush.color:=fc;
//draw
x.polygon([d1,d2,d3]);
except;end;
end;
//## drectangle ##
procedure tccs.drectangle(x:tcanvas;y:trect;fc,bc,_rotate:integer);//draw rectangle
var
   x25,y25,xd,yd:integer;
   d1,d2,d3,d4:tpoint;
begin
try
//check
if (x=nil) then exit;
{prepare}
xd:=y.right-y.left;
yd:=y.bottom-y.top;
y25:=yd div 4;
x25:=xd div 4;
case _rotate of
90,270:begin
   d1:=point(y.left+x25,y.top);
   d2:=point(y.left+x25*3,y.top);
   d3:=point(y.left+x25*3,y.bottom);
   d4:=point(y.left+x25,y.bottom);
   end;//end of begin
else{0/180/360}
   begin
   d1:=point(y.right,y.top+y25);
   d2:=point(y.right,y.top+y25*3);
   d3:=point(y.left,y.top+y25*3);
   d4:=point(y.left,y.top+y25);
   end;//end of begin
end;//end of case
//colors
x.pen.color:=bc;
x.brush.color:=fc;
//draw
x.polygon([d1,d2,d3,d4]);
except;end;
end;
//## rectalign ##
function tccs.rectalign(source,base:trect;align:trectalign):trect;
var
   s,b:integer;
begin
try
//process
if (align=rtaCenterVertical) then
   begin
   //.get
   result.left:=source.left;
   result.right:=source.right;
   s:=source.bottom-source.top;
   b:=base.bottom-base.top;
   //.set
   result.top:=base.top+((b-s) div 2);
   result.bottom:=result.top+s;
   end
else if (align=rtaCenterHorizontal) then
   begin
   //.get
   result.top:=source.top;
   result.bottom:=source.bottom;
   s:=source.right-source.left;
   b:=base.right-base.left;
   //.set
   result.left:=base.left+((b-s) div 2);
   result.right:=result.left+s;
   end
else result:=source;
except;end;
end;
//## rectrotate90 ##
function tccs.rectrotate90(x:trect):trect;
begin
try
result.left:=x.bottom;
result.top:=x.left;
result.right:=x.top;
result.bottom:=x.right;
except;end;
end;
//## drectb ##
procedure tccs.drectb(x:tcanvas;y:trect;fc,bc:integer;_rounded:boolean;_size:integer);//draw rect
var
   p:integer;
begin
try;for p:=0 to (_size-1) do drect(x,rectgrow(y,-p),fc,bc,_rounded);except;end;
end;
//## drect ##
procedure tccs.drect(x:tcanvas;y:trect;fc,bc:integer;_rounded:boolean);//draw rect
begin
try
//check
if (x=nil) then exit;
if (fc=clNone) and (bc=clNone) then exit;
//process
case _rounded of
true:begin
    x.pen.color:=fc;
    x.brush.color:=bc;
    if (fc=clNone) then x.pen.style:=psClear;
    if (bc=clNone) then x.brush.style:=bsClear;
    if (fc<>clNone) then x.roundrect(y.left,y.top,y.right,y.bottom,viCornerA,viCornerB)
    else x.roundrect(y.left,y.top,y.right+1,y.bottom+1,viCornerA,viCornerB);//width/height correction
    end;//end of begin
false:begin
    if (bc<>clNone) then
       begin
       x.brush.color:=bc;
       x.fillrect(y)
       end;//end of if
    if (fc<>clNone) then
       begin
       x.brush.color:=fc;
       x.framerect(y);
       end;//end of if
    end;//end of begin
end;//end of case
//clean up
if (fc=clNone) then x.pen.style:=psSolid;
if (bc=clNone) then x.brush.style:=bsSolid;
except;end;
end;
//## inverttext ##
procedure tccs.inverttext(a:tcanvas;x,y,w,h:integer;s:string);
var
   b:tbitmap;
begin
try
//defaults
//.size
b:=nil;
b:=tbitmap.create;
b.width:=w;
b.height:=h;
//.cls
b.canvas.brush.color:=clblack;
b.canvas.fillrect(rect(0,0,b.width,b.height));
//.text
b.canvas.font.assign(a.font);
b.canvas.font.color:=clWhite;
b.canvas.brush.style:=bsClear;
b.canvas.textout(0,0,s);
//.draw
a.copymode:=cmSrcInvert;
a.draw(x,y,b);
except;end;
try;freeObj(@b);except;end;
end;
//## newbmp ##
function tccs.newbmp(w,h:integer):tbitmap;
begin
try
result:=nil;
result:=tbitmap.create;
result.pixelformat:=pf24bit;
result.width:=frcmin(w,1);
result.height:=frcmin(h,1);
except;end;
end;
//## newbmpeh ##
function tccs.newbmpeh(w,h:integer):tbitmapenhanced;
begin
try
result:=nil;
result:=tbitmapenhanced.create;
result.pixelformat:=pf24bit;
result.width:=frcmin(w,1);
result.height:=frcmin(h,1);
except;end;
end;
//## size ##
function tccs.size(x:tbitmap;w,h:integer):boolean;
begin
try
//error
result:=false;
//check
if (x=nil) then exit;
//process
x.width:=frcmin(w,1);
x.height:=frcmin(h,1);
x.pixelformat:=pf24bit;
//successful
result:=true;
except;end;
end;
//## valid8 ##
function tccs.valid8(i:tbitmap):boolean;
begin
try
//no
result:=false;
//process
if (i<>nil) then
   begin
   if (i.pixelformat<>pf8bit) then i.pixelformat:=pf8bit;
   //yes
   result:=true;
   end;//end of if
except;end;
end;
//## valid24 ##
function tccs.valid24(i:tbitmap):boolean;
begin
try
//no
result:=false;
//process
if (i<>nil) then
   begin
   if (i.pixelformat<>pf24bit) then i.pixelformat:=pf24bit;
   //yes
   result:=true;
   end;//end of if
except;end;
end;
//## nonempty24 ##
function tccs.nonempty24(x:tbitmap):boolean;
begin
try;result:=(x<>nil) and valid24(x) and (x.width>=1) and (x.height>=1);except;end;
end;
//## cls ##
function tccs.cls(i:tbitmap;c:integer;fsd:string):boolean;
var//fsd = frame STYLE data "tframeinfo.STYLE"
   a:tframeinfo;
   rx,ry:integer;
   cRGB:trgbcolor;
   r:prgbcolorrow;
   z:trgbcolor;
begin
try
//error
result:=false;
//check
if not valid24(i) then exit;
//process
case (fsd<>'') of
true:begin
   //shade CLS
   a.style:=fsd;
   a.width:=i.height;
   a.color:=colortorgb(c);
   Draw3DFrame(a,i,true);
   end;//end of begin
else
   begin
   //cls
   cRGB:=intrgb(c);
   for ry:=0 to (i.height-1) do
   begin
   r:=i.scanline[ry];
   for rx:=0 to (i.width-1) do r[rx]:=cRGB;
   end;//end of loop
   end;//end of begin
end;//end of case
//successful
result:=true;
except;end;
end;
//## stretchdraw ##
function tccs.stretchdraw(darea:trect;dest,source:tbitmap;_omitcolor:integer):boolean;//19-MAY-2007
begin
try;result:=stretchdrawex(darea,rect(0,0,maxint,maxint),dest,source,_omitcolor);except;end;
end;
//## stretchdrawex ##
function tccs.stretchdrawex(darea,allowarea:trect;dest,source:tbitmap;_omitcolor:integer):boolean;//19-MAY-2007
var//non-transparent: set "_omitcolor:=clNone"
   //Note: now supports dynamic "xmap/ymap" using only RAM needed - 19MAY2007
   //Important: darea="x1,y1...x2,y2" and same "allowarea"
   _xmap,_ymap:tdynamicword;
   xmap,ymap:pdlWORD;
   o:tint4;
   c:trgbcolor;
   d,s:prgbcolorrow;
   _x,_y,_p,dw,dh,w,h,x,y,ox,oy,xmin,xmax,ymin,ymax,xdiv,ydiv:integer;
   _xinv,_yinv:boolean;
   _xratio,_yratio:extended;
begin
try
//error
result:=false;
//defaults
_xmap:=nil;
_ymap:=nil;
//check
if not valid24(dest) then exit;
if not valid24(source) then exit;
//init
w:=source.width;
h:=source.height;
dw:=dest.width;
dh:=dest.height;
//inversion check
_xinv:=(darea.right<darea.left);
_yinv:=(darea.bottom<darea.top);
if _xinv then swapint(darea.left,darea.right);
if _yinv then swapint(darea.top,darea.bottom);
//non-zero
darea.right:=darea.right-1;
darea.bottom:=darea.bottom-1;
xdiv:=darea.right-darea.left;
ydiv:=darea.bottom-darea.top;
//check
if (xdiv<0) or (ydiv<0) then exit;
_xratio:=w/(xdiv+1);
_yratio:=h/(ydiv+1);
if (w=0) or (h=0) or (dw=0) or (dh=0) then exit;
//enforce range
if (darea.left<0) then
   begin
   xmin:=-darea.left;
   ox:=darea.left;
   end
   else
   begin
   xmin:=0;
   ox:=darea.left;
   end;//end of if
if (darea.right>=dw) then xmax:=xdiv-(darea.right-dw+1) else xmax:=xdiv;
if (darea.top<0) then
   begin
   ymin:=-darea.top;
   oy:=darea.top;
   end
   else
   begin
   ymin:=0;
   oy:=darea.top;
   end;//end of if
if (darea.bottom>=dh) then ymax:=ydiv-(darea.bottom-dh+1) else ymax:=ydiv;
//.map x-y
_xmap:=tdynamicword.create;
_ymap:=tdynamicword.create;
_xmap.setparams(xmax+1,xmax+1,0);
_ymap.setparams(ymax+1,ymax+1,0);
xmap:=_xmap.core;
ymap:=_ymap.core;
for x:=xmin to xmax do
    begin
    if _xinv then _p:=xdiv-x else _p:=x;
    _x:=round(int(_p*_xratio));
    if (_x<0) or (_x>=w) then _x:=0 else _x:=_x+1;
    xmap[x]:=_x;
    end;
for y:=ymin to ymax do
    begin
    if _yinv then _p:=ydiv-y else _p:=y;
    _y:=round(int(_p*_yratio));
    if (_y<0) or (_y>=h) then _y:=0 else _y:=_y+1;
    ymap[y]:=_y;
    end;
//process
if (_omitcolor=clnone) then
   begin
   for y:=ymin to ymax do if (ymap[y]<>0) and ((y+oy)>=allowarea.top) and ((y+oy)<allowarea.bottom) then
       begin
       s:=source.scanline[ymap[y]-1];
       d:=dest.scanline[y+oy];
       for x:=xmin to xmax do if (xmap[x]<>0) and ((x+ox)>=allowarea.left) and ((x+ox)<allowarea.right) then d[x+ox]:=s[xmap[x]-1];
       end;//end of if
   end
   else
   begin
   o.val:=_omitcolor;
   for y:=ymin to ymax do if (ymap[y]<>0) and ((y+oy)>=allowarea.top) and ((y+oy)<allowarea.bottom) then
       begin
       s:=source.scanline[ymap[y]-1];
       d:=dest.scanline[y+oy];
       for x:=xmin to xmax do if (xmap[x]<>0) and ((x+ox)>=allowarea.left) and ((x+ox)<allowarea.right) then
           begin
           c:=s[xmap[x]-1];
           if (c.r<>o.r) or (c.g<>o.g) or (c.b<>o.b) then d[x+ox]:=c;
           end;//end of if
       end;//end of if
   end;//end of if
//successful
result:=true;
except;end;
try
freeobj(@_xmap);
freeobj(@_ymap);
except;end;
end;
//## draw ##
function tccs.draw(dx,dy:integer;dest,source:tbitmap;_omitcolor:integer):boolean;//15-SEP-2004
var//stats: can be faster when transparent, generally slower than tcanvas.draw() -  2x slower
   c:trgbcolor;
   o:tint4;
   d,s:prgbcolorrow;
   _x,_y,x,y,w,h,dw,dh:integer;
begin
try
//error
result:=false;
//check
if not valid24(dest) then exit;
if not valid24(source) then exit;
//prepare
w:=source.width;
h:=source.height;
dw:=dest.width;
dh:=dest.height;
//enforce range
if (w=0) or (h=0) or (dw=0) or (dh=0) then exit;
//process
if (_omitcolor=clnone) then
   begin
   for y:=0 to (h-1) do
   begin
   _y:=dy+y;
   if (_y>=0) and (_y<dh) then
      begin
      s:=source.scanline[y];
      d:=dest.scanline[_y];
      for x:=0 to (w-1) do
      begin
      _x:=dx+x;
      if (_x>=0) and (_x<dw) then d[_x]:=s[x];
      end;//end of loop
      end;//end of if
   end;//end of loop
   end
   else
   begin
   o.val:=_omitcolor;
   for y:=0 to (h-1) do
   begin
   _y:=dy+y;
   if (_y>=0) and (_y<dh) then
      begin
      s:=source.scanline[y];
      d:=dest.scanline[_y];
      for x:=0 to (w-1) do
      begin
      _x:=dx+x;
      if (_x>=0) and (_x<dw) then
         begin
         c:=s[x];
         if (c.r<>o.r) or (c.g<>o.g) or (c.b<>o.b) then d[_x]:=c;
         end;//end of if
      end;//end of loop
      end;//end of if
   end;//end of loop
   end;//end of if
//successful
result:=true;
except;end;
end;
//## copybmp ##
function tccs.copybmp(dest,source:tbitmap):boolean;
var
   z:trgbcolor;
   d,s:prgbcolorrow;
   w,h,x,y:integer;
begin
try
//error
result:=false;
//check
if not valid24(dest) then exit;
if not valid24(source) then exit;
//prepare
w:=source.width;
h:=source.height;
if (w=0) or (h=0) then exit;
//process
//.size
if not size(dest,w,h) then exit;
//.copy
for y:=0 to (h-1) do
begin
d:=dest.scanline[y];
s:=source.scanline[y];
for x:=0 to (w-1) do
    begin
    z:=s[x];
    d[x]:=z;
    end;//end of if
end;//end of loop
//successful
result:=true;
except;end;
end;

//## ttbt ######################################################################
//## tedb ##
function tedb(p:string;var x,e:string;_encode:boolean):boolean;
var
   tmp:string;
begin
try
//defaults
result:=false;
e:=gecUnexpectedError;
//get
if ted(p,x,tmp,e,_encode) then
   begin
   e:=gecOutOfMemory;
   //set
   x:='';
   x:=tmp;
   //successful
   result:=true;
   end;//end of if
except;end;
end;
//## ted ##
function ted(p:string;var s,d,e:string;_encode:boolean):boolean;
var
   a:ttbt;
begin
try
//defaults
result:=false;
e:=gecOutOfMemory;
a:=nil;
//process
//.get
a:=ttbt.create;
a.password:=p;
a.power:=1000;//maximum encryption power
//.set
case _encode of
true:result:=a.encode(s,d,e);
false:result:=a.decode(s,d,e);
end;//end of case
except;end;
try;freeobj(@a);except;end;
end;
//## tedb4 ##
function tedb4(p:string;var x,e:string;_power:integer;_encode:boolean):boolean;//21SEP2007
var
   tmp:string;
begin
try
//defaults
result:=false;
e:=gecUnexpectedError;
//get
if ted4(p,x,tmp,e,_power,_encode) then
   begin
   e:=gecOutOfMemory;
   //set
   x:='';
   x:=tmp;
   //successful
   result:=true;
   end;//end of if
except;end;
end;
//## ted4 ##
function ted4(p:string;var s,d,e:string;_power:integer;_encode:boolean):boolean;//21SEP2007
var
   a:ttbt;
begin
try
//defaults
result:=false;
e:=gecOutOfMemory;
a:=nil;
//process
//.get
a:=ttbt.create;
a.password:=p;
a.power:=_power;//variable length key for TBT4
//.set
case _encode of
true:result:=a.encode4(s,d,e);
false:result:=a.decode(s,d,e);
end;//end of case
except;end;
try;freeobj(@a);except;end;
end;

//## create ##
constructor ttbt.create;
var
   p:integer;
begin
//controls

//defaults
ipower:=1000;//8,000 bits(max), range 2..1000
ipassword:='';
ikey:='';
ikeyrandom:='';
ikeymodified:=true;
end;
//## destroy ##
destructor ttbt.destroy;
begin
try
//controls

//self
inherited;
except;end;
end;
//## setpassword ##
procedure ttbt.setpassword(x:string);
begin
try;if general.setstring(x,ipassword) then ikeymodified:=true;except;end;
end;
//## setpower ##
procedure ttbt.setpower(x:integer);
begin
try
//range
x:=frcrange(x,2,1000);
//set
if general.setint(x,ipower) then ikeymodified:=true;
except;end;
end;
//## keyinit ##
function ttbt.keyinit:boolean;
label
   skipend;
const
   klimit=1000;
var
   maxp,p:integer;
   k,x,j:string;
   v:byte;
begin
try
//defaults
result:=false;
//check
if not ikeymodified then
   begin
   result:=true;
   exit;
   end;//end of if
//process

//PASSWORD KEY
//.setup
j:='';
k:='';
//.password
x:=copy(ipassword,1,klimit);
if (length(x)<2) then x:=copy(x+'O3ksiaAlkasdr',1,klimit);
//.fill
repeat
//..get
if not frs(x,j,tbtFeedback) then goto skipend;
//..set
k:=k+x;
x:=k;
until (length(k)>=klimit);
//.trim to "klimit"
k:=copy(k,1,klimit);
//.finalise
if not frs(k,j,tbtFeedback) then goto skipend;
//.set
ikey:=k;

//RANDOM KEY
//.setup
x:='';
k:='';
j:='';
maxp:=frcrange(ipower,2,klimit);
//.random
for p:=1 to maxp do
begin
v:=random(256);
if (v=5) then v:=13+random(65)
else if (v=79) then v:=random(19)+100
else if (v=201) then v:=9+random(200);
x:=x+chr(v);
end;//end of loop
//.fill
repeat
//..get
if not frs(x,j,tbtFeedback) then goto skipend;
//..set
k:=k+x;
x:=k;
until (length(k)>=klimit);
//.trim to "klimit"
k:=copy(k,1,klimit);
//.finalise
if not frs(k,j,tbtFeedback) then goto skipend;
//.set
ikeyrandom:=k;
//successful
ikeymodified:=false;
result:=true;
skipend:
except;end;
end;
//## frs ##
function ttbt.frs(var s,d:string;m:byte):boolean;//feedback randomisation of string
label
   skipend;
var//Note: m=0(tbtFeedback, just feedback encode "s"),
   //      m=1(tbtEncode, feedback "s" and encode "d" with it),
   //      m=2(tbtDecode, as with m=1 but decode with it).
   //Accepts variable length s/d strings (but dLEN<=sLEN for m=1 or 2.
   dlen,maxp,o1,r1,r2,r3,x1,x2,x3,y1,y2,y3,p:integer;
begin
try
//defaults
result:=false;
//check
maxp:=length(s);
dlen:=length(d);
if (length(s)<2) then exit;
//setup
o1:=byte(s[1]);
//process
//.feedback randomisation on "s"
for p:=1 to maxp Do
begin
//..r1-r3
r1:=byte(s[p]);
if (p<maxp) then r2:=byte(s[p+1]) else r2:=o1;
if (p>1) then r3:=byte(s[p-1]) else r3:=0;
//..y1-y3
y1:=r1 div 16;
y2:=r2 div 16;
y3:=r3 div 16;
//..x1-x3
x1:=r1-y1*16;
x2:=r2-y2*15;//* - throws random rounding
x3:=r3-y3*16;
//..set
s[p]:=char(((x1+x3)+(y2*16)+3) mod 256);//s[p]
if (p<maxp) then s[p+1]:=char((x2+(x1*4+x3*2)) mod 256);//s[p+1]
end;//end of loop
//.m
if (m<>tbtFeedback) then
   begin
   //.range
   if (dlen>maxp) then goto skipend
   else maxp:=frcmax(maxp,dlen);
   //.set
   if (m=tbtEncode) then for p:=1 to maxp do d[p]:=char((byte(s[p])+byte(d[p])) mod 256)
   else if (m=tbtDecode) then for p:=1 to maxp do d[p]:=char((byte(d[p])-byte(s[p])) mod 256);
   end;//end of if
//successful
result:=true;
skipend:
except;end;
end;
//## keyid ##
function ttbt.keyid(var x:string;var id:integer):boolean;
var
   xlen,tmp,p:integer;
   v:byte;
begin
try
//defaults
result:=false;
id:=0;
tmp:=0;
//setup
xlen:=length(x);
tmp:=xlen;
//process
//.get
for p:=1 to xlen do
begin
v:=byte(x[p]);
inc(tmp,v);
//"even" values:
if (((p div 2)*2)=p) then
   begin
   if (v<100) then inc(tmp,3)
   else if (v>200) then inc(tmp,357);
   end
else
   begin
   if (v<51) then inc(tmp,71)
   else if (v=93) then inc(tmp,191)
   else if (v=101) then inc(tmp,191)
   else if (v=104) then inc(tmp,191)
   else if (v>130) then inc(tmp,191);
   end;//end of if
end;//end of loop
//successful
result:=true;
id:=tmp;
except;end;
end;
//## encode ##
function ttbt.encode(var s,d,e:string):boolean;
label
   skipend;
const
   klimit=1000;
var
   i4:tint4;
   t,cc,sLEN,dLEN,cs,rc,p:integer;
   tmp,h,j,k,kr:string;
begin
try
//defaults
result:=false;
d:='';
cs:=0;
dLEN:=0;
sLEN:=length(s);
j:='';
//init
e:=gecUnexpectedError;
if not keyinit then exit;
k:=ikey;
kr:=ikeyrandom;
//.offset checksum using keyID (password key)
if not keyid(k,cs) then exit;
rc:=2+random(21);//2..22 (old system was 0..15)
e:=gecOutOfMemory;
//process
//.create header key "encrypt random key (1..12)"
tmp:=kr;
for p:=1 to ((rc div 2)+1) do if not frs(k,tmp,tbtEncode) then goto skipend;
//.feedback randomise "kr"
for p:=1 to rc do if not frs(kr,j,tbtFeedback) then goto skipend;
//.header                    //pos=6,7,8,9=checksum
pushb(dLEN,d,'TBT3'+char(rc)+#0#0#0#0+from32bit(sLEN)+tmp);
tmp:='';
//.encrypt
t:=gettickcount;
cc:=0;
p:=1;
while true do
begin
//.get
tmp:=copy(s,p,klimit);
//.set
if (tmp='') then break
else
   begin
   //.cs
   inc(cs,byte(tmp[1]));
   //.encode
   if not frs(kr,tmp,tbtEncode) then goto skipend;
   //.store
   pushb(dLEN,d,tmp);
   //.breath
   inc(cc);
   if (cc>=50) then
      begin
      if ((gettickcount-t)>=200) then
         begin
         application.processmessages;
         t:=gettickcount;
         end;//end of if
      cc:=0;
      end;//end of if
   end;//end of if
//.inc
inc(p,klimit);
end;//end of loop
//.finalise
pushb(dLEN,d,'');
//.insert check sum value into header
i4.val:=cs;
d[6]:=i4.chars[0];
d[7]:=i4.chars[1];
d[8]:=i4.chars[2];
d[9]:=i4.chars[3];
//successful
result:=true;
skipend:
except;end;
end;
//## encode4 ##
function ttbt.encode4(var s,d,e:string):boolean;
label
   skipend;
var
   i4:tint4;
   pw2,t,cc,sLEN,dLEN,cs,rc,p:integer;
   tmp,h,j,k,kr:string;
   pw:twrd2;
begin
try
//defaults
result:=false;
d:='';
cs:=0;
dLEN:=0;
sLEN:=length(s);
j:='';
//init
e:=gecUnexpectedError;
if not keyinit then exit;
pw2:=ipower;
pw.val:=pw2;
k:=copy(ikey,1,pw2);
kr:=copy(ikeyrandom,1,pw2);
//.offset checksum using keyID (password key)
if not keyid(k,cs) then exit;
rc:=2+random(21);//2..22 (old system was 0..15)
e:=gecOutOfMemory;
//process
//.create header key "encrypt random key (1..12)"
tmp:=kr;
for p:=1 to ((rc div 2)+1) do if not frs(k,tmp,tbtEncode) then goto skipend;
//.feedback randomise "kr"
for p:=1 to rc do if not frs(kr,j,tbtFeedback) then goto skipend;
//.header                    //pos=6,7,8,9=checksum      //length of key (power)
pushb(dLEN,d,'TBT4'+char(rc)+#0#0#0#0+from32bit(sLEN)+pw.chars[0]+pw.chars[1]+tmp);
tmp:='';
//.encrypt
t:=gettickcount;
cc:=0;
p:=1;
while true do
begin
//.get
tmp:=copy(s,p,pw2);
//.set
if (tmp='') then break
else
   begin
   //.cs
   inc(cs,byte(tmp[1]));
   //.encode
   if not frs(kr,tmp,tbtEncode) then goto skipend;
   //.store
   pushb(dLEN,d,tmp);
   //.breath
   inc(cc);
   if (cc>=50) then
      begin
      if ((gettickcount-t)>=200) then
         begin
         application.processmessages;
         t:=gettickcount;
         end;//end of if
      cc:=0;
      end;//end of if
   end;//end of if
//.inc
inc(p,pw2);
end;//end of loop
//.finalise
pushb(dLEN,d,'');
//.insert check sum value into header
i4.val:=cs;
d[6]:=i4.chars[0];
d[7]:=i4.chars[1];
d[8]:=i4.chars[2];
d[9]:=i4.chars[3];
//successful
result:=true;
skipend:
except;end;
end;
//## decode ##
function ttbt.decode(var s,d,e:string):boolean;
label
   skipend;
const
   klimit=1000;
var
   i4:tint4;
   startpos,klen,tmpLEN,v,t,cc,sLEN,dLEN,cl,cs,rc,p:integer;
   tmp,h,j,k,kr:string;
   v3,v4:boolean;
   pw:twrd2;
begin
try
//defaults
result:=false;
v3:=false;
v4:=false;
d:='';
cs:=0;
dLEN:=0;
sLEN:=length(s);
j:='';
startpos:=1;
//init
e:=gecUnexpectedError;
if not keyinit then exit;
//process
//.header
e:=gecDataCorrupt;
if (comparetext(copy(s,1,4),'TBT4')=0) and (sLEN>=15) then v4:=true
else if (comparetext(copy(s,1,4),'TBT3')=0) and (sLEN>=1013) then v3:=true
else
   begin
   e:=gecUnknownFormat;
   goto skipend;
   end;//end of if
//.read
rc:=byte(s[5]);
cs:=to32bit(copy(s,6,4));
cl:=to32bit(copy(s,10,4));
if (cs<0) or (cl<0) then goto skipend;
//.version
if v3 then
   begin
   //get
   if ((cl+1013)>sLEN) then goto skipend;
   kr:=copy(s,14,klimit);
   klen:=length(kr);
   startpos:=1014;
   //check
   if (klen<>klimit) then goto skipend;
   end
else if v4 then
   begin
   //get
   pw.chars[0]:=s[14];
   pw.chars[1]:=s[15];
   if (pw.val<2) or (pw.val>1000) then goto skipend;//enforce range of 2..1000 (upto 8000bit)
   if ((cl+pw.val+15)>sLEN) then goto skipend;
   kr:=copy(s,16,pw.val);
   klen:=length(kr);
   startpos:=15+klen+1;
   //check
   if (klen<>pw.val) then goto skipend;
   end;//end of if
//.keyid
k:=copy(ikey,1,klen);
if not keyid(k,v) then exit;
//..cs
e:=gecAccessDenied;
dec(cs,v);
if (cs<0) then goto skipend;
//.recover header key "decrypt random key"
for p:=1 to ((rc div 2)+1) do if not frs(k,kr,tbtDecode) then goto skipend;
//.feedback randomise "kr"
for p:=1 to rc do if not frs(kr,j,tbtFeedback) then goto skipend;
//.decrypt
t:=gettickcount;
cc:=0;
p:=startpos;
while true do
begin
//.get
tmp:=copy(s,p,klen);
//.set
if (tmp='') then break
else
   begin
   //.decode
   if not frs(kr,tmp,tbtDecode) then goto skipend;
   //.store
   pushb(dLEN,d,tmp);
   //.cs
   dec(cs,byte(tmp[1]));
   if (cs<0) then
      begin
      e:=gecAccessDenied;
      goto skipend;
      end;//end of if
   //.stop
   if (dLEN>=cl) then break;
   //.breath
   inc(cc);
   if (cc>=50) then
      begin
      if ((gettickcount-t)>=200) then
         begin
         application.processmessages;
         t:=gettickcount;
         end;//end of if
      cc:=0;
      end;//end of if
   end;//end of if
//.inc
inc(p,klen);
end;//end of loop
//.finalise
pushb(dLEN,d,'');
//.check
if (cs<>0) then goto skipend;
//.size
if (length(d)>cl) then setlength(d,cl);
//successful
result:=(length(d)=cl);
skipend:
except;end;
end;


//## mimes ##
function mimes:tmimes;
begin
siAutoCreate(@fmimes,tmimes,@result);
end;
//## lm ##
function lm:tlookupmanagement;
begin
siAutoCreate(@flm,tlookupmanagement,@result);
end;
//## dm ##
function dm:tdomains;
begin
siAutoCreate(@fdm,tdomains,@result);
end;
//## whs ##
function whs:TWebHeaders;
begin
siAutoCreate(@fwebheaders,twebheaders,@result);
end;
//## webheaders ##
function webheaders:twebheaders;
begin
siAutoCreate(@fwebheaders,twebheaders,@result);
end;
//## netsession ##
function netsession:tnetsession;
begin
siAutoCreate(@fnetsession,tnetsession,@result);
end;
//## ns ##
function ns:tnetsession;
begin
siAutoCreate(@fnetsession,tnetsession,@result);
end;
//## nw ##
function nw:tnetwork;
begin
siAutoCreate(@fnw,tnetwork,@result);
end;
//## rawlog ##
function rawlog:trawlog;
begin
siAutoCreate(@frawlog,trawlog,@result);
end;
//## mt ##
function mt:tmt;
begin
siAutoCreate(@fmt,tmt,@result);
end;
//## mm ##
function mm:tmm;
begin
siAutoCreate(@fmm,tmm,@result);
end;
//## ass ##
function ass:tass;
begin
siAutoCreate(@fass,tass,@result);
end;
//## fs ##
function fs:tfilters;
begin
siAutoCreate(@ffs,tfilters,@result);
end;
//## ccs ##
function ccs:tccs;
begin
siAutoCreate(@fccs,tccs,@result);
end;
//## fonts ##
function fonts:tfonts;
begin
siAutoCreate(@ffonts,tfonts,@result);
end;
//## mc ##
function mc:tmanagedconnections;
begin
siAutoCreate(@fmc,tmanagedconnections,@result);
end;
//## mr ##
function mr:tmanagedrobot;
begin
siAutoCreate(@fmr,tmanagedrobot,@result);
end;
//## cr ##
function cr:tcacheredirect;
begin
siAutoCreate(@fcr,tcacheredirect,@result);
end;
//## mip ##
function mip:tmapperip;
begin
siAutoCreate(@fmip,tmapperip,@result);
end;
//## secip ##
function secip:tsecurityip;
begin
siAutoCreate(@fsecip,tsecurityip,@result);
end;
//## navdlg ##
function navdlg:tnavdlg;//nav dialog
begin
siAutoCreate(@fnavdlg,tnavdlg,@result);
end;
//## navimgs ##
function navimgs:tnavcacheimages;//tnavbase images cache
begin
siAutoCreate(@fnavimgs,tnavcacheimages,@result);
end;
//## navurls ##
function navurls:tnavcacheurls;//tnavbase urls cache
begin
siAutoCreate(@fnavurls,tnavcacheurls,@result);
end;


initialization
  //start
  siInit;
  //translated strings
  tsDate:=ntranslate('date');
  tsDefault:=ntranslate('default');
  tsType:=ntranslate('type');
  tsSent:=ntranslate('sent');
  tsRecv:=ntranslate('recv');
  tsIdle:=ntranslate('idle');
  tsResource:=ntranslate('resource');
  tsUrl:=ntranslate('url');
  tsState:=ntranslate('state');
  tsBanned:=ntranslate('banned');
  tsAllowed:=ntranslate('allowed');
  tsUrlPerMin:=ntranslate('url/min');
  tsUrlPerHour:=ntranslate('url/hr');
  tsUrlPerDay:=ntranslate('url/day');

  //system versions
  if programnetworkenabled then
     begin
     systemversions:=systemversions+
     ntranslate('Network Management') +#9+translate('Manages and coordinates network traffic')+rcode
                                      +#9+'v3.00.9880'+rcode;
     end;//end of if

finalization
  //system
  siCloseAll;

end.

