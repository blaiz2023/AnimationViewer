unit av2;
//## ==========================================================================================================================================================================================================================
//##
//## MIT License
//##
//## Copyright 2025 Blaiz Enterprises ( http://www.blaizenterprises.com )
//##
//## Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation
//## files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy,
//## modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
//## is furnished to do so, subject to the following conditions:
//##
//## The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//##
//## THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
//## OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
//## LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
//## CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//##
//## ==========================================================================================================================================================================================================================
//##
//## Please note: This is legacy code and is designed to compile in Borland Delphi 3
//##
//##############################################################################
//## Name......... CORE
//## Desciption... root support code for low->high application construction
//## Items........ 139
//## Version...... 3.00.15925 (+2081 self)
//## Date......... 09-MAR-2008
//## Lines........ 56,291
//## Translation.. Confirmed - showerror60/showinfo60/showinfo()/showbasic() as pre-translation usage (translate string before sending to procedure)
//## Linux........ winroot, wintemp and findfolder 17-JAN-2007 (not confirmed)
//##
//## =========================================================================================
//## | Name                   | Hierarchy         | Version   | Date        | Desciption
//## |-- GENERAL -------------|-------------------|-----------|-------------|--------------------------------------------------------
//## | trootobject            | tobject           | 1.00.032  | 01-JUL-2005 | Standardised System Object
//## | tdynamiclist           | tobject           | 1.00.092  | 27-JAN-2007f | Base class for dynamic arrays/lists of differing structures: byte, word, integer, currency, pointer. Can be useed with user-defined records/structures/objects
//## | tdynamicbyte           | tdynamiclist      | 1.00.010  | 21-JUN-2006 | Dynamic array of BYTE
//## | tdynamicchar           | tdynamiclist      | 1.00.010  | 17-JAN-2008 | Dynamic array of CHAR
//## | tdynamicboolean        | tdynamiclist      | 1.00.006  | 21-JUN-2006 | Dynamic array of BOOLEAN
//## | tdynamicword           | tdynamiclist      | 1.00.011  | 21-JUN-2006 | Dynamic array of WORD
//## | tdynamicsmallint       | tdynamiclist      | 1.00.005  | 11-JUN-2007 | Dynamic array of SMALLINT
//## | tdynamicinteger        | tdynamiclist      | 1.00.011  | 21-JUN-2006 | Dynamic array of INTEGER
//## | tdynamicrgb            | tdynamiclist      | 1.00.052  | 14-SEP-2007 | Dynamic array of TRGBCOLOR
//## | tdynamicpoint          | tdynamiclist      | 1.00.012  | 14-APR-2007 | Dynamic array of TPOINT
//## | tdynamicintegerlist    | tobject           | 1.00.073  | 17-APR-2005 | Dynamic array of tdynamicinteger (ie. dynamic 2D array)
//## | tdynamiccurrency       | tdynamiclist      | 1.00.014  | 21-JUN-2006 | Dynamic array of CURRENCY
//## | tdynamicdouble         | tdynamiclist      | 1.00.015  | 21-JUN-2006 | Dynamic array of DOUBLE
//## | tdynamicdatetime       | tdynamiclist      | 1.00.009  | 21-JUN-2006 | Dynamic array of TDATETIME
//## | tdynamicrect           | tdynamiclist      | 1.00.006  | 21-JUN-2006 | Dynamic array of TRECT
//## | tdynamicpointer        | tdynamiclist      | 1.00.010  | 21-JUN-2006 | Dynamic array of POINTER
//## | tdynamicnotifyevent    | tdynamiclist      | 1.00.012  | 21-JUN-2006 | Dynamic array of TNOTIFYEVENT events
//## | tdynamicmsgproc        | tdynamiclist      | 1.00.025  | 04-MAR-2005 | Dynamic array of TMSGPROC events
//## | tdynamicobject         | tdynamiclist      | 1.00.018  | 18-APR-2005 | Dynamic array of TOBJECT
//## | tdynamicstring         | tdynamiclist      | 1.00.039  | 16-OCT-2005 | Dynamic array of STRING
//## | tdynamicname           | tdynamicstring    | 1.00.025  | 05-APR-2005 | Dynamic array of STRING with quick lookup system
//## | tdynamicnamelist       | tdynamicname      | 1.00.040  | 30-AUG-2007 | Dynamically tracks a list of names
//## | tdynamicbit            | tobject           | 1.00.060  | 21-JUN-2006 | Dynamic array of BIT (8xBOOLEAN per BYTE)
//## | tdynamicmatrix         | tobject           | 1.00.047  | 03-SEP-2005 | Dynamic 2-dimensional array
//## | tdynamicbitmap         | tdynamicmatrix    | 1.00.104  | 26-JUL-2004 | Dynamic bitmap, independent of Operating System Image Pool
//## | tdynamicvars           | tobject           | 1.00.095  | 28-FEB-2008 | Dynamic set of named variables with rapid lookup system (e.g. fred=some value)
//## | tdynamictext           | tobject           | 1.00.037  | 22-SEP-2007 | Name-Value variables (single lines) for client-server communication
//## | tqueuestring           | tobject           | 1.00.056  | 22-JAN-2008 | Fast, first-in-first-out queue of strings with basic network info support (ip,port and tag)
//## | tcachebasic            | tobject           | 1.00.214  | 22-MAR-2007 | Base class for dynamic/disk cached arrays/lists of differing structures: byte, word, integer, currency, pointer. Can be useed with user-defined records/structures/objects
//## | tcacheexample          | tcachebasic       | 1.00.039  | 22-MAY-2006 | Example dynamic cache array of custom record
//## | tnotifylist            | tobject           | 1.00.035  | 01-JUL-2005 | List of "tnotifyevents" (call all by ".notify")
//## | tvirtualstorage        | trootobject       | 1.00.466  | 20-FEB-2008 | Dynamic list of variables for fast system storage/reference
//## | tvirtualimage          | tobject           | 1.00.135  | 16-SEP-2007 | Image matrix
//## | tvirtualbitmap         | tvirtualimage     | 1.00.090  | 28-JAN-2006 | Bitmap - GDI independent (non system based)
//## | tvirtualbitmapanimated | tobject           | 1.00.142  | 30-SEP-2007 | Animated bitmap - GDI independent (non system based)
//## | tvirtualiconanimated   | tobject           | 1.00.021  | 16-SEP-2007 | Animated icon - supports multiple animation formats
//## | Pixel Filters          | n/a               | 1.00.020  | 08-JUL-2005 | Pixel filters for "tvirtualimage"
//## | tsampleint             | tobject           | 1.00.014  | 13-MAY-2005 | Definable range of integer values for long term average
//## | trolltext              | tobject           | 1.00.035  | 12-MAR-2007 | List of rotating strings
//## | tscrolltext            | tobject           | 1.00.010  | 27-FEB-2005 | Fixed list of scrolling strings
//## | tnamevalue             | tobject           | 1.00.098  | 05-APR-2006 | Dynamic text/binary name/value pair storage/lookup system
//## | tmultilingual          | trootobject       | 1.00.030  | 23-JAN-2006 | Language translator (English -> selected language)
//## | tsuptrans              | trootobject       | 1.00.150  | 07-FEB-2008 | User language translator (English -> selected language)
//## | tsplash                | trootobject       | 1.00.300  | 11-SEP-2006 | Compact, Professional, Splash/About Screen
//## | tnv                    | tobject           | 1.00.070  | 17-OCT-2004 | Name-value pair reader/writer
//## | tdualmask              | tobject           | 1.00.006  | 28-DEC-2004 | Include and exclude mask filter
//## | tio                    | trootobject       | 1.00.535  | 05-OCT-2007 | Enhanced and rich IO system
//## | tmasks                 | tobject           | 1.00.059  | 24-MAY-2006 | Multiple Complex FileMask support
//## | talerts                | tobject           | 1.00.068  | 08-MAY-2007 | Multi-mode alerting control
//## | tdebug                 | trootobject       | 1.00.025  | 12-OCT-2007 | Debug aid
//## | tstripscroll           | tvirtualcontrol   | 1.00.225  | 04-MAR-2008 | Scrolling ad display system (graphical and/or text ads with url hyperlink, capacity of 100 ads, no screen width limit)
//## | tpg                    | trootobject       | 1.00.502  | 19-FEB-2008 | Program management (key information/settings)
//## | tdisplay               | trootobject       | 1.00.003  | 27-JUL-2005 | Control display modification handler
//## | twec                   | trootobject       | 1.00.083  | 22-FEB-2008 | Web error messages (with admincontact/info)
//## | tgeneral               | trootobject       | 1.00.1224 | 07-MAR-2008 | General Low Level Routines
//## | tdates                 | trootobject       | 1.00.110  | 01-FEB-2008 | Advanced date/time support
//## | Error Conts            | n/a               | 1.00.007  | 22-FEB-2002 | Standard Error Messages
//## | Image Printer          | n/a               | 1.00.011  |        2002 | Image Printer Launcher Routines
//## | ECap                   | n/a               | 1.00.021  | 12-NOV-2002 | Random String Encrypter - Valid Input/Output range 14-255 ASCII
//## |-- MAIN ----------------|-------------------|-----------|-------------|--------------------------------------------------------
//## | G.E.C.                 | n/a               | 1.00.029  | 14-SEP-2006 | General Error Codes
//## | W.E.C.                 | n/a               | 1.00.022  | 19-OCT-2006 | Web/HTTP Error Codes
//## | Main                   | n/a               | 1.00.124  | 29-AUG-2007 | Vital Support Unit for Small Applications
//## | tmsglist               | trootobject       | 1.00.029  | 17-MAR-2004 | Message Handler System
//## | tliteform              | tobject           | 1.00.167  | 15-JAN-2008 | Compact "TForm" Version
//## | tapp                   | trootobject       | 1.00.039  | 17-MAR-2004 | Compact "TApplication" Version
//## | system information     | n/a               | 1.00.079  | 06-MAY-2007 | System information management - system objects
//## |-- ADDITIONAL ----------|-------------------|-----------|-------------|---------------------------------------------------------
//## | tbinaryfile            | tobject           | 1.00.044  | 24-MAY-2006 | Simplified file data management
//## | tfilepush              | tobject           | 1.00.040  | 26-JAN-2006 | Binary appending file (push text)
//## | tstreamstr             | tstream           | 1.00.008  | 24-JUN-2006 | Stream wrapper for string (lightweight, no memory duplication, reads/writes direct to external string)
//## | tstreammem             | tstreamstr        | 1.00.020  | 30-SEP-2006 | Stream wrapper for tmemorystrteam
//## | tzof                   | tobject           | 1.00.175  | 31-DEC-2006 | Zip on the fly (GZ)
//## | tresdata               | tcomponent        | 1.00.004  | 30-SEP-2006 | Read/write object for "tsmic.to/fromres"
//## | thtml                  | trootobject       | 1.00.045  | 29-FEB-2008 | Common html elements for creating webpages for system services using system scheme colors and settings
//## | tmisc                  | trootobject       | 1.00.820  | 03-MAR-2008 | Misc. additional general support
//## | tscript                | trootobject       | 1.00.036  | 24-SEP-2005 | Scripting support
//## | thtmltemplate          | trootobject       | 1.00.250  | 21-OCT-2006 | Automated html generation
//## |                        |                   |           |             |
//## |-- USER MANAGEMENT MK-III ----------------------------------------------------------------------------------------------------
//## CORE:
//## | tfontmap               | tobject           | 1.00.014  | 18-OCT-2007 | Font mapper
//## | tdraws                 | trootobject       | 1.00.112  | 09-NOV-2007 | Drawing system
//## | tmenus                 | trootobject       | 1.00.052  | 08-FEB-2007 | Menu coordination and management system
//## | tvirtualcontrols       | tdynamiclist      | 1.00.005  | 02-JAN-2006 | Dynamic list of "tvirtualcontrol"
//## | tvirtualcontrollist    | tobject           | 1.00.080  | 13-NOV-2007 | Maintains a list of children controls for it's owner
//## | tvirtualcontrol        | tobject           | 1.00.471  | 07-MAR-2008 | Non-standard, independant graphical control - root class for all controls
//## FORM:
//## | tdlgform               | tcustomform       | 1.00.002  | 08-JAN-2006 | Auto closing form, when "ESC" key is pressed
//## | tvirtualform           | tcustomform       | 1.00.1008 | 12-FEB-2008 | Graphical user interface management and display system
//## | tvirtualdlg            | tvirtualform      | 1.00.080  | 13-OCT-2007 | Dialog ready form
//## | tvirtualhead          D| tvirtualcontrol   | 1.00.161  | 01-JAN-2008 | Form caption
//## MENU:
//## | tpop                   | tvirtualform      | 1.00.032  | 05-FEB-2006 | Popup form
//## | tpoplist               | tobject           | 1.00.032  | 25-SEP-2007 | Popup list
//## | tpopmenu               | tpop              | 1.00.104  | 05-FEB-2006 | Popup menu
//## | tvirtualmenuitem       | tvirtualcontrol   | 1.00.097  | 28-JUN-2006 | Menu item
//## MISC:
//## | tvirtualhelp           | tvirtualpage      | 1.00.036  | 10-NOV-2007 | Realtime help display bar
//## | tvirtualbutton         | tvirtualcontrol   | 1.00.240  | 22-SEP-2007 | Button
//## | tvirtualglyph          | tvirtualbutton    | 1.00.004  | 03-SEP-2007 | Glyph - Button style
//## | tvirtualsystembutton   | tvirtualbutton    | 1.00.014  | 07-OCT-2007 | System button - predefined system actions
//## | tvirtualsystemlink     | tvirtuallink      | 1.00.022  | 03-OCT-2007 | System standard action links
//## | tvirtualwebedit        | tvirtualpage      | 1.00.040  | 04-SEP-2006 | Realtime, encoded url+data web link generator
//## | tvirtualmousecursor    | tvirtualbutton    | 1.00.035  | 08-JAN-2006 | Cursor chooser
//## | tvirtualtick           | tvirtualbutton    | 1.00.014  | 06-JUN-2007 | Tick
//## | tvirtualpanel          | tvirtualcontrol   | 1.00.008  | 23-DEC-2005 | Panel
//## | tvirtualflash          | tvirtualpanel     | 1.00.015  | 07-JUL-2006 | Flash
//## | tvirtualprogress       | tvirtualpanel     | 1.00.018  | 24-JAN-2006 | Progress bar - 2 decimal points
//## | tvirtualchart          | tvirtualpanel     | 1.00.067  | 15-JUL-2006 | Scrolling graphical chart
//## | tvirtualsep            | tvirtualpanel     | 1.00.001  | 06-JAN-2006 | Sep
//## | tvirtualrows           | tvirtualcontrol   | 1.00.058  | 12-FEB-2008 | Flicker free list (no scrolling)
//## | tvirtualcolor          | tvirtualbutton    | 1.00.070  | 07-MAR-2008 | Color palette
//## | tvirtualgrid          D| tvirtualpage      | 1.00.071  | 19-DEC-2006 | Grid (with automatic wrap around caption)
//## | tvirtualschemes        | tvirtualpanel     | 1.00.068  | 12-JAN-2008 | Schemes manager
//## | tvirtualanimations     | tvirtualpage      | 1.00.054  | 03-JUL-2006 | Multiple format, graphic/animation viewer/converter
//## | tvirtualfilelist       | tvirtualpage      | 1.00.070  | 18-JUN-2007 | Multiple format, graphic/animation viewer/converter
//## | tvirtualanimationviewer| tvirtualpage      | 1.00.135  | 08-NOV-2007 | Animation Viewer
//## | tvirtualviewertext     | tvirtualpagevsplit| 1.00.052  | 07-OCT-2007 | Multiple topic viewer (plain text)
//## | tvirtualviewerhelp     | tvirtualviewertext| 1.00.018  | 07-OCT-2007 | Program help viewer (plain text)
//## | tvirtualsysinfo        | tvirtualpage      | 1.00.225  | 09-MAR-2008 | System information panel
//## | tvirtualalertaudio     | tmanaged          | 1.00.240  | 22-FEB-2008 | Audio alert manager
//## | tvirtualcontacts       | tvirtualpage      | 1.00.032  | 02-AUG-2006 | IP/Domain contacts manager
//## | tvirtualpath           | tvirtualbutton    | 1.00.030  | 21-OCT-2007 | Path
//## | tvirtualfile           | tvirtualbutton    | 1.00.012  | 21-OCT-2007 | Filename
//## | tvirtualtile           | tvirtualpage      | 1.00.053  | 03-JUN-2007 | Tile load/save and draw control
//## | tvirtualpanelserver    | tvirtualoage      | 1.00.050  | 19-FEB-2008 | Server status panel
//## | tmanaged               | tvirtualpage      | 1.00.020  | 01-SEP-2006 | Multi-element control (managed)
//## LABEL/LINK:
//## | tvirtuallabel          | tvirtualbutton    | 1.00.002  | 24-DEC-2005 | Label
//## | tvirtuallabelb         | tvirtuallabel     | 1.00.005  | 31-DEC-2006 | Label (with tabs)
//## | tvirtuallink           | tvirtualbutton    | 1.00.012  | 19-DEC-2006 | Link
//## TITLE:
//## | tvirtualtitle          | tvirtualpage     D| 1.00.014  | 22-SEP-2007 | Title
//## | tvirtualtitleb         | tvirtualtitle    D| 1.00.009  | 22-SEP-2007 | Title (with tabs)
//## SCROLL:
//## | tvirtualscrollbar      | tvirtualcontrol   | 1.00.303  | 05-APR-2007 | Scrollbar
//## | tvirtualpage          D| tvirtualpanel     | 1.00.038  | 08-SEP-2007 | Box - contains and destroy's children controls
//## | tvirtualpagescroll    D| tvirtualpage      | 1.00.220  | 12-JUN-2007 | Scrollbox (vertical)
//## | tvirtualpages          | tvirtualcontrol   | 1.00.155  | 28-FEB-2008 | Pages
//## | tvirtualpagevsplit    D| tvirtualpage      | 1.00.055  | 30-OCT-2006 | Dual vertical pages split by percentage
//## LIST:
//## | tvirtualbaselist       | tvirtualcontrol   | 1.00.514  | 12-FEB-2008 | List (shell of listbox)
//## | tvirtuallist           | tvirtualbaselist  | 1.00.065  | 24-JAN-2006 | Listbox (items of text)
//## | tvirtualdroplist       | tvirtualcontrol   | 1.00.082  | 09-NOV-2007 | Drop down list
//## | tvirtualdropliststatic | tvirtualcontrol   | 1.00.086  | 19-DEC-2007 | Drop down static list (content can't be modified by user)
//## TEXT:
//## | tvirtualbasetext       | tvirtualcontrol   | 1.00.105  | 12-FEB-2008 | Text controls base class
//## | tvirtualpassword       | tvirtualbasetext  | 1.00.012  | 06-JAN-2006 | Password entry (simple)
//## | tvirtualedit           | tvirtualbasetext  | 1.00.010  | 06-JAN-2006 | Single line text entry (simple)
//## | tvirtualtext           | tvirtualbasetext  | 1.00.145  | 14-DEC-2006 | Multiline text viewer
//## | tvirtualtextwrap       | tvirtualbasetext  | 1.00.096  | 14-DEC-2006 | Multiline word wrapped text viewer
//## ===========================================================================================
//## Information:
//## D = destroy's children controls
//## Notes:
//## 19DEC2007 - "floattostr" replaced with "floattostrex" and "floattostrex2" which
//##             do not use scientific notation at any time
//##
//## Verification: 3.00.13203, 25-SEP-2007
//## Language Enabled {tmultilingual "format v2"}
//##############################################################################

interface
{$align on}{$iochecks on}{$O+}{$W-}{$U+}{$V+}{$B-}{$X+}{$T-}{$P+}{$H+}{$J-} { set critical compiler conditionals for proper compilation - 10aug2025 }

Uses
  Windows, Forms, Controls, SysUtils, Classes, ShellApi, ShlObj, Graphics,
  Clipbrd, messages, math, jpeg, stdctrls{tmemo}, extctrls{tpanel},
  {startup link "tmisc.csl"}
  ActiveX, ComObj, av5;


//## Version information #######################################################
var
   systemversions:string='';


//## Virtual Storage - System Pointers #########################################
//Keys:
// # = internet specific values
const
   //NIL
   vsNil                           =-1;
   vsProgramBASE                   =500;
   vsProgramMAX                    =2048;//new limit as of 01-SEP-2006
   vsMax                           =vsProgramBASE+vsProgramMAX;//restrict max number of items

   //INTEGER
   //.standard=FALSE (0..29)
   vsBackground                    =0;//background color*
   vsBorder                        =1;//border color*
   vsHighlight                     =2;//highlight color*
   vsFont                          =3;//font color*
   vsFonthighlight                 =4;//font highlight color*
   //not used, was vsFontheight, which has now been replaced with vsFontsize 12OCT2007
   vsScrollSizeMain                =6;//scrollbar size - main
   vsBorderSize                    =7;//true/false only
   //yyy #8 was vsAudio, but now removed
   vsPort                          =9;//#
   vsRate                          =10;//# - network send rate
   vsHover                         =11;//hover color*
   vsDisable                       =12;//background disable color*
   vsDisableborder                 =13;//border disable color*
   vsDisablefont                   =14;
   vsScrollSize                    =15;//scrollbar size
   vsFontSize                      =16;//12OCT2007

   vsVersion                       =89;//0..2=unknown assumes v2, 3=v3 (current)

   //BOOLEAN (90..129)
   vsBooleanBASE                   =90;
   vsRound                         =vsBooleanBASE+0;
   vsBold                          =vsBooleanBASE+1;
   vsItalic                        =vsBooleanBASE+2;
   vsUnderline                     =vsBooleanBASE+3;
   vsStrikeout                     =vsBooleanBASE+4;
   vsAutoStartup                   =vsBooleanBASE+5;
   vsSystemTray                    =vsBooleanBASE+6;
   vsOnTop                         =vsBooleanBASE+7;
   vsStartMinimised                =vsBooleanBASE+8;
   vsShowSplash                    =vsBooleanBASE+9;
   vsAutoScroll                    =vsBooleanBASE+10;
   vsDblClickRun                   =vsBooleanBASE+11;
   vs24hr                          =vsBooleanBASE+12;
   vsUsePath                       =vsBooleanBASE+13;
   vsUseCustomUA                   =vsBooleanBASE+14;//-- no longer used --
   vsUseProxy                      =vsBooleanBASE+15;
   vsAlertFlash                    =vsBooleanBASE+16;
   vsAlertShow                     =vsBooleanBASE+17;
   vsAlertVibrate                  =vsBooleanBASE+18;
   vsEnhanced                      =vsBooleanBASE+19;//was "vsAlertAudio" but retired
   vsLogs                          =vsBooleanBASE+20;//#
   vsRequireAuthorisation          =vsBooleanBASE+21;//#
   vsShowClone                     =vsBooleanBASE+22;
   vsShowSoft                      =vsBooleanBASE+23;
   vsCompact                       =vsBooleanBASE+24;//new
   vsBufferedPaint                 =vsBooleanBASE+25;//new - 18-JAN-2007
   vsAnimateIcon                   =vsBooleanBASE+26;//15SEP2007
   vsSafeArea                      =vsBooleanBASE+27;//03OCT2007
   vsSizeFast                      =vsBooleanBASE+28;//03OCT2007
   vsSizeBalanced                  =vsBooleanBASE+29;//03OCT2007
   vsHelp                          =vsBooleanBASE+30;//06OCT2007
   vsUseNM                         =vsBooleanBASE+31;//Network Monitor - 20FEB2008

   //STRING (130..199)
   vsStringBASE                    =130;
   vsFontName                      =vsStringBASE+0;
   vsPath                          =vsStringBASE+1;
   vsCustomUA                      =vsStringBASE+2;
   vsProxy                         =vsStringBASE+3;
   vsUsername                      =vsStringBASE+4;//#
   vsPassword                      =vsStringBASE+5;//##
   vsMimes                         =vsStringBASE+6;//#
   vsBanIP                         =vsStringBASE+7;//#
   vsSuptrans                      =vsStringBASE+8;//13OCT2007 - custom translation
   vsNMIP                          =vsStringBASE+9;//Network Monitor - 20FEB2008
   
   //TITLE special layer (200..399)
   vsTitleBASE                     =200;
   vsTitleBackground               =vsTitleBASE+0;//background color*
   vsTitleBorder                   =vsTitleBASE+1;//border color*
   vsTitleHighlight                =vsTitleBASE+2;//highlight color*
   vsTitleFont                     =vsTitleBASE+3;//font color*
   vsTitleFonthighlight            =vsTitleBASE+4;//font highlight color*
   vsTitleFontheight               =vsTitleBASE+5;//not yet used
   vsTitleHover                    =vsTitleBASE+11;//hover color*
   vsTitleDisable                  =vsTitleBASE+12;//background disable color*
   vsTitleDisableborder            =vsTitleBASE+13;//border disable color*
   vsTitleDisableFont              =vsTitleBASE+14;//font disalbe color*

   vsTitleBold                     =vsTitleBASE+vsBooleanBASE+1;
   vsTitleItalic                   =vsTitleBASE+vsBooleanBASE+2;
   vsTitleUnderline                =vsTitleBASE+vsBooleanBASE+3;
   vsTitleStrikeout                =vsTitleBASE+vsBooleanBASE+4;
   vsTitleFontName                 =vsTitleBASE+vsStringBASE+0;

   //CURSORS "string" - (400..x)
   vsCursorBASE                    =400;
   vsCursorArrow                   =vsCursorBASE+0;
   vsCursorHand                    =vsCursorBASE+1;
   vsCursorText                    =vsCursorBASE+2;
   vsCursorBusy                    =vsCursorBASE+3;
   vsCursorSize                    =vsCursorBASE+4;

   //SUPPORT VALUES - NOT POINTERS
   vsvVersion                     =3;//version 3.0
   vsvRate=';256;512;1,024;2,048;4,096;8,192;16,384;32,000;32,768;64,000;65,536;102,400;128,000;196,608;256,000;512,000;1,024,000;2,048,000;5,120,000;10,240,000';//1Kbyte - 10Mbyte/sec
   vsvRateDefault=1024000;

//## Virtual Folders - Blaiz Enterprises #######################################
   //.main
   bvfBlaizEnterprises       ='Blaiz Enterprises\';
   bvfAccessories            ='Accessories\';
   bvfCommunications         ='Communications\';
   bvfFastCards              ='FastCards\';
   bvfFiles                  ='Files\';
   bvfImageTools             ='Image Tools\';
   bvfSecurity               ='Security\';
   bvfSystem                 ='System\';
   bvfTools                  ='Tools\';
   bvfCritical               =bvfSystem+'Critical\';
   //.categories
   bvfClipboard              ='Clipboard\';//08NOV2007 - backward compatible
   bvfLogs                   =bvfFiles+'Logs\';//26-MAY-2006
   bvfHelp                   =bvfSystem+'Help\';
   bvfActive                 =bvfCritical+'Active\';//not for user
   bvfSettings               =bvfCritical+'Settings\';//not for user
   bvfLicenses               =bvfCritical+'Licenses\';//not for user
   bvfSnippet                =bvfCritical+'Snippet\';//not for user
   bvfTemp                   =bvfCritical+'Temp\';//not for user
   bvfCommOLD                =bvfCritical+'Comm\';//not for user
   bvfSchemesOLD             =bvfSystem+'Schemes\';//old v2 (EATS)
   bvfLanguage               =bvfCritical+'Language';
   //.files
   bvfAnimations             =bvfFiles+'Animations\';
   bvfCursors                =bvfFiles+'Cursors\';
   bvfDocuments              =bvfFiles+'Documents\';
   bvfFrames                 =bvfFiles+'Frames\';
   bvfMusic                  =bvfFiles+'Music\';
   bvfPictures               =bvfFiles+'Pictures\';
   bvfShades                 =bvfFiles+'Shades\';
   bvfSchemes                =bvfFiles+'Schemes\';//new schemes v3 (DSD)
   bvfTextBrushs             =bvfFiles+'TextBrushs\';
   bvfMiscellaneous          =bvfFiles+'Miscellaneous\';//ArtCards, PhotoCards and EBooks
   bvfUnknown                =bvfFiles+'Unknown';//unknown file types etc, they are stored here
   bvfContacts               =bvfFiles+'Contacts\';
   bvfWork                   =bvfFiles+'Work\';//12SEP2007 - for Batch Image Converter

//VIRTUAL CONTROLS
   //.tabs - safe standard tab sets
   tabsLL   ='TABS:S5,L0,L200';
   tabsLLL  ='TABS:S5,L0,L200,L400';
   tabsLRL  ='TABS:S5,L0,R200,L400';
   tabsLRR  ='TABS:S5,L0,R200,R400';
   tabsNLL  ='TABS:S5,L0,L30,L220';//#,L,L

   //.corner ratio's
   viCornerA=10;//10
   viCornerB=13;//13

   //.scrollbar.size
   sbrSize=16;
   //.key - special
   mLeft=0;
   mCenter=1;
   mRight=2;
   //.action
   aNone=0;
   aDown=1;
   aMove=2;
   aUp=3;
   //.offsets
   osGreen=256;
   osBlue=256*256;

   //value filters (for tvirtualdroplist etc)
   vfNone           =0;
   vfEncodedUrl     =1;

   //program control related
   pcSymClone       ='_';
   pcSymPortable    ='~';
   pcSymSafe        ='-';//used to replace unsafe filename characters

   //general values
   dwtbX=2;//start point of tabs is X=2

   //click key codes
   clkyNone         =0;//none
   clkySpace        =32;//space bar
   clkyReturn       =13;//enter/return key
   clkyDefault      =clkyReturn;
   //system menu codes
   smcNil           =0;
   smcCut           =1;
   smcCopy          =2;
   smcPaste         =3;
   smcDelete        =4;
   smcUpper         =5;
   smcLower         =6;
   smcEdit          =7;
   smcSelectAll     =8;
   smcCopyAll       =9;
   smcSettings      =10;//29-MAR-2007
   smcMinimize      =11;
   //.help/information
   smcHelp                =100;
   smcPlainTextHelp       =101;
   smcAbout               =102;
   smcUnlock              =103;
   smcExtractSupportFiles =104;
   smcCategory            =105;
   smcProgramSite         =106;
   smcRawGruntSite        =107;
   smcFreeSite            =108;
   smcBlaizSite           =109;
   smcBlaizFiles          =110;
   smcSystemFolder        =111;//Blaiz Enterprises
   smcCenterWindow        =112;
   smcRawGruntAddUrl      =113;
   smcBlaizContact        =114;
   smcNewInstance         =115;
   smcClose               =116;
   smcClone               =117;
   smcBlaizTemp           =118;
   //sizes
   smcMINSIZE             =250;
   smcMAXSIZE             =280;
   smcEnlarge             =250;
   smcShrink              =251;
//CORE
   //masks
   cmAllFiles             ='*';

type
  PChooseColor = ^TChooseColor;
  TChooseColor = packed record
    lStructSize: DWORD;
    hWndOwner: HWND;
    hInstance: HWND;
    rgbResult: COLORREF;
    lpCustColors: ^COLORREF;
    Flags: DWORD;
    lCustData: LPARAM;
    lpfnHook: function(Wnd: HWND; Message: UINT; wParam: WPARAM; lParam: LPARAM): UINT stdcall;
    lpTemplateName: PAnsiChar;
  end;

  POpenFilenameA = ^TOpenFilenameA;
  POpenFilename = POpenFilenameA;
  tagOFNA = packed record
    lStructSize: DWORD;
    hWndOwner: HWND;
    hInstance: HINST;
    lpstrFilter: PAnsiChar;
    lpstrCustomFilter: PAnsiChar;
    nMaxCustFilter: DWORD;
    nFilterIndex: DWORD;
    lpstrFile: PAnsiChar;
    nMaxFile: DWORD;
    lpstrFileTitle: PAnsiChar;
    nMaxFileTitle: DWORD;
    lpstrInitialDir: PAnsiChar;
    lpstrTitle: PAnsiChar;
    Flags: DWORD;
    nFileOffset: Word;
    nFileExtension: Word;
    lpstrDefExt: PAnsiChar;
    lCustData: LPARAM;
    lpfnHook: function(Wnd: HWND; Msg: UINT; wParam: WPARAM; lParam: LPARAM): UINT stdcall;
    lpTemplateName: PAnsiChar;
  end;

  TOpenFilenameA = tagOFNA;
  TOpenFilename = TOpenFilenameA;

  function messagebox(hWnd :Integer;lpText:String;lpCaption:String;wType:Integer):Integer;stdcall;external 'USER32.DLL' name 'MessageBoxA';
  procedure GetSystemTime(lpSystemTime:psystemtime);stdcall;external 'KERNEL32.DLL' name 'GetSystemTime';
  function choosecolor(var CC: TChooseColor): Bool; stdcall; external 'comdlg32.dll'  name 'ChooseColorA';
  function GetOpenFileName(var OpenFile: TOpenFilename): Bool; stdcall; external 'comdlg32.dll'  name 'GetOpenFileNameA';
  function GetSaveFileName(var OpenFile: TOpenFilename): Bool; stdcall; external 'comdlg32.dll'  name 'GetSaveFileNameA';

const
     {MAXPOINTER/MAXPIXEL}
     maxpointer=(maxint div 4)-1;
     maxpixel=maxpointer;
     maxrow=(high(word)*2-1);//safe range (0..131,071) - any higher and we run out of memory
     minint=low(integer);
     mincur=-922337203685477.5807;//note: 0.5808 exceeds range
     maxcur=922337203685477.5807;
     UDPpacketlimit=65507;//wikipedia.org 21DEC2007
     UDPdatalimit=UDPpacketlimit-8;//8 bytes for UDP header - size is header inclusive
     //Standard Safe Return Code
     RCode=#13+#10;
     //G.E.C. General Error Codes v1.00.028, 22-JUN-2005
     gecFileInUse              ='File in use';//translate('File in use')
     gecNotFound               ='Not found';//translate('Not found')
     gecBadFileName            ='Bad file name';//translate('Bad file name')
     gecFileNotFound           ='File not found';//translate('File not found')
     gecUnknownFormat          ='Unknown format';//translate('Unknown format')
     gecTaskCancelled          ='Task cancelled';//translate('Task cancelled')
     gecPathNotFound           ='Path not found';//translate('Path not found')
     gecOutOfMemory            ='Out of memory';//translate('Out of memory')
     gecIndexOutOfRange        ='Index out of range';//translate('Index out of range')
     gecUnexpectedError        ='Unexpected error';//translate('Unexpected error')
     gecDataCorrupt            ='Data corrupt';//translate('Data corrupt')
     gecUnsupportedFormat      ='Unsupported format';//translate('Unsupported format')
     gecAccessDenied           ='Access Denied';{04/11/2002}//translate('Access Denied')
     gecOutOfDiskSpace         ='Out of disk space';//translate('Out of disk space')
     gecAProgramExistsWithThatName='A program exists with that name';//translate('A program exists with that name')
     gecUseAnother             ='Use another';//translate('Use another')
     gecSendToFailed           ='Send to failed';//translate('Send to failed')
     gecCapacityReached        ='Capacity reached';//translate('Capacity reached')
     gecNoFilesFound           ='No files found';//translate('No files found')
     gecUnsupportedEncoding    ='Unsupported encoding';//translate('Unsupported encoding')
     gecUnsupportedDecoding    ='Unsupported decoding';//translate('Unsupported decoding')
     gecEmpty                  ='Empty';//translate('Empty')
     gecLocked                 ='Locked';//translate('Locked')
     gecTaskFailed             ='Task failed';//translate('Task failed')
     gecTaskSuccessful         ='Task successful';//translate('Task successful')
     //New 16/08/2002
     gecTaskTimedOut           ='Task Timed Out';//translate('Task Timed Out')
     gecIncorrectUnlockInformation='Incorrect Unlock Information';//Translate('Incorrect Unlock Information');
     gecOk                     ='OK';//translate('OK');
     gecReadOnly               ='Read Only';//translate('Read Only');
     gecRepeat                 ='Repeat';//translte('Repeat');
     gecBusy                   ='Busy';//translate('Busy');
     gecReady                  ='Ready';//translate('Ready');
     gecWorking                ='Working';//translate('Working');
     gecSearching              ='Searching';//translate('Searching');
     gecNoFurtherMatchesFound  ='No further matches found';//translate('No further matches found');
     gecAccessGranted          ='Access Granted';//Translate('Access Granted') - [bait]
     gecFailed                 ='Failed';//Translate('Failed') - [bait]
     gecDeleted                ='Deleted';//Translate('Deleted') - [bait]
     gecSkipped                ='Skipped';//Translate('Skipped') - [bait]
     gecEXTnotAllowed          ='Extension not allowed';//Translate('Extension not allowed') - [bait]
     gecSaved                  ='Saved';//Translate('Saved')
     gecNoContentPresent       ='No content present';//Translate('No content present') - [bait]
     gecSyntaxError            ='Invalid syntax';//translate('Invalid syntax') - [bait]
     gecUnterminatedLine       ='Unterminated line';//translate('Unterminated line') - [bait]
     gecUnterminatedString     ='Unterminated string';//translate('Unterminated string') - [bait]
     gecUndefinedObject        ='Undefined Object';//translate('Undefined Object') - [bait]
     gecPrivilegesModified     ='Privileges Modified';//Translate('Privileges Modified') - [bait]
     gecConnectionFailed       ='Connection Failed';//translate('Connection Failed');
     gecTimedOut               ='Timed Out';//translate('Timed Out');
     //W.E.C. HTTP Error Codes v1.00.003, 08-JUL-2005
     //.internal                     
     wecRedirectLimit                =920;
     wecDownloadExceedsLimit         =919;
     wecUnstable                     =918;
     wecTransferBroken               =917;
     wecCapacityReached              =916;
     wecSkipped                      =915;
     wecFileExists                   =914;
     wecHeaderExceedsLimit           =913;
     wecInvalidUrl                   =912;
     wecBotBanned                    =911;
     wecTaskFailed                   =910;
     wecIPBanned                     =909;
     wecOutOfMemory                  =908;
     wecOutOfDiskSpace               =907;
     wecFileInUse                    =906;
     wecBadFileName                  =905;
     wecCancelled                    =904;
     wecTimedOut                     =903;
     wecConnectionFailed             =902;
     wecAddressNotFound              =901;
     wecNoData                       =900;
     //.external
     wecOK                           =200;
     wecPartial                      =206;
     wecMoved                        =300;
     wecMovedPermanently             =301;
     wecMovedTemporarily             =302;
     wecMovedTemporarily2            =303;//"see other, http/1.1 code can be treated as a 302"
     wecNotModified                  =304;
     wecUseProxy                     =305;
     wecTemporaryRedirect            =307;
     wecBadRequest                   =400;
     wecAuthorizationRequired        =401;
     wecForbidden                    =403;
     wecNotFound                     =404;
     wecMethodNotAllowed             =405;
     wecRequestedRangeNotSatisfiable =416;
     wecInternalServerError          =500;
     wecBadGateway                   =502;
     wecServiceUnavailable           =503;
     wecGatewayTimeout               =504;
     wecUndefinedError               =maxint;
     wecNotUsed                      =minint;//no error, no message => not used
     //.labels - internal
     weclRedirectLimit               ='Redirect Limit';//translate('Redirect Limit')
     weclDownloadExceedsLimit        ='Download Exceeds Limit';//translate('Download Exceeds Limit')
     weclUnstable                    ='Unstable';//translate('Unstable')
     weclTransferBroken              ='Transfer Broken';//translate('Transfer Broken');
     weclCapacityReached             =gecCapacityReached;
     weclSkipped                     ='Skipped';//translate('Skipped');
     weclFileExists                  ='File Exists';//translate('File Exists');
     weclHeaderExceedsLimit          ='Header Exceeds Limit';//translate('Header Exceeds Limit');
     weclInvalidUrl                  ='Invalid Url';//translate('Invalid Url')
     weclBotBanned                   ='Bot Banned';//translate('Bot Banned')
     weclTaskFailed                  ='Task Failed';//translate('Task Failed')
     weclIPBanned                    ='IP Banned';//translate('IP Banned')
     weclOutOfMemory                 =gecOutOfMemory;
     weclOutOfDiskSpace              =gecOutOfDiskSpace;
     weclFileInUse                   =gecFileInUse;
     weclBadFileName                 =gecBadFileName;
     weclCancelled                   ='Cancelled';//translate('Cancelled');
     weclTimedOut                    =gecTimedOut;
     weclConnectionFailed            =gecConnectionFailed;
     weclAddressNotFound             ='Address Not Found';//translate('Address Not Found')
     weclNoData                      ='No Data';//translate('No Data');//custom
     //.labels - external
     weclOK                          =gecOk;
     weclPartial                     ='Partial Download';//translate('Partial Download');
     weclMoved                       ='Moved';//translate('Moved');
     weclMovedPermanently            ='Moved Permanently';//translate('Moved Permanently');
     weclMovedTemporarily            ='Moved Temporarily';//translate('Moved Temporarily');
     weclMovedTemporarily2           ='Moved Temporarily';//translate('Moved Temporarily');
     weclUseProxy                    ='Use Proxy';//translate('Use Proxy');
     weclTemporaryRedirect           ='Temporary Redirect';//translate('Temporary Redirect');
     weclNotModified                 ='Not Modified';//translate('Not Modified');
     weclBadRequest                  ='Bad Request';//translate('Bad Request');
     weclAuthorizationRequired       ='Authorization Required';//translate('Authorization Required');
     weclForbidden                   ='Forbidden';//translate('Forbidden');
     weclNotFound                    ='Not Found';//translate('Not Found');
     weclMethodNotAllowed            ='Method Not Allowed';//translate('Method Not Allowed');
     weclRequestedRangeNotSatisfiable='Requested Range Not Satisfiable';//translate('Requested Range Not Satisfiable');
     weclInternalServerError         ='Internal Server Error';//translate('Internal Server Error');
     weclBadGateway                  ='Bad Gateway';//translate('Bad Gateway');
     weclServiceUnavailable          ='Service Unavailable';//translate('Service Unavailable');
     weclGatewayTimeout              ='Gateway Timeout';//translate('Gateway Timeout');
     weclUndefinedError              =gecUnexpectedError;
     weclNotUsed                     ='-';//not used
{zip}
    zlib_Version = '1.0.4';
{tio}
    tio1MB=1024000;
    tio1GB=1024000000;
    tio2Gb=2048000000;
    //known headers
    tiohUnknown=0;
    tiohC=1;
    tiohBMP=2;
    tiohEAT=3;
    tiohLST=4;
    tiohMTXT=5;
    tioTXT=6;
    tioEML=7;
    //compression.header
    tiocmCompressed='C!1';//compressed
    tiocmRaw='C!0';//raw
    //formatsize.styles
    tiofsAuto=-1;
    tiofsBytes=0;
    tiofsKB=1;
    tiofsMB=2;
    tiofsGB=3;
    //base64 - references
    base64:array[0..64] of char=('A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z','a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z','0','1','2','3','4','5','6','7','8','9','+','/','=');
    base64r:array[0..255] of char='qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqnqqqodefghijklmqqqpqqq0123456789:;<=>?@ABCDEFGHIqqqqqqJKLMNOPQRSTUVWXYZ[\]^_`abcqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq'+'qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq';

{TCompactSplash}
     //Label Codes
     cpscName=0;
     cpscVer=1;
     cpscLic=2;
     cpscDes=3;
     cpscCopy=4;
     cpscWeb=5;
     //Show Modes
     cpscSplash=0;
     cpscAbout=1;
     cpscShowMax=1;
     //text style
     cptsPlain=0;
     cptsBlackWhite=1;
     cptsBlackWhiteSmall=2;
{TMasks}
     mktcMax=499;//upto 500 different file masks
     mktcSep=';';
{TGeneral}
     //modes
     glseEncrypt=0;
     glseDecrypt=1;
     glseTextEncrypt=2;
     glseTextDecrypt=3;
     //other
     glseEDK='2-13-09afdklJ*[q-02490-9123poasdr90q34[9q2u3-[9234[9u0w3689yq28901iojIOJHPIae;riqu58pq5uq9531asdo';

{tsuptrans}
     stNa      =0;//unknown entries, that may or may not be part of current program's translation system
     stError   =1;//error message translation
     stMain    =2;//main program translation
     stHelp    =3;//realtime help translation

{tmisc}
     //return types for "tmisc.gat"
     gatNil=0;
     gatLocalFile=1;
     gatNetworkFile=2;
     gatIPAddress=3;
     gatWebAddress=4;
     //months
     _months:array[1..12] of string=('January','February','March','April','May','June','July','August','September','October','November','December');
     _months_abrv:array[1..12] of string=('Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec');
     //days
     _days:array[1..7] of string=('Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday');
     _days_abrv:array[1..7] of string=('Sun','Mon','Tue','Wed','Thu','Fri','Sat');
     //country codes - do not modify the order or value of this list, as RAWGRUNT uses it within it's database.
     countrycodes:array[0..46] of string=('','ae','af','ar','at','au','be','bg','bh','br','ca','ch','cl','cn','co','cy','cz','de','dk','ee','es','fi','fr','gr','hk','hu','id','ie','il','in','it','jp','mx','nl','no','nz','ph','pk','pl','ro','ru','se','th','tr','tw','uk','za');
     countrynames:array[0..46] of string=('World','United Arab Emirates','Afghanistan','Argentina','Austria','Australia','Belgium','Bulgaria','Bahrain','Brazil','Canada','Switzerland','Chile','China','Colombia','Cyprus','Czech','Germany','Denmark','Estonia','Spain','Finland','France','Greece','Hong Kong','Hungary','Indonesia','Ireland','Israel','India','Italy','Japan','Mexico','Netherlands','Norway','New Zealand','Philippines','Pakistan','Poland','Romania','Russia','Sweden','Thailand','Turkey','Taiwan','United Kingdom','South Africa');

     //dns
     //.qtype
     qtypeA             =1;
     qtypeNS            =2;
     qtypeCNAME         =5;
     qtypeSOA           =6;
     qtypePTR           =12;
     qtypeHINFO         =13;
     qtypeMINFO         =14;
     qtypeMX            =15;
     qtypeTXT           =16;
     qtypeAXFR          =252;//request to transfer entire ZONE
     qtypeALL           =255;//request for all records
     //.qclass
     qclassIN           =1;//internet
     qclassANY          =255;//any class
     //.rcode
     rcodeOK            =0;
     rcodeFormatError   =1;
     rcodeServerFailure =2;
     rcodeNameError     =3;
     rcodeNotSupported  =4;
     rcodeRefused       =5;

{thtmltemplate}
     htnMAX=29;
     //..0=nothing, 1=safecolor, 2=safeline, 3=safehtml, 4=goodcolor, 5=safealign, 6=safevalign
     htmlnames:array[0..htnMAX] of string=('nil','dark','light','link','alink','vlink','bgcolor','text','title','keywords','description','toolbar.name','toolbar.subname','toolbar.links','margin.top','margin.left','caption.align','content.align','window.style','content.style','table.aligns','table.rowcolors','table.widths','table.spacing','table.border','content.spacing','footer','footer.color','footer.align','table.valigns');
     htmlmodes:array[0..htnMAX] of byte=(   0,    4,     4,      1,     1,      1,      1,        1,     3,      2,         2,            3,             3,                0,              0,           0,            5,              5,              0,             0,              0,             0,                0,             0,              0,             0,                3,       4,             5,             0);
     htnnil=0;
     htndark=1;
     htnlight=2;
     htnlink=3;
     htnalink=4;
     htnvlink=5;
     htnbgcolor=6;
     htntext=7;
     htntitle=8;
     htnkeywords=9;
     htndescription=10;
     htntoolbarName=11;
     htntoolbarSubname=12;
     htntoolbarLinks=13;
     htnmarginTop=14;
     htnmarginLeft=15;
     htncaptionAlign=16;
     htncontentAlign=17;
     htnwindowStyle=18;
     htncontentStyle=19;
     htntableAligns=20;
     htntableRowColors=21;
     htntableWidths=22;
     htntableSpacing=23;
     htntableBorder=24;
     htncontentSpacing=25;
     htnfooter=26;
     htnfooterColor=27;
     htnfooterAlign=28;
     htntableVAligns=29;
     //templates
     htmlMessage='light=#ECF4FF;dark=#006EFF;bgcolor=#FFFFFF;text=#000000;link=#0000FF;alink=#FF0000;'+
     'vlink=#777777;margin.top=1;margin.left=11;footer= ;'+
     'window.style=plain;content.align=left;caption.align=left;content.spacing=3;';
{
     htmlWindow='light=#FFE6C4;dark=#DE8101;bgcolor=#FFFFFF;text=#000000;link=#0000FF;alink=#FF0000;'+
     'vlink=#777777;margin.top=1;margin.left=11;footer= ;title=???;'+
     'toolbar.name=???;toolbar.subname=v???;'+
     '{toolbar.links=Contact,,/;Inbox,,/inbox;}{;'+
     'window.style=plain;content.align=left;caption.align=left;content.spacing=3;';
{}//yyyyyyyyyyyyyyy

{tvirtualsysinfo}
     vsiTools         =0;
     vsiProgram       =1;
     vsiSystem        =2;
     vsiRemote        =3;
     vsiTranslation   =4;
     vsiFolders       =5;
     vsiConnections   =6;
     vsiTraffic       =7;
     vsiCodes         =8;
     vsiEULA          =9;
     vsiHelp          =10;
     vsiMax           =10;

{TFrameInfo}
     //core
     frmcMaxWidth=255;{date: 01-NOV-2003}

{Windows - API's}
     MIIM_STATE = 1;
     MIIM_ID = 2;
     MIIM_SUBMENU = 4;
     MIIM_CHECKMARKS = 8;
     MIIM_TYPE = $10;
     MIIM_DATA = $20;

     //PeekMessage() Options
     PM_NOREMOVE = 0;
     PM_REMOVE = 1;
     PM_NOYIELD = 2;

     //Cursor identifiers
     crDefault     = 0;
     crNone        = -1;
     crArrow       = -2;
     crCross       = -3;
     crIBeam       = -4;
     crSize        = -5;
     crSizeNESW    = -6;
     crSizeNS      = -7;
     crSizeNWSE    = -8;
     crSizeWE      = -9;
     crUpArrow     = -10;
     crHourGlass   = -11;
     crDrag        = -12;
     crNoDrop      = -13;
     crHSplit      = -14;
     crVSplit      = -15;
     crMultiDrag   = -16;
     crSQLWait     = -17;
     crNo          = -18;
     crAppStart    = -19;
     crHelp        = -20;
     crHandPoint   = -21;

     //File open modes
     fmOpenRead       = $0000;
     fmOpenWrite      = $0001;
     fmOpenReadWrite  = $0002;
     fmShareCompat    = $0000;
     fmShareExclusive = $0010;
     fmShareDenyWrite = $0020;
     fmShareDenyRead  = $0030;
     fmShareDenyNone  = $0040;

     //File attribute constants
     faReadOnly  = $00000001;
     faHidden    = $00000002;
     faSysFile   = $00000004;
     faVolumeID  = $00000008;
     faDirectory = $00000010;
     faArchive   = $00000020;
     faAnyFile   = $0000003F;

     //Menu flags for AddCheckEnableMenuItem()
     MF_INSERT = 0;
     MF_CHANGE = $80;
     MF_APPEND = $100;
     MF_DELETE = $200;
     MF_REMOVE = $1000;
     MF_BYCOMMAND = 0;
     MF_BYPOSITION = $400;
     MF_SEPARATOR = $800;
     MF_ENABLED = 0;
     MF_GRAYED = 1;
     MF_DISABLED = 2;
     MF_UNCHECKED = 0;
     MF_CHECKED = 8;
     MF_USECHECKBITMAPS = $200;
     MF_STRING = 0;
     MF_BITMAP = 4;
     MF_OWNERDRAW = $100;
     MF_POPUP = $10;
     MF_MENUBARBREAK = $20;
     MF_MENUBREAK = $40;
     MF_UNHILITE = 0;
     MF_HILITE = $80;
     MF_DEFAULT = $1000;
     MF_SYSMENU = $2000;
     MF_HELP = $4000;
     MF_RIGHTJUSTIFY = $4000;
     MF_MOUSESELECT = $8000;
     MF_END = $80;          { Obsolete -- only used by old RES files }
     MFT_STRING = MF_STRING;
     MFT_BITMAP = MF_BITMAP;
     MFT_MENUBARBREAK = MF_MENUBARBREAK;
     MFT_MENUBREAK = MF_MENUBREAK;
     MFT_OWNERDRAW = MF_OWNERDRAW;
     MFT_RADIOCHECK = $200;
     MFT_SEPARATOR = MF_SEPARATOR;
     MFT_RIGHTORDER = $2000;
     MFT_RIGHTJUSTIFY = MF_RIGHTJUSTIFY;

     //Menu flags for AddCheckEnableMenuItem()
     MFS_GRAYED = 3;
     MFS_DISABLED = MFS_GRAYED;
     MFS_CHECKED = MF_CHECKED;
     MFS_HILITE = MF_HILITE;
     MFS_ENABLED = MF_ENABLED;
     MFS_UNCHECKED = MF_UNCHECKED;
     MFS_UNHILITE = MF_UNHILITE;
     MFS_DEFAULT = MF_DEFAULT;

     //PopupMenu Alignment
     TPM_LEFTBUTTON = 0;
     TPM_RIGHTBUTTON = 2;
     TPM_LEFTALIGN = 0;
     TPM_CENTERALIGN = 4;
     TPM_RIGHTALIGN = 8;

     //Ternary raster operations
     SRCCOPY     = $00CC0020;     { dest = source                 }
     SRCPAINT    = $00EE0086;     { dest = source OR dest          }
     SRCAND     = $008800C6;     { dest = source AND dest          }
     SRCINVERT   = $00660046;     { dest = source XOR dest          }
     SRCERASE    = $00440328;     { dest = source AND (NOT dest )    }
     NOTSRCCOPY  = $00330008;     { dest = (NOT source)            }
     NOTSRCERASE = $001100A6;     { dest = (NOT src) AND (NOT dest)  }
     MERGECOPY   = $00C000CA;     { dest = (source AND pattern)     }
     MERGEPAINT  = $00BB0226;     { dest = (NOT source) OR dest     }
     PATCOPY     = $00F00021;     { dest = pattern                }
     PATPAINT    = $00FB0A09;     { dest = DPSnoo                 }
     PATINVERT   = $005A0049;     { dest = pattern XOR dest         }
     DSTINVERT   = $00550009;     { dest = (NOT dest)              }
     BLACKNESS   = $00000042;     { dest = BLACK                  }
     WHITENESS   = $00FF0062;     { dest = WHITE                  }

     //StretchBlt() modes
     BLACKONWHITE = 1;
     WHITEONBLACK = 2;
     COLORONCOLOR = 3;
     HALFTONE = 4;
     MAXSTRETCHBLTMODE = 4;

     //System Menu Command Values
     SC_SIZE = 61440;
     SC_MOVE = 61456;
     SC_MINIMIZE = 61472;
     SC_MAXIMIZE = 61488;
     SC_NEXTWINDOW = 61504;
     SC_PREVWINDOW = 61520;
     SC_CLOSE = 61536;
     SC_VSCROLL = 61552;
     SC_HSCROLL = 61568;
     SC_MOUSEMENU = 61584;
     SC_KEYMENU = 61696;
     SC_ARRANGE = 61712;
     SC_RESTORE = 61728;
     SC_TASKLIST = 61744;
     SC_SCREENSAVE = 61760;
     SC_HOTKEY = 61776;
     SC_DEFAULT = 61792;
     SC_MONITORPOWER = 61808;
     SC_CONTEXTHELP = 61824;
     SC_SEPARATOR = 61455;

     //Window Messages
     WM_NULL           = $0000;
     WM_CREATE          = $0001;
     WM_DESTROY         = $0002;
     WM_MOVE           = $0003;
     WM_SIZE           = $0005;
     WM_ACTIVATE        = $0006;
     WM_SETFOCUS        = $0007;
     WM_KILLFOCUS       = $0008;
     WM_ENABLE          = $000A;
     WM_SETREDRAW       = $000B;
     WM_SETTEXT         = $000C;
     WM_GETTEXT         = $000D;
     WM_GETTEXTLENGTH    = $000E;
     WM_PAINT          = $000F;
     WM_CLOSE          = $0010;
     WM_QUERYENDSESSION  = $0011;
     WM_QUIT           = $0012;
     WM_QUERYOPEN       = $0013;
     WM_ERASEBKGND      = $0014;
     WM_SYSCOLORCHANGE   = $0015;
     WM_ENDSESSION      = $0016;
     WM_SYSTEMERROR     = $0017;
     WM_SHOWWINDOW      = $0018;
     WM_CTLCOLOR        = $0019;
     WM_WININICHANGE     = $001A;
     WM_SETTINGCHANGE = WM_WININICHANGE;
     WM_DEVMODECHANGE    = $001B;
     WM_ACTIVATEAPP     = $001C;
     WM_FONTCHANGE      = $001D;
     WM_TIMECHANGE      = $001E;
     WM_CANCELMODE      = $001F;
     WM_SETCURSOR       = $0020;
     WM_MOUSEACTIVATE    = $0021;
     WM_CHILDACTIVATE    = $0022;
     WM_QUEUESYNC       = $0023;
     WM_GETMINMAXINFO    = $0024;
     WM_PAINTICON       = $0026;
     WM_ICONERASEBKGND   = $0027;
     WM_NEXTDLGCTL      = $0028;
     WM_SPOOLERSTATUS    = $002A;
     WM_DRAWITEM        = $002B;
     WM_MEASUREITEM     = $002C;
     WM_DELETEITEM      = $002D;
     WM_VKEYTOITEM      = $002E;
     WM_CHARTOITEM      = $002F;
     WM_SETFONT         = $0030;
     WM_GETFONT         = $0031;
     WM_SETHOTKEY       = $0032;
     WM_GETHOTKEY       = $0033;
     WM_QUERYDRAGICON    = $0037;
     WM_COMPAREITEM     = $0039;
     WM_COMPACTING      = $0041;
     WM_COMMNOTIFY      = $0044;    { obsolete in Win32}
     WM_WINDOWPOSCHANGING = $0046;
     WM_WINDOWPOSCHANGED = $0047;
     WM_POWER          = $0048;
     WM_COPYDATA        = $004A;
     WM_CANCELJOURNAL    = $004B;
     WM_NOTIFY          = $004E;
     WM_INPUTLANGCHANGEREQUEST = $0050;
     WM_INPUTLANGCHANGE  = $0051;
     WM_TCARD          = $0052;
     WM_HELP           = $0053;
     WM_USERCHANGED     = $0054;
     WM_NOTIFYFORMAT     = $0055;
     WM_CONTEXTMENU     = $007B;
     WM_STYLECHANGING    = $007C;
     WM_STYLECHANGED     = $007D;
     WM_DISPLAYCHANGE    = $007E;
     WM_GETICON         = $007F;
     WM_SETICON         = $0080;
     WM_NCCREATE        = $0081;
     WM_NCDESTROY       = $0082;
     WM_NCCALCSIZE      = $0083;
     WM_NCHITTEST       = $0084;
     WM_NCPAINT         = $0085;
     WM_NCACTIVATE      = $0086;
     WM_GETDLGCODE      = $0087;
     WM_NCMOUSEMOVE     = $00A0;
     WM_NCLBUTTONDOWN    = $00A1;
     WM_NCLBUTTONUP     = $00A2;
     WM_NCLBUTTONDBLCLK  = $00A3;
     WM_NCRBUTTONDOWN    = $00A4;
     WM_NCRBUTTONUP     = $00A5;
     WM_NCRBUTTONDBLCLK  = $00A6;
     WM_NCMBUTTONDOWN    = $00A7;
     WM_NCMBUTTONUP     = $00A8;
     WM_NCMBUTTONDBLCLK  = $00A9;
     WM_KEYFIRST        = $0100;
     WM_KEYDOWN         = $0100;
     WM_KEYUP          = $0101;
     WM_CHAR           = $0102;
     WM_DEADCHAR        = $0103;
     WM_SYSKEYDOWN      = $0104;
     WM_SYSKEYUP        = $0105;
     WM_SYSCHAR         = $0106;
     WM_SYSDEADCHAR     = $0107;
     WM_KEYLAST         = $0108;
     WM_INITDIALOG      = $0110;
     WM_COMMAND         = $0111;
     WM_SYSCOMMAND      = $0112;
     WM_TIMER          = $0113;
     WM_HSCROLL         = $0114;
     WM_VSCROLL         = $0115;
     WM_INITMENU        = $0116;
     WM_INITMENUPOPUP    = $0117;
     WM_MENUSELECT      = $011F;
     WM_MENUCHAR        = $0120;
     WM_ENTERIDLE       = $0121;
     WM_CTLCOLORMSGBOX   = $0132;
     WM_CTLCOLOREDIT     = $0133;
     WM_CTLCOLORLISTBOX  = $0134;
     WM_CTLCOLORBTN     = $0135;
     WM_CTLCOLORDLG     = $0136;
     WM_CTLCOLORSCROLLBAR= $0137;
     WM_CTLCOLORSTATIC   = $0138;
     WM_MOUSEFIRST      = $0200;
     WM_MOUSEMOVE       = $0200;
     WM_LBUTTONDOWN     = $0201;
     WM_LBUTTONUP       = $0202;
     WM_LBUTTONDBLCLK    = $0203;
     WM_RBUTTONDOWN     = $0204;
     WM_RBUTTONUP       = $0205;
     WM_RBUTTONDBLCLK    = $0206;
     WM_MBUTTONDOWN     = $0207;
     WM_MBUTTONUP       = $0208;
     WM_MBUTTONDBLCLK    = $0209;
     WM_MOUSEWHEEL      = $020A;
     WM_MOUSELAST       = $020A;
     WM_PARENTNOTIFY     = $0210;
     WM_ENTERMENULOOP    = $0211;
     WM_EXITMENULOOP     = $0212;
     WM_NEXTMENU        = $0213;
     WM_SIZING          = 532;
     WM_CAPTURECHANGED   = 533;
     WM_MOVING          = 534;
     WM_POWERBROADCAST   = 536;
     WM_DEVICECHANGE     = 537;
     WM_IME_STARTCOMPOSITION       = $010D;
     WM_IME_ENDCOMPOSITION         = $010E;
     WM_IME_COMPOSITION           = $010F;
     WM_IME_KEYLAST               = $010F;
     WM_IME_SETCONTEXT            = $0281;
     WM_IME_NOTIFY               = $0282;
     WM_IME_CONTROL               = $0283;
     WM_IME_COMPOSITIONFULL        = $0284;
     WM_IME_SELECT               = $0285;
     WM_IME_CHAR                 = $0286;
     WM_IME_KEYDOWN               = $0290;
     WM_IME_KEYUP                = $0291;
     WM_MDICREATE       = $0220;
     WM_MDIDESTROY      = $0221;
     WM_MDIACTIVATE     = $0222;
     WM_MDIRESTORE      = $0223;
     WM_MDINEXT         = $0224;
     WM_MDIMAXIMIZE     = $0225;
     WM_MDITILE         = $0226;
     WM_MDICASCADE      = $0227;
     WM_MDIICONARRANGE   = $0228;
     WM_MDIGETACTIVE     = $0229;
     WM_MDISETMENU      = $0230;
     WM_ENTERSIZEMOVE    = $0231;
     WM_EXITSIZEMOVE     = $0232;
     WM_DROPFILES       = $0233;
     WM_MDIREFRESHMENU   = $0234;
     WM_MOUSEHOVER      = $02A1;
     WM_MOUSELEAVE      = $02A3;
     WM_CUT            = $0300;
     WM_COPY           = $0301;
     WM_PASTE          = $0302;
     WM_CLEAR          = $0303;
     WM_UNDO           = $0304;
     WM_RENDERFORMAT     = $0305;
     WM_RENDERALLFORMATS = $0306;
     WM_DESTROYCLIPBOARD = $0307;
     WM_DRAWCLIPBOARD    = $0308;
     WM_PAINTCLIPBOARD   = $0309;
     WM_VSCROLLCLIPBOARD = $030A;
     WM_SIZECLIPBOARD    = $030B;
     WM_ASKCBFORMATNAME  = $030C;
     WM_CHANGECBCHAIN    = $030D;
     WM_HSCROLLCLIPBOARD = $030E;
     WM_QUERYNEWPALETTE  = $030F;
     WM_PALETTEISCHANGING= $0310;
     WM_PALETTECHANGED   = $0311;
     WM_HOTKEY          = $0312;
     WM_PRINT          = 791;
     WM_PRINTCLIENT     = 792;

     //Window Styles
     WS_DEFAULT = -1;{custom, internal use only}
     WS_OVERLAPPED = 0;
     WS_POPUP = $80000000;
     WS_CHILD = $40000000;
     WS_MINIMIZE = $20000000;
     WS_VISIBLE = $10000000;
     WS_DISABLED = $8000000;
     WS_CLIPSIBLINGS = $4000000;
     WS_CLIPCHILDREN = $2000000;
     WS_MAXIMIZE = $1000000;
     WS_CAPTION = $C00000;     { WS_BORDER or WS_DLGFRAME  }
     WS_BORDER = $800000;
     WS_DLGFRAME = $400000;
     WS_VSCROLL = $200000;
     WS_HSCROLL = $100000;
     WS_SYSMENU = $80000;
     WS_THICKFRAME = $40000;
     WS_GROUP = $20000;
     WS_TABSTOP = $10000;
     WS_MINIMIZEBOX = $20000;
     WS_MAXIMIZEBOX = $10000;
     WS_TILED = WS_OVERLAPPED;
     WS_ICONIC = WS_MINIMIZE;
     WS_SIZEBOX = WS_THICKFRAME;

     //Common Window Styles
     WS_OVERLAPPEDWINDOW = (WS_OVERLAPPED or WS_CAPTION or WS_SYSMENU or
     WS_THICKFRAME or WS_MINIMIZEBOX or WS_MAXIMIZEBOX);
     WS_TILEDWINDOW = WS_OVERLAPPEDWINDOW;
     WS_POPUPWINDOW = (WS_POPUP or WS_BORDER or WS_SYSMENU);
     WS_CHILDWINDOW = (WS_CHILD);

     //Extended Window Styles
     WS_EX_DEFAULT = -1;{custom, internal use only}
     WS_EX_DLGMODALFRAME = 1;
     WS_EX_NOPARENTNOTIFY = 4;
     WS_EX_TOPMOST = 8;
     WS_EX_ACCEPTFILES = $10;
     WS_EX_TRANSPARENT = $20;
     WS_EX_MDICHILD = $40;
     WS_EX_TOOLWINDOW = $80;
     WS_EX_WINDOWEDGE = $100;
     WS_EX_CLIENTEDGE = $200;
     WS_EX_CONTEXTHELP = $400;
     WS_EX_RIGHT = $1000;
     WS_EX_LEFT = 0;
     WS_EX_RTLREADING = $2000;
     WS_EX_LTRREADING = 0;
     WS_EX_LEFTSCROLLBAR = $4000;
     WS_EX_RIGHTSCROLLBAR = 0;
     WS_EX_CONTROLPARENT = $10000;
     WS_EX_STATICEDGE = $20000;
     WS_EX_APPWINDOW = $40000;
     WS_EX_OVERLAPPEDWINDOW = (WS_EX_WINDOWEDGE or WS_EX_CLIENTEDGE);
     WS_EX_PALETTEWINDOW = (WS_EX_WINDOWEDGE or WS_EX_TOOLWINDOW or WS_EX_TOPMOST);

     //ShowWindow() Commands
     SW_HIDE = 0;
     SW_SHOWNORMAL = 1;
     SW_NORMAL = 1;
     SW_SHOWMINIMIZED = 2;
     SW_SHOWMAXIMIZED = 3;
     SW_MAXIMIZE = 3;
     SW_SHOWNOACTIVATE = 4;
     SW_SHOW = 5;
     SW_MINIMIZE = 6;
     SW_SHOWMINNOACTIVE = 7;
     SW_SHOWNA = 8;
     SW_RESTORE = 9;
     SW_SHOWDEFAULT = 10;
     SW_MAX = 10;

     //GetSystemMetrics() codes
     SM_CXSCREEN = 0;
     SM_CYSCREEN = 1;
     SM_CXVSCROLL = 2;
     SM_CYHSCROLL = 3;
     SM_CYCAPTION = 4;
     SM_CXBORDER = 5;
     SM_CYBORDER = 6;
     SM_CXDLGFRAME = 7;
     SM_CYDLGFRAME = 8;
     SM_CYVTHUMB = 9;
     SM_CXHTHUMB = 10;
     SM_CXICON = 11;
     SM_CYICON = 12;
     SM_CXCURSOR = 13;
     SM_CYCURSOR = 14;
     SM_CYMENU = 15;
     SM_CXFULLSCREEN = $10;
     SM_CYFULLSCREEN = 17;
     SM_CYKANJIWINDOW = 18;
     SM_MOUSEPRESENT = 19;
     SM_CYVSCROLL = 20;
     SM_CXHSCROLL = 21;
     SM_DEBUG = 22;
     SM_SWAPBUTTON = 23;
     SM_RESERVED1 = 24;
     SM_RESERVED2 = 25;
     SM_RESERVED3 = 26;
     SM_RESERVED4 = 27;
     SM_CXMIN = 28;
     SM_CYMIN = 29;
     SM_CXSIZE = 30;
     SM_CYSIZE = 31;
     SM_CXFRAME = $20;
     SM_CYFRAME = 33;
     SM_CXMINTRACK = 34;
     SM_CYMINTRACK = 35;
     SM_CXDOUBLECLK = 36;
     SM_CYDOUBLECLK = 37;
     SM_CXICONSPACING = 38;
     SM_CYICONSPACING = 39;
     SM_MENUDROPALIGNMENT = 40;
     SM_PENWINDOWS = 41;
     SM_DBCSENABLED = 42;
     SM_CMOUSEBUTTONS = 43;
     SM_CXFIXEDFRAME = SM_CXDLGFRAME; { win40 name change }
     SM_CYFIXEDFRAME = SM_CYDLGFRAME; { win40 name change }
     SM_CXSIZEFRAME = SM_CXFRAME;     { win40 name change }
     SM_CYSIZEFRAME = SM_CYFRAME;     { win40 name change }
     SM_SECURE = 44;
     SM_CXEDGE = 45;
     SM_CYEDGE = 46;
     SM_CXMINSPACING = 47;
     SM_CYMINSPACING = 48;
     SM_CXSMICON = 49;
     SM_CYSMICON = 50;
     SM_CYSMCAPTION = 51;
     SM_CXSMSIZE = 52;
     SM_CYSMSIZE = 53;
     SM_CXMENUSIZE = 54;
     SM_CYMENUSIZE = 55;
     SM_ARRANGE = 56;
     SM_CXMINIMIZED = 57;
     SM_CYMINIMIZED = 58;
     SM_CXMAXTRACK = 59;
     SM_CYMAXTRACK = 60;
     SM_CXMAXIMIZED = 61;
     SM_CYMAXIMIZED = 62;
     SM_NETWORK = 63;
     SM_CLEANBOOT = 67;
     SM_CXDRAG = 68;
     SM_CYDRAG = 69;
     SM_SHOWSOUNDS = 70;
     SM_CXMENUCHECK = 71;     { Use instead of GetMenuCheckMarkDimensions()! }
     SM_CYMENUCHECK = 72;
     SM_SLOWMACHINE = 73;
     SM_MIDEASTENABLED = 74;
     SM_MOUSEWHEELPRESENT = 75;
     SM_CMETRICS = 76;

     //Standard Icon IDs
     IDI_APPLICATION = MakeIntResource(32512);
     IDI_HAND = MakeIntResource(32513);
     IDI_QUESTION = MakeIntResource(32514);
     IDI_EXCLAMATION = MakeIntResource(32515);
     IDI_ASTERISK = MakeIntResource(32516);
     IDI_WINLOGO = MakeIntResource(32517);
     IDI_WARNING = IDI_EXCLAMATION;
     IDI_ERROR = IDI_HAND;
     IDI_INFORMATION = IDI_ASTERISK;

     //Standard Cursor IDs
     IDC_ARROW = MakeIntResource(32512);
     IDC_IBEAM = MakeIntResource(32513);
     IDC_WAIT = MakeIntResource(32514);
     IDC_CROSS = MakeIntResource(32515);
     IDC_UPARROW = MakeIntResource(32516);
     IDC_SIZE = MakeIntResource(32640);
     IDC_ICON = MakeIntResource(32641);
     IDC_SIZENWSE = MakeIntResource(32642);
     IDC_SIZENESW = MakeIntResource(32643);
     IDC_SIZEWE = MakeIntResource(32644);
     IDC_SIZENS = MakeIntResource(32645);
     IDC_SIZEALL = MakeIntResource(32646);
     IDC_NO = MakeIntResource(32648);
     IDC_APPSTARTING = MakeIntResource(32650);
     IDC_HELP = MakeIntResource(32651);

     //Stock Logical Objects
     WHITE_BRUSH = 0;
     LTGRAY_BRUSH = 1;
     GRAY_BRUSH = 2;
     DKGRAY_BRUSH = 3;
     BLACK_BRUSH = 4;
     NULL_BRUSH = 5;
     HOLLOW_BRUSH = NULL_BRUSH;
     WHITE_PEN = 6;
     BLACK_PEN = 7;
     NULL_PEN = 8;
     OEM_FIXED_FONT = 10;
     ANSI_FIXED_FONT = 11;
     ANSI_VAR_FONT = 12;
     SYSTEM_FONT = 13;
     DEVICE_DEFAULT_FONT = 14;
     DEFAULT_PALETTE = 15;
     SYSTEM_FIXED_FONT = $10;
     DEFAULT_GUI_FONT = 17;
     STOCK_LAST = 17;
     CLR_INVALID = $FFFFFFFF;

     //Brush Styles
     BS_SOLID              = 0;
     BS_NULL               = 1;
     BS_HOLLOW             = BS_NULL;
     BS_HATCHED            = 2;
     BS_PATTERN            = 3;
     BS_INDEXED            = 4;
     BS_DIBPATTERN          = 5;
     BS_DIBPATTERNPT        = 6;
     BS_PATTERN8X8          = 7;
     BS_DIBPATTERN8X8       = 8;
     BS_MONOPATTERN         = 9;

     //Hatch Styles
     HS_HORIZONTAL = 0;      { ----- }
     HS_VERTICAL   = 1;      { ||||| }
     HS_FDIAGONAL  = 2;      { ///// }
     HS_BDIAGONAL  = 3;      { \\\\\ }
     HS_CROSS     = 4;      { +++++ }
     HS_DIAGCROSS  = 5;      { xxxxx }

     //Pen Styles
     PS_SOLID      = 0;
     PS_DASH       = 1;     { ------- }
     PS_DOT        = 2;     { ....... }
     PS_DASHDOT     = 3;     { _._._._ }
     PS_DASHDOTDOT  = 4;     { _.._.._ }
     PS_NULL = 5;
     PS_INSIDEFRAME = 6;
     PS_USERSTYLE = 7;
     PS_ALTERNATE = 8;
     PS_STYLE_MASK = 15;
     PS_ENDCAP_ROUND = 0;
     PS_ENDCAP_SQUARE = $100;
     PS_ENDCAP_FLAT = $200;
     PS_ENDCAP_MASK = 3840;
     PS_JOIN_ROUND = 0;
     PS_JOIN_BEVEL = $1000;
     PS_JOIN_MITER = $2000;
     PS_JOIN_MASK = 61440;
     PS_COSMETIC = 0;
     PS_GEOMETRIC = $10000;
     PS_TYPE_MASK = $F0000;
     AD_COUNTERCLOCKWISE = 1;
     AD_CLOCKWISE = 2;

     //Window field offsets for GetWindowLong()
     GWL_WNDPROC = -4;
     GWL_HINSTANCE = -6;
     GWL_HWNDPARENT = -8;
     GWL_STYLE = -16;
     GWL_EXSTYLE = -20;
     GWL_USERDATA = -21;
     GWL_ID = -12;

     //Controls
     CN_BASE            = $BC00;

     //MessageBox
     mbCustom=$0;
     mbError=$10;
     mbInformation=$40;
     mbWarning=$30;
     mbrYes=6;
     mbrNo=7;

     //MessageBox() Flags
     MB_OK = $00000000;
     MB_OKCANCEL = $00000001;
     MB_ABORTRETRYIGNORE = $00000002;
     MB_YESNOCANCEL = $00000003;
     MB_YESNO = $00000004;
     MB_RETRYCANCEL = $00000005;

     //registry entries for special paths are kept in:
     CSIDL_DESKTOP                    = $0000;
     CSIDL_PROGRAMS                   = $0002;
     CSIDL_CONTROLS                   = $0003;
     CSIDL_PRINTERS                   = $0004;
     CSIDL_PERSONAL                   = $0005;
     CSIDL_FAVORITES                  = $0006;
     CSIDL_STARTUP                    = $0007;
     CSIDL_RECENT                    = $0008;
     CSIDL_SENDTO                    = $0009;
     CSIDL_BITBUCKET                  = $000a;
     CSIDL_STARTMENU                  = $000b;
     CSIDL_DESKTOPDIRECTORY            = $0010;
     CSIDL_DRIVES                    = $0011;
     CSIDL_NETWORK                    = $0012;
     CSIDL_NETHOOD                    = $0013;
     CSIDL_FONTS                     = $0014;
     CSIDL_TEMPLATES                  = $0015;
     CSIDL_COMMON_STARTMENU            = $0016;
     CSIDL_COMMON_PROGRAMS             = $0017;
     CSIDL_COMMON_STARTUP              = $0018;
     CSIDL_COMMON_DESKTOPDIRECTORY      = $0019;
     CSIDL_APPDATA                    = $001a;
     CSIDL_PRINTHOOD                  = $001b;

{TMsgLst}
     mglMaxItem=999;
{TLiteForm}
     lfmDown=0;
     lfmMove=1;
     lfmUp=2;

type
    pwndproc=^twndproc;
    twndproc=procedure(window:HWND;message,wparam,lparam:longint) of object;
    pwindowproc=^twindowproc;
    twindowproc=function(hWnd:hwnd;msg:uint;wparam:wparam;lparam:lparam):lresult of object;stdcall;
    tdecideevent=procedure(sender:tobject;var value:boolean) of object;
    tstringevent=procedure(sender:tobject;value:string) of object;
    tstringfuncevent=function(sender:tobject;value:string):boolean of object;
    tsetstringevent=procedure(sender:tobject;var value:string) of object;
    teventinteger=procedure(sender:tobject;value:integer) of object;
    teventintegerf=function(sender:tobject;value:integer):boolean of object;
    tliteform=class;
    tio=class;
    tdynamiclist=class;
    tdynamicstring=class;
    tdynamicboolean=class;
    tdynamicinteger=class;
    tdynamicrect=class;
    tdynamicobject=class;
    pobject=^tobject;
    tstoragestyle=(sgsNil,sgsString,sgsExtended,sgsCurrency,sgsInteger,sgsBoolean,sgsECap);
    tvirtualimage=class;
    tvirtualbitmap=class;
    tvirtualbaselist=class;
    tvirtualtext=class;
    tfontmap=class;
    tpopmenu=class;
    tvirtualpanel=class;
    tvirtualform=class;
    tvirtualtitle=class;
    tvirtualbasetext=class;
    pvirtualcontrol=^tvirtualcontrol;
    tvirtualcontrol=class;
    tvirtuallabel=class;
    tvirtualpagescroll=class;
    tvirtualtick=class;
    tvirtualsep=class;
    tvirtualglyph=class;
    tvirtualdroplist=class;
    tpoplist=class;
    tstripscroll=class;
    tvirtualhelp=class;
    tvirtualpage=class;
    tvirtualedit=class;
    tvirtualscrollbar=class;
    pdlVIRTUALCONTROL=^tdlVIRTUALCONTROL;tdlVIRTUALCONTROL=array[0..((maxint div sizeof(pvirtualcontrol))-1)] of tvirtualcontrol;
    tvirtualcontrollist=class;
    tvirtualpages=class;
    tvirtualhead=class;
    tvirtualbutton=class;
    tvirtuallink=class;
    tvirtualdrawstate=set of(vdsSelected,vdsGrayed,vdsDisabled,vdsChecked,vdsFocused);
    tvirtualtextevent=procedure(control:tvirtualcontrol;canvas:tcanvas;index:integer;var text:string) of object;
    tvirtualimageevent=procedure(sender:tobject;index:integer;var image:tvirtualbitmap) of object;
    tvirtualdrawevent=procedure(control:tvirtualcontrol;canvas:tcanvas;index:integer;area:trect;state:tvirtualdrawstate;ontext:tvirtualtextevent;onimage:tvirtualimageevent) of object;
    tvirtualpaintevent=procedure(sender:tobject;canvas:tcanvas) of object;
    pip = ^tip;
    tip = record
    case integer of
    0:(ip:integer);
    1:(p:array [0..3] of byte);
    2:(c:array [0..3] of char);
    end;
    tcolor8=byte;
    prow8=^trow8;
    trow8=array[word] of tcolor8;
    prows8=^trows8;
    trows8=array[word] of prow8;
    prgbcolor=^trgbcolor;trgbcolor=record b:byte;g:byte;r:byte;end;
    prgbcolorrow=^trgbcolorrow;trgbcolorrow=array[0..maxpixel] of trgbcolor;
    prgbcolorrows=^trgbcolorrows;trgbcolorrows=array[0..maxrow] of prgbcolorrow;
    pBITBOOLEAN=^tBITBOOLEAN;tBITBOOLEAN=set of 0..7;
    pdlBITBOOLEAN=^tdlBITBOOLEAN;tdlBITBOOLEAN=array[0..((maxint div sizeof(tBITBOOLEAN))-1)] of tBITBOOLEAN;
    pdlBOOLEAN=^tdlBOOLEAN;tdlBOOLEAN=array[0..((maxint div sizeof(boolean))-1)] of boolean;
    pdlCHAR=^tdlCHAR;tdlCHAR=array[0..((maxint div sizeof(char))-1)] of char;
    pdlBYTE=^tdlBYTE;tdlBYTE=array[0..((maxint div sizeof(byte))-1)] of byte;
    pdlWORD=^tdlWORD;tdlWORD=array[0..((maxint div sizeof(word))-1)] of word;
    pdlSMINT=^tdlSMINT;tdlSMINT=array[0..((maxint div sizeof(smallint))-1)] of smallint;
    pdlINTEGER=^tdlINTEGER;tdlINTEGER=array[0..((maxint div sizeof(integer))-1)] of integer;
    pdlRGB=^tdlRGB;tdlRGB=array[0..((maxint div sizeof(trgbcolor))-1)] of trgbcolor;
    pdlPOINT  =^tdlPOINT;  tdlPOINT  =array[0..((maxint div sizeof(tpoint))-1)] of tpoint;
    pdlIP=^tdlIP;tdlIP=array[0..((maxint div sizeof(tip))-1)] of tip;
    pdlRECT=^tdlRECT;tdlRECT=array[0..((maxint div sizeof(trect))-1)] of trect;
    pdlNOTIFYEVENT=^tdlNOTIFYEVENT;tdlNOTIFYEVENT=array[0..((maxint div sizeof(tnotifyevent))-1)] of tnotifyevent;
    tmsgproc=function (hWnd:hwnd;msg:uint;wparam:wparam;lparam:lparam):lresult of object;
    pdlMSGPROC=^tdlMSGPROC;tdlMSGPROC=array[0..((maxint div sizeof(tmsgproc))-1)] of tmsgproc;
    pBIINTEGER=^tBIINTEGER;tBIINTEGER=array[0..1] of integer;
    pdlBIINTEGER=^tdlBIINTEGER;tdlBIINTEGER=array[0..((maxint div sizeof(tBIINTEGER))-1)] of tBIINTEGER;
    pdlCURRENCY=^tdlCURRENCY;tdlCURRENCY=array[0..((maxint div sizeof(currency))-1)] of currency;
    pdlDOUBLE=^tdlDOUBLE;tdlDOUBLE=array[0..((maxint div sizeof(double))-1)] of double;
    pdlDATETIME=^tdlDATETIME;tdlDATETIME=array[0..((maxint div sizeof(tdatetime))-1)] of tdatetime;
    pdlPOINTER=^tdlPOINTER;tdlPOINTER=array[0..((maxint div sizeof(pointer))-1)] of pointer;
    pdlOBJECT=^tdlOBJECT;tdlOBJECT=array[0..((maxint div sizeof(pobject))-1)] of tobject;
    pdlSTRING=^tdlSTRING;tdlSTRING=array[0..((maxint div sizeof(pstring))-1)] of pstring;
    tdynamiclistevent=procedure(sender:tobject;index:integer) of object;
    tdynamiclistswapevent=procedure(sender:tobject;x,y:integer) of object;

    tbit8=record//28-OCT-2006
    case integer of
    0:(bits:tBITBOOLEAN);
    1:(val:byte);
    2:(c:char);
    end;

    pbytechar=^tbytechar;//03-OCT-2004
    tbytechar=record
    case integer of
    0:(c:char);
    1:(b:byte);
    end;

    PWrd2 = ^TWrd2;
    TWrd2 = record
    case Integer of
      0:(val:word);
      1:(si:smallint);
      2:(chars:array [0..1] of char);
      3:(bytes:array [0..1] of byte);
    end;

    PInt4 = ^TInt4;
    TInt4 = record
    case Integer of
      0:(R,G,B,T:Byte);
      1:(val:integer);
      2:(chars:array [0..3] of char);
      3:(bytes:array [0..3] of byte);
      4:(wrds:array [0..1] of word);
    end;

    PCur8 = ^TCur8;
    TCur8 = record
    case Integer of
      0:(dbl:double);
      1:(val:currency);
      3:(chars:array[0..7] of char);
      4:(bytes:array[0..7] of byte);
      5:(wrds:array[0..3] of word);
      6:(ints:array[0..1] of integer);
    end;

    pext10 = ^text10;
    text10 = record
    case integer of
      0:(val:extended);
      1:(chars:array[0..9] of char);
      2:(bytes:array[0..9] of byte);
      3:(wrds:array[0..4] of word);
    end;

    pvirtualinfo=^tvirtualinfo;
    tvirtualinfo=record
      //colors
      border:integer;
      background:integer;
      highlight:integer;
      hover:integer;
      disable:integer;//used for background
      disableborder:integer;//used for border
      disablefont:integer;
      font:integer;
      fonthighlight:integer;
      //font
      fontname:string;
      fontmap:tfontmap;
      //html
      hfontname:string;
      hborder:string;
      hbackground:string;
      hbackshade:string;//second background color;
      hfont:string;
      hlink:string;
      halink:string;
      hvlink:string;
      hstyle:string;
      hbody:string;
      end;
{trootobject}
    trootclass=class of trootobject;
    prootobject=^trootobject;
    trootobject=class(tobject)
    private
     isysVar:prootobject;//isysVar<>nil => system instance
    public
     //vars
     name:string;
     //create
     constructor create; virtual;
     constructor createsys(sysVar:prootobject); virtual;
     destructor destroy; override;
     property sysVar:prootobject read isysVar;
     function empty:boolean; virtual;
    end;

{tdynamiclist}
    tdynamiclist=class(tobject)
    private
     itextsupported:boolean;
     icore:pointer;
     iincsize,ilimit,ibpi,isize:integer;
     procedure setcount(x:integer);
     procedure setsize(x:integer);
     procedure setbpi(x:integer);//bytes per item
     procedure setincsize(x:integer);
     function notify(s,f:integer;_event:tdynamiclistevent):boolean;
     function gettext:string;
     procedure settext(x:string);
    protected
     icount:integer;
     ilockedBPI:boolean;
     freesorted:boolean;//destroys "sorted" object if TRUE
     //critical info handlers
     procedure _oncreateitem(sender:tobject;index:integer); virtual;
     procedure _onfreeitem(sender:tobject;index:integer); virtual;
     function _setparams(_count,_size,_bpi:integer;_notify:boolean):boolean; virtual;
     procedure shift(s,by:integer); virtual;
     procedure _init; virtual;
     procedure _corehandle; virtual;
     procedure _sort(_asc:boolean); virtual;
    public
     //vars
     sorted:tdynamicinteger;
     //events
     oncreateitem:tdynamiclistevent;
     onfreeitem:tdynamiclistevent;
     onswapitems:tdynamiclistswapevent;
     //create
     constructor create; virtual;
     destructor destroy; override;
     procedure _createsupport; virtual;
     procedure _destroysupport; virtual;
     //workers
     procedure clear; virtual;
     //.add
     function add:boolean;
     function addrange(_count:integer):boolean;
     //.delete
     function del(x:integer):boolean;
     function delrange(s,_count:integer):boolean;
     //.insert
     function ins(x:integer):boolean;
     function insrange(s,_count:integer):boolean;
     function swap(x,y:integer):boolean;
     function setparams(_count,_size,_bpi:integer):boolean;
     //limits
     property count:integer read icount write setcount;
     property size:integer read isize write setsize;
     function atleast(_size:integer):boolean; virtual;
     property bpi:integer read ibpi write setbpi;//bytes per item
     property limit:integer read ilimit;
     property incsize:integer read iincsize write setincsize;
     function findvalue(_start:integer;_value:pointer):integer;
     function sindex(x:integer):integer;
     //text - note: not always a supported feature, only for byte, word, integer and other simple types (note for string, object, etc)
     procedure pulltext(var x:string);
     procedure pushtext(var x:string);
     property text:string read gettext write settext;
     property cantext:boolean read itextsupported;
     //sort
     procedure sort(_asc:boolean);
     procedure nosort;
     //core
     property core:pointer read icore;
    end;

{tdynamicbyte}
    tdynamicbyte=class(tdynamiclist)
    private
     iitems:pdlBYTE;
     ibits:pdlBITBOOLEAN;
     function getvalue(_index:integer):byte;
     procedure setvalue(_index:integer;_value:byte);
     function getsvalue(_index:integer):byte;
     procedure setsvalue(_index:integer;_value:byte);
     procedure _init; override;
     procedure _corehandle; override;
    protected
     procedure _sort(_asc:boolean); override;
     procedure __sort(a:pdlBYTE;b:pdlINTEGER;l,r:integer;_asc:boolean);
    public
     property value[x:integer]:byte read getvalue write setvalue;
     property svalue[x:integer]:byte read getsvalue write setsvalue;
     property items:pdlBYTE read iitems;
     property bits:pdlBITBOOLEAN read ibits;
     function find(_start:integer;_value:byte):integer;
    end;

{tdynamicchar}
    tdynamicchar=class(tdynamiclist)
    private
     iitems:pdlCHAR;
     function getvalue(_index:integer):char;
     procedure setvalue(_index:integer;_value:char);
     function getsvalue(_index:integer):char;
     procedure setsvalue(_index:integer;_value:char);
     procedure _init; override;
     procedure _corehandle; override;
    protected
     procedure _sort(_asc:boolean); override;
     procedure __sort(a:pdlCHAR;b:pdlINTEGER;l,r:integer;_asc:boolean);
    public
     property value[x:integer]:char read getvalue write setvalue;
     property svalue[x:integer]:char read getsvalue write setsvalue;
     property items:pdlCHAR read iitems;
     function find(_start:integer;_value:char):integer;
    end;

{tdynamicboolean}
    tdynamicboolean=class(tdynamiclist)
    private
     iitems:pdlBOOLEAN;
     function getvalue(_index:integer):boolean;
     procedure setvalue(_index:integer;_value:boolean);
     function getsvalue(_index:integer):boolean;
     procedure setsvalue(_index:integer;_value:boolean);
     procedure _init; override;
     procedure _corehandle; override;
    public
     property value[x:integer]:boolean read getvalue write setvalue;
     property svalue[x:integer]:boolean read getsvalue write setsvalue;
     property items:pdlBOOLEAN read iitems;
     function find(_start:integer;_value:boolean):integer;
    end;

{tdynamicword}
    tdynamicword=class(tdynamiclist)
    private
     iitems:pdlWORD;
     function getvalue(_index:integer):word;
     procedure setvalue(_index:integer;_value:word);
     function getsvalue(_index:integer):word;
     procedure setsvalue(_index:integer;_value:word);
     procedure _init; override;
     procedure _corehandle; override;
    protected
     procedure _sort(_asc:boolean); override;
     procedure __sort(a:pdlWORD;b:pdlINTEGER;l,r:integer;_asc:boolean);
    public
     property value[x:integer]:word read getvalue write setvalue;
     property svalue[x:integer]:word read getsvalue write setsvalue;
     property items:pdlWORD read iitems;
     function find(_start:integer;_value:word):integer;
    end;

{tdynamicsmallint}
    tdynamicsmallint=class(tdynamiclist)
    private
     iitems:pdlSMINT;
     function getvalue(_index:integer):smallint;
     procedure setvalue(_index:integer;_value:smallint);
     function getsvalue(_index:integer):smallint;
     procedure setsvalue(_index:integer;_value:smallint);
     procedure _init; override;
     procedure _corehandle; override;
    protected
     procedure _sort(_asc:boolean); override;
     procedure __sort(a:pdlSMINT;b:pdlINTEGER;l,r:integer;_asc:boolean);
    public
     property value[x:integer]:smallint read getvalue write setvalue;
     property svalue[x:integer]:smallint read getsvalue write setsvalue;
     property items:pdlSMINT read iitems;
     function find(_start:integer;_value:smallint):integer;
    end;

{tdynamicinteger}
    tdynamicinteger=class(tdynamiclist)
    private
     iitems:pdlINTEGER;
     function getvalue(_index:integer):integer;
     procedure setvalue(_index:integer;_value:integer);
     function getsvalue(_index:integer):integer;
     procedure setsvalue(_index:integer;_value:integer);
     procedure _init; override;
     procedure _corehandle; override;
    protected
     procedure _sort(_asc:boolean); override;
     procedure __sort(a:pdlINTEGER;b:pdlINTEGER;l,r:integer;_asc:boolean);
    public
     property value[x:integer]:integer read getvalue write setvalue;
     property svalue[x:integer]:integer read getsvalue write setsvalue;
     property items:pdlINTEGER read iitems;
     function find(_start:integer;_value:integer):integer;
    end;

{tdynamicrgb}
    tdynamicrgb=class(tdynamiclist)
    private
     iitems:pdlRGB;
     function getvalue(_index:integer):trgbcolor;
     procedure setvalue(_index:integer;_value:trgbcolor);
     function getsvalue(_index:integer):trgbcolor;
     procedure setsvalue(_index:integer;_value:trgbcolor);
     procedure _init; override;
     procedure _corehandle; override;
     function getindirect(_index:integer):trgbcolor;
     procedure setindirect(_index:integer;z:trgbcolor);
    protected
     procedure _sort(_asc:boolean); override;
     procedure __sort(a:pdlRGB;b:pdlRGB;l,r:integer;_asc:boolean);
    public
     property value[x:integer]:trgbcolor read getvalue write setvalue;
     property svalue[x:integer]:trgbcolor read getsvalue write setsvalue;
     function find(_start:integer;_value:trgbcolor):integer;
     //items - Warning: refering to items directly confuses Delphi in some cause causing the ADDRESS of the entire row to be copied and not the color (e.g. tmp.items[dx]:=r[dx] where r=prgbcolorrow and tmp=tdynamicrgb, use tmp.indirect[dx]:=r[dx] instead)//14SEP2007
     property items:pdlRGB read iitems;
     property indirect[x:integer]:trgbcolor read getindirect write setindirect;
     //extra
     function readfrom(x:tbitmap;dy:integer):boolean;
     function readfromex(x:tbitmap;dy:integer;bolPad,eolPad,colPad:integer):boolean;
    end;

{tdynamicpoint}
    tdynamicpoint=class(tdynamiclist)
    private
     iitems:pdlPOINT;
     function getvalue(_index:integer):tpoint;
     procedure setvalue(_index:integer;_value:tpoint);
     function getsvalue(_index:integer):tpoint;
     procedure setsvalue(_index:integer;_value:tpoint);
     procedure _init; override;
     procedure _corehandle; override;
    protected
     procedure _sort(_asc:boolean); override;
     procedure __sort(a:pdlPOINT;b:pdlINTEGER;l,r:integer;_asc:boolean);
    public
     property value[x:integer]:tpoint read getvalue write setvalue;
     property svalue[x:integer]:tpoint read getsvalue write setsvalue;
     property items:pdlPOINT read iitems;
     function find(_start:integer;_value:tpoint):integer;
    end;

{tdynamicintegerlist}
    tdynamicintegerlist=class(tobject)
    private
     irows:tdynamicobject;
     function getrow(x:integer):tdynamicinteger;
     function getcount:integer;
     procedure setcount(x:integer);
    public
     //create
     constructor create;
     destructor destroy; override;
     //other
     procedure del(x:integer);
     property row[x:integer]:tdynamicinteger read getrow;
     property count:integer read getcount write setcount;
     procedure clear;
    end;

{tdynamiccurrency}
    tdynamiccurrency=class(tdynamiclist)
    private
     iitems:pdlCURRENCY;
     function getvalue(_index:integer):currency;
     procedure setvalue(_index:integer;_value:currency);
     function getsvalue(_index:integer):currency;
     procedure setsvalue(_index:integer;_value:currency);
     procedure _init; override;
     procedure _corehandle; override;
    protected
     procedure _sort(_asc:boolean); override;
     procedure __sort(a:pdlCURRENCY;b:pdlINTEGER;l,r:integer;_asc:boolean);
    public
     property value[x:integer]:currency read getvalue write setvalue;
     property svalue[x:integer]:currency read getsvalue write setsvalue;
     property items:pdlCURRENCY read iitems;
     function find(_start:integer;_value:currency):integer;
    end;

{tdynamicdouble}
    tdynamicdouble=class(tdynamiclist)
    private
     iitems:pdlDOUBLE;
     function getvalue(_index:integer):double;
     procedure setvalue(_index:integer;_value:double);
     function getsvalue(_index:integer):double;
     procedure setsvalue(_index:integer;_value:double);
     procedure _init; override;
     procedure _corehandle; override;
    protected
     procedure _sort(_asc:boolean); override;
     procedure __sort(a:pdlDOUBLE;b:pdlINTEGER;l,r:integer;_asc:boolean);
    public
     property value[x:integer]:double read getvalue write setvalue;
     property svalue[x:integer]:double read getsvalue write setsvalue;
     property items:pdlDOUBLE read iitems;
     function find(_start:integer;_value:double):integer;
    end;

{tdynamicdatetime}
    tdynamicdatetime=class(tdynamiclist)
    private
     iitems:pdlDATETIME;
     function getvalue(_index:integer):tdatetime;
     procedure setvalue(_index:integer;_value:tdatetime);
     function getsvalue(_index:integer):tdatetime;
     procedure setsvalue(_index:integer;_value:tdatetime);
     procedure _init; override;
     procedure _corehandle; override;
    protected
     procedure _sort(_asc:boolean); override;
     procedure __sort(a:pdlDATETIME;b:pdlINTEGER;l,r:integer;_asc:boolean);
    public
     property value[x:integer]:tdatetime read getvalue write setvalue;
     property svalue[x:integer]:tdatetime read getsvalue write setsvalue;
     property items:pdlDATETIME read iitems;
     function find(_start:integer;_value:tdatetime):integer;
    end;

{tdynamicrect}
    tdynamicrect=class(tdynamiclist)
    private
     iitems:pdlRECT;
     function getvalue(_index:integer):trect;
     procedure setvalue(_index:integer;_value:trect);
     function getsvalue(_index:integer):trect;
     procedure setsvalue(_index:integer;_value:trect);
     procedure _init; override;
     procedure _corehandle; override;
    protected
     procedure _sort(_asc:boolean); override;
     procedure __sort(a:pdlRECT;b:pdlRECT;l,r:integer;_asc:boolean);
    public
     property value[x:integer]:trect read getvalue write setvalue;
     property svalue[x:integer]:trect read getsvalue write setsvalue;
     property items:pdlRECT read iitems;
     function find(_start:integer;_value:trect):integer;
    end;

{tdynamicpointer}
    tdynamicpointer=class(tdynamiclist)
    private
     iitems:pdlPOINTER;
     function getvalue(_index:integer):pointer;
     procedure setvalue(_index:integer;_value:pointer);
     function getsvalue(_index:integer):pointer;
     procedure setsvalue(_index:integer;_value:pointer);
     procedure _init; override;
     procedure _corehandle; override;
    public
     property value[x:integer]:pointer read getvalue write setvalue;
     property svalue[x:integer]:pointer read getsvalue write setsvalue;
     property items:pdlPOINTER read iitems;
     function find(_start:integer;_value:pointer):integer;
    end;

{tdynamicnotifyevent}
    tdynamicnotifyevent=class(tdynamiclist)
    private
     iitems:pdlNOTIFYEVENT;
     function getvalue(_index:integer):tnotifyevent;
     procedure setvalue(_index:integer;_value:tnotifyevent);
     function getsvalue(_index:integer):tnotifyevent;
     procedure setsvalue(_index:integer;_value:tnotifyevent);
     procedure _init; override;
     procedure _corehandle; override;
    public
     property value[x:integer]:tnotifyevent read getvalue write setvalue;
     property svalue[x:integer]:tnotifyevent read getsvalue write setsvalue;
     property items:pdlNOTIFYEVENT read iitems;
     function find(_start:integer;_value:tnotifyevent):integer;
    end;

{tdynamicmsgproc}
    tdynamicmsgproc=class(tdynamiclist)
    private
     iitems:pdlMSGPROC;
     function getvalue(_index:integer):tmsgproc;
     procedure setvalue(_index:integer;_value:tmsgproc);
     function getsvalue(_index:integer):tmsgproc;
     procedure setsvalue(_index:integer;_value:tmsgproc);
     procedure _init; override;
     procedure _corehandle; override;
    public
     property value[x:integer]:tmsgproc read getvalue write setvalue;
     property svalue[x:integer]:tmsgproc read getsvalue write setsvalue;
     property items:pdlMSGPROC read iitems;
     function find(_start:integer;_value:tmsgproc):integer;
    end;

{tdynamicobject}
    tdynamicobject=class(tdynamiclist)
    private
     iitems:pdlOBJECT;
     function getvalue(_index:integer):tobject;
     procedure setvalue(_index:integer;_value:tobject);
     function getsvalue(_index:integer):tobject;
     procedure setsvalue(_index:integer;_value:tobject);
     procedure _init; override;
     procedure _corehandle; override;
    public
     procedure freeValue(p:integer);
     procedure freeValues;
     property value[x:integer]:tobject read getvalue write setvalue;
     property svalue[x:integer]:tobject read getsvalue write setsvalue;
     property items:pdlOBJECT read iitems;
     function find(_start:integer;_value:tobject):integer;
     function new(obj:tobject):integer;
    end;

{tdynamicstring}
    tdynamicstring=class(tdynamiclist)
    private
     iitems:pdlSTRING;
     function getvalue(_index:integer):string;
     procedure setvalue(_index:integer;_value:string); virtual;
     function getsvalue(_index:integer):string;
     procedure setsvalue(_index:integer;_value:string);
     procedure _oncreateitem(sender:tobject;index:integer); override;
     procedure _onfreeitem(sender:tobject;index:integer); override;
     procedure _init; override;
     procedure _corehandle; override;
     function gettext:string;
     procedure settext(x:string);
    protected
     procedure _sort(_asc:boolean); override;
     procedure __sort(a:pdlSTRING;b:pdlINTEGER;l,r:integer;_asc:boolean);
    public
     property text:string read gettext write settext;
     property value[x:integer]:string read getvalue write setvalue;
     property svalue[x:integer]:string read getsvalue write setsvalue;
     property items:pdlSTRING read iitems;
     function find(_start:integer;_value:string;_casesensitive:boolean):integer;
    end;

{tdynamicname}
    tdynamicname=class(tdynamicstring)
    private
     iref:tdynamiccurrency;
     function _setparams(_count,_size,_bpi:integer;_notify:boolean):boolean; override;
     procedure setvalue(_index:integer;_value:string); override;
     procedure shift(s,by:integer); override;
    public
     //create
     procedure _createsupport; override;
     procedure _destroysupport; override;
     //other
     function findfast(_start:integer;_value:string):integer;
     procedure sync(x:integer);
     //internal
     property ref:tdynamiccurrency read iref;
    end;

{tdynamicnamelist}
    tdynamicnamelist=class(tdynamicname)
    private
     iactive:integer;
    public
     //vars
     delshrink:boolean;
     //create
     constructor create; override;
     property active:integer read iactive;
     procedure clear; override;
     function add(x:string):integer;
     function addb(x:string;newonly:boolean):integer;
     function addex(x:string;newonly:boolean;var isnewitem:boolean):integer;
     function addonce(x:string):boolean;//true=non-existent and added, false=already exists
     function del(x:string):boolean;
     function have(x:string):boolean;
     function replace(x,y:string):boolean;//can't prevent duplications if this proc is used
     procedure delindex(x:integer);//30AUG2007
    end;

{tdynamicbit}
    tdynamicbit=class(tobject)
    private
     isize:integer;
     icore:tdynamicbyte;
     procedure setsize(x:integer);
     function getvalue(x:integer):boolean;
     procedure setvalue(x:integer;y:boolean);
     procedure _oncreateitem(sender:tobject;index:integer);
     function gettext:string;
     procedure settext(x:string);
    public
     //create
     constructor create;
     destructor destroy; override;
     //other
     procedure clear;
     property size:integer read isize write setsize;
     property value[x:integer]:boolean read getvalue write setvalue;
     //ultra-fast workers
     procedure settrue(x:integer);
     procedure setfalse(x:integer);
     procedure info(var _true,_false:integer);
     //text
     procedure pulltext(var x:string);
     procedure pushtext(var x:string);
     property text:string read gettext write settext;
    end;

{tdynamicmatrix}
    tdynamicmatrix=class(tobject)
    private
     isize,irowsize,ibpi,iwidth:integer;
     icore:tdynamicpointer;
     procedure _oncreateitem(sender:tobject;index:integer);
     procedure _onfreeitem(sender:tobject;index:integer);
     procedure setbpi(x:integer);//bytes per item
     procedure setwidth(x:integer);
     procedure setheight(x:integer);
     function getheight:integer;
     function getscanline(x:integer):pointer;
    public
     //create
     constructor create;
     destructor destroy; override;
     //other
     procedure clear;
     function setparams(_width,_height,_bpi:integer):boolean;
     property bpi:integer read ibpi write setbpi;//bytes per item
     property width:integer read iwidth write setwidth;
     property height:integer read getheight write setheight;
     property size:integer read isize;
     property rowsize:integer read irowsize;
     property scanline[x:integer]:pointer read getscanline;
     //internal
     property core:tdynamicpointer read icore;
    end;

{tdynamicbitmap}
    tdynamicbitmap=class(tdynamicmatrix)
    private
     function getpixel(_x,_y:integer):integer;
     procedure setpixel(_x,_y,_c:integer);
    public
     //create
     constructor create;
     //workers
     property pixels[x,y:integer]:integer read getpixel write setpixel;
     function pushto(a:tobject;dx,dy:integer;var e:string):boolean;
     function copyfrom(a:tobject;var e:string):boolean;
     procedure flush;
    end;

{tdynamicvars}
    tdynamicvars=class(tobject)
    private
     function getcount:integer;
     function getvalue(n:string):string;
     procedure setvalue(n,v:string);
     function getvaluei(x:integer):string;
     function getname(x:integer):string;
     function getnettext:string;
     procedure setnettext(x:string);
     procedure setmultipart(h:string;x:string);//26-MAY-2006
     function _find(n,v:string;_newedit:boolean):integer;
     procedure setincsize(x:integer);
     function getincsize:integer;
     function getb(x:string):boolean;
     procedure setb(x:string;y:boolean);
     function getd(x:string):double;
     procedure setd(x:string;y:double);
     function getc(x:string):currency;
     procedure setc(x:string;y:currency);
     function geti(x:string):integer;
     procedure seti(x:string;y:integer);
     function getnc(x:string):currency;
     function getni(x:string):integer;
     function getvalueiptr(x:integer):pstring;
    protected
     inamesREF:tdynamiccurrency;
     inames:tdynamicstring;
     ivalues:tdynamicstring;
    public
     //vars
     debug:boolean;
     debugtitle:string;
     storerawvalue:boolean;//true=keeps a raw copy of var (varname_raw) when "nettext:=xxxx", false=default - 28FEB2008
     //create
     constructor create; virtual;
     destructor destroy; override;
     //wrappers
     property s[x:string]:string read getvalue write setvalue;//22SEP2007
     property b[x:string]:boolean read getb write setb;//boolean
     property i[x:string]:integer read geti write seti;//integer
     property ni[x:string]:integer read getni;//numercial comma integer - slow
     property d[x:string]:double read getd write setd;//currency
     property c[x:string]:currency read getc write setc;//currency
     property nc[x:string]:currency read getnc;//numercial comma currency - slow
     procedure roll(x:string;by:currency);
     //other
     procedure clear; virtual;
     function new(n,v:string):integer;
     function find(n:string):integer;
     function found(n:string):boolean;
     function foundb(n:string;var i:integer):boolean;
     property value[n:string]:string read getvalue write setvalue;
     property valuei[x:integer]:string read getvaluei;
     property valueiptr[x:integer]:pstring read getvalueiptr;
     property name[x:integer]:string read getname;
     property count:integer read getcount;
     property nettext:string read getnettext write setnettext;
     property multipart[h:string]:string write setmultipart;
     property incsize:integer read getincsize write setincsize;
     procedure copyfrom(x:tdynamicvars);
     procedure copyvars(x:tdynamicvars;i,e:string);
     procedure delete(x:integer);
     //io
     function pull(hdr:string;var data,e:string):boolean;
     function push(hdr:string;var data,e:string;append:boolean):boolean;
     function savetofile(x,hdr:string;var e:string):boolean;
     function loadfromfile(x,hdr:string;var e:string;append:boolean):boolean;
     //internal
     property namesREF:tdynamiccurrency read inamesREF;
     property names:tdynamicstring read inames;
     property values:tdynamicstring read ivalues;
    end;

{tdynamictext}
    tdynamictext=class(tobject)
    private
     ivars:tdynamicvars;
     function getvalue(x:string):string;
     procedure setvalue(x,y:string);
     function gettext:string;
     procedure settext(x:string);
     function getc(x:string):currency;
     procedure setc(x:string;y:currency);
     function getd(x:string):double;
     procedure setd(x:string;y:double);
     function geti(x:string):integer;
     procedure seti(x:string;y:integer);
     function getb(x:string):boolean;
     procedure setb(x:string;y:boolean);
     procedure setnettext(x:string);
     function getnettext:string;
     procedure setmultipart(h:string;x:string);
    public
     //create
     constructor create;
     destructor destroy; override;
     //workers
     property value[x:string]:string read getvalue write setvalue;
     property s[x:string]:string read getvalue write setvalue;//22SEP2007
     property c[x:string]:currency read getc write setc;
     property d[x:string]:double read getd write setd;
     property i[x:string]:integer read geti write seti;
     property b[x:string]:boolean read getb write setb;
     property nettext:string read getnettext write setnettext;
     property multipart[h:string]:string write setmultipart;
     procedure clear;
     //text
     procedure add(x:string);
     procedure addb(x:string;_clear:boolean);
     property text:string read gettext write settext;
     //io
     function loadfromfile(x:string;var e:string):boolean;
     function savetofile(x:string;var e:string):boolean;
     //internal
     property vars:tdynamicvars read ivars;
    end;

{tqueuestring}
    tqueuestring=class(tobject)//fast in/out queue of strings with extra info for basic network support (ip,port,tag)
    private
     istate:tdynamicbyte;//0=free,1=hold,2=inuse
     idata:tdynamicstring;
     itag,iip:tdynamicinteger;
     iport:tdynamicword;
     iactive,isize,ipushpos,ipullpos:integer;
     procedure setsize(x:integer);
     procedure syncactive;
    public
     //create
     constructor create;
     destructor destroy; override;
     //information
     property active:integer read iactive;
     property size:integer read isize write setsize;
     //workers
     function canclear:boolean;
     procedure clear;
     function canpush:boolean;
     function push(_data:string):boolean;
     function pushex(_data:string;_ip:integer;_port:word;_tag:integer):boolean;
     function canpull:boolean;
     function pull(var _data:string):boolean;
     function pullex(var _data:string;var _ip:integer;var _port:word;var _tag:integer):boolean;
    end;

{tcachebasic}
    tcachestatus=(chsOffline,chsOutOfDISK,chsOutOfRAM,chsOK);
    pcachebuffer=^tcachebuffer;
    tcachebuffer=array[0..32767] of byte;
    tcachehead=packed record
      ver:array[0..3] of char;
      pullindex:integer;
      pushindex:integer;
      end;
    tcachebasic=class(tobject)
    private
     istatus:tcachestatus;
     ifile:tfilestream;
     itimeout,itimeoutDIM,ibytesDISK,ibytesRAM,itimer,iheadsize,ibpi,iactive,iioindex,ipullindex,ipushindex,ilimit,isize:integer;
     ifilename:string;
     iheadchanged,iopen:boolean;
     iemptybuffer:tcachebuffer;
     iid:tdynamicinteger;
     idata:tdynamicbyte;
     procedure setsize(x:integer);
     procedure setfilename(x:string);
     function sizeDISK(x:integer):boolean;
     function roll(var _indexREF,_value:integer;_size:integer):boolean;
     procedure _ontimer(sender:tobject);
     procedure setpullindex(x:integer);
     procedure setpushindex(x:integer);
     //io
     procedure ioclear;
     procedure ioclearitem(x:integer);
     function iofind(x:integer;var y:integer):boolean;
     function ioread(x:integer;var rec):boolean;
     function iowrite(x:integer;var rec):boolean;
     function getiosize:integer;
     procedure setiosize(x:integer);
     //timeout - used for higher level instances
     procedure settimeout(x:integer);
     procedure _dimTIMEOUT;
    public
     title:string;
     beeponload:boolean;
     activetimeintensive:boolean;//information purposes
     //internal
     //.inuse
     function getinuse(x:integer):boolean; virtual;
     procedure setinuse(x:integer;y:boolean); virtual;
     //.ram
     function bpiRAM:integer; virtual;
     function sizeRAM(x:integer):boolean; virtual;
     function fromRAM(x:integer;var rec):boolean; virtual;
     function toRAM(x:integer;var rec):boolean; virtual;
     //.misc
     procedure activeinc(up:boolean);
     function getactive:integer; virtual;
     //create
     constructor create(_bpi:integer);
     destructor destroy; override;
     procedure _createsupport; virtual;
     procedure _destroysupport; virtual;
     //information
     property bpi:integer read ibpi;
     property limit:integer read ilimit;
     property size:integer read isize write setsize;
     property active:integer read getactive;
     function activeSYNC:integer;
     property status:tcachestatus read istatus;
     property bytesDISK:integer read ibytesDISK;
     property bytesRAM:integer read ibytesRAM;
     //file
     property filename:string read ifilename write setfilename;
     property open:boolean read iopen;
     //items
     function valid(x:integer):boolean;
     property inuse[x:integer]:boolean read getinuse write setinuse;
     //.read
     function readhead:boolean;//internal only
     function read(x:integer;var rec):boolean;
     function readitem(x:integer):boolean;
     //.write
     function writehead:boolean;//internal only
     function write(x:integer;var rec):boolean;
     function writeitem(x:integer):boolean;
     //.clear
     function clear:boolean; virtual;
     function clearitem(x:integer):boolean;
     //.io
     property iosize:integer read getiosize write setiosize;
     //.pull/push
     property pullindex:integer read ipullindex write setpullindex;
     function pull(var rec):boolean;
     function pullex(var rec;searchrange:integer):boolean;
     property pushindex:integer read ipushindex write setpushindex;
     function push(var rec):boolean;
     function pushex(var rec;searchrange:integer):boolean;
     //.timeout
     property timeout:integer read itimeout write settimeout;
     property timeoutDIM:integer read itimeoutDIM;
    end;

{tcacheexample}
    tcacheexampleREC=packed record
      inuse:boolean;
      value:integer;
      ref:currency;
      str:array[0..99] of char;
      end;
    tcacheexample=class(tcachebasic)
    private
     iinuse:tdynamicboolean;
     icore:tdynamicinteger;
     function getvalue(x:integer):integer;
     procedure setvalue(x:integer;y:integer);
     procedure setref(x:integer;y:currency);
     function getref(x:integer):currency;
     procedure setstr(x:integer;y:string);
     function getstr(x:integer):string;
    public
     //internal
     function getinuse(x:integer):boolean; override;
     procedure setinuse(x:integer;y:boolean); override;
     function bpiRAM:integer; override;
     function sizeRAM(x:integer):boolean; override;
     function fromRAM(x:integer;var rec):boolean; override;
     function toRAM(x:integer;var rec):boolean; override;
     //create
     constructor create;
     procedure _createsupport; override;
     procedure _destroysupport; override;
     //items
     property value[x:integer]:integer read getvalue write setvalue;
     property ref[x:integer]:currency read getref write setref;
     property str[x:integer]:string read getstr write setstr;
    end;

{tnotifylist}
    tnotifylist=class(tobject)
    private
     iupdsys:currency;
     ievent:tdynamicnotifyevent;
     function getcount:integer;
     function getactive:integer;
    public
     //create
     constructor create;
     destructor destroy; override;
     //items
     function new(_event:tnotifyevent):integer;
     procedure del(var _instance:integer);
     //notify
     procedure notify;
     procedure notifyb(ms:currency);
     property active:integer read getactive;
     property count:integer read getcount;
    end;

  {tvirtualstorage}
    tvirtualstoragemode=(vsmNone,vsmReadfromcontrols,vsmWritetocontrols,vsmUpdatecontrols);
    tvirtualstorage=class(trootobject)
    private
     imode:tvirtualstoragemode;
     ivalue,idefault,irange:tdynamicstring;
     iappearance:tdynamicboolean;
     istyle:tdynamicbyte;
     iinuse:tdynamicboolean;
     isize,itimer,iid,iioid:integer;
     iapplymodified,icanautosave,iautosave:boolean;
     iapplys:tnotifylist;
     irangeintFONTSIZES,ifontsizes:string;
     function getb(x:integer):boolean;
     procedure setb(x:integer;y:boolean);
     function geti(x:integer):integer;
     procedure seti(x:integer;y:integer);
     function getc(x:integer):currency;
     procedure setc(x:integer;y:currency);
     function gete(x:integer):extended;
     procedure sete(x:integer;y:extended);
     function gets(x:integer):string;
     procedure sets(x:integer;y:string);
     procedure _ontimer(sender:tobject);
     function getstyle(x:integer):tstoragestyle;
     function getdefault(x:integer):string;
     procedure setdefault(x:integer;y:string);
     function getrange(x:integer):string;
     procedure setrange(x:integer;y:string);
     procedure setsize(x:integer);
     property size:integer read isize write setsize;
     function rangeb(x:integer;y:boolean):boolean;
     function rangei(x:integer;y:integer):integer;
     function rangec(x:integer;y:currency):currency;
     function rangee(x:integer;y:extended):extended;
     function ranges(x:integer;y:string):string;
     procedure _defaults(full:boolean);
     function getappearance(x:integer):boolean;
     procedure setappearance(x:integer;y:boolean);
     function gettext:string;
     procedure settext(x:string);
     function getblock:string;
     procedure setblock(x:string);
    public
     //vars
     locked:boolean;//TRUE=default, prevents any controls from being updated while system is booting
     autosavelocked:boolean;
     //create
     constructor create; override;
     constructor createsys(sysVar:prootobject); override;
     destructor destroy; override;
     function _autosave:boolean;
     //.delete support
     procedure deletefinalise;
     //values
     //.core
     procedure initsystem;
     function init(x:integer;_style:tstoragestyle):boolean;
     function initfill(x:integer;_style:tstoragestyle;_default,_range:string):boolean;
     function initfillb(x:integer;_style:tstoragestyle;_default,_range:string;_appearance:boolean):boolean;
     property default[x:integer]:string read getdefault write setdefault;
     property style[x:integer]:tstoragestyle read getstyle;
     //.range
     property range[x:integer]:string read getrange write setrange;
     function rangebol(val:boolean):string;
     function rangeint(min,max:integer):string;
     function rangecur(min,max:currency):string;
     function rangeext(min,max:extended):string;
     function rangestrFONTNAME:string;
     function rangestrLENGTH(len:integer):string;
     property rangeintFONTSIZES:string read irangeintFONTSIZES;
     property fontsizes:string read ifontsizes;
     //.rangeref
     procedure rangerefi(x:string;var min,max:integer);
     //.get/set
     property b[x:integer]:boolean read getb write setb;
     property i[x:integer]:integer read geti write seti;
     property c[x:integer]:currency read getc write setc;
     property e[x:integer]:extended read gete write sete;
     property s[x:integer]:string read gets write sets;
     //.other
     function inrange(x:integer):boolean;
     property count:integer read isize;
     //apply connections
     function connect(_event:tnotifyevent):integer;
     procedure disconnect(var _instance:integer);
     //io
     function filename:string;
     function filenameb(_programname:string):string;
     //.save
     function save(var e:string):boolean;
     function savetofile(x:string;var e:string):boolean;
     //.load
     function load(var e:string;full:boolean):boolean;
     function loadfromfile(x:string;var e:string;append,full:boolean):boolean;
     //.text
     property text:string read gettext write settext;
     function settextb(x:string;full:boolean;var e:string):boolean;
     //.block - used to transfer entire scheme in one text block chunk
     property block:string read getblock write setblock;
     function setblockex(x:string;prompt:boolean;var e:string):boolean;
     //.copy/paste
     procedure copyto;
     function canpastefrom:boolean;
     procedure pastefrom;
     //.internal
     function pull(hdr:string;var data,e:string):boolean;
     function push(hdr:string;var data,e:string;append,full:boolean):boolean;
     //.id
     property id:integer read iid;
     property ioid:integer read iioid;
     //information
     property appearance[x:integer]:boolean read getappearance write setappearance;
     //other
     property mode:tvirtualstoragemode read imode write imode;//allow for external modification (rare, but needed for some occasions)
     procedure writetocontrols;
     procedure apply;
     procedure defaults(prompt:boolean);
     procedure defaultsb(prompt,full:boolean);
     procedure changed;
     procedure clear;
    end;

{tvirtualimage - bass class}
    ppixelinfo=^tpixelinfo;
    tpixelfilter=function(var p:trgbcolor;pinfo:ppixelinfo):boolean;
    tpixelstyle=(plsSolid,plsTransparent,plsReplace,plsTranswhite);
    tpixelinfo=record//reserved for future
       //rows
       rpos:integer;
       rmax:integer;
       //style
       style:tpixelstyle;
       find:trgbcolor;
       replace:trgbcolor;
       //2
       usefind2:boolean;
       find2:trgbcolor;
       replace2:trgbcolor;
       //filter
       filterON:boolean;
       filter:tpixelfilter;
       //transwhite
       transwhite:boolean;
       end;

    tvirtualimage=class(tobject)
    private
     ibuffer:tbitmap;//pointer only
     ilocked,iempty:boolean;
     ifind2,ireplace2,ifind,ireplace,ibytes,ihlen,iwidth,iheight:integer;
     istyle:tpixelstyle;
     //.paint
     ifilter:tpixelfilter;
     iinfo:tpixelinfo;
     procedure setwidth(x:integer); virtual;
     procedure setheight(x:integer); virtual;
     function getpixel(x,y:integer):integer; virtual;
     procedure setpixel(x,y:integer;z:integer); virtual;
     function getscanline(y:integer):pointer; virtual;
     procedure settext(x:string); virtual;
     function gettext:string; virtual;
     procedure setcolor(_color:integer);
     procedure dorow(s,d:prgbcolorrow;y,xmin,xmax:integer;reverse,copy:boolean);//Updated: 19-JUN-2006
    public
     //vars
     tag:integer;
     //create
     constructor create; virtual;
     destructor destroy; override;
     //dimensions
     property empty:boolean read iempty;
     property width:integer read iwidth write setwidth;
     property height:integer read iheight write setheight;
     function setparams(w,h:integer):boolean; virtual;
     //size
     property bytes:integer read ibytes;
     //lookup
     property pixels[x,y:integer]:integer read getpixel write setpixel;
     property scanline[y:integer]:pointer read getscanline;
     function xyp(x,y:integer;var p:integer):boolean;//xy coordinates to linear position
     //transfer
     function settep(x:string;var e:string):boolean;
     function setbitmap(x:tbitmap;var e:string):boolean;
     property text:string read gettext write settext;
     function copyfrom(x:tobject;var e:string):boolean;
     function copyfromb(x:tobject;tep:string;pf:tpixelfilter;var e:string):boolean;
     //functions
     property color:integer write setcolor;//cls
     //paint
     function lock:boolean;
     function unlock:boolean;
     property locked:boolean read ilocked;
     property filter:tpixelfilter read ifilter write ifilter;
     property style:tpixelstyle read istyle write istyle;
     property find:integer read ifind write ifind;
     property replace:integer read ireplace write ireplace;
     property find2:integer read ifind2 write ifind2;
     property replace2:integer read ireplace2 write ireplace2;
     procedure setfiltersb(_style:tpixelstyle;_find,_replace,_find2,_replace2:integer);
     procedure setfilters(_filter:tpixelfilter;_style:tpixelstyle;_find,_replace,_find2,_replace2:integer);
     //pullrow
     function pullrow(y:integer;reverse:boolean):boolean;
     function pullrowb(y,xstart,xcount:integer;reverse:boolean):boolean;
     //pullall
     function pullall(flip,mirror:boolean):boolean;
     function pullallb(xstart,xcount:integer;flip,mirror:boolean):boolean;
     //pullrows
     function pullrows(ystart,ycount:integer;flip,mirror:boolean):boolean;
     function pullrowsb(ystart,ycount,xstart,xcount:integer;flip,mirror:boolean):boolean;
     //buffer
     function pullraw:boolean;//copy internal image to "buffer" in raw (ignores transparency etc)
     property buffer:tbitmap read ibuffer;//paint buffer
    end;

{tvirtualbitmap}
    tvirtualbitmap=class(tvirtualimage)
    private
     idata:pstring;
     procedure settext(x:string); override;
     function gettext:string; override;
     function getpixel(x,y:integer):integer; override;
     procedure setpixel(x,y:integer;z:integer); override;
     function getscanline(y:integer):pointer; override;
    public
     //create
     constructor create; override;
     destructor destroy; override;
     //size
     function setparams(w,h:integer):boolean; override;
     //internal
     property data:pstring read idata;
    end;

{tvirtualbitmapanimated}
    panimationinformation=^tanimationinformation;
    tanimationinformation=record
     format:string;//uppercase EXT (e.g. JPG, BMP, SAN etc)
     subformat:string;//same style as format, used for dual format streams "ATEP: 1)animation header + 2)image"
     filename:string;
     transparent:boolean;
     flip:boolean;
     mirror:boolean;
     delay:integer;
     itemindex:integer;
     count:integer;//0..X (0=1cell, 1=2cells, etc)
     bpp:byte;
     binary:boolean;
     //final
     readB64:boolean;//true=image was b64 encoded
     writeB64:boolean;//true=encode image using b64
     //internal
     iosplit:integer;//position in IO stream that animation sep. (#0 or "#" occurs)
     cellwidth:integer;
     cellheight:integer;
     end;

    tvirtualbitmapanimated=class(tobject)
    private
     ipai:panimationinformation;
     iai:tanimationinformation;
     iimage:tvirtualbitmap;
     itimer:integer;
     izeroframe,irun,ipainting:boolean;
     function getempty:boolean;
     procedure _ontimer(sender:tobject);
     procedure synctimer;
     function getpixel(x,y:integer):integer;
     function gettransparentcolor:integer;
     procedure setrun(x:boolean);
     procedure setai(x:tanimationinformation);
     procedure setanimationb(x:string);
    public
     //var
     host:tvirtualcontrol;
     tag:integer;
     tagstr:string;//04SEP2007
     tag2:integer;//04SEP2007
     dtransparent:boolean;
     //events
     onprepaint:tnotifyevent;
     onpaint:tnotifyevent;
     onpostpaint:tnotifyevent;
     //create
     constructor create(_host:tvirtualcontrol);
     destructor destroy; override;
     //set
     function setanimation(x:string;var e:string):boolean;
     property animation:string write setanimationb;
     function setparams(x:tanimationinformation;_paint:boolean):boolean;
     function copyfrom(x:tobject;var e:string):boolean;
     function copyfromb(x:tobject;tep:string;pf:tpixelfilter;_count,_delay:integer;_transparent,_flip,_mirror,_run:boolean;var e:string):boolean;
     //paint
     function canpaint:boolean;
     procedure paint;
     property painting:boolean read ipainting;
     //draw
     procedure drawto(canvas:tcanvas;area:trect;linebyline:boolean;filter:tpixelfilter;background,fontcolor:integer);
     procedure drawtoex(dest:tbitmap;area:trect;linebyline:boolean;filter:tpixelfilter;background,fontcolor:integer);
     //pixels
     property pixels[x,y:integer]:integer read getpixel;
     //information
     property ai:tanimationinformation read iai write setai;
     property pai:panimationinformation read ipai;
     property run:boolean read irun write setrun;
     property zeroframe:boolean read izeroframe write izeroframe;//TRUE=paints frame 0 when run=false(no matter what "index" is), FALSE=paints "index" frame even when run=false
     property transparentcolor:integer read gettransparentcolor;
     property empty:boolean read getempty;
     //internal only
     property img:tvirtualbitmap read iimage;
     //io
     function loadfromfile(x:string;var e:string):boolean;
    end;

{tvirtualiconanimated}
    tvirtualiconanimatedevent=procedure(sender:tobject;icon:ticon) of object;
    tvirtualiconanimated=class(tobject)
    private
     ipaintindex,itimer:integer;
     iapp,irun,imasterrun,ipainting:boolean;
     iicons:tdynamicstring;
     procedure setanimation(x:string);
     procedure paint;
     procedure setrun(x:boolean);
     procedure setmasterrun(x:boolean);
     function getcount:integer;
     function getcanrun:boolean;
     procedure syncrun;
     procedure _ontimer(sender:tobject);
    public
     //events
     onchange:tvirtualiconanimatedevent;
     //create
     constructor create;
     destructor destroy; override;
     //workers
     property animation:string write setanimation;
     property run:boolean read irun write setrun;
     property canrun:boolean read getcanrun;//required 2 or more frames to be TRUE, else FALSE
     property count:integer read getcount;
     //internal or system related
     property app:boolean read iapp write iapp;//TRUE=handles application.icon, FALSE(default)=onchange event only
     property masterrun:boolean read imasterrun write setmasterrun;
    end;

{tsampleint}
    tsampleint=class(tobject)
    private
     ipushcount,iave:integer;
     ivalues:tdynamicinteger;
     function getsize:integer;
     procedure setsize(x:integer);
     function getvalue(x:integer):integer;
     procedure setvalue(x,y:integer);
     procedure update;
    public
     //create
     constructor create;
     destructor destroy; override;
     //size
     property size:integer read getsize write setsize;
     //push
     procedure push(x:integer);
     property pushcount:integer read ipushcount;
     //value
     property ave:integer read iave;
     property values[x:integer]:integer read getvalue write setvalue;
     //other
     procedure clear;
    end;

{trolltext}
    trolltext=class(tobject)
    private
     ialltext:boolean;
     iposition:integer;
     iitems:tdynamicstring;
     function getsize:integer;
     procedure setsize(x:integer);
     function gettext:string;
     function getlines(x:integer;up:boolean):string;
     function getitemindex(x:integer):integer;
     function getitem(x:integer):string;
    public
     //create
     constructor create;
     destructor destroy; override;
     //workers
     procedure flush;
     procedure roll(x:string);
     property alltext:boolean read ialltext write ialltext;
     property position:integer read iposition;
     property size:integer read getsize write setsize;
     property text:string read gettext;
     property lines[bytes:integer;up:boolean]:string read getlines;
     property items[x:integer]:string read getitem;
     //internal
     property itemindex[x:integer]:integer read getitemindex;//index converter
    end;

{tscrolltext}
    tscrolltext=class(tobject)
    private
     icore:tdynamicstring;
     iposition:integer;
     function gettext:string;
     procedure settext(x:string);
     function getcount:integer;
    public
     //vars
     alltext:boolean;
     //create
     constructor create;
     destructor destroy; override;
     //other
     property text:string read gettext write settext;
     property position:integer read iposition;
     property count:integer read getcount;
     procedure clear;
     function pull:string;
    end;

{tnamevalue}
     tnamevalue=class(tobject)
     private
      iio:tio;
      iin:tdynamicname;
      iiv:tdynamicstring;
      iionames:string;
      inativeformat:integer;
      function getname(x:integer):string;
      function getvalue(x:string):string;
      function getvaluei(x:integer):string;
      procedure setvaluei(x:integer;y:string);
      function getvalueptr(x:integer):pstring;
      procedure setvalue(x:string;y:string);
      function gettext:string;
      procedure settext(x:string);
      function _findname(x:string):integer;
      function getionames:string;
      procedure setnativeformat(x:integer);
     public
      //create
      constructor create;
      destructor destroy; override;
      //host
      procedure clear;
      //.name
      property names[x:integer]:string read getname;
      function findmask(i,e:string):integer;
      function findname(x:string):integer;
      function newname(x:string):integer;
      function allnames:string;
      function allnamesex(sep:string;aslabels:boolean):string;
      function inuse(x:string):boolean;
      procedure del(x:string;eatINFO:boolean);
      function ias(_names:string):integer;//items as size
      //.value
      property values[x:string]:string read getvalue write setvalue;
      property valuesi[x:integer]:string read getvaluei write setvaluei;
      property valuesptr[x:integer]:pstring read getvalueptr;
      //.stats
      function count:integer;
      function usedcount:integer;//actual number of items being used
      function limit:integer;
      //workers
      procedure copyfrom(s:tnamevalue;_mask:string);
      procedure copyfromex(s:tnamevalue;_mask:string;_unpack:boolean);
      //other
      //.ionames - used by IO system to write items (if ionames='' then all items are written)
      property ionames:string read getionames write iionames;
      //io
      property nativeformat:integer read inativeformat write setnativeformat;
      property io:tio read iio;
      function push(_format:integer;var x,e:string):boolean;
      function pull(_format:integer;var x,e:string):boolean;
      property text:string read gettext write settext;
      function savetofile(x:string;var e:string):boolean;
      function loadfromfile(x:string;_format:integer;var e:string):boolean;
     end;

{tmultilingual}
    ptranshitinfo=^ttranshitinfo;
    ttranshitinfo=record
      good:currency;
      fail:currency;
      total:currency;
      end;
    ptransinfo=^ttransinfo;
    ttransinfo=record
      total:integer;
      error:integer;
      main:integer;
      help:integer;
      unused:integer;
      //used counts
      utotal:integer;
      uerror:integer;
      umain:integer;
      uhelp:integer;
      uunused:integer;
      end;//end of record
    tmultilingual=class(trootobject)
    private
     iactive:ttransinfo;
     ipactive:ptransinfo;
     ihit:ttranshitinfo;
     iphit:ptranshitinfo;
     ieng:tdynamicnamelist;
     ioth:tdynamicstring;
     isyserr,iinuse:tdynamicboolean;
     ilasteng,ilastoth:string;
     itimer:integer;
     imustupdateinfo:boolean;
     function getcount:integer;
     procedure sfc(var x,y,z:string;_replace:boolean);//swap first character
     procedure _ontimer(sender:tobject);
     procedure syncinfo;
    public
     caption:string;
     tep:string;
     details:string;
     ex1:string;
     ex2:string;
     ka:string;
     kb:string;
     kc:string;
     kd:string;
     //create
     constructor create; override;
     constructor createsys(sysVar:prootobject); override;
     destructor destroy; override;
     //information
     property eng:tdynamicnamelist read ieng;
     property oth:tdynamicstring read ioth;
     property active:ttransinfo read iactive;
     property pactive:ptransinfo read ipactive;
     property hit:ttranshitinfo read ihit;
     property phit:ptranshitinfo read iphit;
     function stats(showall:boolean;colsep,linesep:string):string;
     //other
     property count:integer read getcount;
     procedure clear;
     function findeng(x:string;var i:integer):boolean;
     function addonce(_eng,_oth:string):boolean;
     function sync(_eng,_oth:string):boolean;
     procedure clearlast;//clear last memory - used when "transup" is updated
     //translate
     function translate(_eng:string;var _oth,e:string;_style:byte):boolean;
     //io
     //.push
     function push(var x,e:string):boolean;
     function load(var e:string):boolean;
     function loadfromfile(x:string;var e:string):boolean;
     //.pull
     function pull(var x,e:string):boolean;
    end;

{tsplash}
    tsplash=class(trootobject)
    private
     ix,iy:integer;
     ionce,ipseonce,ipse:boolean;
     iform:tform;
     ifont:tfont;
     ishadecolor,ibgcolor,iclientwidth,iclientheight,ipt,iph:integer;
     imode:byte;
     iimg:tbitmap;
     FOnShow:TNotifyEvent;
     procedure _onkey(Sender: TObject; var Key: Word; Shift: TShiftState);
     procedure _onpaint(sender:tobject);
     procedure _onshow(sender:tobject);
     procedure _onclick(sender:tobject);
     procedure setimg(x:tbitmap);
     procedure _show;
     procedure pse;//perform special effects
     procedure paint;
     procedure _onum(sender:tobject);
     procedure _hide;
     procedure noimage;
     procedure _onmousemove(sender:tobject;shift:tshiftstate;x,y:integer);
    public
     showname:boolean;
     newv:boolean;
     //help
     help:string;
     //create
     constructor create; override;
     destructor destroy; override;
     property form:tform read iform;
     //year
     function year(min:integer):integer;
     //dimensions
     property clientwidth:integer read iclientwidth;
     property clientheight:integer read iclientheight;
     //image
     function loadfromfile(x:string;var e:string):boolean;
     property img:tbitmap read iimg write setimg;
     //fill
     function read(var eat,e:string):boolean;
     procedure fill(_name:string;_shadecolor,_color,_size:integer;_style:tfontstyles;_x,_y:integer);
     //splash
     procedure splash;
     procedure about;
     procedure hide;
     //events
     property OnShow:TNotifyEvent Read FOnShow Write FOnShow;
    end;

{TMasks}
    PMaskItems=^TMaskItems;
    TMaskItems=record
      bm:string;//base mask - always present
      dm:string;//default mask - present only if input is "nil"
      m:string;//mask
      i:array[0..mktcMax] of string;//items
      sc:array[0..mktcMax] of word;//slash count
      ews:array[0..mktcMax] of boolean;//ends with slash
      all:boolean;//TRUE=all i.e "*" else FALSE=different masks see "i[0]..i[c]"
      c:integer;
      end;//end of record

    PMaskAttr=^TMaskAttr;
    TMaskAttr=record
      Archive:boolean;
      ReadOnly:boolean;
      Hidden:boolean;
      System:boolean;
      Volume:boolean;
      end;//end of record

    PMaskFileList=^TMaskFileList;
    TMaskFileList=record
      fb:currency;//files in bytes
      fc:currency;//file count
      dc:currency;//directory count
      end;//end of record

    TMasks=class(tobject)
    private
     iisc:boolean;//include slash count
     ifm:TMaskAttr;//file mode
     ipfm:PMaskAttr;
     iinfo:TMaskItems;
     ipinfo:PMaskItems;
     icancelled:boolean;
     FOnChange:TNotifyEvent;
     procedure dc;
     function GetDefMask:string;
     procedure SetDefMask(x:string);
     function GetBaseMask:string;
     procedure SetBaseMask(x:string);
     procedure SetMask(x:string);
     function GetMask:string;
     procedure fi;//fill items
     function mia(x:string):boolean;//mask is ALL
     function aemd(x:string):string;//as expanded mask data
    public
     //padders - used for text searching i.e mask="Fred01;Mary" => "<pre>Fred01<post>;<pre>Mary<post"
     prepad:string;
     postpad:string;
     {create}
     constructor create;
     {other}
     //masks
     property info:PMaskItems read ipinfo;
     property mask:string read GetMask write SetMask;//""
     property dmask:string read GetDefMask write SetDefMask;//"*"
     property bmask:string read GetBaseMask write SetBaseMask;//""
     procedure clear;
     //slash count
     property isc:boolean read iisc write iisc;
     //other
     property fm:PMaskAttr read ipfm write ipfm;
     function fl(x:string;_sd:boolean;var r:TMaskFileList;_nameonly:boolean):string;
     function _fl(x:string;_sd:boolean;_fm:TMaskAttr;var r:TMaskFileList;_nameonly:boolean):string;
     function wm(x:string):boolean;//within mask
     function nwm(_n:string;var _m:string):boolean;//name within mask
     function cm(x:string):string;//clean mask
     property cancelled:boolean read icancelled;
     procedure cancel;
     {events}
     property OnChange:TNotifyEvent read FOnChange write FOnChange;
    end;

{talerts}
    talertstyle=set of (alsAudio,alsEnhancedAudio,alsShow,alsVibrate,alsUser);
    taudiostyle=(adsNone,adsStandard,adsEnhanced,adsCustom);
    talerts=class(tobject)
    private
     iactive,ivibrate,ishow:integer;
     ivsID,isystem,itimer:integer;
     icanvibrate,icanshow:boolean;
     procedure _ontimer(sender:tobject);
     procedure _onsystem(sender:tobject);
     procedure setvibrate(x:integer);
     procedure setshow(x:integer);
     procedure setactive(x:integer);
     procedure _dec(var x:integer);
    public
     //events
     onstyle:tnotifyevent;
     onactive:tnotifyevent;
     onuser:tnotifyevent;
     //create
     constructor create;
     destructor destroy;
     //vibrate
     property vibrate:integer read ivibrate write setvibrate;
     //show
     property show:integer read ishow write setshow;
     //active
     property active:integer read iactive write setactive;//-1=forever,0=stop,1..X=limited
     function isactive:boolean;
    end;

{tpg - "program"}
    tcursorisestyle=set of (crssWinControl,crssRootControl,crssChildren);
    tpgsetup=set of (pstNoPlacement,pstNoSplash);
    tpg=class(trootobject)
    private
     iicons:tvirtualiconanimated;
     iads:tstripscroll;
     ihelp:tvirtualhelp;
     iapp:tfilestream;
     istyle:tpgsetup;
     ilockwnd,ihandle:hwnd;
     itime,icursortime:currency;
     imodalcount,isyslockcount,isetup,itimer,ilastapp:integer;
     icursorlast:tpoint;
     imsg:tliteform;
     iuc,ishortfilename,ifilename,imaxpath,imaxcomputer:string;
     isuw,iontop,ishowingsplash,itranslated,imodified,isystray,ibooting:boolean;
     isystrayinfo:tnotifyicondata;
     ialerts:talerts;
     ionminimize,ionrestore,ionicon:tnotifyevent;
     function getboot:boolean;
     procedure setboot(x:boolean);
     procedure setsystray(x:boolean);
     procedure setontop(x:boolean);
     function getcomputer:string;
     function getuser:string;
     procedure setfilename(x:string);
     procedure setmodified(x:boolean);
     function getminimized:boolean;
     procedure setminimized(x:boolean);
     procedure _onminimize(sender:tobject);
     procedure _onrestore(sender:tobject);
     function _wndproc(hWnd:HWND;Msg:UINT;wParam:WPARAM;lParam:LPARAM):LRESULT;stdcall;
     function geticon:ticon;
     procedure _onicon(sender:tobject);
     procedure _ontimer(sender:tobject);
     function getlockupdate:boolean;
     procedure setlockupdate(x:boolean);
     function getcursoridle:currency;
     function getcanus:boolean;//can unpack support
     function getshouldus:boolean;//should unpack support
     procedure setuc(x:string);//set "menu" unlock caption
     function getcanclone:boolean;
     function getcandelete:boolean;
     function gethelp:string;
     procedure sethelp(x:string);
    public
     //vars
     cansplash:boolean;
     startminimised:boolean;
     //events
     onminimize:tnotifyevent;
     onrestore:tnotifyevent;
     onicon:tnotifyevent;
     ue:tnotifyevent;//unlock execute - remote unlock link
     //system - users are not to use these
     procedure visyncnow;
     //create
     constructor create; override;
     destructor destroy; override;
     property handle:hwnd read ihandle;
     //app
     function appactivefilename:string;//CDROM compatiable - 12JAN2008
     function appactive:boolean;//12JAN2008
     procedure apprelease;//12JAN2008
     //paths
     property computer:string read getcomputer;
     property user:string read getuser;
     //titles
     property modified:boolean read imodified write setmodified;
     property filename:string read ifilename write setfilename;
     property shortfilename:string read ishortfilename;
     procedure settitles;
     //workers
     procedure place(category:string);
     property boot:boolean read getboot write setboot;
     property ontop:boolean read iontop write setontop;
     //system tray
     procedure syncapp;
     property systray:boolean read isystray write setsystray;
     property minimized:boolean read getminimized write setminimized;
     procedure hidefromview;
     property lastapp:integer read ilastapp;
     //icon
     property icon:ticon read geticon;
     property icons:tvirtualiconanimated read iicons;
     //program
     property style:tpgsetup read istyle;
     procedure setup(va,vb,splX,splY:integer;_style:tpgsetup;shadecolor,fontcolor:integer);
     procedure done(width,height:integer);//24JAN2008
     procedure showsplash;//auto "cursorisenow's" program's mainform
     procedure hidesplash;
     //clone
     property canclone:boolean read getcanclone;
     procedure clone;
     //delete (remove program)
     property candelete:boolean read getcandelete;
     procedure delete;
     //modal
     procedure modal(lock:boolean);
     //booting
     property booting:boolean read ibooting;
     //unlock caption
     property uc:string read iuc write setuc;
     property suw:boolean read isuw write isuw;//show unlock window
     //support
     property canus:boolean read getcanus;
     property shouldus:boolean read getshouldus;
     procedure usprompt(prompt:boolean);//prompt to unpack
     function us(var e:string):boolean;
     //sync support folders
     function cansyncsupportfolders:boolean;
     procedure syncsupportfolders;
     //alerts
     property alerts:talerts read ialerts;
     //update
     property lockupdate:boolean read getlockupdate write setlockupdate;
     //cursor
     property cursoridle:currency read getcursoridle;
     //testing
     procedure rerun;
     //simple text-html help
     function helppath:string;//12JAN2008
     procedure delhelp;//03JAN2008
     function canhelp:boolean;
     procedure showhelp(text:boolean);//03JAN2008
     //interactive help
     property help:string read gethelp write sethelp;
     //other
     property maxpath:string read imaxpath;
     property maxcomputer:string read imaxcomputer;
     procedure update;
    end;

{tdebug}
    tdebug=class(trootobject)
    private
     iform:tvirtualform;
     itext:tvirtualtext;
     imsvalue,ims:currency;
     function gettext:string;
     procedure settext(x:string);
    public
     //create
     destructor destroy; override;
     //area
     function srect(x,y,w,h:integer;digpad:integer):string;
     function sarea(x:trect;digpad:integer):string;
     function scontrolrect(x:twincontrol;digpad:integer):string;
     //numbers
     function sint2(a,b:integer):string;
     function sint3(a,b,c:integer):string;
     function sint4(a,b,c,d:integer):string;
     function rgb1(x:trgbcolor):string;
     //time
     procedure msstart;
     procedure msstop;
     procedure msshow;
     function msstr:string;
     property msvalue:currency read imsvalue;
     //strings
     function chars(x,sep,linesep:string):string;
     function showfiles2(f1,f2:string;s,f:integer):string;
     //text
     property text:string read gettext write settext;
     //system
     procedure showalldlgs;
    end;

{twec}
    twec=class(trootobject)
    private
     ihoneypoturl:string;//23DEC2007
     procedure sethoneypoturl(x:string);
    public
     //web error messages
     e400BadRequest,
     e401AuthorizationRequired,
     e403Forbidden,
     e4031ClientBanned,
     e4032UrlBanned,
     e4033ProtocolNotSupported,
     e4034FeedbackLoopDetected,
     e4035PasswordRequired,
     e4036ServiceDisabled,
     e404NotFound,
     e405MethodNotAllowed,
     e416RequestedRangeNotSatisfiable,
     e5031TooManyUsers,
     e5032NoConnection,
     e5033NoGateway,
     e5041ConnectionTimeout,
     e5042GatewayTimeout:string;
     e910TaskFailed:string;
     //vars
     admincontact:string;//email or webaddress
     info:string;
     //create
     constructor create; override;
     destructor destroy; override;
     //honeypot
     property honeypoturl:string read ihoneypoturl write sethoneypoturl;
     function honeypotLINK:string;//use to insert hidden link to other html documents
     //other
     function format(code:integer;typ,msg,des:string):string;
     procedure update;
     //workers
     function find(code:integer;var z:string):boolean;//22FEB2008
    end;

{tgeneral}
    pparseurl=^tparseurl;
    tparseurl=record
     u:string;//original url
     h:string;//host "www.blaiz.net" or "abc.com" or ""<error>
     p:string;//path "/" or "" or "/docs" or "/docs/"
     f:string;//file "index.html" or "" or "HOME.HTM"
     e:string;//extension ("HTM HTML TXT ASP" etc)
     d:string;//data "?key=33&data=41"
     m:string;//page mark "#basics"
     pt:word;
     //other
     cu:string;//clean url
     ca:string;//clean address (host or host:port)
     //used for "ip-port" addresses (pusIPPort)
     ip:integer;
     end;//end of record

    //create ref,create ref using uppercase,allow duplicates,allow null
    tparseurlstyle=set of (pusExcludeData,pusExcludeMark,pusExcludePort,pusExcludeCollapse,pusExcludeCleanURL,pusExcludeQuotes,pusIPPort,pusExcludePathClean);
    TGeneralSortSet=set of (glssRef,glssRefUC,glssDup,glssNull);
    trsfSTYLE=set of (rsfTestOnly,rsfIncBy,rsfSize);
    tgeneral=class(trootobject)
    Private
     iprogramserial:currency;
     imachineserial,iunique_system_id:integer;
     iprogramserialSTR,imachineserialSTR:String;
     iUpdSys:currency;
     ierrlist:tdynamicnamelist;
     function _fromHEX(x:string):Integer;
     function _toHEX(x:byte):char;
    Public
     //create
     constructor create; override;
     destructor destroy; override;
     //special numbers
     property machineserial:integer read imachineserial;//serial number of "C" drive
     property programserial:currency read iprogramserial;
     property machineserialSTR:string read imachineserialSTR;//serial number of "C" drive
     property programserialSTR:string read iprogramserialSTR;
     function selfGTI(t:integer):string;//self as Global Task ID
     function toGTI(m,p,t:integer):string;//to Global Task ID
     function fromGTI(x:string;var m,p,t:integer):boolean;//from Global Task ID
     {routines}
     //set
     function setBOL(new:boolean;var value:boolean):boolean;
     function setWRD(new:integer;var value:word):boolean;
     function setINT(new:integer;var value:integer):boolean;
     function setSTRING(new:string;var value:string):boolean;
     function setWINCONTROL(new:twincontrol;var value:twincontrol):boolean;
     //lock (all return LOCKED status}
     function lockbool(var x:boolean):boolean;
     function lock(var x:integer):boolean;
     function unlock(var x:integer):boolean;
     function locked(x:integer):boolean;
     function lockb(var x:integer;var _lockedVAR:boolean;_onchange:tnotifyevent;sender:tobject):boolean;
     function unlockb(var x:integer;var _lockedVAR:boolean;_onchange:tnotifyevent;sender:tobject):boolean;
     //strings
     //.upto
     function uptob(x:string;sep:char):string;
     function upto(var x:string;sep:char):string;
     //.other
     function AsWin95(x:string):string;//21-AUG-2004
     function asname(x:string):string;//10JUN2007
     function strs(_use2:boolean;_str1,_str2:string):string;//22-SEP-2004
     function ptc(x:char):boolean;//plain text character
     function plaintext(x:string;allowLATIN1:boolean):string;//25NOV2007
     function eptc(x:char):boolean;//enhanced/plain text character
     function keywordsb(x:string;limit:integer):string;//extract keywords
     function keywordclean(x:string):string;//31-JAN-2007
     function keywords(var x:string;limit:integer;var count:integer):string;//31-JAN-2007
     function split(var x,x1,x2:string;z:char):boolean;
     function findbrkval(var _pos:integer;var _data:string;_type:char):string;//find bracket value
     function notDS09AZ(var pos:integer;var x:string):boolean;//finds character outside of range
     function findchar(var x:string;c:char):integer;
     function findchardown(var x:string;c:char):integer;//15SEP2007
     function havechar(var x:string;c:char):boolean;//02FEB2008
     function havecharU(var x:string;c:char):boolean;//02FEB2008
     function copyupto(var x:string;c:char):string;//14SEP2007
     function copyuptob(x:string;c:char):string;
     function copydowntob(x:string;c:char):string;//19OCT2007
     function copydownto(var x:string;c:char):string;//19OCT2007
     function findchars(var _pos,_listpos:integer;var _data:string;_list:string):boolean;
     function findtext(var _pos:integer;var _data:string;_find:string):boolean;
     function findtextb(var _pos:integer;_len:integer;var _data:string;_find:string):boolean;
     function findtextL(var _pos:integer;_len:integer;var _data:string;_find:string):boolean;
     function byteslines(var x:string;xbytes:integer):string;
     function firstline(var _data:string):string;
     function firstlineb(_data:string):string;
     function firstNBL(var _data:string):string;//first non-blank line
     function xxxlineb(count:integer;_data:string):string;
     function xxxline(count:integer;var _data:string):string;
     function linecount(var _data:string):integer;//18JAN2008
     function nextline(var _pos:integer;var _data,_line:string):boolean;
     function readline(var _pos,_start,_length:integer;var _data:string):boolean;
     function readlineb(var _pos,_start,_length:integer;var _data:string;var _winrc:boolean):boolean;
     function readvalueb(var _pos:integer;var _data,_value:string):boolean;
     function readvalue(var _pos,_start,_length:integer;var _data:string):boolean;
     function readbasehref(var x,u:string):boolean;//find <base href="http://www.blaiz.net"> and return "http://www.blaiz.net"
     function readlink(var _pos,_start,_length:integer;var _data:string):boolean;
     function isunix(var _data:string):boolean;
     procedure parseexts(x:string;y:tdynamicname);//parse extensions list
     procedure urlAUTODATA(getpost,url:string;var u,content:string);
     function urlDATA(u:string):string;
     procedure urlDATAb(url:string;var u,d:string);
     function urlEXT(u:string):string;//date: 01-FEB-2005
     function urlEXTb(u:string;var pos:integer):string;//date: 01-FEB-2005
     function urlcpath(x:string):string;//collapse url path
     function fqb(var x:string;var ri,rc:integer):boolean;//find quote boundaries
     function src(var x:string):integer;//server reply code
     function srcb(var x:string;defcode:integer):integer;//server reply code
     procedure remdupc(var x:string;c:char);//remove duplicate characters
     procedure remsymbols(var x:string);//remove html symbols - &nbsp; &mdash; "&ABCDEFG;"
     procedure rembinary(var x:string);//remove binary characters
     procedure rcr(var x:string;s,f:byte);//remove character range
     procedure rcrb(var x:string;f:string);//remove characters defined by "f"
     function networkcodes(sep,eol:string):string;
     //NETWORK ERRORS
     function ecd(c:integer):string;//error code description
     function ecdb(c:integer;t:boolean):string;//error code description
     function ecdc(c:integer;var d:string):boolean;
     function neterrCount:integer;
     function neterr(c:integer;var d:string):boolean;//network error codes
     //SYSTEM ERRORS
     function syserrCount:integer;
     function syserr(c:integer;var d:string):boolean;//system error codes
     function syserrFind(x:string;var i:integer):boolean;
     //other
     procedure whXXX(var x:string;sn,lastmodified,e,mimedef:string;c:integer;nocache:boolean);
     procedure whCODE(var header,content:string;code:integer);//write coded server response - 22FEB2008
     procedure whREPLY(var header,content:string;data,dataext:string);//automatically write server reply - 22FEB2008
     procedure whBUFFERS(var _header,_content:string;sn,lastmodified,ext,mimedef:string;c:integer;nocache:boolean);//write header to header buffer
     procedure whBUFFERSb(var _header,_content:string;sn,lastmodified,ext,mimedef:string;c:integer;nocache,contentlength:boolean);//write header to header buffer
     function ufnSTRING(x:string):string;
     function ufn(url:string):string;//url as filename (http://google.com/index.html -> google_com_index.html)
     function ufnb(url:string;includeURL:boolean):string;//url as filename (http://google.com/index.html -> google_com_index.html)
     function safefilename(x:string;allowpath:boolean):string;//19-JUN-2005
     function putb(x:string):string;
     function put(var x:string;var r,rLEN:integer;all:boolean):boolean;//parse url type "X..Z://" ie. "http://, https://, ftp://" etc
     procedure pub(u,ou:string;var i:tparseurl;s:tparseurlstyle;dp:word);
     procedure puc(u,ou:string;var i:tparseurl;s:tparseurlstyle;dp,fp:word);//parse url 05-JUL-2005, updated 03-FEB-2007
     procedure pu(u,ou:string;var i:tparseurl;s:tparseurlstyle);//parse url
     procedure puCLEAR(var x:tparseurl);
     function readmeta(var x:string;xp:integer;var name,content:string;var pos:integer):boolean;
     function readmetab(var x:string;xp,xlen:integer;var name,content:string;var pos:integer):boolean;
     procedure robotsmeta(content:string;var canindex,canfollow:boolean);
     function filterTDK(x:string;xmaxsize:integer):string;//Updated to "nearest whole word" on 27-JAN-2007, removes "&nbsp;" on 18-MAR-2007
     function trimtoword(x:string;maxlen:integer):string;
     function textgood(x:string):boolean;//non-white text
     procedure getTDK(var _data:string;agent:string;maxscan,tSIZE,dSIZE,kSIZE:integer;var t,d,k:string;var canindex,canfollow:boolean);//extract raw title/description/keywords
     procedure rawTDK(var _data:string;agent:string;maxscan,tSIZE,dSIZE,kSIZE:integer;var tlarge,t,d,k:string;var canindex,canfollow:boolean);//extract raw title/description/keywords - 18MAR2007
     procedure chop(var x:string;var xlen:integer;index,count:integer);
     function udv(v,dv:string):string;//use default value
     function lsp(xsize:integer;x:string):string;//left-align string padding
     function rsp(xsize:integer;x:string):string;//right-align string padding
     function replacec(n,s:string;index:integer):string;
     function replaceb(n:string;var s:string;index,count:integer;var schange:integer):boolean;//modify sub-string
     function replace(var n,s:string;index,count:integer;var schange:integer):boolean;//modify sub-string
     //stringlists
     function fle(n:string;list:tstringlist):integer;//find list element
     //high speed filters
     function aslf(x:string):string;//as single line filter
     procedure rdfs(x:string;var i,e:string);//read dual filters
     procedure rdfsb(x:string;var i,e:string;sep:char);//read dual filters
     function indf(x:string;var i,e:string):boolean;//in dual filter
     function indfb(x:string;sep:char;var i,e:string):boolean;//in dual filter
     function inf(x:string;var f:string):boolean;//in filter (v1.00.081/29-DEC-2004)
     function infb(x:string;sep:char;var f:string):boolean;
     function _infb(var x:string;xlen:integer;var m:string;ms,mf:integer):boolean;
     //high speed string sets (partial string compare)
     function inps(x:string;sep:char;var f:string;matchcase:boolean):integer;//in partial set (v1.00.023/22-SEP-2005)
     function inpsb(var x:string;sep:char;var f:string;matchcase:boolean;var _fpos,_flen:integer):boolean;//in partial set (v1.00.023/22-SEP-2005)
     //robots.txt
     function robotnv(x:string;var n,v:string):boolean;
     procedure fromrobots(var x,f:string;agent:string;sep:char;flimit:integer);//updated 12-OCT-2005
     procedure fromrobotsb(x:string;var f:string;agent:string;sep:char;flimit:integer);
     function binary(var x:string):integer;
     //null
     function fromnullb(x:string):string;//24JAN2008 - removes trailing null's - i.e. null terminated string -> string
     procedure fromnull(var x:string);{removes trailing null's - i.e. null terminated string -> string}
     function nullstr(x:integer;y:char):string;
     function randomstr(x:integer):string;//21DEC2007
     //sort
     function SortByRef(var x:array of string;var xRef:array of integer;xCount:integer;y:TGeneralSortSet):integer;
     function ParseStr(var x:string;xSep:char;var z:array of string;zMaxCount:integer):integer;
     //files
     procedure fapne(x:string;var p,n,e:string);{filename as path/name/extension}
     procedure fane(x:string;var n,e:string);{filename as name/extension}
     function files(sPath:String;AsFullFileNames:Boolean):String;
     function filesex(spath:string;asfullfilenames:boolean;_sort:boolean):string;//23SEP2007
     function filesb(mask:string;full:boolean;_name:tdynamicstring;_size,_time:tdynamicinteger):boolean;
     function filesc(pathmask:string;_name,_fullname:tdynamicstring;_size,_time,_attr:tdynamicinteger;_date:tdynamicdatetime):boolean;//09-OCT-2006
     function filesize(x:string):integer;//25SEP2007
     function rword:word;
     function rwordSTR:string;
     function viewb(app,x,dv:string;var e:string):boolean;
     function view(app,x:string;var dv,e:string):boolean;
     //..from "tpaths"
     function serial(x:char):integer;
     function mkfile(x:string;y:integer):boolean;
     function sc(x:string):integer;//slash count
     function etls(x:string;bs:boolean):string;//extract to last slash
     function ednf(var x:string;y:integer):string;//extract dir name fragment, "left to right"
     function rsf(x:string;var os,ns:longint;_inc:longint;_style:trsfSTYLE;var e:string):boolean;//resize file 03-OCT-2004
     function forceEXT(x,_ext:string;_override:boolean):string;
     Function RemLastExt(X:String):String;{Remove Last Extension}
     function copyto(source,dest:string):boolean;
     function copytoex(s,d:string;var e:string):boolean;//05OCT2007
     function clean(_pathmask:string;_hours:integer):boolean;//removes files newer/older by "_hours"
     //ref
     function ref24DU(const x:string):integer;//updated 10-JUN-2006
     function ref32(const x:string):integer;
     function ref32U(const x:string):integer;//non-case sensitive
     function ref256(const x:string):currency;
     function ref256U(const x:string):currency;//non-case sensitive
     procedure ref256UD(const x:string;var ua,ub:integer);
     //rollers
     procedure iroll(var x:integer;by:integer);//continuous incrementer with safe auto. reset
     procedure irollb(var x:integer;by,ex:integer);//continuous incrementer with safe auto. reset to user specified value
     procedure croll(var x:currency;by:currency);//continuous incrementer with safe auto. reset
     procedure crollb(var x:currency;by,ex:currency);//continuous incrementer with safe auto. reset
     ///inc
     Procedure incInt(var x:integer);
     Procedure incCur(var x:currency);
     Procedure incxInt(var x:integer;by:integer);
     Procedure incxCur(var x:currency;by:currency);
     //compare
     Function StrsMatch(Mask,Name:String):Boolean;
     //boolean
     Function NB(X:String):Boolean;
     function bn(x:boolean):char;//14-JUN-2005
     {StdEncrypt:now supports plaintext in "14..255", plaintext out "14..255" on modes2&3}
     Function StdEncrypt(X:String;EKey:String;Mode1:Integer):String;{date: 22-FEB-2004}
     //colors
     Function ColShade(X,P:Integer):Integer;
     Function ColSplice(X,C1,C2:Integer):Integer;
     Function ColDark(X:Integer):Integer;
     Function ColBright(X:Integer):Integer;
     function nrw(x,y,r:integer):boolean;//number within range
     function cnrw(x,y,r:currency):boolean;//number within range - currency - 07MAR2008
     function dc(x,y:integer):integer;//differential color
     //colors - HEX
     function fromHEX(x:string):integer;
     function toHEX(x:integer;hash:boolean):string;//07-AUG-2004
     function toHEXex(x:integer;hash,_uppercase:boolean):string;//19-DEC-2006
     //control position
     Procedure MveControl(X,Y,W,H:Integer;Z:TWinControl);
     procedure PosControl(x,y:integer;z:twincontrol);
     procedure vibratecontrol(x:twincontrol);
     function controlstable(x:twincontrol):boolean;
     function findcontrol(x:twincontrol;y:tpoint;allowdisabled:boolean):tcontrol;
     function objin(x:tobject;y:array of tobject):boolean;
     //center
     procedure center(x:twincontrol;w,h:integer;_fullscreen:boolean);//work area
     procedure centerb(x:twincontrol;w,h:integer;a:trect);//work area
     procedure centerbyapp(x:twincontrol;w,h:integer;_fullscreen:boolean);
     //swap
     procedure SwapChars(var x:string;a,b:char);
     function swapcharsb(x:string;a,b:char):string;
     function swapstrsb(x,a,b:string):string;
     function SwapStrs(Var X:String;A,B:String):boolean;
     function swapstrsUb(var x:string;a,b,pr,pt:string;_word,_html:boolean):boolean;
     function swapstrsU(var x:string;a,b,pr,pt:string;_word,_html:boolean;_count:integer):boolean;//update 17-JAN-2006
     function remchar(var x:string;c:char):boolean;
     function remcharb(x:string;c:char):string;
     //numbers
     function posn(x:longint):longint;//positive number
     function oddn(x:longint):longint;//odd number
     function evenn(x:longint):longint;//even number
     function isodd(x:integer):boolean;
     function iseven(x:integer):boolean;
     Function Thousands(X:Integer):String;{fixed "minus problem" on 4-FEB-2004}
     function CurComma(x:currency):string;{same as "Thousands" but for "currency"}
     function curstrex(x:currency;sep:string):string;//07SEP2007
     function StrDec(a:string;y:byte;z:boolean):string;
     function CurDec(x:currency;y:byte;z:boolean):string;
     function insint(x:integer;y:boolean):integer;//insert integer
     function insstr(x:string;y:boolean):string;//insert string
     function ifstr(x,y:string):string;//insert string
     function ifstrex(x,pre,post:string):string;//insert string
     function aorb(a,b:integer;_useb:boolean):integer;
     function caorb(a,b:currency;_useb:boolean):currency;
     function eaorb(a,b:extended;_useb:boolean):extended;
     function ifdiv(x,divby:integer;_usediv:boolean):integer;
     function aorbstr(a,b:string;_useb:boolean):string;
     function percentage(x:extended;_symbol:boolean):string;//08-OCT-2006
     function percentageb(x:extended;points:byte;_symbol:boolean):string;
     function ipercentage(a,b:integer):extended;
     function cpercentage(a,b:currency):extended;
     procedure sortINT(var a:array of integer;l,r:integer;_asc:boolean);//ascending
     procedure dualsortINT(var a,b:array of integer;l,r:integer;_asc:boolean);//ascending
     function createid:integer;//1..N (-N..0=empty/invalid, 1..N=valid) - 09-MAY-2005
     function sdigpad(v:string;s:integer):string;//1 -> 01
     function digpad(v,s:integer):string;//1 -> 01
     function fromcents(x:integer):string;
     function tocents(x:string):integer;
     function fromcc(x:string):currency;//1,234,567 -> 1234567
     function fromci(x:string):integer;//1,234,567 -> 1234567
     //fonts
     function fm(x,y:tfont):boolean;//fonts match
     procedure afs(x:tfont;y:tfontstyle;z:boolean);//adjust font style
     procedure ifs(x:tfont;y:tfontstyle);//include font style
     procedure efs(x:tfont;y:tfontstyle);//exclude font style
     //time
     function dim(x:tdatetime):integer;//date in minutes
     function dayofyear(x:tdatetime):integer;//v1.00.009/30-DEC-2004
     //sound
     procedure shortbeep(_repeats:integer);
     procedure shortbeepb(_repeats,_delay,_strength:integer);
     //keyboard
     function keyON(k:integer):boolean;
     function keyESET(k:integer;_on:boolean):boolean;
     procedure shortblinkb(_key,_repeats,_delay:integer);
     procedure shortblink(_key,_repeats:integer);
     //other
     function pause:boolean;//no "application.processmessages"
     function updsys:boolean;//same as "pause", but with "application.processmessages"
     procedure wait(ms:integer);
     {Error}
     procedure iferror(x:string);
     procedure startfailure;
     procedure raiseerror(x:string);
     //program name
     function safeprogramname(x:string):string;//09-FEB-2007
    end;

{tdates}
    pdateZERO=^tdateZERO;
    tdateZERO=packed record
     year:integer;//-25,000..0..25,000
     month:byte;
     day:byte;
     hour:byte;
     minute:byte;
     second:byte;
     msec:word;
     end;
    tdatediv=array[0..6] of currency;
    tdateMS=currency;
    tdatestamp=set of (dspDate,dspBC,dspTime,dspAMPM,dspTranslate,dspShort,dspExcludeMS);
    tdates=class(trootobject)
    private
     idiv:tdatediv;
     inilZERO:tdateZERO;
     imonths:array[1..12] of string;
     imonths_abrv:array[1..12] of string;
     idays:array[1..7] of string;
     idays_abrv:array[1..7] of string;
     ibc,iam,ipm,igmt:string;
     iinit:boolean;
     function getday(x:byte;t:boolean):string;
     function getdayABRV(x:byte;t:boolean):string;
     function getmonth(x:byte;t:boolean):string;
     function getmonthABRV(x:byte;t:boolean):string;
     procedure init;//don't translate strings until we need them, makes booting smoother for dual translation systems
    public
     //create
     constructor create; override;
     destructor destroy; override;
     //.strings
     function wsd(d,m,y:word;sep:char):string;//write string date
     function wsdb(x:tdatetime;sep:char):string;//write string date
     procedure rsd(var d,m,y:word;sep:char;x:string);//read string date
     function yearLABEL(x:integer;bc,ad:string):string;
     function stamp(x:tdateZERO;s:tdatestamp):string;
     //.translated labels
     property day[x:byte;t:boolean]:string read getday;
     property dayABRV[x:byte;t:boolean]:string read getdayABRV;
     property month[x:byte;t:boolean]:string read getmonth;
     property monthABRV[x:byte;t:boolean]:string read getmonthABRV;
     //.ms
     procedure restrictZERO(var x:tdateZERO);
     function toMSb(x:tdateZERO):tdateMS;
     procedure toMS(var x:tdateZERO;var y:tdateMS);
     function fromMSb(x:tdateMS):tdateZERO;
     procedure fromMS(x:tdateMS;var y:tdateZERO);
     //.dt
     function toDT(x:tdateMS):tdatetime;//ms to datetime
     function fromDT(x:tdatetime):tdateMS;//datetime to ms
     function dtzero(x:tdatetime):tdateZERO;//datetime -> dateZERO
     function zerodt(x:tdateZERO):tdatetime;//dateZERO -> datetime
     //.filedate
     function toFILEDATE(x:tdateZERO):string;
     function toFILEDATEb(x:tdateZERO;sepA,sepB,sep1,sep2,sep3:string):string;
     function fromFILEDATE(x:string):tdateZERO;
     //.gmt
     function asGMT(x:tdatetime):tdatetime;//convert date to GMT date
     procedure gmtOFFSET(var h,m,factor:integer);
     function gmt(x:tdatetime):string;//gtm for webservers
     function gmtb(x:tdatetime;t:boolean):string;//gtm for webservers
     function gmtnow:string;
     function gmtnowb(t:boolean):string;
     //.log specific
     function logstyle:string;//01FEB2008
     function logstyleex(full:boolean):string;//01FEB2008
     //FILETIME
     function filedatetime(x:tfiletime):tdatetime;
     function fileage(x:thandle):tdatetime;
     //DATE
     function shortdate(x:tdatetime;t:boolean):string;
     function shortdateex(x:tdatetime;t,ordered:boolean):string;
     function date(x:tdatetime;sep:string;t,abrv:boolean):string;
     function dateex(x:tdatetime;sep:string;t,abrv,ordered:boolean):string;
     //TIME
     function shorttimeb(x:tdatetime;t,showsec:boolean):string;
     function shorttime(x:tdatetime;t:boolean):string;
     function time(x:tdatetime;sep,sep2:string;t,showsec:boolean):string;//02-AUG-2006
     //DATETIME
     function shortdatetimeb(x:tdatetime;t,showsec:boolean):string;
     function shortdatetime(x:tdatetime;t:boolean):string;
     //YEAR
     function year:word;
     function yearstr:string;
     //.other
     //..seconds
     function strYDHMS(xsec:integer):string;
     procedure toYDHMS(xsec:integer;var y,d,h,m,s:integer);
     //..minutes
     function strYDHMSb(xmin,xsec:integer):string;
     procedure toYDHM(xmin:integer;var y,d,h,m:integer);
     //.conversion
     function findmonth(x:string;var i:integer):boolean;
     function toDMY(shortdate:string;sep:char;var d,m,y:integer):boolean;
     //.64-bit
     function uptime(x:currency;t:boolean;sep:string):string;
     function uptimeb(x:currency;t,showms:boolean;sep:string):string;//Updated: 07SEP2007
    end;

{tresdata}
    tresdata=class(tcomponent)
    private
     iptr:pstring;//pointer to an external string for storage of data from "value"
     procedure setvalue(x:string);
     function getvalue:string;
    public
     //create
     constructor create(_ptr:pstring);
    published
     property value:string read getvalue write setvalue;
    end;

{html - common html elements that use system scheme colors and settings}
    thtml=class(trootobject)
    private
     ifaviconDONE:boolean;
     ifaviconICO,ifaviconGIF,ifaviconAGIF,ifaviconJPG:string;
     irows,icols,isize,iwidth:integer;
     procedure setrows(x:integer);
     procedure setcols(x:integer);
     procedure setsize(x:integer);
     procedure setwidth(x:integer);
    public
     //create
     constructor create; override;
     destructor destroy; override;
     //defaults
     property rows:integer read irows write setrows;
     property cols:integer read icols write setcols;
     property size:integer read isize write setsize;
     property width:integer read iwidth write setwidth;
     //workers
     function formbegin(f,_method:string):string;//18FEB2008
     function formend:string;
     function areabegin(_width:integer;_nowidth:boolean;_title:boolean):string;
     function areaend:string;
     function rowbegin(_width:integer;_nowidth:boolean;_title:boolean):string;//19FEB2008
     function row(_labels:array of string;_bgcolor,_title:boolean):string;//19FEB2008
     function rowBG(_labels:array of string;var _bgcolor:boolean;_title:boolean):string;
     function rowend:string;
     function fontcolor(_title:boolean):string;
     function bgcolor(_title:boolean):string;
     function cappage(_label,_deslabel,_links:string;_title:boolean):string;
     function cappageex(_favicon:boolean;_label,_deslabel,_links:string;_title:boolean):string;
     function cap(_label:string;_title:boolean):string;
     function capex(_label,_comment:string;_title:boolean):string;//22FEB2008
     function comment(_label:string;_title:boolean):string;
     function line(_title:boolean):string;
     function lineex(_size:integer;_title:boolean):string;
     function href(_label,_url,_currentpage:string;_title:boolean):string;
     function hrefex(_label,_url,_currentpage:string;_title:boolean;_encode:boolean):string;
     function localfile(_label,_varname:string;_size:integer;_title:boolean):string;//18FEB2008
     function text(_label,_line,_varname:string;_size:integer;_title:boolean):string;
     function textarea(_label,_text,_varname:string;_rows,_cols:integer;_wrap:boolean;_title:boolean):string;
     function tick(_label:string;_value:boolean;_varname:string;_title:boolean):string;
     function button(_label,_varname:string):string;
     function buttonsave:string;
     function buttonview:string;
     function buttonclear:string;
     function eol:string;//end of line
     function hsp:string;//horizontal space
     //favicon - multi-format support
     function favicon(ext:string):string;
     procedure faviconBUFFERS(ext:string;var header,content:string);
     //support
     function aswidth(_width:integer;_enable:boolean):string;
    end;

{tmisc}
    tdns=record//Note: never "fillchar()" this record, it uses dynamic strings "string"
     //header
     id:word;
     qr:boolean;
     opcode:byte;
     aa:boolean;
     tc:boolean;
     rd:boolean;
     ra:boolean;
     z:byte;
     rcode:byte;
     qdcount:word;
     ancount:word;
     nscount:word;
     arcount:word;
     //question
     qdata:string;
     qtype:word;
     qclass:word;
     //.answer
     andata:string;
     nsdata:string;
     ardata:string;
     maxlen:integer;//512bytes for UDP, higher for TCP
     end;//end of record

    turlfilestyle=(ufsUrlPathFile,ufsUrlFile,ufsPathFile,ufsFile,ufsSumUrlPathFile,ufsSumPathFile);
    taddresstype=(atUnknown,atLocal,atUrl,atEmail);
    tmisc=class(trootobject)
    private
     iimageextlist:tstringlist;
     iinitcrc32:boolean;
     icrc32:array[0..255] of integer;
     icursorfi:integer;
     iimg:tbitmap;
     icursorpath:string;
     procedure setcursorpath(x:string);
     procedure initcrc32;
     function getimageext(x:integer):string;
    public
     //create
     constructor create; override;
     destructor destroy; override;
     //simple effects
     function signalbar(pert:extended):string;//03SEP2007
     //midi
     procedure testmidi;
     procedure delmidi;
     //strip
     function stripHTTP(x:string):string;
     function striphtml(x:string):string;
     //string
     function enforceEOL(x:string):string;//12FEB2008
     function enforceEOLex(x:string;includeempty:boolean):string;//12FEB2008
     function yes(x:boolean):string;
     function yest(x:boolean):string;//translated version
     function passed(x:boolean):string;
     procedure realtimehelpUpgrade(pasFiles:array of string;rthText:string;saveoutput:boolean);//upgrade application's realtime help
     function extracttext(s:tstringlist;var output:string;findtext:string;var olinecount:integer):boolean;
     procedure remdup(x:tstringlist);
     function remdupb(x:string):string;//remove duplicates
     function insertampb(usedchars:string;x:string):string;
     function insertamp(var usedchars:string;x:string):string;
     function stringfixedlength(len:integer;_input:string;_null:char):string;
     //.snippet
     function snippetenhance(x:string;var r:string;var rlimit:integer;rlimitonly:boolean):boolean;//03MAR2008
     function snippetfound(snippets,data:string;var _snippetfound:string):boolean;//03MAR2008
     function snippetfoundex(snippets,data:string;var _snippetfound:string;_enhancedsnippets:boolean):boolean;//03MAR2008
     //internet services
     function calcservice(s:string;var d:string):boolean;
     function showservice(s:string):boolean;//runs service: mailto:, http:, callto: etc
     function findemail(var s,d:string):boolean;
     function findweb(var s,d:string):boolean;
     function findphone(var s,d:string):boolean;
     function findVoIP(var s,d:string):boolean;
     //crc32
     procedure crc32inc(var _crc32:integer;x:char);//31-DEC-2006
     procedure crc32(var _crc32:integer;var x:string;s,f:integer);//31-DEC-2006, updated 27-MAR-2007
     function crc32b(x:string):integer;
     //nav (basic support for tnav controls}
     function navtype(_image:string):string;
     function navaction(_image:string):string;
     procedure navfin(_image:string;var _type,_action,_class:string);//tnav: from image name
     function navbaa(_image,_name,_host,_path,_file:string;_navs:tdynamicstring):string;//tnav: build action address
     //url
     function ucc(u:string):byte;//convert url to contry code index
     function ecc(_domainext:string):byte;//convert domainext to contry code index
     function at(x:string):taddresstype;//address type (unknown,local,email,internet)
     function bu(x:string):string;//breakable url
     function EnforceService(X:String):String;
     function IsWebService(X:String):Boolean;
     function gat(x:string):byte;//get address type
     function hasurls(var x:string):boolean;
     function hasurlsb(x:string):boolean;
     function extracturls(x:string;onurl:tstringevent):string;
     function jpf(_path,_file:string):string;//join path and file
     function jpfb(_path,_file:string;sep:char):string;//join path and file
     function urlasfile(localpath,url:string;style:turlfilestyle):string;
     function isredirect(x:integer):boolean;
     //ip address
     function ip127(x:integer):boolean;//ip is "127.x.x.x"
     function iphighest(newip:integer;var ip:integer):boolean;//03FEB2008
     function ipmachine(x:integer):boolean;//ip is "local machine" 25JAN2008
     function ippublic(x:integer):boolean;//ip is "public (internet) network"
     function ipprivate(x:integer):boolean;//ip is "private network"
     function ipprivateex(x:integer;var _class:char):boolean;//ip is "private network"
     function iplist(x,sep:string):string;
     //file
     function shortfile(_longfilename:string):string;//translate long filenames to short filename, using MS api, for "MCI playback of filenames with 125+c" - 23FEB2008
     function isfolder(x:string):boolean;
     function mapfile(x:string):string;//remap
     function mapfileex(x:string;var z:string):boolean;//attempts to locate path/file (if "x" can't be found) 23SEP2007
     function subfile(x:string;xlimit:integer):string;//automatically returns a new filename based on "x" if x's size exceeds "xlimit" bytes
     function retainformatext(_filename,_retainfilename:string;_retain:boolean):string;
     //header - http, requires header to complete and independent, ie. not "HEADER+CONTENT" but just "HEADER"
     function readIP(var header:string;sourceip:integer):integer;//reads proxy-ip
     procedure headeradd(var h:string;n,v:string);
     procedure headeraddb(var h:string;n,v,rc:string);
     procedure headeraddex(var h:string;n,v,rc:string;_delete:boolean);
     procedure headerdel(var h:string;n:string);
     function headerfind(var h:string;n:string;var v:string):boolean;
     //timing
     function timeup(var _timeindex:currency;_delay:currency):boolean;
     //numbers
     function writeUNIX32(x:integer):string;//write unix 32bit number
     function writeUNIX16(x:word):string;//write unix 16bit number
     function readUNIX32(x:string):integer;//read unix 32bit number
     function readUNIX16(x:string):word;//read unix 16bit number
     function isnumber(x:string):boolean;
     function isint(x:string):boolean;
     function iscur(x:string):boolean;
     function ints(x:array of integer):integer;//add all numbers together
     function curs(x:array of currency):currency;//add all numbers together
     //TRichText
//yyy     procedure fc(x:trichedit);//font check
//yyy     function MaxLen(x:trichedit;y:integer):boolean;
     //font
     function fontheight(x:tfont):integer;
     function fontwidth(x:tfont;y:string):integer;
     //alignment
     function alignmentcalc(a:talignment;left,textwidth,right:integer):integer;
     //colors
     function savecolors(x:string;var y:array of integer;var e:string):boolean;
     function loadcolors(x:string;var y:array of integer;var e:string):boolean;
     function showcolor(var _color:integer):boolean;
     function rndsplashbc:integer;
     //folder
     function folderdlg(title:string;var path:string):boolean;
     function cansyncfolder(a,b:string):boolean;
     function syncfolder(a,b:string;var e:string):boolean;
     function syncfolderex(a,b:string;var count,ecount:integer;var e:string):boolean;
     //open/save
     function opendlg(defext,filters,idir:string;var filterindex:integer;var filename:string):boolean;
     function opendlgb(defext,filters,idir:string;filterindex:integer;var filename:string):boolean;
     function savedlg(defext,filters,idir:string;filterindex:integer;var filename:string;allowuserext:boolean):boolean;
     function savedlgb(defext,filters,idir:string;var filterindex:integer;var filename:string;promptreplace,allowuserext:boolean):boolean;
     function opendlgex(handle:thandle;defext,filters,idir,title:string;var filterindex:integer;var filename:string;isopen,promptreplace,allowuserext:boolean):boolean;
     //.direct io for text (with in-built prompt window)
     function getfilterext(x:string;i:integer):string;
     function getfilterextex(x,userext:string;i:integer):string;
     function getfilterinfo(_filename,_filters:string;var ext:string;var filterindex:integer):boolean;
     function opentext(var filename,data,e:string;filters:string;prompt:boolean):boolean;
     function opentextb(var filename,data,e:string;filters:string;var filterindex:integer;prompt:boolean):boolean;
     function savetext(var filename,data,e:string;filters:string;prompt:boolean):boolean;
     function savetextb(var filename,data,e:string;filters:string;var filterindex:integer;prompt:boolean):boolean;
     function openurl(var _address,_mask,_data,e:string;prompt:boolean):boolean;
     //dialogs
     //.cursor
     property cursorpath:string read icursorpath write setcursorpath;
     function cursordlg(var filename:string):boolean;
     //.image
     function imageextcount:integer;
     property imageext[x:integer]:string read getimageext;
     function imageexts:string;
     function imagelabel(extorfilename:string;var z:string):boolean;
     function imagelabelb(extorfilename:string):string;
     function imagelabelext(extorfilename,sep1,sep2:string):string;
     function imageextdes(extorfilename,sep:string):string;
     function imageextdesmany(manyextorfilenames:string;manysep:char;outsep,outeol:string):string;
     function imagefilters(all:boolean;sep1,sep2:string):string;
     function imagefiltersex(all:boolean;sep1,sep2,eol:string;var count:integer):string;
     function openimagedlg(a:tbitmap;idir:string;var filename:string):boolean;
     function saveimagedlg(a:tbitmap;idir:string;var filename:string):boolean;
     function saveimagedlgex(a:tbitmap;idir:string;var filename:string;var _saved:boolean):boolean;
     function pastefromimagedlg(var sfilename,dfilename:string):boolean;//04OCT2007
     //.support folders and information
     function supportcount:integer;
     function supportinfo(x:integer;var _label,_foldername,_realtimehelp:string):boolean;//return information about support folders
     //class
     function findclass(x:twincontrol;y:tclass):tobject;
     //internet ad
     function tofileIAD(x:string;url,des:string;image:tbitmap;var e:string):boolean;
     function toIAD(url,des:string;image:tbitmap;var data,e:string):boolean;
     function fromfileIAD(x:string;var url,des,image:string;var e:string):boolean;
     function fromIAD(var data,url,des,image:string;var e:string):boolean;
     //DELPHI
     //.block
     function toblock(x:string;perline:integer):string;
     //.object - read
     function dobRead(var pos:integer;var data,name,vs:string;var vi:integer;var useVI:boolean):boolean;//delphi object read
     //.object - write
     function dobHead(var len:integer;var data:string;name:string;init:boolean):boolean;
     procedure dobEnd(var len:integer;var data:string);
     function dobName(var name:string):boolean;
     procedure dobBoolean(var len:integer;var data:string;name:string;value:boolean);
     procedure dobInteger(var len:integer;var data:string;name:string;value:integer);
     procedure dobString(var len:integer;var data:string;name,value:string);
     //text enhancers (text => html)
     function helpise(x:string;html:boolean):string;
     function linkise(x:string):string;
     function linkiseb(x:string;_class:string):string;
     function filtertext(x:string):string;
     function filtertextb(x:string;removebrackets:boolean):string;
     function nospaces(x:string;_lowercase:boolean):string;//filtered content (no html code allowed)
     function htmlise(x:string):string;
     function htmliseb(x,_topicslabel,_generatorname:string;_topicsnumber,_nocopyright:boolean):string;//08NOV2007
     procedure htmlallow(var x:string;start,stop:string);
     procedure htmlallowb(var x:string;var okcount:integer;start,stop:string);
     //html support
     function htmlcaption(x:string;large:boolean):string;
     //generators
     function numbers(_from,_to:integer;sep:char):string;
     //raw binary storage
     function pushend(var xlen:integer;var x:string):boolean;
     function pushbol(var xlen:integer;var x:string;y:boolean):boolean;
     function pushbyt(var xlen:integer;var x:string;y:byte):boolean;
     function pushint(var xlen:integer;var x:string;y:integer):boolean;
     function pushcur(var xlen:integer;var x:string;y:currency):boolean;
     function pushstr(var xlen:integer;var x:string;y:string):boolean;
     function pullbol(var pos:integer;xlen:integer;var x:string;var y:boolean):boolean;
     function pullbyt(var pos:integer;xlen:integer;var x:string;var y:byte):boolean;
     function pullint(var pos:integer;xlen:integer;var x:string;var y:integer):boolean;
     function pullcur(var pos:integer;xlen:integer;var x:string;var y:currency):boolean;
     function pullstr(var pos:integer;xlen:integer;var x:string;var y:string):boolean;
     //bytes
     function b(x:currency;sym:boolean):string;
     function kb(x:currency;sym:boolean):string;
     function kbb(x:currency;p:byte;sym:boolean):string;
     function mb(x:currency;sym:boolean):string;
     function gb(x:currency;sym:boolean):string;
     //dynamic
     procedure reverseINT(x:tdynamicinteger;minp,maxp:integer);
     //data encoders
     function rd(var x:string;k:string):boolean;//rotate data
     function ro(var x,e:string):boolean;//reverse order
     function ll(var x:string;linesep:string;linelength:integer;var e:string):boolean;//line length
     //res file (.res) - use to pack/unpack internal data values
     function tores(name,value:string;var output,e:string):boolean;
     function fromres(name:string;var value,e:string):boolean;
     function respack(name,sfile,dfile:string;var e:string):boolean;
     function resunpack(name,filename:string;var e:string):boolean;
     function resread(name,mask:string;_nv:tnamevalue;var e:string):boolean;
     //strong decoder (note: encode must be commented out before release)
     function dt(x:string):string;//decode text - shows error and halts with NULL result
     //DNS
     //.support
     function dnsRCODENAME(x:byte):string;
     function dnsQTYPENAME(x:byte):string;
     procedure dnsinit(var x:tdns);
     procedure dnsshow(var x:tdns;comment:string);
     procedure dnsshowb(var x,y:tdns;xl,yl:string);
     function dnsreadQ(var x:tdns;var y:string;ylen:integer;var p:integer):boolean;
     function dnswritedomain(x:string):string;
     function dnswritedomainb(x:string;eod:boolean):string;
     function dnswritestr(x:string):string;
     function dnswriteRR(dn:string;_type,_class:word;_ttl,rdata:string):string;//write resource record
     //.main
     function dnsread(var y:tdns;x:string):boolean;
     function dnswrite(var y:tdns;var x:string):boolean;
     //PROGRAM
     procedure initprogramdata(var programdata:string);//10JAN2008
    end;

{tsuptrans}
    tsuptrans=class(trootobject)//custom translation system
    private
     ieng:tdynamicnamelist;
     ioth:tdynamicstring;
     istyle:tdynamicbyte;
     iactive:ttransinfo;
     ipactive:ptransinfo;
     ihit:ttranshitinfo;
     iphit:ptranshitinfo;
     ifull,imustupdateinfo:boolean;
     iid,ilimit,itimer:integer;
     ilanguage,idetails,itep:string;
     function gettext:string;
     procedure settext(x:string);
     function geteng(x:integer):string;
     function getoth(x:integer):string;
     procedure fill(x:string;init:boolean);
     procedure _ontimer(sender:tobject);
     procedure syncsizes;
     function getvalid(x:integer):boolean;
     procedure flush;
     procedure syncinfo;
    public
     //create
     constructor create; override;
     constructor createsys(sysVar:prootobject); override;
     destructor destroy; override;
     //information
     property eng[x:integer]:string read geteng;
     property oth[x:integer]:string read getoth;
     property active:ttransinfo read iactive;
     property pactive:ptransinfo read ipactive;
     property hit:ttranshitinfo read ihit;
     property phit:ptranshitinfo read iphit;
     property valid[x:integer]:boolean read getvalid;
     function stats(showall:boolean;colsep,linesep:string):string;
     //.id - changes every time contents are modified
     property id:integer read iid;
     //details
     property language:string read ilanguage;
     property details:string read idetails;
     property tep:string read itep;
     //workers
     procedure addonce(_eng,_oth:string;_style:byte);
     procedure sync(_eng,_oth:string);
     function findeng(x:string;var i:integer):boolean;
     property text:string read gettext write settext;
    end;

{tscript}
    tscript=class(trootobject)
    private
     function getmv(core,temp:tdynamicvars;name:string):string;//get multi-value
     procedure setmv(core,temp:tdynamicvars;name,value:string);//set multi-value
     function getmc(core,temp:tdynamicvars;name:string):currency;
     procedure setmc(core,temp:tdynamicvars;name:string;value:currency);
     function getmi(core,temp:tdynamicvars;name:string):integer;
     procedure setmi(core,temp:tdynamicvars;name:string;value:integer);
     function getmb(core,temp:tdynamicvars;name:string):boolean;
     procedure setmb(core,temp:tdynamicvars;name:string;value:boolean);
     property mv[core,temp:tdynamicvars;name:string]:string read getmv write setmv;
     property mc[core,temp:tdynamicvars;name:string]:currency read getmc write setmc;
     property mi[core,temp:tdynamicvars;name:string]:integer read getmi write setmi;
     property mb[core,temp:tdynamicvars;name:string]:boolean read getmb write setmb;
     function setup(var core,temp:tdynamicvars):boolean;
    public
     //workers
     function issystem(name:string):boolean;//$
     function isuser(name:string):boolean;//@
     function istemp(name:string):boolean;//all others except $ and @
     procedure exec(core,temp:tdynamicvars;defpath,content:string);
     procedure equate(core,temp:tdynamicvars;name:string);
     procedure equatevalue(core,temp:tdynamicvars;var value:string);
     function next(core,temp:tdynamicvars;name:string):string;
    end;

{thtmltemplate}
    thtmlvalues=array[0..htnMAX] of string;
    thtmltemplate=class(trootobject)
    public
     //create
     constructor create; override;
     destructor destroy; override;
     //.safe
     function safeline(x:string):string;
     function safecolor(x:string):string;
     function safealign(x:string):string;
     function safevalign(x:string):string;
     //.style
     function findname(x:string):integer;
     procedure fromSTYLE(x:string;var y:thtmlvalues);
     function toSTYLE(var x:thtmlvalues):string;
     function goodcolor(color:string):string;
     function line(color,width:string):string;
     function lineb(color:string):string;
     function progressbar(p,width,height:integer;fcolor,bcolor:string;border:boolean):string;
     function toolbar(color,name,subname,links:string):string;
     function frame(width:integer;dark,light,content:string):string;
     function createcaption(var v:thtmlvalues;caption:string):string;
     function createbgcolor(index:integer;colorlist:tstringlist):string;
     function createtable(var v:thtmlvalues;c:string):string;
     function createwindow(var v:thtmlvalues;caption,content:string):string;
     function page(values,content:string):string;
     function pagewindow(values,caption,content:string):string;
     //table
     function table(cap,caplinks,data:string;sep:char;encode:boolean;cols,border,width:integer):string;
     function tableb(cap,caplinks,data:string;sep:char;encode,rawcode,topline,strong:boolean;cols,border,width,cellpad:integer):string;
     function tablec(cap,caplinks,data:string;sep:char;encode,rawcode,topline,strong:boolean;cols,border,width,cellpad:integer;cborder,cbackground,cbacktitle,cfonttitle,crow1,crow2:string):string;
     //window
     function window(cap,caplinks,data:string;encode,topline,bottompad:boolean;border,width:integer):string;
     function windowb(cap,caplinks,data:string;encode,topline,bottompad:boolean;border,width,cellpad:integer):string;
    end;

{TFrameInfo}
    TFrameInfo=record
      color:integer;
      width:integer;
      style:string;
      comment:string;
      end;//end of record
{//yyyyyyyyyyyyyyyyy
type
  PPoint = ^TPoint;
  TPoint = record
    x: Longint;
    y: Longint;
  end;
{}
  LongRec = packed record
    Lo, Hi: Word;
  end;

{ Cursor type }
//yyyyyyyyyyyy  TCursor = -32768..32767;

{  PRect = ^TRect;
  TRect = record
    case Integer of
      0: (Left, Top, Right, Bottom: Integer);
      1: (TopLeft, BottomRight: TPoint);
    end;
{}//yyyyyyyyyyyyyyyyy
  PSHItemID = ^TSHItemID;
  TSHItemID = packed record           { mkid }
    cb: Word;                         { Size of the ID (including cb itself) }
    abID: array[0..0] of Byte;        { The item ID (variable length) }
  end;

  WCHAR = WideChar;
  PWChar = PWideChar;
  LPSTR = PAnsiChar;
  LPCSTR = PAnsiChar;
  LPWSTR = PWideChar;
  LPCWSTR = PWideChar;
  DWORD = Integer;
  BOOL = LongBool;
  PBOOL = ^BOOL;
  PByte = ^Byte;
  PINT = ^Integer;
  PSingle = ^Single;
  PWORD = ^Word;
//yyyyyyyyyyyyyyyyy  PDWORD = ^DWORD;
  LPDWORD = PDWORD;
  UCHAR = Byte;
  PUCHAR = ^Byte;
  SHORT = Smallint;
  UINT = Integer;
  PUINT = ^UINT;
  ULONG = Longint;
  PULONG = ^ULONG;
  PLongint = ^Longint;
  PInteger = ^Integer;
  PBoolean = ^Boolean;//14-JUN-2005
  PSmallInt = ^Smallint;
  PDouble = ^Double;
  LCID = DWORD;
  LANGID = Word;
  THandle = Integer;
  PHandle = ^THandle;
  HWND = Integer;
  HHOOK = Integer;
  ATOM = Word;
  TAtom = Word;
  HGLOBAL = THandle;
  HLOCAL = THandle;
  FARPROC = Pointer;
  TFarProc = Pointer;
  PROC_22 = Pointer;
  HGDIOBJ = Integer;
  HACCEL = Integer;
  HBITMAP = Integer;
  HBRUSH = Integer;
  HCOLORSPACE = Integer;
  HDC = Integer;
  HGLRC = Integer;
  HDESK = Integer;
  HENHMETAFILE = Integer;
  HFONT = Integer;
  HICON = Integer;
  HMENU = Integer;
  HMETAFILE = Integer;
  HINST = Integer;
  HMODULE = HINST;              { HMODULEs can be used in place of HINSTs }
  HPALETTE = Integer;
  HPEN = Integer;
  HRGN = Integer;
  HRSRC = Integer;
  HSTR = Integer;
  HTASK = Integer;
  HWINSTA = Integer;
  HKL = Integer;
  HFILE = Integer;
  HCURSOR = HICON;              { HICONs & HCURSORs are polymorphic }
  COLORREF = DWORD;
  TColorRef = Longint;
  WPARAM = Longint;
  LPARAM = Longint;
  LRESULT = Longint;
  MakeIntResource = PAnsiChar;

  PMenuItemInfo = ^TMenuItemInfo;
  TMenuItemInfo = packed record
    cbSize: UINT;
    fMask: UINT;
    fType: UINT;             { used if MIIM_TYPE}
    fState: UINT;            { used if MIIM_STATE}
    wID: UINT;               { used if MIIM_ID}
    hSubMenu: HMENU;         { used if MIIM_SUBMENU}
    hbmpChecked: HBITMAP;    { used if MIIM_CHECKMARKS}
    hbmpUnchecked: HBITMAP;  { used if MIIM_CHECKMARKS}
    dwItemData: DWORD;       { used if MIIM_DATA}
    dwTypeData: PAnsiChar;      { used if MIIM_TYPE}
    cch: UINT;               { used if MIIM_TYPE}
  end;

  TMsgConv=Record
   case Integer of
   0: (
        WParam:Word;
        LParam:Longint);
   1: (
        WParamLo: SmallInt;//Date: 14-NOV-2003
        WParamHi: SmallInt;
        LParamLo: SmallInt;
        LParamHi: SmallInt);
    end;//end of case

  TWMMenuSelect = record
    Msg: Cardinal;
    IDItem: Word;
    MenuFlag: Word; { MF_BITMAP, MF_CHECKED, MF_DISABLED, MF_GRAYED,
                      MF_MOUSESELECT, MF_OWNERDRAW, MF_POPUP, MF_SEPARATOR,
                      MF_SYSMENU }
    Menu: HMENU;
    Result: Longint;
    end;

{
  PMessage = ^TMessage;
  TMessage = record
    Msg: Cardinal;
    case Integer of
      0: (
        WParam: Longint;
        LParam: Longint;
        Result: Longint);
      1: (
        WParamLo: Word;
        WParamHi: Word;
        LParamLo: Word;
        LParamHi: Word;
        ResultLo: Word;
        ResultHi: Word);
  end;
{}

{Message structure}

  {MultiByte Character Set (MBCS) byte type}
  TMbcsByteType = (mbSingleByte, mbLeadByte, mbTrailByte);

  {TMsg}
{  PMsg = ^TMsg;
  TMsg = packed record
    hwnd: HWND;
    message: UINT;
    wParam: WPARAM;
    lParam: LPARAM;
    time: DWORD;
    pt: TPoint;
    end;

  TFNWndProc = TFarProc;
{}//yyyyyyyyyyyyyyyyy
  {TWndClass}
  TWndClass = packed record
    style: UINT;
    lpfnWndProc: TFNWndProc;
    cbClsExtra: Integer;
    cbWndExtra: Integer;
    hInstance: HINST;
    hIcon: HICON;
    hCursor: HCURSOR;
    hbrBackground: HBRUSH;
    lpszMenuName: PAnsiChar;
    lpszClassName: PAnsiChar;
    end;

  PWndClassEx = ^TWndClassEx;
  TWndClassEx = packed record
    cbSize: UINT;
    style: UINT;
    lpfnWndProc: TFNWndProc;
    cbClsExtra: Integer;
    cbWndExtra: Integer;
    hInstance: HINST;
    hIcon: HICON;
    hCursor: HCURSOR;
    hbrBackground: HBRUSH;
    lpszMenuName: PAnsiChar;
    lpszClassName: PAnsiChar;
    hIconSm: HICON;
  end;

{ Generic window message record }
  PPaintStruct = ^TPaintStruct;
  TPaintStruct = packed record
    hdc: HDC;
    fErase: BOOL;
    rcPaint: TRect;
    fRestore: BOOL;
    fIncUpdate: BOOL;
    rgbReserved: array[0..31] of Byte;
    end;

  TPopupAlignment = (paLeft, paRight, paCenter);

    TMessageEvent=procedure (var Msg:TMsg; var Handled:Boolean) of object;
    TIdleEvent=procedure (Sender:TObject; var Done:Boolean) of object;

    TWndMethod = procedure(var Message: TMessage) of object;
    PWindowPlacement = ^TWindowPlacement;
    TWindowPlacement = packed record
       length: UINT;
       flags: UINT;
       showCmd: UINT;
       ptMinPosition: TPoint;
       ptMaxPosition: TPoint;
       rcNormalPosition: TRect;
       end;//end of record

{TMsgList}
    TMsgListItem=Record
      handle:Hwnd;
      proc:TWindowProc;
      end;//end of record

    PMsgListItems=^TMsgListItems;
    TMsgListItems=Record
      items:Array[0..mglMaxItem] of TMsgListItem;
      count:Integer;
      end;//end of record

    tmsglist=class(trootobject)
    Private
     iItems:TMsgListItems;
     ipItems:PMsgListItems;
    Public
     {create}
     constructor create; override;
     destructor destroy; override;
     {Other}
     Procedure Clear;
     Function Find(X:Hwnd):Integer;
     Function Add(X:Hwnd;Y:TWindowProc):Integer;
     Procedure Del(X:Hwnd);
     Property Items:PMsgListItems Read ipItems;
     Function WindowProc(hWnd:HWND;Msg:UINT;wParam:WPARAM;lParam:LPARAM):LRESULT;stdcall;
    end;

{TLiteForm}
//    TCloseAction=(caNone, caHide, caFree, caMinimize);
//    TCloseEvent=Procedure(Sender:TObject;var Action:TCloseAction) of Object;
//    TCloseQueryEvent=Procedure(Sender:TObject;var CanClose:Boolean) of Object;
//yyyyyyyyyyyyyyyyy    TShiftState=set of (ssShift, ssAlt, ssCtrl, ssLeft, ssRight, ssMiddle, ssDouble);
//yyyyyyyyyyyyyyyyy    TMouseButton=(mbLeft,mbRight,mbMiddle);
    PMouseInfo=^TMouseInfo;
    TMouseInfo=Record
     Down:Boolean;
     Button:TMouseButton;
     Shift:TShiftState;
     X:Integer;
     Y:Integer;
     lX:Integer;
     lY:Integer;
     end;//end of record
{    TMouseEvent=Procedure(Sender:TObject;Button:TMouseButton;Shift:TShiftState;X,Y:Integer) of Object;
    TMouseMoveEvent=Procedure(Sender:TObject;Shift:TShiftState;X,Y:Integer) of Object;
{}//yyyyyyyyyyyyyyyyy

    TLiteForm=class(tobject)
    Private
     iTag:Integer;
     iCursor:HCursor;
     iPaintDC:HDC;
     iHandle:HWND;
     iVisible:Boolean;
     iMouseInfo:TMouseInfo;
     ipMouseInfo:PMouseInfo;
     FOnWndProc:TWindowProc;
     FOnPaint:TNotifyEvent;
     FOnClose:TNotifyEvent;
     FOnCloseQuery:TCloseQueryEvent;
     FOnResize:TNotifyEvent;
     FOnMouseDown:TMouseEvent;
     FOnMouseMove:TMouseMoveEvent;
     FOnMouseUp:TMouseEvent;
     FOnEndSession:TNotifyEvent;
     FOnHalt:TNotifyEvent;
     Procedure SetVisible(X:Boolean);
     Procedure SetCaption(X:String);
     Function GetCaption:String;
     Function GetLeft:Integer;
     Procedure SetLeft(X:Integer);
     Function GetTop:Integer;
     Procedure SetTop(X:Integer);
     Function GetWidth:Integer;
     Procedure SetWidth(X:Integer);
     Function GetHeight:Integer;
     Procedure SetHeight(X:Integer);
     Function GetClientWidth:Integer;
     Procedure SetClientWidth(X:Integer);
     Function GetClientHeight:Integer;
     Procedure SetClientHeight(X:Integer);
     Procedure msgXY(X:Longint;Var rX,rY:Integer);
     Procedure DoMouse(X:Integer);
     Procedure SetMouseCapture(X:Boolean);
     Function GetMouseCapture:Boolean;
     Property MouseCapture:Boolean Read GetMouseCapture Write SetMouseCapture;
     Function WndProc(hWnd:HWND;Msg:UINT;wParam:WPARAM;lParam:LPARAM):LRESULT;stdcall;
     Function _GetClientRect:TRect;
     Procedure _SetClientRect(X:TRect);
     Procedure _SetCursor(X:HCursor);
    Public
     {create}
     constructor create(dwStyle,dwExStyle:DWORD;pHandle:HWND); virtual;
     destructor destroy; override;
     {Other}
     //Handles
     Property Handle:HWND Read iHandle;
     Function Perform(Msg:UINT;wParam:WPARAM;lParam:LPARAM):LRESULT;
     Property Cursor:HCursor Read iCursor Write _SetCursor;
     Property Tag:Integer Read iTag Write iTag;
     //Paint
     Procedure PaintTo(dRect:TRect;sDC:HDC;sRect:TRect;Rop:DWORD);
     //Visibility
     Procedure Show;
     Procedure Hide;
     Property Visible:Boolean Read iVisible Write SetVisible;
     //Text
     Property Caption:String Read GetCaption Write SetCaption;
     //Dimensions
     Procedure SetBounds(X,Y,W,H:Integer);
     Function GetBounds:TRect;
     Property Left:Integer Read GetLeft Write SetLeft;
     Property Top:Integer Read GetTop Write SetTop;
     Property Width:Integer Read GetWidth Write SetWidth;
     Property Height:Integer Read GetHeight Write SetHeight;
     Property ClientRect:TRect Read _GetClientRect Write _SetClientRect;
     Property ClientWidth:Integer Read GetClientWidth Write SetClientWidth;
     Property ClientHeight:Integer Read GetClientHeight Write SetClientHeight;
     //Other
     Property MouseInfo:PMouseInfo Read ipMouseInfo;
     //Events
     Property OnWndProc:TWindowProc Read FOnWndProc Write FOnWndProc;
     Property OnResize:TNotifyEvent Read FOnResize Write FOnResize;
     Property OnPaint:TNotifyEvent Read FOnPaint Write FOnPaint;
     Property OnCloseQuery:TCloseQueryEvent Read FOnCloseQuery Write FOnCloseQuery;
     Property OnMouseDown:TMouseEvent Read FOnMouseDown Write FOnMouseDown;
     Property OnMouseMove:TMouseMoveEvent Read FOnMouseMove Write FOnMouseMove;
     Property OnMouseUp:TMouseEvent Read FOnMouseUp Write FOnMouseUp;
     Property OnClose:TNotifyEvent Read FOnClose Write FOnClose;{Main System Menu "Close"}
     Property OnEndSession:TNotifyEvent Read FOnEndSession Write FOnEndSession;{Windows Shutdown}
     Property OnHalt:TNotifyEvent Read FOnHalt Write FOnHalt;{Close or Windows Shutdown}
    end;

{TApp}
    TApp=class(trootobject)
    Private
     iExeName:String;
     iRunning:Boolean;
     iTerminated:Boolean;
     iHandle:HWND;
     iMainForm:Pointer;
     FOnMessage:TMessageEvent;
     FOnIdle:TIdleEvent;
     FOnClose:TNotifyEvent;
     Function IsKeyMsg(var Msg:TMsg):Boolean;
     Procedure Idle;
     Procedure Close(Sender:TObject);
    Public
     {create}
     constructor create; override;
     destructor destroy; override;
     {Other}
     Property Running:Boolean Read iRunning;
     Property Terminated:Boolean Read iTerminated;
     Procedure Terminate;
     Property Handle:HWND Read iHandle;
     Property MainForm:Pointer Read iMainForm Write iMainForm;
     Procedure ProcessMessages;
     Function ProcessMessage:Boolean;
     Procedure HandleMessage;
     Procedure Run;
     Property EXEName:String Read iExeName;
     {Events}
     Property OnMessage:TMessageEvent Read FOnMessage Write FOnMessage;
     Property OnIdle:TIdleEvent Read FOnIdle Write FOnIdle;
     Property OnClose:TNotifyEvent Read FOnClose Write FOnClose;
    end;


//[3]#################### ZIP/HELP Support #####################################
  TAlloc = function (AppData: Pointer; Items, Size: Integer): Pointer;
  TFree = procedure (AppData, Block: Pointer);

  // Internal structure.  Ignore.
  TZStreamRec = packed record
    next_in: PChar;       // next input byte
    avail_in: Integer;    // number of bytes available at next_in
    total_in: Integer;    // total nb of input bytes read so far

    next_out: PChar;      // next output byte should be put here
    avail_out: Integer;   // remaining free space at next_out
    total_out: Integer;   // total nb of bytes output so far

    msg: PChar;           // last error message, NULL if no error
    internal: Pointer;    // not visible by applications

    zalloc: TAlloc;       // used to allocate the internal state
    zfree: TFree;         // used to free the internal state
    AppData: Pointer;     // private data object passed to zalloc and zfree

    data_type: Integer;   //  best guess about the data type: ascii or binary
    adler: Integer;       // adler32 value of the uncompressed data
    reserved: Integer;    // reserved for future use
  end;

{tnv}
    tnvstyle=set of (nvsInit,nvsStart,nvsEnd,nvsDataLen);
    tnv=class(tobject)
    private
     icount,idatalen,ipos:integer;
    public
     //vars
     data:pstring;
     //create
     constructor create;
     //.write
     function initwrite(_hdr:string;var e:string):boolean;
     function writeb(n,v:string;var e:string):boolean;
     function write(n:string;var v,e:string):boolean;
     //.read
     function initread(_hdr:string;var e:string):boolean;
     function canread:boolean;
     function read(var n,v,e:string):boolean;
     //.read only
     property dataLEN:integer read idataLEN;
     property pos:integer read ipos;
     property count:integer read icount;
     //other
     procedure clear;
    end;

{tdualmask}
    tdualmask=class(tobject)
    private
     imask,emask:tmasks;
     procedure setmasks(x:string);
     function getmasks:string;
    public
     prepad:string;
     postpad:string;
     sep:char;
     isc:boolean;//include slash
     //create
     constructor create;
     destructor destroy; override;
     //other
     property masks:string read getmasks write setmasks;
     procedure init(_include,_exclude:string); virtual;
     function inmask(x:string):boolean; virtual;
     function inlist(x:string):string;//filters supplied list
    end;

{tio}
    //.name-value header
    tioscaninfo=record
      filename:string;
      scanto:integer;//count in bytes of file
      cc:integer;//check code
      end;
    tiocompressstyle=set of (iocsCompress,iocsDecompress,iocsHeader);
    tioforcestyle=set of (iofsPath,iofsName,iofsExt,iofsUpperCase,iofsLowerCase,iofsTitle);
    tiostyle=(iosNone,iosToC,iosFromC,iosToBMP,iosFromBMP,iosToTXT,iosFromTXT,iosToFILE,iosFromFILE,iosToNV,iosFromNV,iosToMTXT,iosFromMTXT,iosToB64,iosFromB64);
    tioUnpackStyle=set of (ioupOverwrite,ioupAutoPath,ioupPersistWithErrors,ioupTitleName);
    pioinfo=^tioinfo;
    tioinfo=record
      //.position
      position:integer;
      size:integer;
      outputsize:integer;
      percentage:single;
      //.totals
      cantotal:boolean;
      positionTOTAL:currency;
      sizeTOTAL:currency;
      percentageTOTAL:single;
      //.image
      width:integer;
      height:integer;
      posH:integer;
      //.style
      style:tiostyle;
      //.other
      instance:tio;//points to self, easy reference
      end;//end of record
    tiofileinfo=record
      date:currency;
      size:integer;
      end;
    tio=class(trootobject)
    private
     iinfo:tioinfo;
     ipinfo:pioinfo;
     icancelled:boolean;
     //.lock
     ilock:tfilestream;
     ilockfn:string;
     //.nv
     invPOS:integer;
     invDATALEN:integer;
     invDATA:string;
     invTEXTPOS,invTEXTLEN:integer;
     //.masks
     imask:tdualmask;
     //.translated labels
     itlFileName,itlSize,itlDate,itlByte:string;
     procedure aem(var e:string);//adjust error message
     procedure clear;
     procedure eventSTRM(x:TZStreamRec);
     function _compress(var x,e:string;_style:tiocompressstyle):boolean;
     function ccmatch(x,y:integer):boolean;
     function scanfile(var x:tioscaninfo):boolean;
     procedure tls;//translate labels
     function getmask:tdualmask;
     function getsnippetfilename(name:string):string;
     function getsnippet(name:string):string;
     procedure setsnippet(name:string;value:string);
     function _extractfilename(x:string;_style:tioUnpackStyle):string;
     function getint(x:string):integer;
     procedure setint(x:string;value:integer);
    public
     onchange:tnotifyevent;
     //vars
     hml:boolean;//hide main label
     hfls:boolean;//hide file labels
     blocking:boolean;//if TRUE prevents system breathing during file IO (default is FALSE)
     //create
     constructor create; override;
     destructor destroy; override;
     //value
     function pushvalueb(n,v:string;var e:string):boolean;
     function pushvalue(n:string;var v,e:string):boolean;
     function pullvalue(n:string;var v,e:string):boolean;
     //info
     procedure _init(_size:integer;_width,_height:integer;_style:tiostyle);
     procedure incpos(_p,_op,_ph:integer);
     property info:pioinfo read ipinfo;
     //cancel
     property cancelled:boolean read icancelled;
     procedure cancel;
     //core
     //.write/read string values
     //..32bit value length
     function wsvb32(var x:string;v:string):boolean;//write string value
     function wsv32(var x,v:string):boolean;//write string value
     function rsv32(var p:integer;var x,v:string):boolean;//read str value
     //..16bit value length
     function wsvb16(var x:string;v:string):boolean;//write string value (16bit length)
     function wsv16(var x,v:string):boolean;//write string value (16bit length)
     function rsv16(var p:integer;var x,v:string):boolean;//read str value (16bit length)
     //workers
     //.raw compression
     function compress(var x,e:string):boolean;
     function decompress(var x,e:string):boolean;
     //.header based compression - optimised compression decision
     function toC(var x,e:string):boolean;
     function fromC(var x,e:string):boolean;
     //.image
     function toBMPb(var x,e:string):boolean;
     function toBMP(var a:tbitmap;var x,e:string):boolean;
     function fromBMPb(var x,e:string):boolean;
     function fromBMP(var a:tbitmap;var x,e:string):boolean;
     function eatread(var eat:string;name:string;var value,e:string):boolean;
     //.text
     function toTXT(var x,y:string;var e:string):boolean;//binary to text
     function fromTXT(var x:string;var e:string):boolean;//binary to text
     //.base64
     function tob64(var s,d:string;linelength:integer;var e:string):boolean;//to base64
     function tob64b(s:string;linelength:integer):string;
     function fromb64(var s,d:string;var e:string):boolean;//from base64
     function fromb64b(s:string):string;
     //.file
     function toFILEc(x:string;var y,e:string;_trycount:integer):boolean;
     function toFILEb(x:string;y:string;var e:string):boolean;
     function toFILE(x:string;var y,e:string):boolean;
     function toFILEAPPEND(x:string;var y,e:string):boolean;
     function fromFILEd(x:string):string;
     function fromFILEc(x:string;var y,e:string;_trycount:integer):boolean;
     function fromFILE(x:string;var y,e:string):boolean;
     function fromFILEb(x:string;var y,e:string;var _filesize,_from:integer;_size:integer;var _date:tdatetime):boolean;//20-OCT-2006
     //.filedate
     function fromFILEDATE(x:string;var y:tdatetime):boolean;
     //..int
     property int[x:string]:integer read getint write setint;
     //.eat - to=write to str, from=read from str
     function toEAT(_nv:tobject;var y,e:string):boolean;
     function fromEAT(_nv:tobject;var y,e:string):boolean;
     //.nv - to=write to str, from=read from str
     function isNVobj(_nv:tobject;var e:string):boolean;
     function toNV(_nv:tobject;_hdr:string;var y,e:string):boolean;
     function fromNV(_nv:tobject;_hdr:string;var y,e:string):boolean;
     //.info - packs/unpacks file related information
     function toINFO(x:string):tiofileinfo;
     function fromINFO(var x:tiofileinfo):string;
     //.multi-text (mtxt or txt)
     function isMTXT(var x:string):boolean;
     function toMTXT(_nv:tobject;var x,e:string):boolean;
     function fromMTXT(_nv:tobject;var x,e:string):boolean;
     //.decode-encode
     function dds(var x:string):integer;//determine data style
     function decode(var x:string;_nv:tobject;_destformat:integer;var e:string):boolean;
     function encode(var x:string;_nv:tobject;_destformat:integer;var e:string):boolean;
     //.masks
     property mask:tdualmask read getmask;
     //.paths
     function forcefilename(_master,_slave:string;_style:tioforcestyle):string;//force PATH/FILENAME/EXTENSION
     //.virus scanner
     procedure scan(x,y:integer);
     //.snippet
     property snippetfilename[name:string]:string read getsnippetfilename;
     property snippet[name:string]:string read getsnippet write setsnippet;
     //.unpack
     function unpackto(var eat:string;_destpath:string;var _count,_total:integer;_style:tioUnpackStyle;var e:string):boolean;//09OCT2007
     //.lock
     function lock(_name:string):boolean;//io blocking/locking system
     function unlock:boolean;
     //other
     procedure inserttext(var x:string;y:string;yp:integer);
     function formatsize(x:currency;style:integer):string;
    end;

{TBinaryFile}
   TBinaryFileBuffer=array[0..32766] of byte;
   TBinaryFile=class(tobject)
   private
    ipushTMP,iNullStr:string;
    iLockCount:integer;
    iLocked,iNew,iOpen,iCanWrite:boolean;
    iFileName:string;
    iFileStream:TFileStream;
    iErrorMessage:string;
    function _CanWriteTo(x:string):boolean;
    procedure _Open(x:string);
    procedure SetFileName(x:string);
    function GetPosition:integer;
    procedure SetPosition(x:integer);
   public
    //create
    constructor create(x:string);
    destructor destroy; override;
    property ErrorMessage:string read iErrorMessage write iErrorMessage;
    //other
    //indicators
    property New:boolean read iNew;
    property Open:boolean read iOpen;
    property CanWrite:boolean read iCanWrite;
    property FileName:string read iFileName write SetFileName;
    property FileStream:TFileStream read iFileStream;
    //io
    function WriteStr(x:integer;var y:string):boolean;
    function ReadStr(x:integer;yc:integer;var y:string):boolean;{3.1Mb/sec/yc=32,000 on CPU:200Mhz}
    function Wipe(x,yc:integer):boolean;
    property position:integer read GetPosition write SetPosition;
    function size:integer;
    //push
    procedure flush;
    function push(x:string):boolean;//streams data to disk in bits
    //lock
    property Locked:boolean read iLocked;
    procedure Lock;
    procedure Unlock;
   end;

{tfilepush}
  tfilestage=(fesClosed,fesOpening,fesOpen,fesClosing);
  tfilepush=class(tobject)
  private
   ifilestream:tfilestream;
   ifilename:string;
   ibytes:currency;
   istage:tfilestage;
   procedure clear;
  public
   //create
   constructor create;
   destructor destroy; override;
   //open
   function canopen:boolean;
   function open(x:string;var e:string):boolean;
   //push
   function canpush:boolean;
   function push(x:string;var e:string):boolean;
   //close
   function canclose:boolean;
   procedure close;
   //info
   property filename:string read ifilename;
   property bytes:currency read ibytes;
   property stage:tfilestage read istage;
  end;

{tstreamstr}
  tstreamstr=class(tstream)//tstringstream replacement
  private
   iposition:integer;
   iptr:pstring;//pointer to outside string - zero memory duplication
  protected
   procedure setsize(newsize:longint); override;
  public
   //create
   constructor create(_ptr:pstring);
   //workers
   function read(var x;xlen:longint):longint; override;
   function write(const x;xlen:longint):longint; override;
   function seek(offset:longint;origin:word):longint; override;
   function readstring(count:longint):string;
   procedure writestring(const x:string);
  end;

{tstreammem}
  tstreammem=class(tstreamstr)//tmemorystream replacement
  public
   //workers
   procedure clear;
   procedure loadfromstream(stream:tstream);
   procedure loadfromfile(const FileName: string);
   function write(const x;xlen:longint):longint; override;
  end;

{tzof - on the fly compression}
  tzof=class(tobject)
  private
   istrm:tzstreamrec;
   icompressing,ifirst:boolean;
   ifbc:integer;
   isize,icrc32:tint4;
   procedure compressflush(var data:string;tmp:pointer;tmpLEN:integer);
   procedure insertcrc32(var d:string);
  public
   //create
   constructor create;
   destructor destroy; override;
   //support
   function zof(var x,e:string;c:boolean):boolean;//passed
   //workers
   function gzHEAD(filename:string):string;
   function fileGZIP(filename,x:string):string;
   function httpGZIP(x:string):string;
   //compress
   property compressing:boolean read icompressing;
   function start(trimfirstbytes:boolean;var e:string):boolean;
   function compress(x:string;var d,e:string;readall:boolean):boolean;
   procedure stop;
  end;

{ttesting}
  ttesting=class(trootobject)
  public
   //create
   constructor create; override;
   destructor destroy; override;
   //other
   procedure showmsg(x:string);
  end;

{tfontmap}
   tfontmaplast=record
      name:string;
      height:integer;
      style:tfontstyles;
      end;//end of record
   pfontmapsize=^tfontmapsize;
   tfontmapsize=array[0..255] of word;
   tfontmap=class(tobject)
   private
    ilast:tfontmaplast;
    iid:integer;
    iw,ih:tfontmapsize;
    ipw,iph:pfontmapsize;
    iminw,iminh,imaxw,imaxh,iavew,iaveh:word;
    ifont:tfont;
   public
    //create
    constructor create;
    destructor destroy; override;
    //information
    property minw:word read iminw;
    property minh:word read iminh;
    property maxw:word read imaxw;
    property maxh:word read imaxh;
    property avew:word read iavew;
    property aveh:word read iaveh;
    property w:pfontmapsize read ipw;
    property h:pfontmapsize read iph;
    property font:tfont read ifont;
    property id:integer read iid;//increments every time font information is changed
    //calc
    function textwidth(var x:string):integer;
    function textwidthc(x:string):integer;
    function textwidthb(var x:string;s,f:integer):integer;
    function textwidthi(var x:string;ingorechar:char;s,f:integer):integer;
    function countchars(var x:string;s,maxwidth:integer;lefttoright:boolean):integer;
    //copy
    procedure copyfrom(x:tfont);
    //update
    function canupdate:boolean;
    function update:boolean;
   end;

{tdraws}
   tdraws=class(trootobject)
   public
    //spacing
    function numberspace(normal:boolean;count:integer):integer;
    //virtual
    procedure drawitem(control:tvirtualcontrol;canvas:tcanvas;index:integer;area:trect;state:tvirtualdrawstate;ontext:tvirtualtextevent;onimage:tvirtualimageevent);
    procedure drawtabs(control:tvirtualcontrol;canvas:tcanvas;offx,offy:integer;var tmp:string);
   end;

{tmenus}
   tmenus=class(trootobject)
   private
    icaption,itep,ishortcut:tdynamicstring;
    ishowing,iinuse,ienabled:tdynamicboolean;
    icode:tdynamicinteger;
    function newindex:integer;
    function getcaption(x:integer):string;
    function gettep(x:integer):string;
    function getenabled(x:integer):boolean;
    function getshortcut(x:integer):string;
    function getcode(x:integer):integer;
    function getshowing(x:integer):boolean;
    procedure setcaption(x:integer;y:string);
    procedure settep(x:integer;y:string);
    procedure setenabled(x:integer;y:boolean);
    procedure setcode(x:integer;y:integer);
    procedure setshortcut(x:integer;y:string);
    procedure setitemenabled(_menu:pstring;_code:integer;_enabled:boolean);
    function getitemenabled(_menu:pstring;_code:integer):boolean;
    function valid(x:integer):boolean;
   public
    //create
    constructor create; override;
    destructor destroy; override;
    //items
    function additem(_menu:pstring;_caption,_tep,_shortcut:string;_code:integer;_enabled:boolean):integer;
    function addsep(_menu:pstring):integer;
    function delitem(x:integer):boolean;
    //akey - accelerator key functions
    function safeAKEY(x:string):char;
    function extractAKEY(x:string):char;
    //menu
    function ismenu(_menu:pstring):boolean;
    function newmenu(_menu:pstring):boolean;
    function delmenu(_menu:pstring):boolean;
    function readmenu(_gui:tvirtualform;_menu:pstring):boolean;
    //.by code
    function finditem(_menu:pstring;_code:integer):integer;
    property itemenabled[_menu:pstring;_code:integer]:boolean read getitemenabled write setitemenabled;
    //information
    property caption[x:integer]:string read getcaption write setcaption;
    property tep[x:integer]:string read gettep write settep;
    property enabled[x:integer]:boolean read getenabled write setenabled;
    property showing[x:integer]:boolean read getshowing;
    property shortcut[x:integer]:string read getshortcut write setshortcut;
    property code[x:integer]:integer read getcode write setcode;
    function findshortcut(_shortcut:string):integer;
   end;

{tvirtualcontrols}
   tvirtualcontrols=class(tdynamiclist)
   private
    iitems:pdlVIRTUALCONTROL;
    function getvalue(_index:integer):tvirtualcontrol;
    procedure setvalue(_index:integer;_value:tvirtualcontrol);
    function getsvalue(_index:integer):tvirtualcontrol;
    procedure setsvalue(_index:integer;_value:tvirtualcontrol);
    procedure _init; override;
    procedure _corehandle; override;
   public
    procedure freeValue(p:integer);
    procedure freeValues;
    property value[x:integer]:tvirtualcontrol read getvalue write setvalue;
    property svalue[x:integer]:tvirtualcontrol read getsvalue write setsvalue;
    property items:pdlVIRTUALCONTROL read iitems;
    function find(_start:integer;_value:tvirtualcontrol):integer;
    function new(obj:tvirtualcontrol):integer;
   end;

{tdlgform}
   tdlgform=class(tform)
   private
    procedure _onkeydown(sender:tobject;var key:word;shift:tshiftstate);
   public
    //create
    constructor create(aowner:tcomponent);
   end;

{tvirtualform}
   tsizestyle=(sisTL,sisBL,sisTR,sisBR,sisTRraw,sisAuto);
   tgroupevent=procedure(sender:tobject;control:tvirtualcontrol;group:integer) of object;
   tvirtualcursor=(vcArrow,vcLink,vcText,vcBusy,vcSize);
   tvirtualeventclas=(recNone,recMouse,recKey,recKeyX);
   tvirtualalign=(valNone,valLeft,valRight,valTop);
   tvirtualctrlevent=function(sender:tobject;code:byte):boolean of object;
   tvirtualform=class(tform)
   private
    ipaintxy:tpoint;
    ipaintrgn:hrgn;
    iwindowstate:twindowstate;
    inormalrect:trect;
    imovepos,itmpxy:tpoint;
    isafetime,islowref,imaxtime,idowntime,itimepaint:currency;
    ipaintcount,ilastdragx,ilastdragy,iminspace,iminwidth,iminheight,itimer,iposW,iposH,iposx,iposy:integer;
    ilasttop,ilastleft,ilastwidth,ilastheight:integer;
    isizingstyle:tsizestyle;
    ilastvisible,imoving,isizing,iempty,iwasactive,idestroying,ilockalign,irepaintloop,iactive:boolean;
    ilastpages:tvirtualpages;
    ilinkparent:tvirtualcontrol;
    ifocuscontrol,ihovercontrol:tvirtualcontrol;
    iroot:tvirtualpage;
    ipaintdelayed,ilocked,idialog,ichanging:boolean;
    itmpclas,iclas:tvirtualeventclas;
    ishowresult,ishowingwait,ishowingmodal,ictrl,ialt,ishift,imouseoffWAIT,ikeyoffWAIT,idown,iwasdown,imove:boolean;
    iact,iclickkey,ikey:byte;
    ix,iy,idx,idy:integer;
    iwheelv:single;
    ilasthint:tvirtualcontrol;
    procedure _onpaint(sender:tobject);
    procedure _onresize(sender:tobject);
    function validrect(x:trect):boolean;
    procedure _changedsize(x:tvirtualcontrol;y:trect);
    procedure setfocuscontrol(x:tvirtualcontrol);
    function _controlatpos(x,y:integer;z:tvirtualcontrol;var r:tvirtualcontrol;mustfocus,mustenable:boolean):boolean;
    procedure _paintallowed;
    procedure wmactivate(var Message: TWMActivate); message wm_activate;
    procedure wmerasebkgnd(var message:twmerasebkgnd); message wm_erasebkgnd;
    procedure resetcanvas(x:tvirtualcontrol;c:tcanvas);
    procedure setparent(x:twincontrol); override;
    function getscreencursor:tvirtualcursor;
    procedure setscreencursor(x:tvirtualcursor);
    procedure wmqueryendsession(var Message:TWMQueryEndSession);
    function mouseoff:boolean;
    function mouseoffb(force:boolean):boolean;
    function keyoff:boolean;
    procedure doevent;
    function guilocked(x:tobject):boolean;
    function validgui(x:tobject;var y:tvirtualform):boolean;
    procedure setcaption(x:string);
    function getcaption:string;
    procedure _ontimer(sender:tobject);
    procedure _onpaintborder(sender:tobject;canvas:tcanvas);
    procedure setwindowstate(x:twindowstate);
    function getwindowstate:twindowstate;
    procedure syncmaximized;
    procedure wmgetdlgcode(var Message: TWMGetDlgCode); message wm_getdlgcode;
    procedure setlockalign(x:boolean);
    procedure _oic(sender:tobject);//on internal click - system only
    procedure wmmousewheel(var Message:tmessage); message wm_mousewheel;
    procedure setPHAL(x:boolean);//popup hosy active locked
    function getPHAL:boolean;
    //shortcut
    function asshortcut(k:byte):string;
    function canAKEY(x:tvirtualcontrol):boolean;//28SEP2007 - Special controls MUST be specified to ignore "akey" (ie. edit,text,list and droplist)
    //pop
    procedure _onpop(sender:tobject); virtual;
    //modal
    procedure setmodalresult(x:tmodalresult);
    function getmodalresult:tmodalresult;
    //other
    procedure setminwidth(x:integer);
    procedure setminheight(x:integer);
    procedure setminspace(x:integer);
    procedure paintstart(_x,_y:integer;_rgn:hrgn);
    function _paintfrom(x:tvirtualcontrol;recurs:boolean):boolean;
    function getpainting:boolean;
    procedure setsizing(a:boolean);//used to switch form into "sizing" mode, which can effect how controls are painted etc - 03OCT2007
    procedure setmoving(a:boolean);//used to switch form into "moving" mode, which can effect how controls are painted etc - 03OCT2007
   public
    //vars
    activelocked:boolean;
    paintallowed:boolean;//controlled by "head"
    pages:tvirtualpages;//pointer only, optional.
    //controls
    head:tvirtualhead;
    safearea:boolean;//default=TRUE (but vspSafeArea=TRUE must also be true for this to take affect)
    piggy:tvirtualform;//extra form (like a dialog) which is part of the overal system
    //action modifiers
    aExtendedfocusshift:boolean;//used arrow keys to shift focus as well as normal TAB/TAB+SHIFT
    aKeys:boolean;//enable accelerator keys
    //enable master form keys (esc and/or return)
    mkEscape:boolean;
    mkReturn:boolean;
    //options
    oResizeable:boolean;
    oRealtimeDrag:boolean;//uses non-windows realtime drag system
    //popup
    popuphost:tvirtualform;
    //events
    onactive:tnotifyevent;
    onnotify:tnotifyevent;//pass on event
    ontimer:tnotifyevent;//extends internal timer reach (interval is automatic)
    //FORM
    //create
    constructor create(aowner:tcomponent); override;
    procedure destroyinit;
    destructor destroy; override;
    property destroying:boolean read idestroying;
    property empty:boolean read iempty write iempty;
    //information
    property active:boolean read iactive;
    property phal:boolean read getPHAL write setPHAL;//popuphost active locked - lock parent and prevents it from closing during focus loss "de-active"
    property lockalign:boolean read ilockalign write setlockalign;
    //show - modal
    property modalresult:tmodalresult read getmodalresult write setmodalresult;
    property showingmodal:boolean read ishowingmodal;
    function showmodal:tmodalresult; virtual;
    //show - wait
    property showingwait:boolean read ishowingwait;
    function showwait:boolean; virtual;
    procedure showclose(_reply:tmodalresult);
    property showresult:boolean read ishowresult;//for showwait and showmodal
    //CLIENT
    //actions
    procedure doaction(c:integer);
    //workers
    function newcontrol:tvirtualcontrol;
    property root:tvirtualpage read iroot;
    procedure clientclean;
    //sizing
    property sizing:boolean read isizing write setsizing;
    procedure sizenow;//03OCT2007
    procedure sizenowex(s:tsizestyle);
    property moving:boolean read imoving write setmoving;
    procedure movenow;//03OCT2007
    //paint
    function canpaint(x:tvirtualcontrol):boolean;
    property painting:boolean read getpainting;
    function paintfrom(x:tvirtualcontrol;recurs:boolean):boolean; virtual;
    //hint
    procedure displayhint(x:tvirtualcontrol);
    property lasthint:tvirtualcontrol read ilasthint;
    //help
    function findhelp(from:tvirtualcontrol;musthavehelp:boolean;var host,sub:tvirtualcontrol):boolean;
    //change
    function beginchange:boolean;
    function endchange:boolean;
    //information
    property caption:string read getcaption write setcaption;
    property dialog:boolean read idialog write idialog;
    procedure checkfocuscontrol;
    property focuscontrol:tvirtualcontrol read ifocuscontrol write setfocuscontrol;
    property hovercontrol:tvirtualcontrol read ihovercontrol;
    function controlatpos(x,y:integer;var z:tvirtualcontrol):boolean;
    function controlatposb(x,y:integer;var z:tvirtualcontrol;mustfocus,mustenable:boolean):boolean;
    procedure setbounds(_left,_top,_width,_height:integer); override;
    function boundsfilter(var _left,_top,_width,_height:integer):boolean;
    //.center
    function cancenter:boolean;
    procedure center;
    //.enlarge
    function canenlarge:boolean;
    procedure enlarge(wBy,hBy:integer);
    //.sizeto
    function cansizeto(w,h:integer):boolean;
    procedure sizeto(w,h:integer);
    //notifications
    function changedsize(sender:tvirtualcontrol):boolean;
    function changedsizeb(sender:tvirtualcontrol;dopaint,fromparent:boolean):boolean;//13-DEC-2006
    //construction
    function new(_type:string;_caption,_tep,_help:string;_align:tvirtualalign;_newparent:tvirtualcontrol;_onclick:tnotifyevent):tvirtualcontrol;
    function newb(_type:string;_caption,_tep,_help:string;_align:tvirtualalign;_newparent:tvirtualcontrol;_onclick:tnotifyevent;_sysptr:integer;_style:tstoragestyle;_default,_range:string):tvirtualcontrol;
    function newlink(_caption,_tep,_help:string;_onclick:tnotifyevent):tvirtuallink;
    property lastpages:tvirtualpages read ilastpages write ilastpages;
    property linkparent:tvirtualcontrol read ilinkparent;
    //window
    property screencursor:tvirtualcursor read getscreencursor write setscreencursor;
    property windowstate:twindowstate read getwindowstate write setwindowstate;
    //coordinates - form based
    property x:integer read ix;
    property y:integer read iy;
    property dx:integer read idx write idx;
    property dy:integer read idy write idy;
    property wheelv:single read iwheelv write iwheelv;
    //information
    property clas:tvirtualeventclas read iclas;
    property down:boolean read idown;
    property wasdown:boolean read iwasdown;
    property move:boolean read imove;
    property key:byte read ikey;
    property act:byte read iact;
    property ctrl:boolean read ictrl;
    property alt:boolean read ialt;
    property shift:boolean read ishift;
    function ismouse:boolean;
    function iskeyboard:boolean;
    function isrepeat:boolean;
    property clickkey:byte read iclickkey;
    //controllers
    procedure groupnotify(sender:tobject;group:integer;event:tgroupevent);
    //internal
    function ptinrect(x,y:integer;z:trect):boolean;
    function _onshortcut(_shortcut:string):boolean; virtual;
    procedure _onaltctrl(key:word);//28NOV2007
    procedure _onnotify(sender:tobject);
    function nextcontrol(next:boolean):tvirtualcontrol;
    function isve(x:tvirtualcontrol):boolean;//visible and enabled
    property minwidth:integer read iminwidth write setminwidth;
    property minheight:integer read iminheight write setminheight;
    property minspace:integer read iminspace write setminspace;
    procedure syncsrr; virtual;
    procedure wmsyscommand(var Message: TWmSysCommand); message wm_syscommand;
//yyyyyyyyyyyyyyyyyy    procedure createwindowhandle(const params:tcreateparams); override;
    //.controls as list
    function controlsAslist:tvirtualcontrols;
    function controlsAslistb(mustbeVisible,mustbeEnabled:boolean):tvirtualcontrols;
    procedure children(x:tvirtualcontrols;y:tvirtualcontrol;mustbeVisible,mustbeEnabled:boolean);
    //.other
    function focuskey(key:word;extended:boolean):boolean;
    function specialkey(key:word):boolean;
    function safekey(x:word):byte;
    procedure _onmousedown(sender:tobject;button:tmousebutton;shift:tshiftstate;x,y:integer);
    procedure _onmousemove(sender:tobject;shift:tshiftstate;x,y:integer);
    procedure _onmouseup(sender:tobject;button:tmousebutton;shift:tshiftstate;x,y:integer);
    procedure _onkeydown(sender:tobject;var key:word;shift:tshiftstate);
    procedure _onkeypress(sender:tobject;var key:char);
    procedure _onkeyup(sender:tobject;var key:word;shift:tshiftstate);
    procedure wndproc(var message:tmessage); override;
    procedure _onMasterkey(key:tmodalresult);
    procedure sync; virtual;
   end;

{tvirtualdlg}
   tvirtualdlg=class(tvirtualform)
   private
    iclient,ipanel:tvirtualpage;
    iclient2:tvirtualpagescroll;
    ihost:tvirtualcontrol;//pointer only
    ivpad:integer;
    procedure __onresize(sender:tobject);
    function _autoheight:integer;
   public
    //vars
    findtext:tvirtualedit;//pointer only
    //create
    constructor create(aowner:tcomponent); override;
    //information
    procedure scroll;//call once, to use a scrolling page instead of a static page
    property client:tvirtualpage read iclient;
    function newbutton(_caption,_tep:string;_reply:tmodalresult):tvirtualbutton;
    function newtext(_caption,_text:string;_wordwrap:boolean):tvirtualbasetext;
    function newlabel(_caption,_tep:string):tvirtuallabel;
    function newtick(_caption,_tep:string):tvirtualtick;
    function newedit(_caption,_text:string):tvirtualedit;
    function newdroplist(_caption,_text,_list,_listtep:string):tvirtualdroplist;
    function newpassword(_caption,_text:string):tvirtualbasetext;
    function newlist(_caption,_text:string):tvirtualbaselist;
    //show
    function showmodal:tmodalresult; override;
    function showwait:boolean; override;
   end;

{tvirtualcontrollist}
   tvirtualcontrollist=class(tobject)
   private
    ilockcount:integer;
    ichanged:boolean;
    icontrols:tdynamicobject;
    function getcount:integer;
    function getcontrol(x:integer):tvirtualcontrol;
   public
    //internal
    property core:tdynamicobject read icontrols;
    //create
    constructor create;
    destructor destroy; override;
    //workers
    function find(x:tobject):integer;
    function add(x:tobject;top:boolean):integer;
    function del(x:tobject):boolean;
    procedure delall(butthis:tvirtualcontrol);//13NOV2007
    procedure flush;
    property changed:boolean read ichanged write ichanged;
    //lock
    procedure lock;
    procedure unlock;
    property lockcount:integer read ilockcount;
    //information
    property count:integer read getcount;
    property items[x:integer]:tvirtualcontrol read getcontrol;
   end;

{tvirtualcontrol}
   tvirtualmovement=(vmNone,vmUp,vmUpLarge,vmUpHome,vmDn,vmDnLarge,vmDnEnd);
   tvirtualshape=(vcsAuto,vcsRounded,vcsSquare);
   tvirtualstyle=set of(vlsHover,vlsFocus);
   tvirtualheightstyle=(vhsInternal,vhsHeight,vhsFont,vhsClient,vhsUnit,vhsHost,vhsParent,vhsControls);
   tvirtualwidthstyle=(vwsInternal,vwsWidth,vwsClient,vwsHost,vwsParent);
   tvirtualcontrol=class(tobject)//"imt" = separate timer for dialog timing (gets around "system mt" getting stuck when displaying "blocking" dialogs)
   private
    imt:tobject;//internal timer for "auto-click" only - since "system mt" may become stuck when displaying a dialog box!
    icursor:tvirtualcursor;
    ipinfo:pvirtualinfo;
    igui:tvirtualform;//pointer only
    ibottommost,iroot,iparent:tvirtualcontrol;//pointer only
    icontrols:tvirtualcontrollist;
    ilastclicktime:currency;
    ihinttime,iid,isystem,ivsAPPLYID,isysptr,iscrollx,iscrolly,ilockcount,iautoclick,itimer,ivalignsep,ialignsep,ialignmargin,icx,icy,ibordersize,ileft,itop,iwidth,iheight:integer;
    ilastclickpt:tpoint;
    ialign:tvirtualalign;
    isr,isrv:trect;
    isrfull:boolean;
    idestroying,iscrollnotify,igroupfocus,ivisible,ienabled:boolean;
    itabspace:word;
    itabs,ihint,icaption:string;
    istyle:tvirtualstyle;
    ishape:tvirtualshape;
    ioheight:tvirtualheightstyle;
    iowidth:tvirtualwidthstyle;
    fonchange,fonscroll,fonresize,fonautoclick,fonrepeat,fonwheelv,fonnotify,fonclick,fondblclick:tnotifyevent;
    fonpaintborder,fonpaint:tvirtualpaintevent;
    procedure setparent(x:tvirtualcontrol);
    procedure setbordersize(x:integer);
    procedure setleft(x:integer);
    procedure settop(x:integer);
    procedure setwidth(x:integer);
    procedure setheight(x:integer);
    procedure setvisible(x:boolean);
    function getenabled:boolean;
    procedure setenabled(x:boolean);
    function getarea:trect;
    function getareab(x,y:integer):trect;
    function getscr:trect;
    function getscrv:trect;
    function getclientrect:trect;
    function getclientwidth:integer;
    function getclientheight:integer;
    function getcaption:string; virtual;
    procedure setcaption(x:string); virtual;
    function getvcaption:string;
    procedure setstyle(x:tvirtualstyle);
    procedure setnormal(x:boolean);
    function getnormal:boolean;
    function gettimer:integer;
    procedure settimer(x:integer); virtual;
    procedure setautoclick(x:integer);
    procedure _onactimer(sender:tobject);
    function gettabcount:integer;
    procedure settabs(x:string);
    function gettabs:string;
    function tabFromalign(a:talignment):char;
    function tabToalign(x:char):talignment;
    procedure setscrollx(x:integer);
    procedure setscrolly(x:integer);
    procedure setcursor(x:tvirtualcursor); virtual;
    function getrounded:boolean;
    procedure sethinttime(x:integer);
    procedure setaligns(x:tvirtualalign);
   public
    dimensionsmodified:boolean;
    hold:boolean;
    buffer:boolean;
    bufferbmp:tbitmap;//19MAY2007 - pointer only - set/flushed internally, refer to it only with "_onpaint" and "_onpaintborder" when "bufferbmp<>nil"
    group:integer;//0=no group, -x/x=group (mixed classes supported)
    tag:integer;
    tag2:integer;
    tagbol:boolean;
    modified:boolean;//like "tag/tag2", is reserved for external use (not by control directly)
    paintcount:currency;
    //used with "oHeight:=vhsUnits" => height=hunits*vhsClient
    hunits:integer;
    //focus controllers
    fFontcolor:boolean;
    fUnderline:boolean;
    fDisable:boolean;
    fBackground:boolean;
    fBorder:boolean;
    fDown:boolean;
    fUpdnpaint:boolean;
    //options
    oNumbered:boolean;
    oVariableheight:boolean;
    oVariablewidth:boolean;//22SEP2007
    oAllowvariableheights:boolean;
    oModalresult:tmodalresult;
    oPaintonvisible:boolean;
    oShowmenu:boolean;
    oAllowBlack:boolean;//TRUE=font.color is not inserted into image
    ovalRightReverse:boolean;
    oAllowCompact:boolean;//supported by tvirtualbutton so far.
    oBgcolor:integer;//background color override (clNone=system, else user)
    //action modifiers
    aDownrelaxed:boolean;
    //default overrides
    dtransparent:boolean;
    //special
    shortcut:string;
    akey:char;//A..Z, 0..9 (uppercase only)
    clickkey:byte;//space, return or none
    tabstop:boolean;
    //help
    internalhelp:string;//for internal control based help - should not be set by host unless required
    help:string;//additional help
    help2:string;//2nd additional help
    //astext - convert controls to text for easy "copytoclipboard" functions
    function copytoclipboard:boolean;//12FEB2008
    function astext:string; virtual;//self as text - 12FEB2008
    function childrenastext:string;//12FEB2008
    function childrenastextex(includeall:boolean):string;//12FEB2008
    //width
    function getalignwidth:integer; virtual;//default=vwsInternal
    function _vwsInternal:integer; virtual;
    function _vwsWidth:integer; virtual;
    function _vwsClient:integer; virtual;
    function _vwsHost:integer; virtual;
    function _vwsParent:integer; virtual;
    //height
    function getalignheight:integer; virtual;//default=vhsClient
    function _vhsInternal:integer; virtual;
    function _vhsHeight:integer; virtual;
    function _vhsFont:integer; virtual;
    function _vhsClient:integer; virtual;
    function _vhsUnit:integer; virtual;
    function _vhsHost:integer; virtual;
    function _vhsParent:integer; virtual;
    function _vhsControls:integer; virtual;//12OCT2007
    procedure setoheight(x:tvirtualheightstyle); virtual;//09NOV2007
    //create
    constructor create(_gui:tvirtualform); virtual;
    procedure destroyinit;
    destructor destroy; override;
    procedure destroychildren;
    property destroying:boolean read idestroying;
    procedure setup(_parent:tvirtualcontrol);
    //new
    function new(_type:string;_caption,_tep,_help:string;_align:tvirtualalign;_onclick:tnotifyevent):tvirtualcontrol; virtual;
    function newb(_type:string;_caption,_tep,_help:string;_align:tvirtualalign;_onclick:tnotifyevent;_sysptr:integer;_style:tstoragestyle;_default,_range:string):tvirtualcontrol;
    function placeon(x:tvirtualcontrol):tvirtualcontrol;
    function newlink(_caption,_tep,_help:string;_onclick:tnotifyevent):tvirtuallink;
    function newllink(_caption,_tep,_help:string;_onclick:tnotifyevent):tvirtuallink;
    function newlinkex(_caption,_tep,_help:string;_onclick:tnotifyevent;_left:boolean):tvirtuallink;
    //tabs
    function tabset(x:integer;a:talignment;y:integer):boolean;
    function tabget(x:integer;var a:talignment;var y:integer):boolean;
    property tabspace:word read itabspace;
    function istabs(x:string):boolean;
    property tabs:string read gettabs write settabs;
    property tabcount:integer read gettabcount;
    //dimensions
    property oheight:tvirtualheightstyle read ioheight write setoheight;
    property owidth:tvirtualwidthstyle read iowidth write iowidth;
    property id:integer read iid;
    property autoclick:integer read iautoclick write setautoclick;
    property gui:tvirtualform read igui;
    property root:tvirtualcontrol read iroot;
    property left:integer read ileft write setleft;
    property top:integer read itop write settop;
    property width:integer read iwidth write setwidth;
    property height:integer read iheight write setheight;
    property alignwidth:integer read getalignwidth;
    property alignheight:integer read getalignheight;
    function setbounds(_left,_top,_width,_height:integer):boolean;
    function setboundsb(_left,_top,_width,_height:integer):boolean;
    function setboundsex(_left,_top,_width,_height:integer;_forceupdate:boolean):boolean;
    property visible:boolean read ivisible write setvisible;
    property enabled:boolean read getenabled write setenabled;
    property bordersize:integer read ibordersize write setbordersize;
    property cx:integer read icx;
    property cy:integer read icy;
    property caption:string read getcaption write setcaption;
    property vcaption:string read getvcaption;
    property hint:string read ihint write ihint;
    property hinttime:integer read ihinttime write sethinttime;
    property align:tvirtualalign read ialign write ialign;
    property aligns:tvirtualalign write setaligns;//sync all children
    property alignsep:integer read ialignsep write ialignsep;
    property valignsep:integer read ivalignsep write ivalignsep;
    property alignmargin:integer read ialignmargin write ialignmargin;
    property groupfocus:boolean read igroupfocus write igroupfocus;
    function canfocus:boolean;
    function focused:boolean;
    function canhover:boolean;
    function hovering:boolean;
    function down:boolean;
    property style:tvirtualstyle read istyle write setstyle;
    property shape:tvirtualshape read ishape write ishape;
    property rounded:boolean read getrounded;
    property cursor:tvirtualcursor read icursor write setcursor;
    property timer:integer read gettimer write settimer;//built-in timer (_ontimer)
    function compact:boolean;
    //coordinates - local (using gui.screenx/y)
    function x:integer;
    function y:integer;
    function dx:integer;
    function dy:integer;
    function inclient:boolean;
    function inborder:boolean;
    //screen - desktop based coordinates
    function screenx:integer;
    function screeny:integer;
    //scroll
    property scrollnotify:boolean read iscrollnotify write iscrollnotify;
    function scroll(x,y:integer;_notify:boolean):boolean;
    property scrollx:integer read iscrollx write setscrollx;
    property scrolly:integer read iscrolly write setscrolly;
    procedure scrollchanged;
    property onscroll:tnotifyevent read fonscroll write fonscroll;
    //lock
    procedure lock; virtual;
    procedure unlock; virtual;
    procedure unlockb(_paint:boolean); virtual;
    function locked:boolean;
    //click
    function canclick:boolean;//02FEB2008
    procedure click; virtual;
    property onclick:tnotifyevent read fonclick write fonclick;
    property onautoclick:tnotifyevent read fonautoclick write fonautoclick;
    procedure dblclick;
    procedure dblclickcancel;
    property ondblclick:tnotifyevent read fondblclick write fondblclick;
    property onnotify:tnotifyevent read fonnotify write fonnotify;
    property onrepeat:tnotifyevent read fonrepeat write fonrepeat;
    property onwheelv:tnotifyevent read fonwheelv write fonwheelv;
    //info
    procedure statefilter(var x:tpixelfilter);
    property normal:boolean read getnormal write setnormal;
    property info:pvirtualinfo read ipinfo;
    //client
    property clientwidth:integer read getclientwidth;
    property clientheight:integer read getclientheight;
    property clientrect:trect read getclientrect;
    //parent
    property parent:tvirtualcontrol read iparent write setparent;
    //paint
    function canpaint:boolean;
    procedure paint; virtual;
    procedure paintb(recurs:boolean);
    //workers
    procedure update;
    procedure updateb(recurs:boolean);
    //mainrect
    property area:trect read getarea;
    property areab[x,y:integer]:trect read getareab;
    //system
    property sysptr:integer read isysptr write isysptr;
    procedure onsystem(sender:tobject);//keep procedure non-virtual for extreme safety
    procedure readwrite(mode:tvirtualstoragemode); virtual;
    //events
    property onpaintborder:tvirtualpaintevent read fonpaintborder write fonpaintborder;
    property onpaint:tvirtualpaintevent read fonpaint write fonpaint;
    property onresize:tnotifyevent read fonresize write fonresize;
    property onchange:tnotifyevent read fonchange write fonchange;
    //internal
    //.screen
    property srfull:boolean read isrfull write isrfull;
    property srv:trect read isrv write isrv;//visible rect on screen, in screen coordinates
    property sr:trect read isr write isr;//full rect on screen, in screen coordinates
    property scrv:trect read getscrv;
    property scr:trect read getscr;
    //.other
    property controls:tvirtualcontrollist read icontrols;
    function showing:boolean;
    procedure _onpaintborder(sender:tobject;canvas:tcanvas); virtual;
    procedure _onpaint(sender:tobject;canvas:tcanvas); virtual;
    procedure _onnotify(sender:tobject); virtual;
    procedure _onwheelv(sender:tobject); virtual;
    procedure _onrepeat(sender:tobject); virtual;
    procedure _onstate(sender:tobject); virtual;//for detecting change in "shift,alt and ctrl"
    procedure _ontimer(sender:tobject); virtual;
    function canalign:boolean; virtual;
    procedure doalign; virtual;
    procedure doalignb(leftpad:integer); virtual;
    property bottommost:tvirtualcontrol read ibottommost;//bottom most control
    procedure realign(_paint:boolean);
    property tabstr:string read itabs;
    function _onshortcut(_shortcut:string):boolean; virtual;
    procedure doonchange; virtual;
   end;

{tstripscroll}
   tstripscrollitem=record
     image:tvirtualbitmapanimated;
     text:string;
     url:string;
     width:integer;
     height:integer;
     canrun:boolean;
     end;//end of record
   tstripscrollitems=record
     items:array[0..99] of tstripscrollitem;//accepted range of 0..255
     xstep:integer;//amount to scroll items by
     ispace:integer;//space between image and text (if both present)
     hspace:integer;//trailing space (between separate items)
     count:integer;
     left:integer;
     width:integer;
     mustpaint:boolean;
     end;//end of record
   tstripscroll=class(tvirtualcontrol)
   private
    iwaiting,imousedown,iadding,ipainting:boolean;
    imax:integer;
    icore:tstripscrollitems;
    iclickindex:string;
    procedure sync;
    procedure _onclick(sender:tobject);
    function _add(_tep,_text,_url:string):boolean;
   public
    //internal
    procedure readwrite(mode:tvirtualstoragemode); override;
    procedure _ontimer(sender:tobject); override;
    procedure _onpaint(sender:tobject;canvas:tcanvas); override;
    procedure _onnotify(sender:tobject); override;
    //create
    constructor create(_gui:tvirtualform); override;
    destructor destroy; override;
    //add
    procedure clear;
    function add(_tep,_text,_url:string):boolean;
    function addall(x:string):boolean;//29FEB2008
   end;

{tvirtualhead}
   tvirtualhead=class(tvirtualcontrol)
   private
    icatlist:tpoplist;
    ilastcat:string;
    iimage:tvirtualbitmapanimated;
    imoving,ishowclone,imousedown:boolean;
    ioth1:tvirtualpage;
    isize,icat:tvirtualglyph;
    idef,imin,iwnd,imax,iclose:tvirtualbutton;
    procedure _onactive(sender:tobject);
    procedure _onicon(sender:tobject);
    procedure _onclick(sender:tobject);
    procedure _ondblclick(sender:tobject);
    procedure _oncat(sender:tobject);
    procedure _onsize(sender:tobject);
    procedure _cat;
   public
    //internal
    function _vhsInternal:integer; override;
    //create
    constructor create(_gui:tvirtualform); override;
    destructor destroy; override;
    //information
    property min:tvirtualbutton read imin;
    property wnd:tvirtualbutton read iwnd;
    property max:tvirtualbutton read imax;
    property close:tvirtualbutton read iclose;
    property image:tvirtualbitmapanimated read iimage;
    //sync
    procedure syncbuttons;
    //internal
    procedure _onpaintborder(sender:tobject;canvas:tcanvas); override;
    procedure _onpaint(sender:tobject;canvas:tcanvas); override;
    procedure _onnotify(sender:tobject); override;
    procedure _onwheelv(sender:tobject); override;
    procedure readwrite(mode:tvirtualstoragemode); override;
   end;

{tvirtualbutton}
   tvirtualbutton=class(tvirtualcontrol)
   private
    imark,imousedown:boolean;
    iimage:tvirtualbitmapanimated;
    iimagealign:tvirtualalign;
    function gethaveimage:boolean;
    procedure setmark(x:boolean);
    procedure setanimation(x:string);
   public
    //vars
    padwidth:integer;
    //extra options
    oFrameimage:boolean;//TRUE=paints a single line border around image (used for image previewers etc)
    //internal
    function _vhsInternal:integer; override;
    function _vwsInternal:integer; override;
    //create
    constructor create(_gui:tvirtualform); override;
    destructor destroy; override;
    //image
    property animation:string write setanimation;
    property haveimage:boolean read gethaveimage;
    property imagealign:tvirtualalign read iimagealign write iimagealign;
    property image:tvirtualbitmapanimated read iimage;//sometimes will be nil, must check before using
    property mark:boolean read imark write setmark;
    //other
    procedure _onpaint(sender:tobject;canvas:tcanvas); override;
    procedure _onnotify(sender:tobject); override;
    procedure aslink;
    procedure aslinkb(_right:boolean);
   end;

{tvirtualglyph}
   tvirtualglyph=class(tvirtualbutton)
   public
    //internal
    function _vwsInternal:integer; override;
    //create
    constructor create(_gui:tvirtualform); override;
   end;

{tvirtualmousecursor}
   tvirtualmousecursor=class(tvirtualbutton)
   private
    idata:string;
    procedure _nocursor;
    procedure setcursor(x:tvirtualcursor); override;
   public
    //create
    constructor create(_gui:tvirtualform); override;
    //information
    function havecursor:boolean;
    //internal
    procedure readwrite(mode:tvirtualstoragemode); override;
    procedure click; override;
   end;

{tvirtualtick}
   tvirtualtick=class(tvirtualbutton)
   private
    iticked:boolean;
    fontick:tnotifyevent;
    procedure setticked(x:boolean);
   public
    //create
    constructor create(_gui:tvirtualform); override;
    //information
    property ticked:boolean read iticked write setticked;
    property ontick:tnotifyevent read fontick write fontick;
    procedure click; override;
    //system
    procedure readwrite(mode:tvirtualstoragemode); override;
   end;

{tvirtuallabel}
   tvirtuallabel=class(tvirtualbutton)//with image support
   private
    ixshift:integer;
   public
    constructor create(_gui:tvirtualform); override;
   end;

{tvirtuallabelb}
   tvirtuallabelb=class(tvirtuallabel)//with tabs (no image support)
   public
    procedure _onpaint(sender:tobject;canvas:tcanvas); override;
   end;

{tvirtualpanel}
   tvirtualpanel=class(tvirtualcontrol)
   public
    constructor create(_gui:tvirtualform); override;
   end;

{tvirtualflash}
   tvirtualflash=class(tvirtualpanel)
   private
    ion:boolean;
   public
    //internal
    procedure settimer(x:integer); override;
    procedure _onpaint(sender:tobject;canvas:tcanvas); override;
    procedure _ontimer(sender:tobject); override;
    //create
    constructor create(_gui:tvirtualform); override;
   end;

{tvirtualprogress}
   tvirtualprogress=class(tvirtualpanel)
   private
    iprogress:single;
    iprogresscaption:string;
    imustpaint,ishowtext:boolean;
    procedure setprogress(x:single);
    procedure setshowtext(x:boolean);
   public
    //create
    constructor create(_gui:tvirtualform); override;
    //progress - range 0..100 (to 2 decimal points)
    property progress:single read iprogress write setprogress;
    property showtext:boolean read ishowtext write setshowtext;
    //internal
    procedure _onpaint(sender:tobject;canvas:tcanvas); override;
    procedure _ontimer(sender:tobject); override;
   end;

{tvirtualchart}
   tvirtualchartstyle=set of (vcsHorzLines,vcsVertLines,vcsMarks,vcsFill,vcsMini);
   tvirtualchartmovement=(vcmScrollLeft,vcmScrollRight);
   tvirtualchart=class(tvirtualpanel)
   private
    istyle:tvirtualchartstyle;
    imovement:tvirtualchartmovement;
    itext:string;
    iv:array[-1..60] of tpoint;
    ivalues:array[0..59] of integer;
    isegvalue,imarkpos,ilv,imaxvalue:integer;
    procedure setmaxvalue(x:integer);
    procedure setstyle(x:tvirtualchartstyle);
    procedure setmovement(x:tvirtualchartmovement);
   public
    //create
    constructor create(_gui:tvirtualform); override;
    //style
    property style:tvirtualchartstyle read istyle write setstyle;
    property movement:tvirtualchartmovement read imovement write setmovement;
    //text
    property text:string read itext write itext;//additional text (caption + text)
    //clear
    procedure clear;
    //value
    property maxvalue:integer read imaxvalue write setmaxvalue;
    procedure pushvalue(x:integer);
    procedure pushvalueb(x,_segvalue:integer);
    //internal
    procedure _onpaint(sender:tobject;canvas:tcanvas); override;
   end;

{tvirtualsep}
   tvirtualsep=class(tvirtualpanel)
   public
    //options
    oPaintcolor:boolean;
    //create
    constructor create(_gui:tvirtualform); override;
    procedure _onpaint(sender:tobject;canvas:tcanvas); override;
   end;

{tvirtuallink}
   tvirtuallink=class(tvirtualbutton)
   public
    //internal
    function _vwsInternal:integer; override;
    //create
    constructor create(_gui:tvirtualform); override;
   end;

{tvirtualpage}
   tvirtualpage=class(tvirtualpanel)
   private
    ipagetabs:tvirtualpages;
    function getpagetabs:tvirtualpages;
   public
    //vars
    button:tvirtualbutton;//points to TAB/BUTTON that controls page for a multipage control
    //internal
    function getclient:tvirtualpage; virtual;//compatiable with "tvirtualpagescroll" (both can refer to .client for ease of use)
    //create
    constructor create(_gui:tvirtualform); override;
    destructor destroy; override;
    //workers
    property client:tvirtualpage read getclient;
    //pagetabs - auto. creates a tabs for multiple sub-pages
    property pagetabs:tvirtualpages read getpagetabs;//08SEP2007
   end;

{tvirtualhelp}
   tvirtualhelp=class(tvirtualpage)
   private
    ideftext,itext,ittext:string;
    iimg:tvirtuallink;
    ipos:integer;
    ipostime:currency;
    procedure settext(x:string);
    procedure paintscroll;
   public
    //internal
    procedure _onpaint(sender:tobject;canvas:tcanvas); override;
    procedure _ontimer(sender:tobject); override;
    //create
    constructor create(_gui:tvirtualform); override;
    destructor destroy; override;
    //workers
    property text:string read itext write settext;
   end;

{tmanaged}
   tmanaged=class(tvirtualpage)
   private
    ivars:tdynamictext;
   public
    //create
    constructor create(_gui:tvirtualform;_sysptr:integer;_vars:string); virtual;
    procedure createfinished;
    destructor destroy; override;
    //vars - note: use only between "create...createfinished"
    property vars:tdynamictext read ivars;
   end;

{tvirtualpagescroll}
   tvirtualpagescroll=class(tvirtualpage)
   private
    ilastsbw:integer;
    ibar:tvirtualpage;
    isb:tvirtualscrollbar;
    iclient:tvirtualpage;
    ilockalign:integer;
    procedure _onpos(sender:tobject);
   public
    //internal
    function getclient:tvirtualpage; override;
    procedure _onpaint(sender:tobject;canvas:tcanvas); override;
    function canalign:boolean; override;
    procedure doalign; override;
    procedure readwrite(mode:tvirtualstoragemode); override;
    //create
    constructor create(_gui:tvirtualform); override;
    destructor destroy; override;
    //new
    function new(_type:string;_caption,_tep,_help:string;_align:tvirtualalign;_onclick:tnotifyevent):tvirtualcontrol; override;
    function newb(_type:string;_caption,_tep,_help:string;_align:tvirtualalign;_onclick:tnotifyevent;_sysptr:integer;_style:tstoragestyle;_default,_range:string):tvirtualcontrol;
    //information
    property sb:tvirtualscrollbar read isb;
    property bar:tvirtualpage read ibar;
    procedure fillbar;
    procedure lockalign;
    procedure unlockalign;
   end;

{tvirtualpagevsplit}
   tvirtualpagevsplit=class(tvirtualpage)
   private
    ifillbar:boolean;
    ipages:array[0..1] of tvirtualpage;
    ipercentage:extended;
    ipageheight:integer;
    ihorizontal:boolean;
    function getpages(x:integer):tvirtualpage;
    procedure setpercentage(x:extended);
    procedure setpageheight(x:integer);
    procedure sethorizontal(x:boolean);
   public
    //vars
    hspace:integer;//space between two HORIZONTAL [a]<space>[b] pages
    //internal
    function canalign:boolean; override;
    procedure doalign; override;
    //create
    constructor create(_gui:tvirtualform); override;
    procedure createinit(scrollTOP,scrollBOTTOM:boolean);
    //pages
    property pages[x:integer]:tvirtualpage read getpages;
    property percentage:extended read ipercentage write setpercentage;
    property pageheight:integer read ipageheight write setpageheight;
    property horizontal:boolean read ihorizontal write sethorizontal;
    procedure fillbar;
   end;

{tvirtualgrid}
   tvirtualgrid=class(tvirtualpage)
   private
    ispace:integer;
   public
    oAlignpastcaption:boolean;
    //internal
    procedure doalign; override;
    procedure _onpaint(sender:tobject;canvas:tcanvas); override;
    function _vhsInternal:integer; override;
    //create
    constructor create(_gui:tvirtualform); override;
    //information
    property space:integer read ispace write ispace;
   end;

{tvirtualtitle}
   tvirtualtitle=class(tvirtuallabel)
   public
    fBold:boolean;
    fheightfixed:integer;
    constructor create(_gui:tvirtualform); override;
    destructor destroy; override;
    procedure _onpaint(sender:tobject;canvas:tcanvas); override;
   end;

{tvirtualtitleb}
   tvirtualtitleb=class(tvirtualtitle)//with tabs
   public
    constructor create(_gui:tvirtualform); override;
    procedure _onpaint(sender:tobject;canvas:tcanvas); override;
   end;

{tvirtualrows}
   tvirtualrows=class(tvirtualcontrol)//with tabs
   private
    iitems:tstringlist;
    iitemlimit:integer;
    procedure __onitems(sender:tobject);
    procedure setitemlimit(x:integer);
    function __vhsOne:integer;
   public
    //events
    ondrawitem:tvirtualdrawevent;
    ontext:tvirtualtextevent;
    onimage:tvirtualimageevent;
    //internal
    function _vhsInternal:integer; override;
    //create
    constructor create(_gui:tvirtualform); override;
    destructor destroy; override;
    //items
    property items:tstringlist read iitems;
    property itemlimit:integer read iitemlimit write setitemlimit;//1..X
    //internal
    procedure _onpaint(sender:tobject;canvas:tcanvas); override;
    procedure _ondrawitem(control:tvirtualcontrol;canvas:tcanvas;index:integer;area:trect;state:tvirtualdrawstate);
    function astext:string; override;//12FEB2008
   end;

{tvirtualcolor}
   tvirtualcolor=class(tvirtualbutton)
   private
    iautoapply,imovecolor:boolean;
    iwascolor,icolor:integer;
    procedure setcolor(x:integer);
    function __vhsOne:integer;
   public
    //vars
    highcontrast:boolean;
    //events
    onchanging:tnotifyevent;//triggered when color is about to change
    //internal
    procedure _onpaintborder(sender:tobject;canvas:tcanvas); override;
    procedure _onpaint(sender:tobject;canvas:tcanvas); override;
    procedure _onnotify(sender:tobject); override;
    procedure click; override;
    function _vhsInternal:integer; override;
    function _vwsInternal:integer; override;
    //create
    constructor create(_gui:tvirtualform); override;
    //other
    property autoapply:boolean read iautoapply write iautoapply;
    property color:integer read icolor write setcolor;
    property changing:boolean read imousedown;//07MAR2007
    //system
    procedure readwrite(mode:tvirtualstoragemode); override;
   end;

{tvirtualscrollbar}
   tvirtualscrollbar=class(tvirtualcontrol)
   private
    iup,idn:tvirtualbitmap;
    istepby,idownpos,iscrollwidth,ibutsize,islidesize,idx,idy,ismall,ilarge,imag,imin,imax,ipos:integer;
    iscrolling,ivertical:boolean;
    ipixelpower:extended;
    idownmovement:tvirtualmovement;
    fonpos:tnotifyevent;
    procedure setvertical(x:boolean);
    procedure setmin(x:integer);
    procedure setpos(x:integer);
    procedure setmax(x:integer);
    procedure setsmall(x:integer);
    procedure setlarge(x:integer);
    procedure mousedown;
    procedure setstepby(x:integer);
   public
    //create
    constructor create(_gui:tvirtualform); override;
    destructor destroy; override;
    //information
    property vertical:boolean read ivertical write setvertical;
    property min:integer read imin write setmin;
    property max:integer read imax write setmax;
    property pos:integer read ipos write setpos;
    property small:integer read ismall write setsmall;
    property large:integer read ilarge write setlarge;
    function setparams(_min,_pos,_max:integer;_notify:boolean):boolean;
    property stepby:integer read istepby write setstepby;
    //coordinates
    function scrollx:integer;
    function scrolldx:integer;
    property scrollwidth:integer read iscrollwidth;
    property scrolling:boolean read iscrolling;
    property butsize:integer read ibutsize;
    property slidesize:integer read islidesize;
    function scrollrect:trect;
    function sliderect:trect;
    function slidexw:tpoint;
    function movement:tvirtualmovement;
    //events
    property onpos:tnotifyevent read fonpos write fonpos;
    //internal
    procedure init;
    procedure _onpaint(sender:tobject;canvas:tcanvas); override;
    procedure _onnotify(sender:tobject); override;
    procedure _onwheelv(sender:tobject); override;
    procedure _onrepeat(sender:tobject); override;
    function canalign:boolean; override;
    procedure doalign; override;
    procedure readwrite(mode:tvirtualstoragemode); override;
   end;

{tvirtualbaselist}
   tvirtualeditfeatures=set of(vefSelectAll,vefCut,vefCopy,vefCopyAll,vefPaste,vefDelete,vefUpper,vefLower,vefEdit);
   tvirtualseltype=set of (vslMouse,vslKeyboard);
   tvirtualkeyevent=procedure(sender:tobject;var key:byte) of object;
   tgetitemevent=procedure(sender:tobject;index:integer;var value:string) of object;
   tdelitemevent=procedure(sender:tobject;index:integer) of object;
   tindentevent=procedure(sender:tobject;index:integer;var value:word) of object;
   tvirtualbaselist=class(tvirtualcontrol)
   private
    iimage:tvirtualbitmap;
    ief:tvirtualeditfeatures;
    ipopmenu:tpopmenu;
    itep,ipartialinfo:string;
    ipartialpaint,ireadonly,istoppaint,imultiselect,iautohide,iautofind,iclientfocused,isbfocused:boolean;
    isb:tvirtualscrollbar;
    ilastch,iselpos,icount,iitemindex,iitemheight,ipaintih:integer;
    iselactive:tvirtualseltype;
    fonitemindex,fonitemhard,fonpos:tnotifyevent;
    fondrawitem:tvirtualdrawevent;
    fontext:tvirtualtextevent;
    fonimage:tvirtualimageevent;
    fongetitem:tgetitemevent;
    fondelitem:tdelitemevent;
    fongetindent:tindentevent;
    procedure setitemindex(x:integer);
    procedure settopindex(x:integer);
    procedure setcount(x:integer);
    procedure setitemheight(x:integer);
    function gettopindex:integer;
    procedure _onpos(sender:tobject);
    procedure init;
    function getitem(x:integer):string; virtual;
    procedure setitem(x:integer;y:string); virtual;
    function getindent(x:integer):word; virtual;
    procedure setindent(x:integer;y:word); virtual;
    procedure setautohide(x:boolean);
    procedure setmultiselect(x:boolean);
    procedure _autohide;
    procedure mousedown;
    function getselected(x:integer):boolean;
    procedure _scrollbar;
    function getcanshowmenu:boolean;
    function gettext:string; virtual;
    procedure settext(x:string); virtual;
    procedure _onimage(sender:tobject;index:integer;var image:tvirtualbitmap);
    procedure settep(x:string);
   public
    //options
    oShowtextlarge:boolean;
    oAsname:boolean;//displays text as names
    oIndent:boolean;
    bufferrows:boolean;
    //events
    onkey:tvirtualkeyevent;//triggered when user presses as key
    ondrawiteminit:tvirtualdrawevent;
    onreturn:tnotifyevent;
    onescape:tnotifyevent;
    //create
    constructor create(_gui:tvirtualform); override;
    destructor destroy; override;
    //information
    function setparams(_itemindex,_topindex,_count,_itemheight:integer;_paint:boolean):boolean;
    function setparamsb(_selpos,_itemindex,_topindex,_count,_itemheight:integer;_paint:boolean):boolean;
    property itemindex:integer read iitemindex write setitemindex;
    property topindex:integer read gettopindex write settopindex;//"topindex"
    property count:integer read icount write setcount;
    property itemheight:integer read iitemheight write setitemheight;
    property paintitemheight:integer read ipaintih;
    function vstart:integer;
    function vfinish:integer;
    function vcount:integer;
    function itemAsrect(p:integer;var r:trect):boolean;
    function itematpos(x,y:integer;existing:boolean):integer;
    property items[x:integer]:string read getitem write setitem;
    property indents[x:integer]:word read getindent write setindent;
    property onitem:tnotifyevent read fonpos write fonpos;
    property onitemhard:tnotifyevent read fonitemhard write fonitemhard;
    property onitemindex:tnotifyevent read fonitemindex write fonitemindex;
    //partial
    procedure partialinit;
    procedure partialpaint;
    //text
    property text:string read gettext write settext;
    property readonly:boolean read ireadonly write ireadonly;
    //image
    property tep:string read itep write settep;
    //selectall
    function canselectall:boolean;
    function selectall(var e:string):boolean;
    //cut
    function cancuttoclipboard:boolean;
    function cuttoclipboard(var e:string):boolean;
    //copy
    function cancopytoclipboard:boolean;
    function copytoclipboard(var e:string):boolean;
    //copy all
    function cancopyall:boolean;
    function copyall(var e:string):boolean;
    //paste
    function canpastefromclipboard:boolean;
    function pastefromclipboard(var e:string):boolean;
    //delete
    function candelete:boolean;
    function delete(var e:string):boolean;//delete selection
    //upper
    function canupper:boolean;
    function upper:boolean;
    //lower
    function canlower:boolean;
    function lower:boolean;
    //edit
    function canedit:boolean;
    function edit:boolean;
    //edit features
    property ef:tvirtualeditfeatures read ief write ief;
    //showmenu
    property canshowmenu:boolean read getcanshowmenu;
    procedure showmenu;
    //options
    //.autohide - scrollbar
    property autohide:boolean read iautohide write setautohide;
    //.autofind
    property autofind:boolean read iautofind write iautofind;
    function findtext(x:string):integer;
    function findtextb(from:integer;x:string;loop:boolean):integer;
    function findvalue(x:string):integer;
    //.multiselect
    property multiselect:boolean read imultiselect write setmultiselect;
    function seltext:string;
    function selstart:integer;
    function selcount:integer;
    property selected[x:integer]:boolean read getselected;
    property selpos:integer read iselpos;//internal use only
    procedure getselA(var x:string);
    procedure getselB(var x:string);
    procedure getselC(var x:string);
    procedure delselB(var i:integer);
    //.selactive
    property selactive:tvirtualseltype read iselactive write iselactive;
    //misc
    function sbwidth:integer;//returns value if scrollbar is visible to user, else returns zero
    function areawidth:integer;
    //events
    property ondrawitem:tvirtualdrawevent read fondrawitem write fondrawitem;
    property ontext:tvirtualtextevent read fontext write fontext;
    property onimage:tvirtualimageevent read fonimage write fonimage;
    property ongetitem:tgetitemevent read fongetitem write fongetitem;
    property ondelitem:tdelitemevent read fondelitem write fondelitem;
    property ongetindent:tindentevent read fongetindent write fongetindent;
    //system
    procedure readwrite(mode:tvirtualstoragemode); override;
    //internal
    procedure deleteitem(x:integer); virtual;
    procedure _onrepeat(sender:tobject); override;
    procedure _onnotify(sender:tobject); override;
    procedure _onwheelv(sender:tobject); override;
    procedure _onstate(sender:tobject); override;
    procedure _onpaint(sender:tobject;canvas:tcanvas); override;
    procedure _ondrawitem(control:tvirtualcontrol;canvas:tcanvas;index:integer;area:trect;state:tvirtualdrawstate);
    function _onshortcut(_shortcut:string):boolean; override;
    function canalign:boolean; override;
    procedure doalign; override;
    procedure lock; override;
    procedure unlock; override;
    function astext:string; override;
   end;

{tvirtuallist}
   tvirtuallist=class(tvirtualbaselist)
   private
    iitems:tstringlist;
    function getitem(x:integer):string; override;
    procedure setitem(x:integer;y:string); override;
    function gettext:string; override;
    procedure settext(x:string); override;
    procedure _onchange(sender:tobject);
   public
    //create
    constructor create(_gui:tvirtualform); override;
    destructor destroy; override;
    //read/write
    procedure readwrite(mode:tvirtualstoragemode); override;
    //information
    property text:string read gettext write settext;
    property items:tstringlist read iitems;
    //internal
    procedure deleteitem(x:integer); override;
   end;

{tvirtualbasetext}
   tfiltertextevent=procedure(sender:tobject;var text:string) of object;
   tvirtualbasetext=class(tvirtualcontrol)
   private
    ief:tvirtualeditfeatures;
    ipopmenu:tpopmenu;
    itime:currency;
    iitemindexlimit,iitemindex,iscrollsize,ifontid,imaxlen,ispace:integer;
    icanedit,iblink,ireadonly:boolean;
    function getcount:integer; virtual;
    procedure setmaxlen(x:integer); virtual;
    function getmaxlen:integer; virtual;
    procedure settext(x:string); virtual;
    function gettext:string; virtual;
    procedure setmask(x:char); virtual;
    function getmask:char; virtual;
    function getcanshowmenu:boolean; virtual;
    function getwordwrap:boolean; virtual;
    function getmouseitem(topindex:integer;existing:boolean):integer;
    procedure setitemindex(x:integer); virtual;
    function getseltext:string; virtual;
    procedure _paintsingleline(sender:tobject;canvas:tcanvas;x:string);
   public
    //vars
    showtextlarge:boolean;//showtext dialog
    fhighlight:boolean;
    oLargeCursor:boolean;
    //events
    onreturn:tnotifyevent;
    onescape:tnotifyevent;
    onfilter:tfiltertextevent;
    //create
    constructor create(_gui:tvirtualform); override;
    destructor destroy; override;
    //text
    property count:integer read getcount;
    function limit:integer;
    property text:string read gettext write settext;
    property mask:char read getmask write setmask;
    property readonly:boolean read ireadonly write ireadonly;
    property maxlen:integer read getmaxlen write setmaxlen;//0=unlimited
    property wordwrap:boolean read getwordwrap;
    //itemindex
    function autoitemindex(topindex:integer;existing:boolean):integer;
    property itemindex:integer read iitemindex write setitemindex;
    //copy
    function cancopytoclipboard:boolean;
    function copytoclipboard(var e:string):boolean;
    //copyall
    function cancopyall:boolean;
    function copyall(var e:string):boolean;
    //cut
    function cancuttoclipboard:boolean;
    function cuttoclipboard(var e:string):boolean;
    //paste
    function canpastefromclipboard:boolean;
    function pastefromclipboard(var e:string):boolean;
    //delete
    function candelete:boolean;
    function delete(var e:string):boolean;
    //clear* - uneffected by "readonly"
    function canclear:boolean;
    function clear:boolean;
    //upper
    function canupper:boolean;
    function upper:boolean;
    //lower
    function canlower:boolean;
    function lower:boolean;
    //edit
    function canedit:boolean; virtual;
    function edit:boolean;
    //add
    procedure addchar(x:char); virtual;
    //delete
    procedure deleteleft; virtual;
    procedure deleteright; virtual;
    //edit features
    property ef:tvirtualeditfeatures read ief write ief;
    //move
    procedure moveleft; virtual;
    procedure moveright; virtual;
    procedure moveup; virtual;
    procedure movedown; virtual;
    procedure movehome; virtual;
    procedure moveend; virtual;
    //showmenu
    property canshowmenu:boolean read getcanshowmenu;
    procedure showmenu;
    //system
    procedure readwrite(mode:tvirtualstoragemode); override;
    //internal
    procedure _ontimer(sender:tobject); override;
    procedure timereset;
    procedure _onnotify(sender:tobject); override;
    procedure _onpaint(sender:tobject;canvas:tcanvas); override;
    function _onshortcut(_shortcut:string):boolean; override;
    function _filter(x:string):string; virtual;
    function astext:string; override;//12FEB2008
   end;

{tvirtualpassword}
   tvirtualpassword=class(tvirtualbasetext)
   private
    imask:char;
    itext:string;
   public
    //create
    constructor create(_gui:tvirtualform); override;
    //information
    function setparams(_mask:char;var _text:string;_notify:boolean):boolean;
    //internal
    procedure settext(x:string); override;
    function gettext:string; override;
    procedure setmask(x:char); override;
    function getmask:char; override;
   end;

{tvirtualedit}
   tvirtualedit=class(tvirtualbasetext)
   private
    itext:string;
   public
    //create
    constructor create(_gui:tvirtualform); override;
    //information
    function setparams(var _text:string;_notify:boolean):boolean;
    //internal
    procedure settext(x:string); override;
    function gettext:string; override;
   end;

{tvirtualtext}
   tvirtualtext=class(tvirtualbasetext)
   private
    ivclient,ihclient:boolean;
    ihunit,ilockpos:integer;
    iitems:tstringlist;
    iv,ih:tvirtualscrollbar;
    fonpos:tnotifyevent;
    procedure _onpos(sender:tobject);
    procedure calc;
    procedure setvpos(x:integer);
    procedure sethpos(x:integer);
    function getvpos:integer;
    function gethpos:integer;
    function getseltext:string; override;
   public
    //create
    constructor create(_gui:tvirtualform); override;
    destructor destroy; override;
    //information
    function setparams(_itemindex:integer;_text:string;_notify:boolean):boolean;
    //position
    function setpos(_hpos,_vpos:integer;_notify:boolean):boolean;
    property hpos:integer read gethpos write sethpos;
    property vpos:integer read getvpos write setvpos;
    property onpos:tnotifyevent read fonpos write fonpos;
    //edit
    function canedit:boolean; override;
    //find
    function find(x:string;_highlight:boolean):integer;
    //misc
    function vclientwidth:integer;
    function vclientheight:integer;
    function vcount:integer;
    function vstart:integer;
    function vfinish:integer;
    function maxwidth:integer;
    function maxheight:integer;
    //internal
    procedure _onpaint(sender:tobject;canvas:tcanvas); override;
    procedure settext(x:string); override;
    function gettext:string; override;
    function getcount:integer; override;
    function canalign:boolean; override;
    procedure doalign; override;
    procedure _onrepeat(sender:tobject); override;
    procedure _onnotify(sender:tobject); override;
    procedure _onwheelv(sender:tobject); override;
    procedure paint; override;
    property core:tstringlist read iitems;
   end;

{tvirtualtextwrap}
   tvirtualtextwrap=class(tvirtualbasetext)
   private
    iwrapchanged,ivclient:boolean;
    ilastwidth,ilockpos:integer;
    iwrap,iitems:tstringlist;
    iv:tvirtualscrollbar;
    fonpos:tnotifyevent;
    procedure _onpos(sender:tobject);
    procedure calc;
    procedure setvpos(x:integer);
    function getvpos:integer;
    procedure dowordwrap;
    function nextwrap(var x:string;xlen,s,_maxwidth:integer):integer;
    function getwordwrap:boolean; override;
    function getseltext:string; override;
   public
    //create
    constructor create(_gui:tvirtualform); override;
    destructor destroy; override;
    //information
    function setparams(_itemindex:integer;_text:string;_notify:boolean):boolean;
    //position
    function setpos(_hpos,_vpos:integer;_notify:boolean):boolean;
    property vpos:integer read getvpos write setvpos;
    property onpos:tnotifyevent read fonpos write fonpos;
    //edit
    function canedit:boolean; override;
    //find
    function find(x:string;_highlight:boolean):integer;
    //misc
    function maxheight:integer;
    function vclientwidth:integer;
    function vcount:integer;
    function vstart:integer;
    function vfinish:integer;
    //internal
    procedure _onpaint(sender:tobject;canvas:tcanvas); override;
    procedure settext(x:string); override;
    function gettext:string; override;
    function getcount:integer; override;
    function canalign:boolean; override;
    procedure doalign; override;
    procedure _onrepeat(sender:tobject); override;
    procedure _onnotify(sender:tobject); override;
    procedure _onwheelv(sender:tobject); override;
    procedure paint; override;
    property _wrap:tstringlist read iwrap;
    property core:tstringlist read iitems;
   end;

{tvirtualmenuitem}
   tvirtualmenuitem=class(tvirtualcontrol)
   private
    imousedown:boolean;
    iimage:tvirtualbitmapanimated;
    function gethaveimage:boolean;
    procedure setanimation(x:string);
   public
    //vars
    offx:integer;
    //internal
    procedure _onpaint(sender:tobject;canvas:tcanvas); override;
    //create
    constructor create(_gui:tvirtualform); override;
    destructor destroy; override;
    //image
    property haveimage:boolean read gethaveimage;
    property image:tvirtualbitmapanimated read iimage;//sometimes will be nil, must check before using
    property animation:string write setanimation;
   end;

{tpop}
   tpop=class(tvirtualform)
   private
    fonpop:tnotifyevent;
   public
    //options
    oNumbered:boolean;
    tabs:string;
    //create
    constructor create(aowner:tcomponent); override;
    //pop
    function canpop:boolean; virtual;
    function popcursor(_popuphost:tvirtualform):boolean;
    function pop(_popuphost:tvirtualform;x,y,yh:integer):boolean; virtual;
    function popwh(_popuphost:tvirtualform;x,y,yh,w,h:integer):boolean; virtual;
    //events
    property onpop:tnotifyevent read fonpop write fonpop;
    //internal
    procedure _onpop(sender:tobject); override;
   end;

{tpoplist}
   tpoplist=class(tpop)
   private
    ititle:tvirtualtitle;
    iclose:tvirtualcontrol;
    ilist:tvirtuallist;
    itext,ivalue:string;
    ivalueindex,idropcount:integer;
    procedure __onclick(sender:tobject);
    procedure syncvalue;
    procedure settep(x:string);
    function gettep:string;
   public
    //vars
    title:string;//shows a window if not nil
    //options
    oAutoliststyle:boolean;//TRUE by default
    //events
    onitemindex:tnotifyevent;
    //create
    constructor create(aowner:tcomponent); override;
    //pop
    function popwh(_popuphost:tvirtualform;x,y,yh,w,h:integer):boolean; override;
    property tep:string read gettep write settep;//23SEP2007
    property text:string read itext write itext;
    property value:string read ivalue write ivalue;
    property valueindex:integer read ivalueindex write ivalueindex;//Note: should not write to "valueindex" - reserved for internal functions
    property dropcount:integer read idropcount write idropcount;
    //internal
    procedure _onpop(sender:tobject); override;
   end;

{tvirtualdroplist}
   tvirtualvaluestyle=(vvsNone,vvsCommaNumber);
   tvirtualdroplist=class(tvirtualcontrol)
   private
    ivaluestyle:tvirtualvaluestyle;
    ilastdropindex,idropcount:integer;
    ieditfocused,ibuttonfocused:boolean;
    iedit:tvirtualedit;
    ibutton:tvirtualbutton;
    iitems:tstringlist;
    ipoplist:tpoplist;
    function gettext:string;
    procedure settext(x:string);
    function getvalue:string;
    procedure setvalue(x:string);
    procedure setdropcount(x:integer);
   public
    //vars
    oFilter:byte;//value filter 0=none)
    oDropwhenfull:boolean;//TRUE=drops list when "enter key" is hit, FALSE=only when "edit.text=''"
    tep:string;
    //internal
    procedure setoheight(x:tvirtualheightstyle); override;
    procedure _onnotify(sender:tobject); override;
    function _onshortcut(_shortcut:string):boolean; override;
    property edit:tvirtualedit read iedit;
    //create
    constructor create(_gui:tvirtualform); override;
    destructor destroy; override;
    //items
    property text:string read gettext write settext;
    property value:string read getvalue write setvalue;
    property valuestyle:tvirtualvaluestyle read ivaluestyle write ivaluestyle;
    property items:tstringlist read iitems;
    //drop
    function candrop:boolean;
    procedure dropclose;
    function drop:boolean;
    property dropcount:integer read idropcount write setdropcount;
    //system
    procedure readwrite(mode:tvirtualstoragemode); override;
   end;

{tvirtualdropliststatic}
   //Note: all information is passed through "onclick" if "onchange" is not set
   tvirtualdropliststatic=class(tvirtualcontrol)
   private
    ivalue,idropcount:integer;
    ibuttonfocused:boolean;
    iitems:tstringlist;
    ipoplist:tpoplist;
    ititle:string;
    function gettext:string;
    procedure settext(x:string);
    function getvalue:integer;
    procedure setvalue(x:integer);
    procedure setdropcount(x:integer);
    procedure synccaption;
    procedure settitle(x:string);
    procedure syncvalue;
    procedure __onitemindex(sender:tobject);
    function getcount:integer;
   public
    //internal
    procedure doonchange; override;
    //create
    constructor create(_gui:tvirtualform); override;
    destructor destroy; override;
    //items
    property title:string read ititle write settitle;
    property text:string read gettext write settext;
    property value:integer read getvalue write setvalue;
    property count:integer read getcount;
    property items:tstringlist read iitems;
    //drop
    function candrop:boolean;
    procedure dropclose;
    function drop:boolean;
    property dropcount:integer read idropcount write setdropcount;
    //system
    procedure readwrite(mode:tvirtualstoragemode); override;
    //internal
    procedure _onnotify(sender:tobject); override;
   end;

{tpopmenu}
   tpopmenu=class(tpop)
   private
    imenu:string;//internal only
    ipmenu:pstring;//pointer only
    imenudel:boolean;
    ihandle,icode:integer;
    procedure setmenu(x:pstring);
   public
    //create
    constructor create(aowner:tcomponent); override;
    destructor destroy; override;
    //menu
    function addsep:integer;
    function additem(_caption,_tep,_shortcut:string;_code:integer;_enabled:boolean):integer;
    //pop
    function popcursor(_popuphost:tvirtualform):integer;
    function pop(_popuphost:tvirtualform;x,y,yh:integer):integer;
    //information - click based
    property handle:integer read ihandle write ihandle;
    property code:integer read icode write icode;
    //overrides
    property menu:pstring read ipmenu write setmenu;
    property menudel:boolean read imenudel write imenudel;
    //internal
    procedure _onpop(sender:tobject); override;
   end;

{tvirtualpages}
   tvirtualpagestyle=(vpsNormal,vpsScrolling,vpsVSplit,vpsPages);
   tvirtualpages=class(tvirtualcontrol)
   private
    iscrollbusy,iaslinks:boolean;
    itabs:tvirtualgrid;
    ipages:array[0..99] of tvirtualpage;
    iscroll,ilimit,ipage:integer;
    procedure setpageinit(x:integer);
    procedure setpage(x:integer);
    procedure setpageb(x:integer;_check:boolean);
    function getpages(x:integer):tvirtualcontrol;
    function getcount:integer;
    procedure __onclick(sender:tobject);
    procedure __onnotify(sender:tobject);
    function vsep:integer;
    procedure setscroll(x:integer);
   public
    //options
    oseptop:boolean;//show clear space above/below buttons
    osepbot:boolean;
    //events
    onpage:tnotifyevent;
    onscroll:teventintegerf;
    onscrollstate:tnotifyevent;
    //internal
    procedure doalign; override;
    procedure _ongroup(sender:tobject;control:tvirtualcontrol;group:integer);
    procedure _ontimer(sender:tobject); override;
    //create
    constructor create(_gui:tvirtualform); override;
    destructor destroy; override;
    //pages
    property pageinit:integer read ipage write setpageinit;
    property page:integer read ipage write setpage;
    property pages[x:integer]:tvirtualcontrol read getpages;
    function newpagevsplit(_cap:string;_tep,_help:string;_capbar,_scrollTOP,_scrollBOT:boolean):tvirtualpagevsplit;
    function newpagescroll(_cap:string;_tep,_help:string;_capbar:boolean):tvirtualpagescroll;
    function newpagescrollex(_cap:string;_tep,_help:string;_capbar,_fillbar:boolean):tvirtualpagescroll;
    function newpagestatic(_cap:string;_tep,_help:string;_capbar:boolean):tvirtualpage;
    function newpagestaticex(_cap:string;_tep,_help:string;_capbar,_fillbar:boolean):tvirtualpage;
    function newpage(_caption,_tep,_help:string;_style:tvirtualpagestyle;var _page:integer):tvirtualpage;
    function newpageb(_caption,_tep,_help:string;_style:tvirtualpagestyle;_existingpage:tvirtualpage;var _page:integer):tvirtualpage;
    property scroll:integer read iscroll write setscroll;
    //move
    procedure moveleft;
    procedure moveright;
    //information
    function valid(x:integer):boolean;
    function inuse(x:integer):boolean;
    property count:integer read getcount;//0..30
    property limit:integer read ilimit;//1..30
    function newindex:integer;
    //other
    property tabs:tvirtualgrid read itabs;
    procedure aslinks;
    procedure aslinksex(_right:boolean);
   end;

{tvirtualschemes}
   tvirtualschemes=class(tvirtualpagevsplit)
   private
    ifilename,ipretext,ischemeext:string;
    ilist:tvirtuallist;
    ibar:tvirtualpage;
    igroup:tvirtuallink;
    icopy,ipaste,idefaults,idefaultappearance,ifolder,irefresh,iloadappearance,iload,iloadfrom,isave,isaveas:tvirtualcontrol;
    procedure __onclick(sender:tobject);
    procedure _ontimer(sender:tobject); override;
    function nopretext(x:string):string;
   public
    //create
    constructor create(_gui:tvirtualform); override;
    //workers
    procedure listrefresh;
    procedure listrefreshex(n:string);
    //scheme
    function schemefilename(x:string):string;
    function schemeselected:string;
    //.load
    function canschemeload:boolean;
    function schemeload(var e:string;full:boolean):boolean;
    //.save
    function canschemesave:boolean;
    function schemesave(x:string;var e:string):boolean;
    function canschemesaveas:boolean;
    function schemesaveas(var e:string):boolean;
    //.copy/paste
    procedure copyto;
    function canpastefrom:boolean;
    procedure pastefrom;
   end;

{tvirtualfilelist}
//yyyyyyyyyyyyyyyyyyyyyyyyyyyyy//77777777777777777777
   tvirtualfilelistevent=function(sender:tobject;var filename,data,e:string):boolean of object;
   tvirtualfilelist=class(tvirtualpage)
   private
    ilist:tvirtuallist;
    ifolder,isave,isaveas,iload,irefresh:tvirtualcontrol;
    iitemlabel,iext,ipath:string;
    procedure __onclick(sender:tobject);
    procedure refreshlist;
    procedure refreshlistex(n:string);
    procedure updatebuttons;
    function getpath:string;
    procedure setpath(x:string);
    procedure setext(x:string);
    procedure settep(x:string);
    function gettep:string;
    procedure setitemindex(x:integer);
    function getitemindex:integer;
    procedure setfilename(x:string);
    function getfilename:string;
    procedure setnameonly(x:string);
    function getnameonly:string;
    function getitem(x:integer):string;
    function getshowsave:boolean;
    procedure setshowsave(x:boolean);
    function getshowload:boolean;
    procedure setshowload(x:boolean);
    function getdata:string;
    procedure setdata(x:string);
   public
    //events
    onload:tvirtualfilelistevent;
    onsave:tvirtualfilelistevent;
    //internal
    procedure readwrite(mode:tvirtualstoragemode); override;
    procedure _ontimer(sender:tobject); override;
    procedure doonchange; override;
    //create
    constructor create(_gui:tvirtualform;_title,_itemlabel:string);
    //information
    property filename:string read getfilename write setfilename;
    property nameonly:string read getnameonly write setnameonly;
    property itemindex:integer read getitemindex write setitemindex;
    property items[x:integer]:string read getitem;
    //.itemlabel - used within "replace prompt window" e.g. "replace 'scheme' " where itemlabel=scheme as an example
    property itemlabel:string read iitemlabel write iitemlabel;
    //workers
    property showload:boolean read getshowload write setshowload;
    property showsave:boolean read getshowsave write setshowsave;
    function canpath:boolean;
    property path:string read getpath write setpath;
    property ext:string read iext write setext;
    procedure setparams(_path,_ext:string);
    property tep:string read gettep write settep;
    //io
    property data:string read getdata write setdata;
    function canload:boolean;
    procedure load;
    function cansave:boolean;
    procedure save(_prompt:boolean);
    function cansaveas:boolean;
    procedure saveas;
   end;

{tvirtualanimationviewer}
   tvirtualanimationviewer=class(tvirtualpage)
   private
    tsPath,tsFiles,ilastmask,ipath:string;
    iimage:tvirtualbutton;
    ilist:tvirtuallist;
    ipathlink,ifiles,irefresh,ifolder:tvirtuallink;
    ianimations,ipictures,icursors:tvirtuallink;//support folders
    ibase,ipreview:tvirtualpagevsplit;
    ititle:tvirtualgrid;
    ioRestrictSF,ioShowFilename:boolean;
    procedure __onclick(sender:tobject);
    procedure refreshlist;
    procedure updatebuttons;
    function getpathfile:string;
    procedure setpathfile(x:string);
    function getfilename:string;
    procedure setfilename(x:string);
    function getpath:string;
    procedure setpath(x:string);
    function getimage:tvirtualbitmapanimated;
    function getframeimage:boolean;
    procedure setframeimage(x:boolean);
    procedure setbgcolor(x:integer);
    function getbgcolor:integer;
    procedure syncstatus;
    procedure setoShowfilename(x:boolean);
    procedure __onstop(sender:tobject);
    function getitemindex:integer;
    function getoshowsf:boolean;
    procedure setoshowsf(x:boolean);
    procedure setorestrictsf(x:boolean);
    function acceptable(n:string):boolean;
   public
    //vars
    namelenlimit:integer;//default=maxint
    mask:string;//optional, default=nil (all files)
    //events
    onload:tnotifyevent;
    onstopnext:tnotifyevent;
    onacceptable:tstringfuncevent;
    //internal
    procedure readwrite(mode:tvirtualstoragemode); override;
    procedure _ontimer(sender:tobject); override;
    //create
    constructor create(_gui:tvirtualform;_title:string);
    //information
    property pathfile:string read getpathfile write setpathfile;
    property filename:string read getfilename write setfilename;
    property path:string read getpath write setpath;
    property title:tvirtualgrid read ititle;//used so other controls can insert extra links
    property pathlink:tvirtuallink read ipathlink;//hidden by default
    property previewbgcolor:integer read getbgcolor write setbgcolor;//clNone=use system, else use specified
    property oShowFilename:boolean read ioShowFilename write setoShowFilename;
    property itemindex:integer read getitemindex;
    //image - Note: will be "nil" is no image is loaded
    property image:tvirtualbitmapanimated read getimage;
    property oFrameimage:boolean read getframeimage write setframeimage;
    property base:tvirtualpagevsplit read ibase;
    procedure load;
    procedure reload(x:string;_update:boolean);
    //support folders
    property oShowSF:boolean read getoshowsf write setoshowsf;
    property oRestrictSF:boolean read ioRestrictSF write setorestrictSF;
    //next
    function cannext:boolean;
    procedure next(_up:boolean);
   end;

{tvirtualviewertext}
   tvirtualviewertext=class(tvirtualpagevsplit)
   private
    icpanel:tvirtualtitle;
    ibusy:boolean;
    iitemindex:integer;
    iitems:tdynamicstring;
    ilist:tvirtuallist;
    itext:tvirtualtextwrap;
    icopy,ivisit:tvirtuallink;
    function gettext:string;
    procedure setitemindex(x:integer);
    function getcount:integer;
    procedure _onitemindex(sender:tobject);
    procedure updatebuttons;
    procedure __onclick(sender:tobject);
    function geturl:string;
   public
    //vars
    textenhance:boolean;
    //internal
    property cpanel:tvirtualtitle read icpanel;
    procedure _ontimer(sender:tobject); override;
    procedure settext(x:string); virtual;
    //create
    constructor create(_gui:tvirtualform); override;
    destructor destroy; override;
    //workers
    property text:string read gettext write settext;
    property itemindex:integer read iitemindex write setitemindex;
    property count:integer read getcount;
    procedure clear;
    //.visit
    function canvisit:boolean;
    procedure visit;
   end;

{tvirtualviewerhelp}
   tvirtualviewerhelp=class(tvirtualviewertext)
   private
    ihtml,itxt:tvirtuallink;
    procedure __onclick2(sender:tobject);
   public
    //create
    constructor create(_gui:tvirtualform); override;
   end;

{tvirtualsysinfo}
   tvirtualsysinfo=class(tvirtualpage)
   private
    ipages:tvirtualpages;
    icopy:tvirtuallink;
    iSLtrans,iSLinfo,icleartransup,icopytransup,ipastetransup,iunlock,ipurchase,iunlockLINK,ipurchaseLINK:tvirtualcontrol;
    iextractsupportfiles,isearch,iaddurl,ihelphtml,ihelptext,iabout:tvirtualcontrol;
    ihomepage,ifreesoftware,iblaiznet,icontact:tvirtualcontrol;
    inmview,inmwebsite,icenter,ienlarge,ishrink,inewinstance,idelete,iclone,iclose:tvirtualcontrol;
    isizetooriginal,isizeto800x600,isizeto640x480,isizeto580x560,isizeto400x400:tvirtualcontrol;
    icaps  :array[0..vsiMax] of string;
    iobjs  :array[0..vsiMax] of tvirtualcontrol;
    istatic:array[0..vsiMax] of boolean;
    idelay :array[0..vsiMax] of integer;
    isuptransid,ifilesize:integer;
    iclENG:boolean;
    itranslist1,itranslist2:tvirtuallist;
    itranstextwrap1,itranstextwrap2:tvirtualtextwrap;
    isuptransbutton:tvirtualbutton;
    //network monitor
    inmip:integer;
    inmtime:currency;
    inmserver:tobject;//tudpbasic object
    //folders support
    icfpath:array[0..49] of string;
    icflink:array[0..49] of tvirtualcontrol;
    icfcount:integer;
    procedure __onclick(sender:tobject);
    procedure __oncf(sender:tobject);
    procedure _onpage(sender:tobject);
    function getpage:integer;
    procedure setpage(x:integer);
    function buildtext(x:tvirtualcontrol;xtag:integer):string;
    procedure buildall(init:boolean);
    procedure updatebuttons;
    function gettext(p:integer):string;
    procedure settext(p:integer;y:string);
    property text[p:integer]:string read gettext write settext;
    procedure setcaption(x:string); override;
    function getcaption:string; override;
    procedure newcflink(_parent:tvirtualcontrol;_label,_help,_path:string);
    function newtlink(_parent:tvirtualcontrol;_label,_tep,_help:string):tvirtuallink;
    procedure nmRESET;//20FEB2008
    procedure nmSEND;//21FEB2008
   public
    //internal
    procedure _ontimer(sender:tobject); override;
    procedure readwrite(mode:tvirtualstoragemode); override;
    //create
    constructor create(_gui:tvirtualform); override;
    destructor destroy; override;
    //workers
    property page:integer read getpage write setpage;
   end;

{tvirtualalertaudio}
   tvirtualalertaudio=class(tmanaged)
   private
    ilocked:boolean;
    imm:tobject;
    irepeatlist,idroplist:tvirtualdropliststatic;
    iname:tdynamicnamelist;
    ilabel,idata:tdynamicstring;
    tsSound,imidifile,iwavefile,ifilename:string;
    icustom,inext,iplay,istop:tvirtuallink;
    icountnew,icount:integer;
    icountmodified:boolean;
    procedure __onclick(sender:tobject);
    procedure updatebuttons;
    procedure add(_label,_name,rawORb64:string);
    function getlabels(sep:string;showtype:boolean):string;
    procedure __fillfromdisk;
    procedure _onitemindex(sender:tobject);
    function getplayNOW:boolean;
    function getplay:boolean;
    procedure setplay(x:boolean);
   public
    //internal
    procedure _ontimer(sender:tobject); override;
    procedure readwrite(mode:tvirtualstoragemode); override;
    //create
    constructor create(_gui:tvirtualform;_sysptr:integer;_vars:string); override;
    destructor destroy; override;
    //workers
    property play:boolean read getplay write setplay;
    property playNOW:boolean read getplayNOW;
   end;

{tvirtualcontacts}
   tvirtualcontacts=class(tvirtualpage)
   private
    iips,idata:string;
    ilocked:boolean;
    ifiles,ifile:tvirtuallist;
    inew,iedit,icopy,iconnect,irefresh,ifolder:tvirtuallink;
    ibase:tvirtualpagevsplit;
    procedure __onclick(sender:tobject);
    procedure refreshlist;
    function getdata(p:integer):string;
    procedure load;
    procedure updatebuttons;
    procedure setdata(x:string);
    procedure savedata(p:integer);
    procedure newcontact;
   public
    //events
    onconnect:tnotifyevent;
    //create
    constructor create(_gui:tvirtualform;_title:string);
    //workers
    property data:string read idata;
    property ips:string read iips;//may be IPs or Domains
   end;

{tvirtualpath}
   tvirtualpath=class(tvirtualbutton)
   private
    tsNopath,ipath:string;
    procedure setpath(x:string);
   public
    //internal
    procedure click; override;
    function getcaption:string; override;
    //create
    constructor create(_gui:tvirtualform); override;
    //information
    property path:string read ipath write setpath;
    //system
    procedure readwrite(mode:tvirtualstoragemode); override;
   end;

{tvirtualfile}
   tvirtualfile=class(tvirtualbutton)
   private
    tsNofile,ifilename:string;
    procedure setfilename(x:string);
   public
    //vars
    filters:string;
    //internal
    procedure click; override;
    function getcaption:string; override;
    //create
    constructor create(_gui:tvirtualform); override;
    //information
    property filename:string read ifilename write setfilename;
    //system
    procedure readwrite(mode:tvirtualstoragemode); override;
   end;

{tvirtualtile}
   tvirtualtile=class(tvirtualpage)
   private
    itimer2:integer;
    ifilenametext:string;
    iview,iclear,icopy,ipaste,iopen:tvirtualcontrol;
    iimg:tvirtualbitmap;
    ibusy,imustpaint:boolean;
    procedure __onpaint(sender:tobject;canvas:tcanvas);
    procedure __onclick(sender:tobject);
    procedure _ontimer2(sender:tobject);
    procedure updatebuttons;
   public
    //create
    constructor create(_gui:tvirtualform;_caption:string);
    destructor destroy; override;
    //system
    procedure readwrite(mode:tvirtualstoragemode); override;
    //workers
    function tile(dr:trect;d:tbitmap;deg:integer;var e:string):boolean;
   end;

{tvirtualsystembutton}
   tvirtualsystemoptions=(vsoNone,vsoApply,vsoDefaults,vsoDefaultAppearance,vsoExit);
   tvirtualsystembutton=class(tvirtualbutton)
   private
    ioption:tvirtualsystemoptions;
    procedure settvirtualsystemoptions(x:tvirtualsystemoptions);
   public
    property option:tvirtualsystemoptions read ioption write settvirtualsystemoptions;
    procedure click; override;
   end;

{tvirtualsystemlink}
   tvirtualsystemlink=class(tvirtuallink)
   private
    ioption:tvirtualsystemoptions;
    procedure settvirtualsystemoptions(x:tvirtualsystemoptions);
   public
    property option:tvirtualsystemoptions read ioption write settvirtualsystemoptions;
    procedure click; override;
   end;

{tvirtualwebedit}
   tvirtualwebedit=class(tvirtualpage)
   private
    iurl:string;
    iedit:tvirtualedit;
    isend:tvirtualbutton;
    procedure __onclick(sender:tobject);
    procedure setanimation(x:string);
   public
    //create
    constructor create(_gui:tvirtualform); override;
    //workers
    property url:string read iurl write iurl;//in form "http://www.blaiz.net/abc.pl?q=<text>"
    property animation:string write setanimation;
    //host
    property edit:tvirtualedit read iedit;
    property send:tvirtualbutton read isend;
   end;

{tvirtualpanelserver}
   tvirtualpanelserver=class(tvirtualpage)
   private
    ititle:tvirtualtitle;
    iinfo:tvirtualrows;
    iserver:tobject;
    itra,iban,ilog,ilogfolder:tvirtuallink;
    iflashok:boolean;//used to flash important item within "doinfo"
    tsSpecifiedportinusetryanother:string;
    procedure _ontimer(sender:tobject); override;
    procedure setserver(x:tobject);
    procedure doinfo;
    procedure __onclick(sender:tobject);
    function getstatus:string;
   public
    //vars
    showLOG,showBAN,showTRA:boolean;//TRUE=display log link no matter what, FALSE=default only if control supports them
    //create
    constructor create(_gui:tvirtualform;_caption:string);
    //workers
    property server:tobject read iserver write setserver;//pointer only
    property status:string read getstatus;
   end;

//const
{tio}
const
   iostylenames:array[tiostyle] of string =('none','to c','from c','to bitmap','from bitmap','to text','from text','to file','from file','to nv','from nv','to mtxt','from mtxt','to base64','from base64');

type
   tsysstate=(ssOK,ssClosing,ssClosed,ssFinished);
   trootinfo=record
     rootvisible:integer;
     rootcontrol:integer;
     rootvisibleCOUNT:integer;
     rootcontrolCOUNT:integer;
     end;
   tsysinfoitem=record
    name:string;
    createtime:currency;//once only
    obj:tobject;
    active:integer;
    count:integer;
    end;
   tsysinfo=record
    //.items
    items:array[0..199] of tsysinfoitem;
    //.general
    create:integer;
    destroy:integer;
    active:integer;
    //.errors
    dupError:integer;//duplication error (more than 1 instance of same system object)
    errors:integer;
    //.other
    rootinfo:trootinfo;
    end;//end of record
var
   //-- VIRTUAL CONTROL SYSTEM -------------------------------------------------
   viControlsCreated:integer=0;
   viControlsDestroyed:integer=0;
   viControlsActive:integer=0;

   //virtual information sets
   viScrollSize:integer=16;
   viMainScrollSize:integer=24;
   viHelp:boolean=false;
   viSizeBalanced:boolean=false;
   viSizeFast:boolean=false;
   viSafeArea:boolean=false;
   viEnhanced:boolean=false;
   viCompact:boolean=false;
   viOnTop:boolean=false;
   viShowSoft:boolean=true;
   viRounded:boolean=true;
   viBufferedPaint:boolean=false;
   viBorder:boolean=true;
   //standard system heights
   viFontHeight:word=14;
   viFontWidthRatio:single=1;//FontSize=8 is normal "1", larger fontsizes increase ratio and the reverse is true
   viTabRatio:single=1;//feeds from "viFontWidthRatio" but with safe range enforced
   //other
   viHtmlEnd:string;

   viNormal:tvirtualinfo=(
     border:150+146*osGreen+63*osBlue;
     background:239+240*osGreen+222*osBlue;
     highlight:94+163*osGreen+255*osBlue;
     hover:196+221*osGreen+255*osBlue;
     disable:239+240*osGreen+222*osBlue;
     disableborder:clGray;
     font:0;
     fonthighlight:clWhite;
     fontname:'MS Sans Serif';
     fontmap:nil;
     );

   viTitle:tvirtualinfo=(
     border:255;//0+110*osGreen+255*osBlue;
     background:0+110*osGreen+255*osBlue;
     highlight:94+163*osGreen+255*osBlue;
     hover:100+171*osGreen+177*osBlue;
     disable:192+192*osGreen+192*osBlue;
     disableborder:clwhite;
     font:255+247*osGreen+255*osBlue;
     fonthighlight:238+239*osGreen+221*osBlue;
     fontname:'MS Sans Serif';
     fontmap:nil;
     );
   fdraws:tdraws=nil;
   fmenus:tmenus=nil;
   forma:tvirtualform=nil;//user controlled form
   //system menus
   smTEXT:string='';

   //-- SYSTEM CRITICAL INFORMATION --------------------------------------------
   siInited:boolean=false;
   sysinfo:tsysinfo;
   sysscanned:boolean=false;
   sysstate:tsysstate=ssOK;
   sysbooted:boolean=false;//set TRUE by "pg.done"
   sysdeleting:boolean=false;//TRUE if tpg.delete has been triggered
   sysdeletelist:tstringlist=nil;//created and filled with FULL PATH-FILENAME (one per line) to delete
   //..app
   appstarted:boolean=false;
   appprompted:boolean=false;
   fht:thtmltemplate=nil;
   fdates:tdates=nil;
   fwec:twec=nil;
   fgeneral:tgeneral=nil;
   fhtml:thtml=nil;
   fmisc:tmisc=nil;
   fscript:tscript=nil;
   fapp:tapp=nil;
   fmsgList:tmsgList=nil;
   fcapturehwnd:hwnd=0;
   fio:tio=nil;
   fvs:tvirtualstorage=nil;
   fmultilingual:tmultilingual=nil;
   fst:tsuptrans=nil;
   fsplash:tsplash=nil;
   fpg:tpg=nil;
   fdb:tdebug=nil;
   ftesting:ttesting=nil;

  UtilWindowClass: TWndClass = (
    style: 0;
    lpfnWndProc: @DefWindowProc;
    cbClsExtra: 0;
    cbWndExtra: 0;
    hInstance: 0;
    hIcon: 0;
    hCursor: 0;
    hbrBackground: 0;
    lpszMenuName: nil;
    lpszClassName: 'TPUtilWindow');

   //leadbytes
   leadbytes:set of char=[];
   //hcursors
   hcrArrow:hcursor=0;

const
   user32='user32.dll';
   gdi32='gdi32.dll';
   kernel32='kernel32.dll';
   shell32='shell32.dll';


function draws:tdraws;
function menus:tmenus;
function mns:tmenus;//same as "menus"
procedure pop(_popuphost:tvirtualform;x,y,yh:integer);
function workarea:trect;
function screenarea:trect;
function safebounds(left,top,width,height,margin:integer;area:trect):trect;
procedure safeboundsb(x:twincontrol;_margin:integer;_workarea:boolean);
//app start & shutdown
procedure appstart;
procedure appsync;
function appprompt:boolean;

//show dialogs
procedure _sdbm(_msg:string);//special DEBUG message box, not to be used by program, only for debugginh - all instances are automatically removed
procedure showbasic(_msg:string);//basic message window
procedure showerror(_msg:string);//basic error window
function showerror60(_msg:string):boolean;
function showinfo(_msg:string):boolean;
function showinfo60(_msg:string):boolean;
function showmsg(_title,_msg,_tep:string;_autoclick:integer):boolean;
function showmsgex(_title,_msg,_tep:string;_autoclick:integer;_soft:boolean):boolean;
function showquery60(_msg:string):boolean;
function showquery(_msg:string;_autoclick:integer):boolean;
function showqueryb(_title,_msg:string;_autoclick:integer):boolean;
function showqueryex(_title,_msg:string;_autoclick:integer;_soft:boolean):boolean;
function showYNC(_msg:string;_autoclick:integer):tmodalresult;
function showconfirm(_msg:string):boolean;
function showreplacefile(filename:string;fullpath:boolean):boolean;
function showreplacefileb(filename,_filelabel:string;fullpath:boolean):boolean;
function newfilename60(var sfilename,dfilename:string):boolean;//04OCT2007 - just prompts user for a "new filename" tied to current "ext"
function newfilename60ex(var sfilename,dfilename:string;newext:string):boolean;//04OCT2007 - just prompts user for a "new filename" tied to current "ext"
function showrenamefile60(sfilename:string;var dfilename:string):boolean;//04OCT2007
function showedit60(var _text:string;_title,_caption,_okbutton:string):boolean;
function showedit(var _text:string;_title,_caption,_okbutton:string;_autoclick:integer):boolean;
function showdroplist60(var _text:string;_list,_listtep,_title,_caption,_okbutton:string):boolean;//27SEP2007
function showdroplist(var _text:string;_list,_listtep,_title,_caption,_okbutton:string;_autoclick:integer):boolean;//27SEP2007
function showeditex(var _text:string;_list,_listtep,_title,_caption,_okbutton:string;_autoclick:integer):boolean;
function showUUP60(var _url,_username,_password:string;_title,_okbutton:string):boolean;//url, username and password entry window
function showUUP(var _url,_username,_password:string;_title,_urlcap,_usernamecap,_passwordcap,_okbutton:string;_autoclick:integer):boolean;//url, username and password entry window
function showlist60(var _text,_value:string;_title,_caption,_okbutton:string;_large,_readonly,_multiselect:boolean):boolean;
function showlist(var _text,_value:string;_title,_caption,_okbutton:string;_large,_readonly,_multiselect:boolean;_autoclick:integer):boolean;
function showtext(var x:string;_wordwrap,_large:boolean):boolean;
function showtextb(title,caption:string;var x:string;_wordwrap,_large:boolean):boolean;
//showfind
procedure showfind(_host:tvirtualform;var x:string;_onfind:tnotifyevent;tag:integer);
procedure showextract(_host:tvirtualform;var x:string;_onfind:tnotifyevent;tag:integer);
procedure showfindex(_host:tvirtualform;var x:string;_onfind:tnotifyevent;tag:integer;wndtep,wndcap,buttep,butcap:string);
function getfind(sender:tobject;var dlg:tvirtualdlg):boolean;
function getfindtag(sender:tobject):integer;
function getfindtext(sender:tobject):string;//14-DEC-2006
procedure closefind(sender:tobject;r:tmodalresult);
//cursor control
function getcursorpointer(x:tvirtualcursor):integer;
function getcursorlabel(x:tvirtualcursor):string;
procedure nocursors;
procedure setcursordata(x:tcursor;y:string);
//virtual control sync
procedure viSync;//20-OCT-2006

//windows
function PeekMessage(var lpMsg: TMsg; hWnd: HWND; wMsgFilterMin, wMsgFilterMax, wRemoveMsg: UINT): BOOL; stdcall;
function SendMessage(hWnd: HWND; Msg: UINT; wParam: WPARAM; lParam: LPARAM): LRESULT; stdcall;
function TranslateMessage(const lpMsg: TMsg): BOOL; stdcall;
function DispatchMessage(const lpMsg: TMsg): Longint; stdcall;
function WaitMessage: BOOL; stdcall;
function ExtractFileName(const FileName: string): string;
Function ReadFileExt(x:string;fu:boolean):string;{Date: 24-DEC-2004, Superceeds "ExtractFileExt"}
function scandownto(x:string;y,stopA,stopB:char;var a,b:string):boolean;//24-DEC-2004, v1.00.015
function CreateWindow(lpClassName:PChar;lpWindowName:PChar;dwStyle:DWORD;X,Y,nWidth,nHeight:Integer;hWndParent:HWND;hMenu:HMENU;hInstance:HINST;lpParam:Pointer):HWND;
function CreateWindowEx(dwExStyle:DWORD;lpClassName:PChar;lpWindowName:PChar;dwStyle:DWORD;X,Y,nWidth,nHeight:Integer;hWndParent:HWND;hMenu:HMENU;hInstance:HINST;lpParam:Pointer):HWND; stdcall;
function GetSystemMetrics(nIndex:Integer): Integer; stdcall;
Function BN(X:Boolean):String;
Function NB(X:String):Boolean;
function bv(x:boolean):byte;//boolean to value, date: 18-MAR-2004
function vb(x:byte):boolean;//value to boolean, date: 18-MAR-2004
function ShowWindow(hWnd: HWND; nCmdShow: Integer): BOOL; stdcall;
function RegisterClassEx(const WndClass: TWndClassEx): ATOM; stdcall;
function RegisterClass(const lpWndClass: TWndClass): ATOM; stdcall;
//function UnregisterClass(lpClassName: PChar; hInstance: HINST): BOOL; stdcall;
function GetClassInfo(hInstance: HINST; lpClassName: PChar;var lpWndClass: TWndClass): BOOL; stdcall;
function GetClassInfoEx(Instance: HINST; Classname: PChar; var WndClass: TWndClassEx): BOOL; stdcall;
function DefWindowProc(hWnd: HWND; Msg: UINT; wParam: WPARAM; lParam: LPARAM): LRESULT; stdcall;
function LoadIcon(hInstance: HINST; lpIconName: PChar): HICON; stdcall;
function LoadCursor(hInstance: HINST; lpCursorName: PAnsiChar): HCURSOR; stdcall;
function LoadCursorFromFile(lpFileName: PAnsiChar): HCURSOR; stdcall;
function SetSystemCursor(hcur: HICON; id: DWORD): BOOL; stdcall;
function GetStockObject(Index: Integer): HGDIOBJ; stdcall;
function SetWindowLong(hWnd: HWND; nIndex: Integer; dwNewLong: Longint): Longint; stdcall;
function LoadResource(hModule: HINST; hResInfo: HRSRC): HGLOBAL; stdcall;
function SetWindowPos(hWnd: HWND; hWndInsertAfter: HWND; X, Y, cx, cy: Integer; uFlags: UINT): BOOL; stdcall;
function ReplyMessage(lResult: LRESULT): BOOL; stdcall;
procedure PostQuitMessage(nExitCode: Integer); stdcall;
function GetWindowPlacement(hWnd: HWND; WindowPlacement: PWindowPlacement): BOOL; stdcall;
function SetWindowPlacement(hWnd: HWND; WindowPlacement: PWindowPlacement): BOOL; stdcall;
function GetClientRect(hWnd: HWND; var lpRect: TRect): BOOL; stdcall;
function GetWindowRect(hWnd: HWND; var lpRect: TRect): BOOL; stdcall;
function AdjustWindowRect(var lpRect: TRect; dwStyle: DWORD; bMenu: BOOL): BOOL; stdcall;
function GetDC(hWnd: HWND): HDC; stdcall;
function GetWindowDC(hWnd: HWND): HDC; stdcall;
function ReleaseDC(hWnd: HWND; hDC: HDC): Integer; stdcall;
function StretchBlt(DestDC: HDC; X, Y, Width, Height: Integer; SrcDC: HDC; XSrc, YSrc, SrcWidth, SrcHeight: Integer; Rop: DWORD): BOOL; stdcall;
Function ScreenWidth:Integer;
Function ScreenHeight:Integer;
Function Rect(X,Y,W,H:Integer):TRect;
function TextOut(DC: HDC; X, Y: Integer; Str: PChar; Count: Integer): BOOL; stdcall;
function ExtTextOut(DC: HDC; X, Y: Integer; Options: Longint; Rect: PRect; Str: PChar; Count: Longint; Dx: PInteger): BOOL; stdcall;
function Rectangle(DC: HDC; X1, Y1, X2, Y2: Integer): BOOL; stdcall;
function DestroyWindow(hWnd: HWND): BOOL; stdcall;
function GetCapture: HWND; stdcall;
function SetCapture(hWnd: HWND): HWND; stdcall;
function ReleaseCapture: BOOL; stdcall;
Procedure SetCaptureHwnd(X:Hwnd);
function BeginPaint(hWnd: HWND; var lpPaint: TPaintStruct): HDC; stdcall;
function EndPaint(hWnd: HWND; const lpPaint: TPaintStruct): BOOL; stdcall;
function CreatePopupMenu: HMENU; stdcall;
function AppendMenu(hMenu: HMENU; uFlags, uIDNewItem: UINT; lpNewItem: PChar): BOOL; stdcall;
function GetSubMenu(hMenu: HMENU; nPos: Integer): HMENU; stdcall;
function GetMenuItemID(hMenu: HMENU; nPos: Integer): UINT; stdcall;
function GetMenuItemCount(hMenu: HMENU): Integer; stdcall;
function InsertMenuItem(p1: HMENU; p2: UINT; p3: BOOL; const p4: TMenuItemInfo): BOOL; stdcall;
function CheckMenuItem(hMenu: HMENU; uIDCheckItem, uCheck: UINT): DWORD; stdcall;
function EnableMenuItem(hMenu: HMENU; uIDEnableItem, uEnable: UINT): BOOL; stdcall;
function DestroyMenu(hMenu: HMENU): BOOL; stdcall;
function GetSystemMenu(hWnd: HWND; bRevert: BOOL): HMENU; stdcall;
Function WindowProc(hWnd:HWND;Msg:UINT;wParam:WPARAM;lParam:LPARAM):LRESULT;stdcall
Function SysHMENU(Handle:Hwnd):HMENU;
Procedure PopMenu(Handle:HWND;X:HMENU;dX,dY:Integer);
Function GetCursorPos(var lpPoint: TPoint): BOOL; stdcall;
function SetCursorPos(X, Y: Integer): BOOL; stdcall;
Function ReadSTDHeader(Var X,Hdr,Body:String):Boolean;
Procedure Draw3DFrame(X:TFrameInfo;Img:TBitmap;_onlyline:boolean);//31-AUG-2004
Function StdEncrypt(X:String;EKey:String;Mode1:Integer):String;
Function ColBright(X:Integer):Integer;
Function InvColor(X:Integer;GreyCorrection:Boolean):Integer;
Function StripService(X:String;Full:Boolean):String;
function asGZfile(filename:string;var data,e:string):boolean;
function zipstr(var x,e:string;raw:boolean):boolean;
function unzipstr(var x,e:String;raw:boolean):boolean;//03-OCT-2004
Function Run(X,Y:String):Boolean;
procedure fireevent(x:tnotifyevent;y:tobject);{date: 11-JAN-2004 v1.00.001}
procedure fireeventsafe(x:tnotifyevent;y:tobject);//27-AUG-2006, only calls "x" if (sysstate=ssOK), for safe and stable closure
procedure swapInt(var x,y:LongInt);
procedure swapCur(var x,y:currency);
procedure swapExt(var x,y:extended);//06JUN2007
procedure swapStr(var x,y:string);//09-MAY-2007
procedure freeObj(x:pobject);//15-OCT-2004
function NewForm(p:twincontrol):tform;{date: 04-AUG-2004}
function decText(x:boolean;y,n:string):string;{Decision Text}
Function StrLen(Str: PChar): Cardinal; assembler;
Function UpperCase(X:String):String;
Function LowerCase(X:String):String;
Function ColSplice(X,C1,C2:Integer):Integer;
function smallest(a,b:integer):integer;//13-JUN-2005
function largest(a,b:integer):integer;//13-JUN-2005
function csmallestex(a:array of currency):currency;//22JAN2008
function clargestex(a:array of currency):currency;//22JAN2008
function frcmin(x,min:integer):integer;//14-SEP-2004
Function FrcCurMin(X,Min:currency):currency;//date: 02-APR-2004
function frcmax(x,max:integer):integer;//14-SEP-2004
Function FrcCurMax(X,Max:currency):currency;//date: 02-APR-2004
function frcrange(x,min,max:integer):integer;//13-SEP-2004
function frcrangeex(x,min,max,defvalue:integer):integer;//14-JAN-2007
function frccurrange(x,min,max:currency):currency;//date: 02-APR-2004
function frcextrange(x,min,max:extended):extended;//06JUN2007
Function FileSize(X:String):Integer;
Function FileAge(const FileName:string):Integer;
Function FileExists(const FileName:string):Boolean;
//push
function xpushPTR(d,dtmp,x:pstring;b:integer):boolean;{date: 12-JUL-2004}
//other
Function From16Bit(X:Integer;si:boolean):String;{DATE: 13-DEC-2003}
Function To16Bit(X:String;si:boolean):Integer;{DATE: 13-DEC-2003}
function to32bit(x:string):integer;//29AUG2007
function from32bit(x:integer):string;//29AUG2007
function To64Bit(x:string):currency;//updated: 02-APRIL-2004
function From64Bit(x:currency):string;//updated: 02-APRIL-2004
function TrackPopupMenu(hMenu: HMENU; uFlags: UINT; x, y, nReserved: Integer; hWnd: HWND; prcRect: PRect): BOOL; stdcall;
function SetFileAttributes(lpFileName: PChar; dwFileAttributes: DWORD): BOOL; stdcall;
function DeleteFile(lpFileName: PChar): BOOL; stdcall;
function SetCursor(hCursor: HICON): HCURSOR; stdcall;
function GetTempPath(nBufferLength: DWORD; lpBuffer: PChar): DWORD; stdcall;
function CreateDirectory(lpPathName: PChar; lpSecurityAttributes: PSecurityAttributes): BOOL; stdcall;
function RemoveDirectory(lpPathName: PChar): BOOL; stdcall; external kernel32 name 'RemoveDirectoryA';
Function DirectoryExists(const Name: string): Boolean;
Function ExtractFilePath(X:String):String;
function GetShortPathName(lpszLongPath: PChar; lpszShortPath: PChar; cchBuffer: DWORD): DWORD; stdcall; external kernel32 name 'GetShortPathNameA';
Procedure ForceDirectories(Dir: string);
function ShellExecute(hWnd: HWND; Operation, FileName, Parameters, Directory: PChar; ShowCmd: Integer): HINST; stdcall;
function GetTickCount: DWORD; stdcall;
function UpdateWindow(hWnd: HWND): BOOL; stdcall;
procedure Sleep(dwMilliseconds: DWORD); stdcall;

//## Language Support ##
function rthtranslate(x:string):string;//realtime help - 05OCT2007 - don't translate, just mark the text for "sniffer", since text will be translated in realtime on demand
function ntranslate(x:string):string;//translate as name
function translate(x:string):string;
function translateparts(x:string):string;{Date: 10-NOV-2003 Version: 1.00.002}
//yyyyyyyyyyyyyyyyyFunction TranslateAssign(FromOld:Boolean;Var ErrMsg:String):Boolean;
Function General:TGeneral;
function html:thtml;
Function misc:tmisc;
function script:tscript;
function multilingual:tmultilingual;
function st:tsuptrans;
function splash:tsplash;
function pg:tpg;
function db:tdebug;
function wec:twec;
function ht:thtmltemplate;
function dates:tdates;
function testing:ttesting;
//.io
function newnv:tnv;
function io:tio;
function vs:tvirtualstorage;
function newio:tio;
function newioE(_onchange:tnotifyevent):tio;
function newstringlist(x:string):tstringlist;
function newdualmask(_include,_exclude:string):tdualmask;
Function App:TApp;
Function MsgList:TMsgList;
Procedure DelWindowProc(X:HWND);
Function AddWindowProc(X:HWND;Y:TWindowProc):Integer;
//## ECap ##
Function ECapK:String;
Function ECap(X:String;E:Boolean):String;
Function ECapBin(X:String;E,bin:Boolean):String;
//## error free handling of str-num conversion
function strtofloatex(x:string):extended;//triggers less errors (x=nil now covered)
function floattostrex(x:extended;dig:byte):string;//19DEC2007
function floattostrex2(x:extended):string;//19DEC2007
function strFlt(x:string):Extended;//date: 27-JAN-2007, v1.00.020
function strInt(const x:string):integer;//date: 10-APR-2004, v1.00.041
function strCur(const x:string):currency;//date: 06-JUL-2004, v1.00.044
function cround(x:extended):currency;//19DEC2007

{tio}
function pushb(var _dataLEN:integer;var _data:string;_add:string):boolean;
function push(var _dataLEN:integer;var _data,_add:string):boolean;
function pushbx(var _dataLEN:integer;_bufferSTEP:integer;var _data:string;_add:string):boolean;
function pushx(var _dataLEN:integer;_bufferSTEP:integer;var _data,_add:string):boolean;
function pushlimit(var _dataLEN:integer;_bufferSTEP,_limit:integer;var _data,_add:string):boolean;//Date: 15-AUG-2005
function pushlimitb(var _dataLEN:integer;_bufferSTEP,_limit:integer;var _data:string;_add:string):boolean;//Date: 15-AUG-2005

//-----------------{ System Information }---------------------------------------
procedure siClose;
procedure siInit;
procedure siInfo(x:string);//comment this out!
procedure siAutoCreate(sysVar:prootobject;cls:trootclass;resultVar:prootobject);
procedure siHalt;//safe system shutdown
procedure siCloseAll;//22-MAY-2006
function siFind(obj:tobject;new:boolean):integer;//21-MAY-2006
procedure siAdd(obj:tobject);
procedure siDel(obj:tobject);
function siFirst(start,dupCount:integer):integer;
function siEmpty(includeform:boolean):boolean;//all but main form

const
     //colors
     cl_white:trgbcolor=(b:255;g:255;r:255);
     cl_black:trgbcolor=(b:0;g:0;r:0);
var
   p4INT32:array[0..32] of integer;
   p4CUR256:array[0..256] of currency;

Function AskMessage(const Msg: string):Boolean;
//## memory ##
procedure getmemb(var p:pointer;size:integer);
procedure reallocmemb(var p:pointer;oldsize,newsize:integer);
//## Pixel Filters ##
function plfMain(var p:trgbcolor;pinfo:ppixelinfo):boolean;//30SEP2007, 23-DEC-2004
function plfGrey(var p:trgbcolor;pinfo:ppixelinfo):boolean;
function plfDisabled(var p:trgbcolor;pinfo:ppixelinfo):boolean;
function plfFocused(var p:trgbcolor;pinfo:ppixelinfo):boolean;
function plfNil(var p:trgbcolor;pinfo:ppixelinfo):boolean;
//## image printer ##
function foldercallback(Wnd: HWND; uMsg: UINT; lParam, lpData: LPARAM): Integer stdcall;

//sites
procedure showcategory;
procedure showsystem;
procedure blaizfiles;
procedure blaiztemp;
procedure rawgruntsite;
procedure rawgruntaddurl;
procedure blaizcontact;
procedure freesite;
procedure blaizsite;
procedure programsite;
//folders
function appdata:string;//out of date
function winroot:string;//17-JAN-2007
function wintemp:string;//17-JAN-2007
function winstartup:string;
function asfolder(x:string):string;//enforces trailing "\"
function exeCategory:string;//category folder as seen by "program exe" - when portable, category becomes ROOT folder where all exe's reside as a common group of files
function crfolder(x:string):boolean;//create folder 25SEP2007
function findfolder(x:integer;var y:string):boolean;//17-JAN-2007
function mixedfolder(x:integer;y:string):string;
function mixedfolderb(x:integer;y:string;var z:string;create:boolean):boolean;
function bvfolder(bvfname:string):string;
function bvfolderb(bvfname:string;create:boolean):string;//Blaiz Enterprises virtual folder 12-NOV-2005
function bvfportable(bvfname:string):string;//Blaiz Enterprises virtual folders 12-NOV-2005
function bvfportableex(bvfname:string;create:boolean):string;//blaiz enterprises virtual folder structure (supports portable mode) 19-JAN-2007
function bvfFindtool(prgname:string;var f:string):boolean;//16OCT2007, find filename (exe) for built-in tools (e.g. Animtor, Text Effects and Clic)
function bvfFindtoolex(prgname:string;var f:string;searchall:boolean):boolean;//03JAN2008, find filename (exe) for built-in tools (e.g. Secure Message, Animtor, Text Effects and Clic)
procedure bvfRuntool(prgname,f:string);//16SEP2007
procedure bvfRuntoolex(prgname,f:string;searchall:boolean);//29OCT2007
function extfolder(ext:string):string;
function extfolderex(ext:string;var folder:string;create:boolean):boolean;//09OCT2007
function clipfile(ext:string):string;
function oldtonew(old,new:string;delold:boolean):boolean;//copy old file to new location
function noattribs(x:string):boolean;
function createfile(x:string):boolean;
function remfile(x:string):boolean;
function remfilems(x:string;timeout:integer):boolean;
function remonce(x:string):boolean;//deletes files that end with ".once"
function aslist(x:string):string;
procedure sysarrays;
procedure _setanimation(var image:tvirtualbitmapanimated;host:tvirtualcontrol;var data:string);
function modalONC(x:tmodalresult):tmodalresult;//ok, no or cancel
function modalOC(x:tmodalresult):tmodalresult;//ok or cancel
function piggyform:tform;//special - returns piggy form, else mainform - 29MAR2007
//tvirtualsystembutton
function getvirtualsystemlabel(x:tvirtualsystemoptions):string;
procedure virtualsystemclick(x:tvirtualsystemoptions);

//NEW - object creators and auto. setup routines
function newvb(tep:string):tvirtualbitmap;//new virtualbitmap

var
   _sdbmLABEL:string='<label not set>';
   //translated strings
   //.general
   tsAddress,tsYes,tsNo,tsErrors,tsHits,tsBandwidth,tsOffline,tsOnline,tsConnections,tsBytes,tsB,tsKB,tsMB,tsGB:string;
   tsCustom,tsSuccessful,tsNotFound,tsCount,tsEncryption,tsAntitamperDetection,tsProgram,tsPortable,tsSystemFolder,tsName,tsVersion,tsDescription,tsCategory,tsPrimaryLanguage,tsCustomLanguage,tsBuiltinHelp,tsSize,tsSecurity,tsPublisher,tsCloned,tsInstance,tsInfrastructure:string;
   tsDiskAccess,tsReadOnly,tsReadWrite:string;
   //.dates.uptime
   tslcMTH,tslcDY,tslcH,tslcM,tslcS,tslcMS:string;
   //.system information
   tsTime,tsBoot,tslcbit,tsUp,tsNoHelp,tsTimer,tsTickCount,tsLoad,tsCodes,tsID,tsNetwork,tsInstructionsExecuted,tsThreads,tsMappings,tsLookup,tsIn,tsOut,tsRequests,tsFileRemaps,tsVirtual,tsControls,tsSystem,tsActive,tsCreated,tsDestroyed:string;
   tsLicense,tsClassification,tsDimensions,tsCode,tsoriginalinstance,tsUnlock,tsTotal,tsUDP,tsServer,tsServerThread,tsQueue,tsStatistics,tsRate,tsClient,tsOrientated,tsMiscellaneous,tsImages,tsAnimations,tsClicks,tsKeyStrokes:string;
   tsLanguage,tsInformation,tsCoverage,tsPrimary,tsError,tsGUI,tsRealtimeHelp,tsUnused,tsIP,tsClientIPlc,tsProxyIPlc,tsTransactiontimelc,tsClientHostlc:string;
   //.nav
   tsHome,tsLocal,tsBookmarks,tsInternet,tsSettings:string;
   //.other
   tsX,tsY,tsW,tsH,tsStatus,tsAlive,tsUserAddress:string;
   //system information
   //.internal
   systemidleref:currency=0;//set within "siInit"
   //.public
   systemboottime:tdatetime;
   systemboot:currency=0;
   mainformwidth:integer=0;
   mainformheight:integer=0;
   virtualimages:currency=0;
   virtualanimations:currency=0;
   virtualclicks:currency=0;
   virtualkeystrokes:currency=0;
   systemfileremaps:currency=0;
   systemidletime:currency=0;//in milliseconds
   //Network Monitor vars - 21FEB2008
   networkmonitorHits:currency=-1;//not in use
   networkmonitorBandwidth:currency=-1;//not in use
   networkmonitorView:string='';//not specified
   networkmonitorAdmin:string='';//not specified
   networkmonitorComment:string='';//not specified - optional
   networkmonitorCat:string='';//uses "programcategoryHARD" by default and set within "tvirtualsysinfo.create" - 09MAR2008
   //other
   tvirtualformclass:twndclassa=(//yyyyyyyyyyyyyyyyyy
    style: (WS_POPUP or WS_SYSMENU or WS_GROUP);
    lpfnWndProc: @DefWindowProc;
    cbClsExtra: 0;
    cbWndExtra: 0;
    hInstance: 0;
    hIcon: 0;
    hCursor: 0;
    hbrBackground: 0;
    lpszMenuName: nil;
    lpszClassName: 'TVirtualForm');

//core app procs
function _appprompt:boolean;//08MAR2008
procedure _appshutdown;
procedure _appdeletelist(var filelist:tstringlist);//v1.00.022, 29OCT2007

implementation

uses av1{app critical data}, av3, av4;

//## _appprompt ##
function _appprompt:boolean;//08MAR2008
begin
try;result:=(not programshutdownprompt) or showquery(ntranslate('close')+#32+programtitle+' ?',5);except;end;
end;
//## _appshutdown ##
procedure _appshutdown;
begin
try
freeObj(@forma);
except;end;
end;
//## _appdeletelist ##
procedure _appdeletelist(var filelist:tstringlist);//v1.00.022, 29OCT2007
begin//Note: Fill filelist with all files that are to be deleted.
try  //      Exclude Start button version of program's EXE.
//check
if (filelist=nil) then exit;

//SNIPPETS
filelist.add(io.snippetfilename['ver']);

//SCHEME
filelist.add(vs.filename);

//CORE - information files (history, password, etc.)
//.history colors
filelist.add(bvfportableex(bvfSettings,false)+programname+'.colors');//don't create folder

//PROGRAM SPECFIC
__appdeletelist(filelist);//29OCT2007
except;end;
end;
//## piggyform ##
function piggyform:tform;//special - returns piggy form, else mainform - 29MAR2007
begin
try
//defaults
result:=application.mainform;
//get
if (result<>nil) and (result is tvirtualform) and ((result as tvirtualform).piggy<>nil) then
   begin
   result:=(result as tvirtualform).piggy;
   end;//end of if
except;end;
end;
//## modalONC ##
function modalONC(x:tmodalresult):tmodalresult;//ok, no or cancel
begin
try
//process
case x of
mrOk,mrYes:result:=mrOk;
mrNo:result:=mrNo;
else
result:=mrCancel;
end;//end of case
except;end;
end;
//## modalOC ##
function modalOC(x:tmodalresult):tmodalresult;//ok or cancel
begin
try
//process
case x of
mrOk,mrYes:result:=mrOk;
else
result:=mrCancel;
end;//end of case
except;end;
end;
//## getfind ##
function getfind(sender:tobject;var dlg:tvirtualdlg):boolean;
begin
try
//defaults
result:=false;
dlg:=nil;
//process
//.button/edit -> gui
if (sender is tvirtualcontrol) then sender:=(sender as tvirtualcontrol).gui;
//.gui[virtualdlg] -> edit
if (sender is tvirtualdlg) then
   begin
   dlg:=(sender as tvirtualdlg);
   result:=true;
   end;//end of if
except;end;
end;
//## getfindtag ##
function getfindtag(sender:tobject):integer;
var
   tmp:tvirtualdlg;
begin
try
//defaults
result:=0;
//get
if getfind(sender,tmp) then result:=tmp.tag;
except;end;
end;
//## getfindtext ##
function getfindtext(sender:tobject):string;//14-DEC-2006
var
   tmp:tvirtualdlg;
begin
try
//defaults
result:='';
//get
if getfind(sender,tmp) and (tmp.findtext<>nil) then result:=tmp.findtext.text;
except;end;
end;
//## closefind ##
procedure closefind(sender:tobject;r:tmodalresult);
begin
try
//process
//.button/edit -> gui
if (sender is tvirtualcontrol) then sender:=(sender as tvirtualcontrol).gui;
//.gui[virtualdlg] -> edit
if (sender is tvirtualdlg) and ((sender as tvirtualdlg).findtext<>nil) then (sender as tvirtualdlg).showclose(r);
except;end;
end;
//## _setanimation ##
procedure _setanimation(var image:tvirtualbitmapanimated;host:tvirtualcontrol;var data:string);
var
   e:string;
begin
try
//check
if (host=nil) then exit;
//clear
if (length(data)=0) then
   begin
   if (image<>nil) then
      begin
      freeobj(@image);
      host.paint;
      end;//end of if
   end
else
//set
   begin
   if (image=nil) then image:=tvirtualbitmapanimated.create(host);
   image.dtransparent:=host.dtransparent;
   image.setanimation(data,e);
   end;//end of if
except;end;
end;
//## aslist ##
function aslist(x:string):string;
begin
try
//defaults
result:='';
if (length(x)<=1) then exit;
//process
if (x[1]=#0) then result:=copy(x,2,length(x))
else result:=general.swapcharsb(copy(x,2,length(x)),x[1],#10);
except;end;
end;
//## showcategory ##
procedure showcategory;
begin
try;run(exeCategory,'');except;end;
end;
//## showsystem ##
procedure showsystem;//blaiz enterprises\
begin
try;run(bvfportable(''),'');except;end;
end;
//## blaizfiles ##
procedure blaizfiles;
begin
try;run(bvfportable(bvfFiles),'');except;end;
end;
//## blaiztemp ##
procedure blaiztemp;
begin
try;run(bvfportable(bvfTemp),'');except;end;
end;
//## rawgruntsite ##
procedure rawgruntsite;
begin
web_run('');
end;
//## rawgruntaddurl ##
procedure rawgruntaddurl;
begin
web_run('');
end;
//## blaizcontact ##
procedure blaizcontact;
begin
web_run('contact.html');
end;
//## freesite ##
procedure freesite;
begin
web_run('');
end;
//## blaizsite ##
procedure blaizsite;
begin
web_run('');
end;
//## programsite ##
procedure programsite;
begin
web_run(webname+'.html')
end;
//## appdata ##
function appdata:string;//out of date
begin
try;findfolder(CSIDL_APPDATA,result);except;end;
end;
//## winroot ##
function winroot:string;//17-JAN-2007
var
  a:pchar;
begin
try
//process
//.size
a:=pchar(general.nullstr(max_path,#0));
//.get
getwindowsdirectorya(a,MAX_PATH);
result:=asfolder(string(a));
except;end;
try;if (length(result)<3) then result:='c:\windows\';except;end;
end;
//## wintemp ##
function wintemp:string;//17-JAN-2007
var
  a:pchar;
begin
try
//defaults
result:='';
//size
a:=pchar(general.nullstr(max_path,#0));
//get
gettemppatha(max_path,a);
//set
result:=asfolder(string(a));
except;end;
try
//range
if (length(result)<3) then result:='c:\windows\temp\';
if not directoryexists(result) then forcedirectories(result);
except;end;
end;
//## winstartup ##
function winstartup:string;
begin
try;findfolder(CSIDL_STARTUP,result);except;end;
end;
//## asfolder ##
function asfolder(x:string):string;//enforces trailing "\"
begin
try;if (copy(x,length(x),1)<>'\') then result:=x+'\' else result:=x;except;end;
end;
//## exeCategory ##
function exeCategory:string;//category folder as seen by "program exe" - when portable, category becomes ROOT folder where all exe's reside as a common group of files
begin
try;if (programportablepath='') then result:=bvfportable(programcategoryHARD) else result:=programportablepath;except;end;
end;
//## crfolder ##
function crfolder(x:string):boolean;//create folder 25SEP2007
begin
try
//defaults
result:=false;
//range
if (x='') then exit;
x:=asfolder(x);
//get
if directoryexists(x) then result:=true
else
   begin
   forcedirectories(x);
   result:=directoryexists(x);
   end;//end of if
except;end;
end;
//## findfolder ##
function findfolder(x:integer;var y:string):boolean;//17-JAN-2007
const
   winroot='c:\windows\';
var
   i:IMalloc;
   a:pitemidlist;
   b:pchar;
begin
try
//defaults
result:=false;
y:='';
a:=nil;
//process
if (SHGetMalloc(i)=NOERROR) then
   begin
   if (shgetspecialfolderlocation(0,x,a)=0) then
      begin
      //.size
      b:=pchar(general.nullstr(max_path,#0));
      //.get
      if shgetpathfromidlist(a,b) then
         begin
         y:=asfolder(string(b));
         result:=(length(y)>=3);
         end;//end of if
      end;//end of if
   end;//end of if
except;end;
try;if (a<>nil) then i.free(a);except;end;
try
//-- Linux and robust Windows Support --
//Note: return a path regardless whether we are Windows or Linux, and wether it's supported
//      or not.
if not result then
   begin
   //init
   y:='';
   //get
   case x of
   CSIDL_DESKTOP:                y:=winroot+'desktop\';
   CSIDL_COMMON_DESKTOPDIRECTORY:y:=winroot+'desktop\';
   CSIDL_FAVORITES:              y:=winroot+'favorites\';
   CSIDL_STARTMENU:              y:=winroot+'start menu\';
   CSIDL_COMMON_STARTMENU:       y:=winroot+'start menu\';
   CSIDL_PROGRAMS:               y:=winroot+'start menu\programs\';
   CSIDL_COMMON_PROGRAMS:        y:=winroot+'start menu\programs\';
   CSIDL_STARTUP:                y:=winroot+'start menu\programs\startup\';
   CSIDL_COMMON_STARTUP:         y:=winroot+'start menu\programs\startup\';
   CSIDL_RECENT:                 y:=winroot+'recent\';
   CSIDL_FONTS:                  y:=winroot+'fonts\';
   CSIDL_APPDATA:                y:=winroot+'application data\';
   end;//end of case
   //set
   result:=(length(y)>=3);
   end;//end of if
except;end;
end;
//## mixedfolder ##
function mixedfolder(x:integer;y:string):string;
begin
try;mixedfolderb(x,y,result,true);except;end;
end;
//## mixedfolderb ##
function mixedfolderb(x:integer;y:string;var z:string;create:boolean):boolean;
var
   tmp:string;
begin
try
//defaults
result:=false;
z:='';
//process
if findfolder(x,tmp) then
   begin
   //.sub-path
   if (y<>'') then tmp:=tmp+asfolder(y);
   //.create
   if create and (not directoryexists(tmp)) then forcedirectories(tmp);
   //.successful
   result:=(length(tmp)>=2);
   if result then z:=tmp;
   end;//end of if
except;end;
end;
//## bvfolder ##
function bvfolder(bvfname:string):string;
begin
try;result:=bvfolderb(bvfname,true);except;end;
end;
//## bvfolderb ##
function bvfolderb(bvfname:string;create:boolean):string;//Blaiz Enterprises virtual folders 12-NOV-2005
begin
try;mixedfolderb(csidl_programs,bvfBlaizEnterprises+bvfname,result,create);except;end;
end;
//## bvfportable ##
function bvfportable(bvfname:string):string;//Blaiz Enterprises virtual folders 12-NOV-2005
begin
try;result:=bvfportableex(bvfname,true);except;end;
end;
//## bvfportableex ##
function bvfportableex(bvfname:string;create:boolean):string;//blaiz enterprises virtual folder structure (supports portable mode) 19-JAN-2007
begin
try
//defaults
result:='';
//process
if (programportablepath<>'') then
   begin
   //.get
   result:=programportablepath+'Blaiz Enterprises\';
   if (bvfname<>'') then result:=result+asfolder(bvfname);
   //.create
   if create and (not directoryexists(result)) then forcedirectories(result);
   end
else result:=bvfolderb(bvfname,create);
except;end;
end;
//## bvfFindtool ##
function bvfFindtool(prgname:string;var f:string):boolean;//16OCT2007, find filename (exe) for built-in tools (e.g. Animtor, Text Effects and Clic)
begin
try;result:=bvfFindtoolex(prgname,f,true);except;end;
end;
//## bvfFindtoolex ##
function bvfFindtoolex(prgname:string;var f:string;searchall:boolean):boolean;//03JAN2008, find filename (exe) for built-in tools (e.g. Secure Message, Animtor, Text Effects and Clic)
label
   skipend;
var
   cat,folder,filename,n:string;
begin
try
//defaults
result:=false;
f:='';
//init
n:=lowercase(general.remlastext(extractfilename(prgname)));
//.supported tools
cat:='';
//.accessories
if (n='addressbook') then cat:='accessories'
else if (n='chimer') then cat:='accessories'
else if (n='ebook builder') then cat:='accessories'
else if (n='text2exe') then cat:='accessories'
//..image tools
else if (n='animator') then cat:='image tools'
else if (n='text effects') then cat:='image tools'
else if (n='clic') then cat:='image tools'
else if (n='animation viewer') then cat:='image tools'
else if (n='hexcolor') then cat:='image tools'
else if (n='vas') then cat:='image tools'
else if (n='font viewer') then cat:='image tools'
else if (n='image viewer') then cat:='image tools'
else if (n='image printer') then cat:='image tools'
else if (n='batch image translator') then cat:='image tools'
//..communications
else if (n='dead simple downloader') then cat:='communications'
else if (n='get going server') then cat:='communications'
else if (n='internet color manager') then cat:='communications'
//..tools
else if (n='pc diagnose') then cat:='tools'
else if (n='runner') then cat:='tools'
else if (n='text viewer') then cat:='tools'
else if (n='email attachment transformer') then cat:='tools'
//..security
else if (n='secure message') then cat:='security'
//..system
else if (n='select language') then cat:='system'
//..not found
else exit;
cat:=cat+'\';
//get
//#1 - root folder - current folder [portable only]
if (f='') and (programportablepath<>'') then
   begin
   folder:=programportablepath;
   if directoryexists(folder) then
      begin
      if fileexists(folder+n+'.exe') then f:=folder+n+'.exe'
      else if fileexists(folder+n+'~.exe') then f:=folder+n+'~.exe';
      end;//end of if
   end;//end of if
//#2 - category folder [portable and non-portable]
if (f='') then
   begin
   folder:=bvfportableex(cat,false);
   if directoryexists(folder) then
      begin
      if fileexists(folder+n+'.exe') then f:=folder+n+'.exe'
      else if fileexists(folder+n+'~.exe') then f:=folder+n+'~.exe';
      end;//end of if
   end;//end of if
//#3 - start button "passive scan" [portable only]
if searchall and (f='') and (programportablepath<>'') then
   begin
   folder:=bvfolderb(cat,false);
   if directoryexists(folder) then
      begin
      if fileexists(folder+n+'.exe') then f:=folder+n+'.exe'
      else if fileexists(folder+n+'~.exe') then f:=folder+n+'~.exe';
      end;//end of if
   end;//end of if
//successful
result:=(f<>'');
skipend:
except;end;
end;
//## bvfRuntool ##
procedure bvfRuntool(prgname,f:string);//16SEP2007
begin
try;bvfRuntoolex(prgname,f,true);except;end;
end;
//## bvfRuntoolex ##
procedure bvfRuntoolex(prgname,f:string;searchall:boolean);//29OCT2007
var
   e,runf:string;
   ok:boolean;
begin
try
//defaults
ok:=false;
e:=gecUnexpectedError;
//get
if (comparetext(prgname,'my computer')=0) then
   begin
   runf:=extractfilepath(f);
   if directoryexists(runf) then
      begin
      run(runf,'');
      ok:=true;
      end
   else e:=gecPathNotFound;
   end
else if bvfFindtoolex(prgname,runf,searchall) then
   begin
   if (f<>'') and fileexists(f) then run(runf,'"'+f+'"') else run(runf,'');
   ok:=true;
   end
else e:=gecNotFound;
except;end;
try;if not ok then showerror60(general.asname(prgname)+#32+translate(e));except;end;
end;
//## extfolder ##
function extfolder(ext:string):string;
begin
try;extfolderex(ext,result,true);except;end;
end;
//## extfolderex ##
function extfolderex(ext:string;var folder:string;create:boolean):boolean;//09OCT2007
var
   z:string;
   other:boolean;
begin
try
//defaults
result:=false;
other:=false;
folder:='';
//setup
ext:=readfileext(ext,true);
z:='';
//process
if (ext='SAN') or (ext='EAN') or (ext='AAN') or (ext='ATEP') or (ext='GIF') then z:=bvfAnimations
else if (ext='ICO') or (ext='CUR') or (ext='ANI') then z:=bvfCursors
else if (ext='MSG') or (ext='TXT') or (ext='RTF') or (ext='DOC') then z:=bvfDocuments
else if (ext='FRM') or (ext='FRS') then z:=bvfFrames
else if (ext='MID') or (ext='RMI') or (ext='MIDI') or (ext='WAV') or (ext='SND') or (ext='MP3') or (ext='MP2') or (ext='WMA') then z:=bvfMusic
else if (ext='BMP') or (ext='WMF') or (ext='EMF') or (ext='JPG') or (ext='JPGT') or (ext='JIF') or (ext='TEP') or (ext='OMI') or (ext='PGM') or (ext='PBM') or (ext='PPM') or (ext='XBM') then z:=bvfPictures//still images
else if (ext='SHD') then z:=bvfShades
else if (ext='SCHEME') then z:=bvfSchemes//UMv3 - DSD+
else if (ext='SCH') then z:=bvfSchemesOLD//UMv2 - EATS only
else if (ext='TBH') then z:=bvfTextBrushs
else if (ext='EXE') or (ext='ZIP') then z:=bvfMiscellaneous
else if (ext='EAT') then
   begin
   if (programportablepath='') then z:=bvfUnknown//don't use desktop when portable
   else
      begin
      other:=true;
      mixedfolderb(CSIDL_DESKTOP,'EAT Files',folder,create);
      end;//end of if
   end
else z:=bvfUnknown;//all other unknown file types store under "unknown"
//virtual folder - updated for "portable mode"
if (not other) and (z<>'') then folder:=bvfportableex(z,create);
//successful
result:=(length(folder)>=2);
except;end;
end;
//## clipfile ##
function clipfile(ext:string):string;
begin
try;result:=bvfportable(bvfClipboard)+'clipboard-object-'+ext+'.'+ext;except;end;
end;
//## oldtonew ##
function oldtonew(old,new:string;delold:boolean):boolean;//copy old file to new location
var
   tmp,e:string;
begin
try
//defaults
result:=false;//no change
//check
if (old='') or (new='') then exit;
if (0=comparetext(old,new)) then exit;
//process
//.decide
if fileexists(old) and (not fileexists(new)) and io.fromfile(old,tmp,e) then
   begin
   //.new + delete old
   if io.tofile(new,tmp,e) then
      begin
      result:=true;//changed
      if delold then remfile(old);
      end;//end of if
   end;//end of if
except;end;
end;
//## noattribs ##
function noattribs(x:string):boolean;
begin
try
//defaults
result:=false;
//process
if fileexists(x) then filesetattr(x,0);
//successful
result:=true;
except;end;
end;
//## createfile ##
function createfile(x:string):boolean;
var//Note: Creates new blank file (when one does not exist)
   //      X is alreadys stripped of attribs (so file can be opened for read/write access)
   tmp:tfilestream;
begin
try
//defaults
result:=false;
tmp:=nil;
//check
if (x='') then exit;
//process
//.create
if fileexists(x) then
   begin
   //.noattribs - remove "readonly"
   try;filesetattr(x,0);except;end;
   result:=true;
   end
else
   begin
   try
   //.create blank file - so we can open later as read/write
   tmp:=tfilestream.create(x,fmCreate);
   result:=true;
   except;end;
   end;//end of if
except;end;
try;freeobj(@tmp);except;end;
end;
//## remfile ##
function remfile(x:string):boolean;
begin
try
//ok
result:=true;
if not fileexists(x) then exit;
//error
result:=false;
try;filesetattr(x,0);except;end;
try;deletefile(pchar(x));except;end;
//return result
result:=not fileexists(x);
except;end;
end;
//## remfilems ##
function remfilems(x:string;timeout:integer):boolean;
var
   t,s:currency;
begin
try
//defaults
result:=false;
t:=timeout;
//process
s:=ms64;
repeat
if remfile(x) then break else general.pause;
until ((ms64-s)>=t);
except;end;
end;
//## remonce ##
function remonce(x:string):boolean;//deletes files that end with ".once"
begin
try
//defaults
result:=false;
//process
if (comparetext(copy(x,length(x)-4,5),'.once')=0) then result:=remfile(x);
except;end;
end;
//## AskMessage ##
Function AskMessage(const Msg: string):Boolean;
begin
try;Result:=(mbrYes=MessageBox(application.handle,Msg,Translate('Warning'),mbWarning+MB_YESNO));except;end;
end;
//## getmemb ##
procedure getmemb(var p:pointer;size:integer);
begin
getmem(p,size);
fillchar(p^,size,0);
end;
//## reallocmemb ##
procedure reallocmemb(var p:pointer;oldsize,newsize:integer);
var
   a:pdlBYTE;
   i:integer;
begin
//get
reallocmem(p,newsize);
//clear
if (newsize>oldsize) then
   begin
   a:=p;
   for i:=frcmin(oldsize,0) to (newsize-1) do a[i]:=0;
   end;//end of if
end;

//################### System Information #######################################
//## siClose ##
procedure siClose;
begin
try;if (fmt<>nil) then fmt.closing;except;end;
end;
//## siInit ##
procedure siInit;
var
   v,p2,p:integer;
   f,tmp,_name:string;
begin
try
//check
if siInited then exit else siInited:=true;

//VARS - these need to be setup before any thing else
//.critical mathematical setup
sysarrays;

//DETECT
//.classes
windows.registerclass(tvirtualformclass);

//MODES
_name:=extractfilename(application.exename);//shared below
//.portable
//for p:=1 to length(_name) do if (_name[p]=pcSymPortable) then
   begin
   programportablepath:=asfolder(extractfilepath(application.exename));
   //startup information
   programsbfilename:=application.exename;
   programsufilename:=winstartup+programname+' ['+general.safeprogramname(application.exename)+'].lnk';
   //break;
   end;//end of if
//.clone - programrename
if programrename then for p:=1 to length(_name) do if (_name[p]=pcSymClone) then
   begin
   //.remove last extension
   tmp:=_name;
   for p2:=length(tmp) downto 1 do if (tmp[p2]='.') then
      begin
      tmp:=copy(tmp,1,p2-1);
      break;
      end;//end of if
   //.set
   programname:=tmp;
   programclonename:=tmp;
   programcloned:=true;
   break;
   end;//end of if

//ROOT INIT
//.64bit timer
ms64;
systemidleref:=ms64;
//.vs - startup before anything else, starts "lock=true" for safe control creation
vs;
//.programdescription
if (programdescription<>'') then programdescription:=translate(programdescription);

//DISK ACCESS
try
for p:=1 to 3 do//try a max of 3 times
begin
//get
f:=bvfportable(bvfActive)+programname+inttostr(random(maxint))+'.RW';//temp filename for checking purposes
//decide
remfile(f);
if general.mkfile(f,1) then programreadwrite:=true;
//clean
remfile(f);
//set
if programreadwrite then break else sleep(100);
end;//end of loop
except;
end;

//SYSTEM VARS
misc.initprogramdata(programsplash);
misc.initprogramdata(programanimatedicon);
misc.initprogramdata(programschemes);
misc.initprogramdata(programdata1);//10JAN2008
misc.initprogramdata(programdata2);//10JAN2008
misc.initprogramdata(programEULA);
misc.initprogramdata(programhelp);
misc.initprogramdata(programads);
misc.initprogramdata(programBLAIZDEL);
if (programencryption<>'') then programencryption:=ecap(programencryption,false);
{
//classification
v:=strint(misc.dt(programid));
//.freeware with optional logo removal
if (v>=1000) and (v<=9000) then
   begin
   programclassification:=ntranslate(misc.dt('=81M3'))+' ('+translate(misc.dt('-)8@M9741.992RRQ'))+')';//ntranslate('freeware')+' ('+translate('with optional scrolling logos removal')+')';
   programshowunlock:=true;
   end
//.shareware
else if (v>=15000) and (v<=50000) then
   begin
   programclassification:=ntranslate(misc.dt('):(.5""CE?/<B3'))+' ('+translate(misc.dt('>?;5@1@=94/0:(32@;29/P'))+')';//ntranslate('shareware')+' ('+translate('requires licensing for full functionality')+')';
   programshowunlock:=true;
   end
//.freeware (no cost)
else if (v=77391) then programclassification:=ntranslate(misc.dt('=81M3'))+' ('+translate(misc.dt(',4D*7?1FAJ46Y'))+')'//ntranslate('freeware')+' ('+translate('no cost')+')';
//.freeware (group scrolling logos removal)
else if (v=799) then
   begin
   programclassification:=ntranslate(misc.dt('=81M3'))+' ('+translate(misc.dt('9<KB2RQ'))+')';//ntranslate('freeware')+' ('+translate('with optional scrolling logos removal - group')+')';
   programshowunlock:=true;
   end
//.id is out of range (fatal shutdown)
else
   begin
   showerror60(viruswarntext(10));
   siHalt;
   end;//end of if
//notification
if programtesting then showinfo('Testing...');
{}//10aug2025

//INIT
//.boot/ms64init
systemboot:=ms64;
systemboottime:=now;
//.gettickcountSEC
gettickcountSEC:=ms64;
getDIM:=general.dim(now);
randomize;{ECap}

//VARS
//.title
programtitle:=programnameHARD+general.insstr(' ['+lowercase(programclonename)+']',programclonename<>'');
application.title:=programtitle;
//getmachineinfo
getmachineinfob(machine_ip,machine_host);
//.exe - start button
if (programportablepath='') then programexestartbutton:=bvfportable(programcategoryHARD)+programname+'.EXE'
else programexestartbutton:=application.exename;
//Cursors
hcrArrow:=LoadCursor(0,IDC_ARROW);
//system menu
viNormal.fontmap:=tfontmap.create;
viTitle.fontmap:=tfontmap.create;
menus.additem(@smTEXT,ntranslate('Cu&t'),tepCut20,'CTRL+T',smcCut,false);
menus.additem(@smTEXT,ntranslate('&Copy'),tepCopy20,'CTRL+C',smcCopy,false);
menus.additem(@smTEXT,ntranslate('Copy &All'),tepCopy20,'CTRL+A',smcCopyAll,false);
menus.additem(@smTEXT,ntranslate('&Paste'),tepPaste20,'CTRL+P',smcPaste,false);
menus.additem(@smTEXT,ntranslate('&Delete'),tepClear20,'CTRL+D',smcDelete,false);
menus.additem(@smTEXT,ntranslate('&Select All'),tepSelectAll20,'CTRL+S',smcSelectAll,false);
menus.addsep(@smText);
menus.additem(@smTEXT,ntranslate('&Upper')+#32+ntranslate('Case'),tepUpper20,'CTRL+U',smcUpper,false);
menus.additem(@smTEXT,ntranslate('&Lower')+#32+ntranslate('Case'),tepLower20,'CTRL+L',smcLower,false);
menus.additem(@smTEXT,ntranslate('&Edit'),'','CTRL+E',smcEdit,false);
//VS - Important: vs must loadfromfile->writetocontrols before any controls refer to it
//     "iindex:=vs.connect()" else it will load while control is still creating causing
//     fatal internal errors - 02-DEC-2006.
vs.locked:=false;

//DEBUG - START
siInfo('start');
except;end;
end;
//## siInfo ##
procedure siInfo(x:string);
var
   p:integer;
   z:string;
begin
try//code is to be commented out before program release
{//yyyyyyyy START
//defaults
z:='';
//process
//get
for p:=0 to high(sysinfo.items) do if (sysinfo.items[p].active>=1) then z:=z+inttostr(p)+'. '+sysinfo.items[p].name+': '+inttostr(sysinfo.items[p].active)+'/'+inttostr(sysinfo.items[p].count)+rcode;
//show
showinfo(
 'System Information'+rcode+
 'comment: '+x+rcode+
 '-----------------------------------'+rcode+
 z+
 '-----------------------------------'
 );
clipboard.astext:=clipboard.astext+rcode+'---'+rcode+z;
{}//yyyyyyy FINISH
except;end;
end;
//## siAutoCreate ##
procedure siAutoCreate(sysVar:prootobject;cls:trootclass;resultVar:prootobject);
begin//Assumes "resultVar" is never "nil"
try
//process
if (sysVar=nil) then
   begin
   resultVar^:=nil;
   exit;
   end
else if (sysVar^=nil) then cls.createsys(sysVar);
//return result
resultVar^:=sysVar^ as cls;
except;end;
end;
//## siHalt ##
procedure siHalt;//safe system shutdown
begin
try
siCloseAll;
halt;
except;end;
end;
//## siEmpty ##
function siEmpty(includeform:boolean):boolean;//all but main form
begin
try
//defaults
result:=true;
//process
//.lookup management
if result and (flm<>nil) and (not flm.empty) then result:=false;
//.managed connections
if result and (fmc<>nil) and (not fmc.empty) then result:=false;
//.managed robot
if result and (fmr<>nil) and (not fmr.empty) then result:=false;
//.form
if result and includeform and (forma<>nil) and (not forma.empty) then result:=false;
except;end;
end;
//## siCloseAll ##
procedure siCloseAll;//22-MAY-2006
var
   t,p2,p:integer;
   e,f:string;
   ok:boolean;
begin
try
//CHECK ------------------------------------------------------------------------
//.programcheck - ensures correct closure occurs, allowing for proper saving,
//                termination etc)
if (sysstate=ssOK) and (programcheck='') then
   begin
   showerror60(ntranslate('incorrect closure'));
   end;//end of if
//.check
if (sysstate>=ssFinished) then exit else sysstate:=ssFinished;

//DELETE - finish deletion (from pg.delete) ------------------------------------
try
if sysdeleting and (sysdeletelist<>nil) then
   begin
   //.1 - files
   for p:=0 to (sysdeletelist.count-1) do
   begin
   f:=sysdeletelist.strings[p];
   if general.textgood(f) then
      begin
      //.delete file/directory (wait upto 30 seconds)
      try
      if directoryexists(f) then removedirectory(pchar(f))//folder
      else remfilems(f,(30*1000));//file
      except;end;
      end;//end of if
   end;//end of loop
   //.2 - exe (delete this program, assumed to be not running)
   if (programexestartbutton<>'') then
      begin
      if remfile(programexestartbutton) then
         begin
         //.attempt to remove folder program resided in
         try;removedirectory(pchar(extractfilepath(programexestartbutton)));except;end;
         end
      else
         begin
         //.exe (delete this program, now known as running, so use BLAIZDEL.EXE to delete externally)
         //..unpack
         f:=wintemp+'BLAIZDEL.EXE';
         io.tofile(f,programBLAIZDEL,e);
         //..run
         if fileexists(f) then run(f,'"'+programexestartbutton+'"')
         else
            begin
            showerror(translate('Automatic program EXE removal "'+extractfilename(programexestartbutton)+'" failed. Please remove manually.'));
            run(extractfilepath(programexestartbutton),'');//display folder for manual removal
            end;//end of if
         end;//end of if
      end;//end of if
   end;//end of if
freeobj(@sysdeletelist);
except;end;

//CLOSE ------------------------------------------------------------------------
//.app
pg.systray:=false;//removes system tray icon
_appshutdown;

//close - first attempt
for p:=high(sysInfo.items) downto 1 do if (sysInfo.items[p].obj<>nil) then freeObj(@sysInfo.items[p].obj);

//close - second attempt (final)
for p2:=1 to 100 do
begin
ok:=true;
for p:=high(sysInfo.items) downto 1 do if (sysInfo.items[p].obj<>nil) then
   begin
   freeObj(@sysInfo.items[p].obj);
   ok:=false;
   end;//end of if
if ok then break;
end;//end of loop

//SYSTEM CLEANUP CODE - ONCE ONLY, MUST BE LAST TO EXECUTE
freeobj(@viNormal.fontmap);
freeobj(@viTitle.fontmap);

//classes
windows.unregisterclass(tvirtualformclass.lpszClassName,hinstance);

//terminate
application.terminate;
except;end;
end;
//## siFind ##
function siFind(obj:tobject;new:boolean):integer;//21-MAY-2006
var//Note: 0=reserved for errors/unknown, 1..N=specific objects
   fep,p:integer;
begin
try
//defaults
if new then result:=0 else result:=-1;
fep:=-1;//first empty position
//process
//.find
for p:=1 to high(sysInfo.items) do
  if (obj=sysInfo.items[p].obj) then
     begin
     result:=p;
     break;
     end
  else if (sysInfo.items[p].obj=nil) and (fep=-1) then fep:=p;
//.add
if new and (result=0) and (fep<>-1) then result:=fep;
//.create - once
if new and (sysInfo.items[result].active=0) then
   begin
   sysInfo.items[result].obj:=obj;
   sysInfo.items[result].createtime:=ms64;
   end;//end of if
except;end;
end;
//## siAdd ##
procedure siAdd(obj:tobject);
var
   p:integer;
begin
try
//process
//.find
p:=siFind(obj,true);
//.set
if (sysInfo.items[p].active=0) then
   begin
   case (obj=nil) of
   true:begin
      sysInfo.items[p].name:='-';
      sysInfo.items[p].obj:=nil;
      end;//end of begin
   false:begin
      sysInfo.items[p].name:=obj.classname;
      sysInfo.items[p].obj:=obj;
      end;//end of begin
   end;//end of case
   end;//end of if
inc(sysInfo.items[p].count);
inc(sysInfo.items[p].active);
if (sysInfo.items[p].count>=2) then inc(sysInfo.dupError);
//.counters
inc(sysInfo.create);
inc(sysInfo.active);
//.errors
if (p=0) then inc(sysInfo.errors);
except;end;
end;
//## siDel ##
procedure siDel(obj:tobject);
var
   p:integer;
begin
try
//process
//.find
p:=siFind(obj,false);
if (p=-1) then exit;
//.set
dec(sysInfo.items[p].active);
//.counters
inc(sysInfo.destroy);
dec(sysInfo.active);
//.errors
if (p=0) then inc(sysInfo.errors);
except;end;
end;
//## siFirst ##
function siFirst(start,dupCount:integer):integer;
var
   p:integer;
begin
try
//defaults
result:=-1;
//process
for p:=start to high(sysinfo.items) do if (sysinfo.items[p].active>=1) and (sysinfo.items[p].count>=dupCount) then
   begin
   result:=p;
   break;
   end;//end of if
except;end;
end;

{
//## intstr ##
function intstr(x:integer):string;//date: 10-APR-2004, v1.00.041
const//similar speed to "inttostr"
     clen=11;
     amax=10;
     vn:array[0..9] of char=('0','1','2','3','4','5','6','7','8','9');
var
   a:array[0..amax] of byte;//11c's
   n:boolean;
   dp,p,ap:byte;
   z,y:integer;
begin
try
//prepare
ap:=amax;
n:=(x<0);
if n then x:=-x;
//process
//get
while TRUE do
begin
y:=(x div 10);
z:=x-(y*10);
x:=y;
if (z>9) then break;
a[ap]:=z;
ap:=ap-1;
if (x=0) or (ap<0) then break;
end;//end of loop
//set
// .negative
if n then dp:=1 else dp:=0;
// .rapid padder
case (amax-ap+dp) of
1:result:='1';
2:result:='12';
3:result:='123';
4:result:='1234';
5:result:='12345';
6:result:='123456';
7:result:='1234567';
8:result:='12345678';
9:result:='123456789';
10:result:='1234567891';
11:result:='12345678911';
end;//end of case
// .rapid value replacer
if (dp=1) then result[1]:='-';
for p:=ap to (amax-1) do result[p-ap+1+dp]:=chr(a[p+1]+48);
except;end;
end;
{}
//## floattostrex2 ##
function floattostrex2(x:extended):string;//19DEC2007
begin
try;result:=floattostrex(x,18);except;end;
end;
//## floattostrex ##
function floattostrex(x:extended;dig:byte):string;//19DEC2007
var//0=integer part only, 1-18=include partial content if present
   p:integer;
   a,b:string;
   ok:boolean;
begin
try
//defaults
result:='0';
//get
a:=floattostrf(x,ffFixed,18,18);
b:='';
for p:=1 to length(a) do if (a[p]='.') then
   begin
   if (dig>=1) then b:=copy(a,p+1,dig);
   a:=copy(a,1,p-1);
   break;
   end;//end of if
//scan
if (b<>'') then
   begin
   ok:=true;
   for p:=length(b) downto 1 do if (b[p]<>'0') then
      begin
      ok:=false;
      break;
      end;//end of if
   //remove zeros
   if ok then b:='';
   end;//end of if
//set
result:=a+general.insstr('.'+b,b<>'');
except;end;
end;
//## strtofloatex ##
function strtofloatex(x:string):extended;//triggers less errors (x=nil now covered)
begin
try
//defaults
result:=0;
//get
if (x<>'') then result:=strtofloat(x);
except;end;
end;
//## strFlt ##
function strFlt(x:string):Extended;//date: 27-JAN-2007, v1.00.020
var
   maxp,p:integer;
   b:string;
begin
try
//default
result:=0;
{prepare}
b:='';
maxp:=length(x);
{process}
//split
for p:=1 to maxp do if (x[p]='.') then
    begin
    b:=copy(x,p+1,maxp);
    x:=copy(x,1,p-1);
    break;
    end;//end of if
//return result
//.whole
result:=strcur(x);
//.fraction
if (b<>'') then result:=result+(strcur(b)/power(10,length(b)));
except;end;
end;
//## strInt ##
function strInt(const x:string):integer;//date: 10-APR-2004, v1.00.041
var //similar speed to "strtoint" - no erros are produced though
   n,xlen,z,y:integer;
begin
try
{default}
result:=0;
if (x='') then exit;
{prepare}
xlen:=length(x);
n:=1;
{process}
z:=1;
while TRUE do
begin
y:=byte(x[z]);
if (y=45) then n:=-1
else
    begin
    if (y<48) or (y>57) then break;
    result:=result*10+y-48;
    end;
z:=z+1;
if (z>xlen) then break;
end;//end of while
//n
result:=result*n;
except;end;
end;
//## strCur ##
function strCur(const x:string):currency;//date: 06-JUL-2004, v1.00.044
var //similar speed to "strtoint" - no errors are produced though
   n,xlen,z,y:integer;
begin
try
{default}
result:=0;
if (x='') then exit;
{prepare}
xlen:=length(x);
n:=1;
{process}
z:=1;
while TRUE do
begin
y:=byte(x[z]);
if (y=45) then n:=-1
else
    begin
    if (y<48) or (y>57) then break;
    result:=result*10+y-48;
    end;
z:=z+1;
if (z>xlen) then break;
end;//end of while
//n
result:=result*n;
except;end;
end;
//## cround ##
function cround(x:extended):currency;//19DEC2007
begin//Note: extended maintains high-level "x/y" values, which if were transfered
try  //within currency would be slightly rounded causing distortion/errors
//defaults
result:=0;
//set
result:=strtocurr(floattostrex(x,0));//remove partial content
except;end;
end;

//######################## General Routines ####################################
//## DirectoryExists ##
Function DirectoryExists(const Name: string): Boolean;
var
  Code: Integer;
begin
try
Code:=GetFileAttributes(PChar(Name));
Result:=(Code <> -1) and (FILE_ATTRIBUTE_DIRECTORY and Code <> 0);
except;end;
end;
//## ForceDirectories ##
Procedure ForceDirectories(Dir: string);
begin
try
If (Length(Dir)=0) then exit;
If (Dir<>'') and (Copy(Dir,Length(Dir),1)='\') then Dir:=Copy(Dir,1,Length(Dir)-1);
If (Length(Dir)<3) or DirectoryExists(Dir) or (ExtractFilePath(Dir)=Dir) then exit; // avoid 'xyz:\' problem.
ForceDirectories(ExtractFilePath(Dir));
CreateDirectory(PChar(Dir), nil);
except;end;
end;

//########################### trootobject ######################################
//## create ##
constructor trootobject.create;
begin
//self
inherited create;
end;
//## createsys ##
constructor trootobject.createsys(sysVar:prootobject);
begin
if (sysVar<>nil) then
   begin
   //.set
   if (sysVar^=nil) then sysVar^:=self;
   //.add
   isysVar:=sysVar;
   siAdd(self);
   end;//end of if
create;
end;
//## destroy ##
destructor trootobject.destroy;
begin
if (isysVar<>nil) then
   begin
   //.del
   siDel(self);
   //.clear
   if (isysVar^=self) then isysVar^:=nil;
   isysVar:=nil;
   end;//end of if
inherited destroy;
end;
//## empty ##
function trootobject.empty:boolean;
begin
try;result:=true;except;end;
end;

//########################### tdynamiclist #####################################
//## create ##
constructor tdynamiclist.create;
begin
inherited;
//vars
sorted:=nil;
icore:=nil;
ilockedBPI:=false;
isize:=0;
icount:=0;
ibpi:=1;
ilimit:=maxint;
iincsize:=200;
freesorted:=true;
//defaults
_createsupport;
_init;
_corehandle;
end;
//## destroy ##
destructor tdynamiclist.destroy;
begin
try
//clear
clear;
//controls
_destroysupport;
freemem(icore);
if freesorted and (sorted<>nil) then freeObj(@sorted);
//self
inherited;
except;end;
end;
//## _createsupport ##
procedure tdynamiclist._createsupport;
begin
//nil
end;
//## _destroysupport ##
procedure tdynamiclist._destroysupport;
begin
//nil
end;
//## pulltext ##
procedure tdynamiclist.pulltext(var x:string);
var
   a:pdlCHAR;
   len,p:integer;
begin
try
//defaults
x:='';
//check
if (icore=nil) or (not itextsupported) then exit;
//process
//.size
len:=count*ibpi;
setlength(x,len);
//.core
a:=icore;
//.set
for p:=1 to len do x[p]:=a[p-1];
except;end;
end;
//## pushtext ##
procedure tdynamiclist.pushtext(var x:string);
var
   a:pdlCHAR;
   xlen,p:integer;
begin
try
//check
if (not itextsupported) then exit;
xlen:=length(x);
if (xlen=0) then exit;
//process
//.size
setparams(xlen div ibpi,xlen div ibpi,0);
//.core
if (icore=nil) then exit else a:=icore;
//.set
for p:=1 to xlen do a[p-1]:=x[p];
except;end;
end;
//## gettext ##
function tdynamiclist.gettext:string;
begin
try;pulltext(result);except;end;
end;
//## settext ##
procedure tdynamiclist.settext(x:string);
begin
try;pushtext(x);except;end;
end;
//## nosort ##
procedure tdynamiclist.nosort;
begin
try;if (sorted<>nil) then freeObj(@sorted);except;end;
end;
//## sort ##
procedure tdynamiclist.sort(_asc:boolean);
var
  p:integer;
begin
try
//check
if (sorted=nil) then
   begin
   freesorted:=true;
   sorted:=tdynamicinteger.create;
   end;//end of if
//process
//.sync "sorted" object
sorted.size:=size;
sorted.count:=count;
//.map "sorted" object with defaults (0...99...400..N)
for p:=0 to (count-1) do sorted.items[p]:=p;
//.sort
if (count>=1) then _sort(_asc);
except;end;
end;
//## _sort ##
procedure tdynamiclist._sort(_asc:boolean);
begin
{nil}
end;
//## _init ##
procedure tdynamiclist._init;
begin
try;_setparams(0,0,1,false);except;end;
end;
//## _corehandle ##
procedure tdynamiclist._corehandle;
begin
{nil}
end;
//## _oncreateitem ##
procedure tdynamiclist._oncreateitem(sender:tobject;index:integer);
begin
try;if assigned(oncreateitem) then oncreateitem(self,index);except;end;
end;
//## _onfreeitem ##
procedure tdynamiclist._onfreeitem(sender:tobject;index:integer);
begin
try;if assigned(onfreeitem) then onfreeitem(self,index);except;end;
end;
//## setincsize ##
procedure tdynamiclist.setincsize(x:integer);
begin
try;iincsize:=frcmin(x,1);except;end;
end;
//## clear ##
procedure tdynamiclist.clear;
begin
try;size:=0;except;end;
end;
//## notify ##
function tdynamiclist.notify(s,f:integer;_event:tdynamiclistevent):boolean;
var
   p:integer;
begin
try
//defaults
result:=false;
//no range checking (isize may be undefined at this stage, assume s & f are within range)
if (s<0) or (f<0) or (s>f) then exit;
//process
for p:=s to f do if assigned(_event) then _event(self,p);
//successful
result:=true;
except;end;
end;
//## shift ##
procedure tdynamiclist.shift(s,by:integer);
var
   p:integer;
begin
try
if (by>=1) then for p:=(isize-1) downto (s+by) do swap(p,p-by)
else if (by<=-1) then for p:=s to (isize-1) do swap(p,p+by);
except;end;
end;
//## swap ##
function tdynamiclist.swap(x,y:integer):boolean;
var
   a:byte;
   b:pdlBYTE;
   p:integer;
begin
try
//defaults
result:=false;
//check
if (x<0) or (x>=isize) or (y<0) or (y>=isize) then exit;
if assigned(onswapitems) then onswapitems(self,x,y)
else
    begin
    //prepare
    b:=icore;
    x:=x*ibpi;
    y:=y*ibpi;
    //process (swap values byte-by-byte)
    for p:=0 to (ibpi-1) do
    begin
    //1
    a:=b[x+p];
    //2
    b[x+p]:=b[y+p];
    //3
    b[y+p]:=a;
    end;//end of loop
    end;//end of if
//successful
result:=true;
except;end;
end;
//## setparams ##
function tdynamiclist.setparams(_count,_size,_bpi:integer):boolean;
begin
try;result:=_setparams(_count,_size,_bpi,true);except;end;
end;
//## _setparams ##
function tdynamiclist._setparams(_count,_size,_bpi:integer;_notify:boolean):boolean;
label
     skipend;
var
   a:pointer;
   p,_oldsize,_limit:integer;
begin
try
//defaults
result:=false;
//enforce range
if ilockedBPI then _bpi:=ibpi else _bpi:=frcmin(_bpi,1);
_limit:=(maxint div _bpi)-1;
_size:=frcrange(_size,0,_limit);
_oldsize:=frcrange(isize,0,_limit)*ibpi;
//process
//.size
if (_size<>isize) then
   begin
   a:=icore;
   //.enlarge
   if (_size>isize) then
      begin
      reallocmemb(icore,_oldsize,_size*_bpi);
      //.update core handle
      if (a<>icore) then _corehandle;
      if _notify then notify(isize,_size-1,_oncreateitem);
      end
   //.shrink
   else if (_size<isize) then
      begin
      if _notify then notify(_size,isize-1,_onfreeitem);
      reallocmemb(icore,_oldsize,_size*_bpi);
      //.update core handle
      if (a<>icore) then _corehandle;
      end;//end of if
   //.check
   end;
//.vars
ilimit:=_limit;
isize:=_size;
icount:=frcrange(_count,0,_size);
ibpi:=_bpi;
//successful
result:=true;
skipend:
except;end;
end;
//## atleast ##
function tdynamiclist.atleast(_size:integer):boolean;
begin
try
if (_size>=size) then result:=_setparams(count,((_size div incsize)+1)*incsize,bpi,true)
else result:=true;
except;end;
end;
//## addrange ##
function tdynamiclist.addrange(_count:integer):boolean;
var
   newsize,newcount:integer;
begin
try
//defaults
result:=false;
//check
if (_count<=0) then exit;
//prepare
newsize:=isize;
newcount:=icount+_count;
//check
if (newcount>ilimit) then exit;
if (newcount>newsize) then
   begin
   newsize:=newcount+iincsize;
   if (newsize>ilimit) then newsize:=ilimit;
   end;//end of if
//process
result:=setparams(newcount,newsize,bpi) and (newcount>=icount);
except;end;
end;
//## add ##
function tdynamiclist.add:boolean;
begin
try;result:=addrange(1);except;end;
end;
//## delrange
function tdynamiclist.delrange(s,_count:integer):boolean;
begin
try
//defaults
result:=false;
//check
if (s<0) or (s>=isize) then exit;
_count:=frcrange(_count,0,isize-s);
if (_count<=0) then exit;
//process
//.free
if not notify(s,s+_count-1,_onfreeitem) then exit;
//.shift down by "_count"
shift(s+_count,-_count);
//.shrink
if not _setparams(count-_count,isize-_count,bpi,false) then exit;
//successful
result:=true;
except;end;
end;
//## del ##
function tdynamiclist.del(x:integer):boolean;
begin
try;result:=delrange(x,1);except;end;
end;
//## insrange ##
function tdynamiclist.insrange(s,_count:integer):boolean;
var
   _oldsize,p:integer;
begin
try
//defaults
result:=false;
//check
_count:=frcmin(_count,0);
if (_count<=0) or (s<0) or (s>=isize) then exit;
if ((isize+_count)>ilimit) then exit;
//process
//.enlarge
_oldsize:=isize*bpi;
inc(isize,_count);
inc(icount,_count);
reallocmemb(icore,_oldsize,isize*bpi);
//.shift up by "_count"
shift(s,_count);
//.new
if not notify(s,s+_count-1,_oncreateitem) then exit;
//successful
result:=true;
except;end;
end;
//## ins ##
function tdynamiclist.ins(x:integer):boolean;
begin
try;result:=insrange(x,1);except;end;
end;
//## setcount ##
procedure tdynamiclist.setcount(x:integer);
begin
try;setparams(x,size,bpi);except;end;
end;
//## setsize ##
procedure tdynamiclist.setsize(x:integer);
begin
try;setparams(count,x,bpi);except;end;
end;
//## setbpi ##
procedure tdynamiclist.setbpi(x:integer);//bytes per item
begin
try;setparams(count,size,x);except;end;
end;
//## findvalue ##
function tdynamiclist.findvalue(_start:integer;_value:pointer):integer;
var
   a,b:pdlBYTE;
   maxp2,ai,p2,p:integer;
begin
try
//defaults
result:=-1;
//check
if (_start<0) or (_start>=count) or (_value=nil) then exit;
//prepare
a:=core;
b:=_value;
maxp2:=ibpi-1;
//process
for p:=_start to (icount-1) do
    begin
    ai:=p*ibpi;
    p2:=0;
    repeat
    if (a[ai+p2]<>b[p2]) then break;
    inc(p2);
    until (p2>maxp2);
    if (p2>maxp2) then
       begin
       result:=p;
       exit;
       end;//end of if
    end;//end of if
except;end;
end;
//## sindex ##
function tdynamiclist.sindex(x:integer):integer;
begin//sorted index
if (sorted=nil) or (x>=sorted.count) then result:=x else result:=sorted.value[x];
end;

//######################## tdynamicbyte ########################################
//## _init ##
procedure tdynamicbyte._init;
begin
try
_setparams(0,0,1,false);
ilockedBPI:=true;
itextsupported:=true;
except;end;
end;
//## _corehandle ##
procedure tdynamicbyte._corehandle;
begin
iitems:=core;
ibits:=core;
end;
//## getvalue ##
function tdynamicbyte.getvalue(_index:integer):byte;
begin
//.check
if (_index<0) or (_index>=count) then result:=0
else result:=items[_index];
end;
//## setvalue ##
procedure tdynamicbyte.setvalue(_index:integer;_value:byte);
begin
//.check
if (_index<0) then exit
else if (_index>=isize) and (not atleast(_index)) then exit;
//.count
if (_index>=icount) then icount:=_index+1;
//.set
items[_index]:=_value;
end;
//## getsvalue ##
function tdynamicbyte.getsvalue(_index:integer):byte;
begin
result:=value[sindex(_index)];
end;
//## setsvalue ##
procedure tdynamicbyte.setsvalue(_index:integer;_value:byte);
begin
value[sindex(_index)]:=_value;
end;
//## find ##
function tdynamicbyte.find(_start:integer;_value:byte):integer;
var
   p:integer;
begin
try
//defaults
result:=-1;
//check
if (_start<0) or (_start>=count) then exit;
//process
for p:=_start to (icount-1) do if (iitems[p]=_value) then
    begin
    result:=p;
    break;
    end;//end of if
except;end;
end;
//## _sort ##
procedure tdynamicbyte._sort(_asc:boolean);
begin
try;__sort(items,sorted.items,0,count-1,_asc);except;end;
end;
//## __sort ##
procedure tdynamicbyte.__sort(a:pdlBYTE;b:pdlINTEGER;l,r:integer;_asc:boolean);
var
  p:byte;
  tmp,i,j:integer;
begin
try
repeat
I := L;
J := R;
P := a^[b^[(L + R) shr 1]];
  repeat
  if _asc then
     begin
     while (a^[b^[I]]<P) do inc(I);
     while (a^[b^[J]]>P) do dec(J);
     end
  else
     begin
     while (a^[b^[I]]>P) do inc(I);
     while (a^[b^[J]]<P) do dec(J);
     end;//end of if
  if I <= J then
     begin
     tmp:=b^[i];
     b^[i]:=b^[j];
     b^[j]:=tmp;
     inc(I);
     dec(J);
     end;//end of if
  until I > J;
if L < J then __sort(a,b,L,J,_asc);
L := I;
until I >= R;
except;end;
end;

//## tdynamicchar ##############################################################
//## _init ##
procedure tdynamicchar._init;
begin
try
_setparams(0,0,1,false);
ilockedBPI:=true;
itextsupported:=true;
except;end;
end;
//## _corehandle ##
procedure tdynamicchar._corehandle;
begin
iitems:=core;
end;
//## getvalue ##
function tdynamicchar.getvalue(_index:integer):char;
begin
//.check
if (_index<0) or (_index>=count) then result:=#0
else result:=items[_index];
end;
//## setvalue ##
procedure tdynamicchar.setvalue(_index:integer;_value:char);
begin
//.check
if (_index<0) then exit
else if (_index>=isize) and (not atleast(_index)) then exit;
//.count
if (_index>=icount) then icount:=_index+1;
//.set
items[_index]:=_value;
end;
//## getsvalue ##
function tdynamicchar.getsvalue(_index:integer):char;
begin
result:=value[sindex(_index)];
end;
//## setsvalue ##
procedure tdynamicchar.setsvalue(_index:integer;_value:char);
begin
value[sindex(_index)]:=_value;
end;
//## find ##
function tdynamicchar.find(_start:integer;_value:char):integer;
var
   p:integer;
begin
try
//defaults
result:=-1;
//check
if (_start<0) or (_start>=count) then exit;
//process
for p:=_start to (icount-1) do if (iitems[p]=_value) then
    begin
    result:=p;
    break;
    end;//end of if
except;end;
end;
//## _sort ##
procedure tdynamicchar._sort(_asc:boolean);
begin
try;__sort(items,sorted.items,0,count-1,_asc);except;end;
end;
//## __sort ##
procedure tdynamicchar.__sort(a:pdlCHAR;b:pdlINTEGER;l,r:integer;_asc:boolean);
var
  p:char;
  tmp,i,j:integer;
begin
try
repeat
I := L;
J := R;
P := a^[b^[(L + R) shr 1]];
  repeat
  if _asc then
     begin
     while (a^[b^[I]]<P) do inc(I);
     while (a^[b^[J]]>P) do dec(J);
     end
  else
     begin
     while (a^[b^[I]]>P) do inc(I);
     while (a^[b^[J]]<P) do dec(J);
     end;//end of if
  if I <= J then
     begin
     tmp:=b^[i];
     b^[i]:=b^[j];
     b^[j]:=tmp;
     inc(I);
     dec(J);
     end;//end of if
  until I > J;
if L < J then __sort(a,b,L,J,_asc);
L := I;
until I >= R;
except;end;
end;

//######################## tdynamicboolean #####################################
//## _init ##
procedure tdynamicboolean._init;
begin
try
_setparams(0,0,1,false);
ilockedBPI:=true;
itextsupported:=true;
except;end;
end;
//## _corehandle ##
procedure tdynamicboolean._corehandle;
begin
iitems:=core;
end;
//## getvalue ##
function tdynamicboolean.getvalue(_index:integer):boolean;
begin
//.check
if (_index<0) or (_index>=count) then result:=false
else result:=items[_index];
end;
//## setvalue ##
procedure tdynamicboolean.setvalue(_index:integer;_value:boolean);
begin
//.check
if (_index<0) then exit
else if (_index>=isize) and (not atleast(_index)) then exit;
//.count
if (_index>=icount) then icount:=_index+1;
//.set
items[_index]:=_value;
end;
//## getsvalue ##
function tdynamicboolean.getsvalue(_index:integer):boolean;
begin
result:=value[sindex(_index)];
end;
//## setsvalue ##
procedure tdynamicboolean.setsvalue(_index:integer;_value:boolean);
begin
value[sindex(_index)]:=_value;
end;
//## find ##
function tdynamicboolean.find(_start:integer;_value:boolean):integer;
var
   p:integer;
begin
try
//defaults
result:=-1;
//check
if (_start<0) or (_start>=count) then exit;
//process
for p:=_start to (icount-1) do if (iitems[p]=_value) then
    begin
    result:=p;
    break;
    end;//end of if
except;end;
end;

//######################## tdynamicbit #########################################
//## create ##
constructor tdynamicbit.create;
begin
inherited;
icore:=tdynamicbyte.create;
icore.oncreateitem:=_oncreateitem;
icore.incsize:=100;
isize:=0;
end;
//## destroy ##
destructor tdynamicbit.destroy;
begin
try
//controls
freeObj(@icore);
//self
inherited;
except;end;
end;
//## pulltext ##
procedure tdynamicbit.pulltext(var x:string);
begin
try;icore.pulltext(x);except;end;
end;
//## pushtext ##
procedure tdynamicbit.pushtext(var x:string);
begin
try
icore.pushtext(x);
isize:=(icore.size*8);
except;end;
end;
//## gettext ##
function tdynamicbit.gettext:string;
begin
try;pulltext(result);except;end;
end;
//## settext ##
procedure tdynamicbit.settext(x:string);
begin
try;pushtext(x);except;end;
end;
//## _oncreateitem ##
procedure tdynamicbit._oncreateitem(sender:tobject;index:integer);
begin
try;icore.items[index]:=0;except;end;
end;
//## clear ##
procedure tdynamicbit.clear;
begin
try;size:=0;except;end;
end;
//## setsize ##
procedure tdynamicbit.setsize(x:integer);
begin
try
//enforce range
x:=frcmin(x,0);
isize:=x;
//set
if (((x div 8)*8)<>x) then x:=x+8;
icore.setparams(x div 8,x div 8,0);
except;end;
end;
//## getvalue ##
function tdynamicbit.getvalue(x:integer):boolean;
var
   a:pdlBITBOOLEAN;
   x8:integer;
   c:byte;
begin
//.check
if (x<0) or (x>=isize) then result:=false
else
    begin
    a:=icore.core;
    x8:=x div 8;
    c:=x-(x8*8);
    result:=(c in a[x8]);
    end;//end of if
end;
//## setvalue ##
procedure tdynamicbit.setvalue(x:integer;y:boolean);
var
   x8:integer;
   c:byte;
begin
//prepare
x8:=x div 8;
//.check
if (x<0) then exit
else if (x>=isize) then
     begin
     if (not icore.atleast(x8)) then exit;
     isize:=x+1;
     end;//end of if
//.set
c:=x-(x8*8);
if y then include(icore.bits[x8],c) else exclude(icore.bits[x8],c);
end;
//## settrue ##
procedure tdynamicbit.settrue(x:integer);
var//No range checking
   x8:integer;
   c:byte;
begin
x8:=x div 8;
c:=x-(x8*8);
include(icore.bits[x8],c);
end;
//## setfalse ##
procedure tdynamicbit.setfalse(x:integer);
var//No range checking
   x8:integer;
   c:byte;
begin
x8:=x div 8;
c:=x-(x8*8);
exclude(icore.bits[x8],c);
end;
//## info ##
procedure tdynamicbit.info(var _true,_false:integer);
var
   a:pdlBITBOOLEAN;
   maxp,p:integer;
   c:tBITBOOLEAN;
begin
try
//defaults
_true:=0;
_false:=isize;
a:=icore.core;
maxp:=icore.size;
p:=0;
//process
repeat
c:=a[p];
if (byte(c)>=1) then//25ms faster than "(c<>[])"
   begin
   if (0 in c) then inc(_true);
   if (1 in c) then inc(_true);
   if (2 in c) then inc(_true);
   if (3 in c) then inc(_true);
   if (4 in c) then inc(_true);
   if (5 in c) then inc(_true);
   if (6 in c) then inc(_true);
   if (7 in c) then inc(_true);
   end;//end of if
inc(p);
until (p>=maxp);
//finalise
_false:=isize-_true;
except;end;
end;

//######################## tdynamicword ########################################
//## _init ##
procedure tdynamicword._init;
begin
try
_setparams(0,0,2,false);
ilockedBPI:=true;
itextsupported:=true;
except;end;
end;
//## _corehandle ##
procedure tdynamicword._corehandle;
begin
iitems:=core;
end;
//## getvalue ##
function tdynamicword.getvalue(_index:integer):word;
begin
//.check
if (_index<0) or (_index>=count) then result:=0
else result:=items[_index];
end;
//## setvalue ##
procedure tdynamicword.setvalue(_index:integer;_value:word);
begin
//.check
if (_index<0) then exit
else if (_index>=isize) and (not atleast(_index)) then exit;
//.count
if (_index>=icount) then icount:=_index+1;
//.set
items[_index]:=_value;
end;
//## getsvalue ##
function tdynamicword.getsvalue(_index:integer):word;
begin
result:=value[sindex(_index)];
end;
//## setsvalue ##
procedure tdynamicword.setsvalue(_index:integer;_value:word);
begin
value[sindex(_index)]:=_value;
end;
//## find ##
function tdynamicword.find(_start:integer;_value:word):integer;
var
   p:integer;
begin
try
//defaults
result:=-1;
//check
if (_start<0) or (_start>=count) then exit;
//process
for p:=_start to (icount-1) do if (iitems[p]=_value) then
    begin
    result:=p;
    break;
    end;//end of if
except;end;
end;
//## _sort ##
procedure tdynamicword._sort(_asc:boolean);
begin
try;__sort(items,sorted.items,0,count-1,_asc);except;end;
end;
//## __sort ##
procedure tdynamicword.__sort(a:pdlWORD;b:pdlINTEGER;l,r:integer;_asc:boolean);
var
  p:word;
  tmp,i,j:integer;
begin
try
repeat
I := L;
J := R;
P := a^[b^[(L + R) shr 1]];
  repeat
  if _asc then
     begin
     while (a^[b^[I]]<P) do inc(I);
     while (a^[b^[J]]>P) do dec(J);
     end
  else
     begin
     while (a^[b^[I]]>P) do inc(I);
     while (a^[b^[J]]<P) do dec(J);
     end;//end of if
  if I <= J then
     begin
     tmp:=b^[i];
     b^[i]:=b^[j];
     b^[j]:=tmp;
     inc(I);
     dec(J);
     end;//end of if
  until I > J;
if L < J then __sort(a,b,L,J,_asc);
L := I;
until I >= R;
except;end;
end;

//### tdynamicsmallint #########################################################
//## _init ##
procedure tdynamicsmallint._init;
begin
try
_setparams(0,0,sizeof(smallint),false);
ilockedBPI:=true;
itextsupported:=true;
except;end;
end;
//## _corehandle ##
procedure tdynamicsmallint._corehandle;
begin
iitems:=core;
end;
//## getvalue ##
function tdynamicsmallint.getvalue(_index:integer):smallint;
begin
//.check
if (_index<0) or (_index>=count) then result:=0
else result:=items[_index];
end;
//## setvalue ##
procedure tdynamicsmallint.setvalue(_index:integer;_value:smallint);
begin
//.check
if (_index<0) then exit
else if (_index>=isize) and (not atleast(_index)) then exit;
//.count
if (_index>=icount) then icount:=_index+1;
//.set
items[_index]:=_value;
end;
//## getsvalue ##
function tdynamicsmallint.getsvalue(_index:integer):smallint;
begin
result:=value[sindex(_index)];
end;
//## setsvalue ##
procedure tdynamicsmallint.setsvalue(_index:integer;_value:smallint);
begin
value[sindex(_index)]:=_value;
end;
//## find ##
function tdynamicsmallint.find(_start:integer;_value:smallint):integer;
var
   p:integer;
begin
try
//defaults
result:=-1;
//check
if (_start<0) or (_start>=count) then exit;
//process
for p:=_start to (icount-1) do if (iitems[p]=_value) then
    begin
    result:=p;
    break;
    end;//end of if
except;end;
end;
//## _sort ##
procedure tdynamicsmallint._sort(_asc:boolean);
begin
try;__sort(items,sorted.items,0,count-1,_asc);except;end;
end;
//## __sort ##
procedure tdynamicsmallint.__sort(a:pdlSMINT;b:pdlINTEGER;l,r:integer;_asc:boolean);
var
  p:smallint;
  tmp,i,j:integer;
begin
try
repeat
I := L;
J := R;
P := a^[b^[(L + R) shr 1]];
  repeat
  if _asc then
     begin
     while (a^[b^[I]]<P) do inc(I);
     while (a^[b^[J]]>P) do dec(J);
     end
  else
     begin
     while (a^[b^[I]]>P) do inc(I);
     while (a^[b^[J]]<P) do dec(J);
     end;//end of if
  if I <= J then
     begin
     tmp:=b^[i];
     b^[i]:=b^[j];
     b^[j]:=tmp;
     inc(I);
     dec(J);
     end;//end of if
  until I > J;
if L < J then __sort(a,b,L,J,_asc);
L := I;
until I >= R;
except;end;
end;

//######################## tdynamicinteger #####################################
//## _init ##
procedure tdynamicinteger._init;
begin
try
_setparams(0,0,4,false);
ilockedBPI:=true;
itextsupported:=true;
except;end;
end;
//## _corehandle ##
procedure tdynamicinteger._corehandle;
begin
iitems:=core;
end;
//## getvalue ##
function tdynamicinteger.getvalue(_index:integer):integer;
begin
//.check
if (_index<0) or (_index>=count) then result:=0
else result:=items[_index];
end;
//## setvalue ##
procedure tdynamicinteger.setvalue(_index:integer;_value:integer);
begin
//.check
if (_index<0) then exit
else if (_index>=isize) and (not atleast(_index)) then exit;
//.count
if (_index>=icount) then icount:=_index+1;
//.set
items[_index]:=_value;
end;
//## getsvalue ##
function tdynamicinteger.getsvalue(_index:integer):integer;
begin
result:=value[sindex(_index)];
end;
//## setsvalue ##
procedure tdynamicinteger.setsvalue(_index:integer;_value:integer);
begin
value[sindex(_index)]:=_value;
end;
//## find ##
function tdynamicinteger.find(_start:integer;_value:integer):integer;
var
   p:integer;
begin
try
//defaults
result:=-1;
//check
if (_start<0) or (_start>=count) then exit;
//process
for p:=_start to (icount-1) do if (iitems[p]=_value) then
    begin
    result:=p;
    break;
    end;//end of if
except;end;
end;
//## _sort ##
procedure tdynamicinteger._sort(_asc:boolean);
begin
try;__sort(items,sorted.items,0,count-1,_asc);except;end;
end;
//## __sort ##
procedure tdynamicinteger.__sort(a:pdlINTEGER;b:pdlINTEGER;l,r:integer;_asc:boolean);
var
  p:integer;
  tmp,i,j:integer;
begin
try
repeat
I := L;
J := R;
P := a^[b^[(L + R) shr 1]];
  repeat
  if _asc then
     begin
     while (a^[b^[I]]<P) do inc(I);
     while (a^[b^[J]]>P) do dec(J);
     end
  else
     begin
     while (a^[b^[I]]>P) do inc(I);
     while (a^[b^[J]]<P) do dec(J);
     end;//end of if
  if I <= J then
     begin
     tmp:=b^[i];
     b^[i]:=b^[j];
     b^[j]:=tmp;
     inc(I);
     dec(J);
     end;//end of if
  until I > J;
if L < J then __sort(a,b,L,J,_asc);
L := I;
until I >= R;
except;end;
end;

//## tdynamicrgb ###############################################################
//## _init ##
procedure tdynamicrgb._init;
begin
try
_setparams(0,0,sizeof(trgbcolor),false);
ilockedBPI:=true;
except;end;
end;
//## _corehandle ##
procedure tdynamicrgb._corehandle;
begin
iitems:=core;
end;
//## getindirect ##
function tdynamicrgb.getindirect(_index:integer):trgbcolor;
begin
result:=items[_index];
end;
//## setindirect ##
procedure tdynamicrgb.setindirect(_index:integer;z:trgbcolor);
begin
items[_index]:=z;
end;
//## getvalue ##
function tdynamicrgb.getvalue(_index:integer):trgbcolor;
begin
//.check
if (_index<0) or (_index>=count) then result:=cl_black
else result:=items[_index];
end;
//## setvalue ##
procedure tdynamicrgb.setvalue(_index:integer;_value:trgbcolor);
begin
//.check
if (_index<0) then exit
else if (_index>=isize) and (not atleast(_index)) then exit;
//.count
if (_index>=icount) then icount:=_index+1;
//.set
items[_index]:=_value;
end;
//## getsvalue ##
function tdynamicrgb.getsvalue(_index:integer):trgbcolor;
begin
result:=value[sindex(_index)];
end;
//## setsvalue ##
procedure tdynamicrgb.setsvalue(_index:integer;_value:trgbcolor);
begin
value[sindex(_index)]:=_value;
end;
//## find ##
function tdynamicrgb.find(_start:integer;_value:trgbcolor):integer;
var
   p:integer;
begin
try
//defaults
result:=-1;
//check
if (_start<0) or (_start>=count) then exit;
//process
for p:=_start to (icount-1) do if (iitems[p].r=_value.r) and (iitems[p].g=_value.g) and (iitems[p].b=_value.b) then
    begin
    result:=p;
    break;
    end;//end of if
except;end;
end;
//## _sort ##
procedure tdynamicrgb._sort(_asc:boolean);
begin
//nil
end;
//## __sort ##
procedure tdynamicrgb.__sort(a:pdlRGB;b:pdlRGB;l,r:integer;_asc:boolean);
begin
//nil
end;
//## readfrom ##
function tdynamicrgb.readfrom(x:tbitmap;dy:integer):boolean;
begin
try;result:=readfromex(x,dy,0,0,clNone);except;end;
end;
//## readfromex ##
function tdynamicrgb.readfromex(x:tbitmap;dy:integer;bolPad,eolPad,colPad:integer):boolean;
var
   r:prgbcolorrow;
   _colPad,c:trgbcolor;
   o,maxx,v,p:integer;
begin
try
//defaults
result:=false;
//range
bolPad:=frcmin(bolPad,0);
eolPad:=frcmin(eolPad,0);
_colPad:=ccs.intrgb(colPad);
//get
if ccs.valid24(x) then
   begin
   //get
   v:=bolPad+x.width+eolPad;
   if (size<>v) then setparams(v,v,0);
   maxx:=x.width-1;
   //set
   case (colPad=clNone) of
   true:begin//fills out-of-bounds area with nearest color within image
      //.get
      dy:=frcrange(dy,0,x.height-1);
      r:=x.scanline[dy];
      for p:=0 to maxx do items[p+bolPad]:=r[p];
      //.bolPad
      if (bolPad>=1) then
         begin
         c:=r[0];
         for p:=0 to (bolPad-1) do items[p]:=c;
         end;//end of if
      //.eolPad
      if (eolPad>=1) then
         begin
         c:=r[maxx];
         o:=bolPad+maxx+1;
         for p:=0 to (eolPad-1) do items[o+p]:=c;
         end;//end of if
      end;//end of begin
   false:begin//fills out-of-bounds area with specified color "colPad"
      //.get
      if (dy>=0) and (dy<x.height) then
         begin
         r:=x.scanline[dy];
         for p:=0 to maxx do items[p+bolPad]:=r[p];
         end
      else for p:=0 to maxx do items[p+bolPad]:=_colPad;
      //.bolPad
      if (bolPad>=1) then for p:=0 to (bolPad-1) do items[p]:=_colPad;
      //.eolPad
      if (eolPad>=1) then
         begin
         o:=bolPad+maxx+1;
         for p:=0 to (eolPad-1) do items[o+p]:=_colPad;
         end;//end of if
      end;//end of begin
   end;//end of case
   //successful
   result:=true;
   end;//end of if
except;end;
end;

//## tdynamicpoint #############################################################
//## _init ##
procedure tdynamicpoint._init;
begin
try
_setparams(0,0,sizeof(tpoint),false);
ilockedBPI:=true;
itextsupported:=true;
except;end;
end;
//## _corehandle ##
procedure tdynamicpoint._corehandle;
begin
iitems:=core;
end;
//## getvalue ##
function tdynamicpoint.getvalue(_index:integer):tpoint;
begin
//.check
if (_index<0) or (_index>=count) then result:=point(0,0)
else result:=items[_index];
end;
//## setvalue ##
procedure tdynamicpoint.setvalue(_index:integer;_value:tpoint);
begin
//.check
if (_index<0) then exit
else if (_index>=isize) and (not atleast(_index)) then exit;
//.count
if (_index>=icount) then icount:=_index+1;
//.set
items[_index]:=_value;
end;
//## getsvalue ##
function tdynamicpoint.getsvalue(_index:integer):tpoint;
begin
result:=value[sindex(_index)];
end;
//## setsvalue ##
procedure tdynamicpoint.setsvalue(_index:integer;_value:tpoint);
begin
value[sindex(_index)]:=_value;
end;
//## find ##
function tdynamicpoint.find(_start:integer;_value:tpoint):integer;
var
   p:integer;
begin
try
//defaults
result:=-1;
//check
if (_start<0) or (_start>=count) then exit;
//process
for p:=_start to (icount-1) do if (iitems[p].x=_value.x) and (iitems[p].y=_value.y) then
    begin
    result:=p;
    break;
    end;//end of if
except;end;
end;
//## _sort ##
procedure tdynamicpoint._sort(_asc:boolean);
begin
try;__sort(items,sorted.items,0,count-1,_asc);except;end;
end;
//## __sort ##
procedure tdynamicpoint.__sort(a:pdlPOINT;b:pdlINTEGER;l,r:integer;_asc:boolean);
begin
//nil - sorting not supported by "tdynamicpoint"
end;

//####################### tdynamicintegerlist ##################################
//## create ##
constructor tdynamicintegerlist.create;
begin
inherited;
//controls
irows:=tdynamicobject.create;
end;
//## destroy ##
destructor tdynamicintegerlist.destroy;
begin
try
//controls
irows.freeValues;
freeObj(@irows);
//self
inherited;
except;end;
end;
//## del ##
procedure tdynamicintegerlist.del(x:integer);
var
   a:tdynamicinteger;
begin
try
if (x>=0) and (x<count) then
   begin
   a:=row[x];
   irows.del(x);
   freeObj(@a);
   end;//end of if
except;end;
end;
//## getrow ##
function tdynamicintegerlist.getrow(x:integer):tdynamicinteger;
begin
try;if (x>=0) and (x<count) then result:=irows.items[x] as tdynamicinteger else result:=nil;except;end;
end;
//## getcount ##
function tdynamicintegerlist.getcount:integer;
begin
try;result:=irows.count;except;end;
end;
//## setcount ##
procedure tdynamicintegerlist.setcount(x:integer);
var
   oc,p:integer;
begin
try
//check
if (x<0) or (x=count) then exit;
//process
if (x>count) then
   begin
   oc:=count;
   irows.setparams(x,x,0);
   for p:=oc to (count-1) do irows.items[p]:=tdynamicinteger.create;
   end
else if (x<count) then
   begin
   for p:=(count-1) downto (x+1) do irows.freeValue(p);
   irows.setparams(x,x,0);
   end;//end of if
except;end;
end;
//## clear ##
procedure tdynamicintegerlist.clear;
begin
try;count:=0;except;end;
end;

//######################## tdynamiccurrency ####################################
//## _init ##
procedure tdynamiccurrency._init;
begin
try
_setparams(0,0,8,false);
ilockedBPI:=true;
itextsupported:=true;
except;end;
end;
//## _corehandle ##
procedure tdynamiccurrency._corehandle;
begin
iitems:=core;
end;
//## getvalue ##
function tdynamiccurrency.getvalue(_index:integer):currency;
begin
//.check
if (_index<0) or (_index>=count) then result:=0
else result:=items[_index];
end;
//## setvalue ##
procedure tdynamiccurrency.setvalue(_index:integer;_value:currency);
begin
//.check
if (_index<0) then exit
else if (_index>=isize) and (not atleast(_index)) then exit;
//.count
if (_index>=icount) then icount:=_index+1;
//.set
items[_index]:=_value;
end;
//## getsvalue ##
function tdynamiccurrency.getsvalue(_index:integer):currency;
begin
result:=value[sindex(_index)];
end;
//## setsvalue ##
procedure tdynamiccurrency.setsvalue(_index:integer;_value:currency);
begin
value[sindex(_index)]:=_value;
end;
//## find ##
function tdynamiccurrency.find(_start:integer;_value:currency):integer;
var//* Uses "2xInteger for QUICK comparision".
   //* Direct "Currency" comparison is upto 3-4 times slower.
   a:pdlBIINTEGER;
   b:pBIINTEGER;
   p:integer;
begin
try
//defaults
result:=-1;
//check
if (_start<0) or (_start>=count) then exit;
//prepare
a:=core;
b:=@_value;
//process
for p:=_start to (icount-1) do if (a[p][0]=b[0]) and (a[p][1]=b[1]) then
    begin
    result:=p;
    break;
    end;//end of if
except;end;
end;
//## _sort ##
procedure tdynamiccurrency._sort(_asc:boolean);
begin
try;__sort(items,sorted.items,0,count-1,_asc);except;end;
end;
//## __sort ##
procedure tdynamiccurrency.__sort(a:pdlCURRENCY;b:pdlINTEGER;l,r:integer;_asc:boolean);
var
  p:currency;
  tmp,i,j:integer;
begin
try
repeat
I := L;
J := R;
P := a^[b^[(L + R) shr 1]];
  repeat
  if _asc then
     begin
     while (a^[b^[I]]<P) do inc(I);
     while (a^[b^[J]]>P) do dec(J);
     end
  else
     begin
     while (a^[b^[I]]>P) do inc(I);
     while (a^[b^[J]]<P) do dec(J);
     end;//end of if
  if I <= J then
     begin
     tmp:=b^[i];
     b^[i]:=b^[j];
     b^[j]:=tmp;
     inc(I);
     dec(J);
     end;//end of if
  until I > J;
if L < J then __sort(a,b,L,J,_asc);
L := I;
until I >= R;
except;end;
end;

//######################## tdynamicdouble ######################################
//## _init ##
procedure tdynamicdouble._init;
begin
try
_setparams(0,0,8,false);
ilockedBPI:=true;
itextsupported:=true;
except;end;
end;
//## _corehandle ##
procedure tdynamicdouble._corehandle;
begin
iitems:=core;
end;
//## getvalue ##
function tdynamicdouble.getvalue(_index:integer):double;
begin
//.check
if (_index<0) or (_index>=count) then result:=0
else result:=items[_index];
end;
//## setvalue ##
procedure tdynamicdouble.setvalue(_index:integer;_value:double);
begin
//.check
if (_index<0) then exit
else if (_index>=isize) and (not atleast(_index)) then exit;
//.count
if (_index>=icount) then icount:=_index+1;
//.set
items[_index]:=_value;
end;
//## getsvalue ##
function tdynamicdouble.getsvalue(_index:integer):double;
begin
result:=value[sindex(_index)];
end;
//## setsvalue ##
procedure tdynamicdouble.setsvalue(_index:integer;_value:double);
begin
value[sindex(_index)]:=_value;
end;
//## find ##
function tdynamicdouble.find(_start:integer;_value:double):integer;
var//* Uses "2xInteger for QUICK comparision".
   //* Direct "Double" comparison is upto 3-4 times slower.
   a:pdlBIINTEGER;
   b:pBIINTEGER;
   p:integer;
begin
try
//defaults
result:=-1;
//check
if (_start<0) or (_start>=count) then exit;
//prepare
a:=core;
b:=@_value;
//process
for p:=_start to (icount-1) do if (a[p][0]=b[0]) and (a[p][1]=b[1]) then
    begin
    result:=p;
    break;
    end;//end of if
except;end;
end;
//## _sort ##
procedure tdynamicdouble._sort(_asc:boolean);
begin
try;__sort(items,sorted.items,0,count-1,_asc);except;end;
end;
//## __sort ##
procedure tdynamicdouble.__sort(a:pdlDOUBLE;b:pdlINTEGER;l,r:integer;_asc:boolean);
var
  p:double;
  tmp,i,j:integer;
begin
try
repeat
I := L;
J := R;
P := a^[b^[(L + R) shr 1]];
  repeat
  if _asc then
     begin
     while (a^[b^[I]]<P) do inc(I);
     while (a^[b^[J]]>P) do dec(J);
     end
  else
     begin
     while (a^[b^[I]]>P) do inc(I);
     while (a^[b^[J]]<P) do dec(J);
     end;//end of if
  if I <= J then
     begin
     tmp:=b^[i];
     b^[i]:=b^[j];
     b^[j]:=tmp;
     inc(I);
     dec(J);
     end;//end of if
  until I > J;
if L < J then __sort(a,b,L,J,_asc);
L := I;
until I >= R;
except;end;
end;

//## tdynamicdatetime ##########################################################
//## _init ##
procedure tdynamicdatetime._init;
begin
try
_setparams(0,0,8,false);
ilockedBPI:=true;
itextsupported:=true;
except;end;
end;
//## _corehandle ##
procedure tdynamicdatetime._corehandle;
begin
iitems:=core;
end;
//## getvalue ##
function tdynamicdatetime.getvalue(_index:integer):tdatetime;
begin
//.check
if (_index<0) or (_index>=count) then result:=0
else result:=items[_index];
end;
//## setvalue ##
procedure tdynamicdatetime.setvalue(_index:integer;_value:tdatetime);
begin
//.check
if (_index<0) then exit
else if (_index>=isize) and (not atleast(_index)) then exit;
//.count
if (_index>=icount) then icount:=_index+1;
//.set
items[_index]:=_value;
end;
//## getsvalue ##
function tdynamicdatetime.getsvalue(_index:integer):tdatetime;
begin
result:=value[sindex(_index)];
end;
//## setsvalue ##
procedure tdynamicdatetime.setsvalue(_index:integer;_value:tdatetime);
begin
value[sindex(_index)]:=_value;
end;
//## find ##
function tdynamicdatetime.find(_start:integer;_value:tdatetime):integer;
var//* Uses "2xInteger for QUICK comparision".
   //* Direct "Double" comparison is upto 3-4 times slower.
   a:pdlBIINTEGER;
   b:pBIINTEGER;
   p:integer;
begin
try
//defaults
result:=-1;
//check
if (_start<0) or (_start>=count) then exit;
//prepare
a:=core;
b:=@_value;
//process
for p:=_start to (icount-1) do if (a[p][0]=b[0]) and (a[p][1]=b[1]) then
    begin
    result:=p;
    break;
    end;//end of if
except;end;
end;
//## _sort ##
procedure tdynamicdatetime._sort(_asc:boolean);
begin
try;__sort(items,sorted.items,0,count-1,_asc);except;end;
end;
//## __sort ##
procedure tdynamicdatetime.__sort(a:pdlDATETIME;b:pdlINTEGER;l,r:integer;_asc:boolean);
var
  p:tdatetime;
  tmp,i,j:integer;
begin
try
repeat
I := L;
J := R;
P := a^[b^[(L + R) shr 1]];
  repeat
  if _asc then
     begin
     while (a^[b^[I]]<P) do inc(I);
     while (a^[b^[J]]>P) do dec(J);
     end
  else
     begin
     while (a^[b^[I]]>P) do inc(I);
     while (a^[b^[J]]<P) do dec(J);
     end;//end of if
  if I <= J then
     begin
     tmp:=b^[i];
     b^[i]:=b^[j];
     b^[j]:=tmp;
     inc(I);
     dec(J);
     end;//end of if
  until I > J;
if L < J then __sort(a,b,L,J,_asc);
L := I;
until I >= R;
except;end;
end;

//########################## tdynamicrect ######################################
//## _init ##
procedure tdynamicrect._init;
begin
try
_setparams(0,0,sizeof(trect),false);
ilockedBPI:=true;
itextsupported:=true;
except;end;
end;
//## _corehandle ##
procedure tdynamicrect._corehandle;
begin
iitems:=core;
end;
//## getvalue ##
function tdynamicrect.getvalue(_index:integer):trect;
begin
//.check
if (_index<0) or (_index>=count) then result:=rect(0,0,0,0)
else result:=items[_index];
end;
//## setvalue ##
procedure tdynamicrect.setvalue(_index:integer;_value:trect);
begin
//.check
if (_index<0) then exit
else if (_index>=isize) and (not atleast(_index)) then exit;
//.count
if (_index>=icount) then icount:=_index+1;
//.set
items[_index]:=_value;
end;
//## getsvalue ##
function tdynamicrect.getsvalue(_index:integer):trect;
begin
result:=value[sindex(_index)];
end;
//## setsvalue ##
procedure tdynamicrect.setsvalue(_index:integer;_value:trect);
begin
value[sindex(_index)]:=_value;
end;
//## find ##
function tdynamicrect.find(_start:integer;_value:trect):integer;
var
   p:integer;
begin
try
//defaults
result:=-1;
//check
if (_start<0) or (_start>=count) then exit;
//process
for p:=_start to (icount-1) do if
 (iitems[p].left=_value.left) and
 (iitems[p].top=_value.top) and
 (iitems[p].right=_value.right) and
 (iitems[p].bottom=_value.bottom) then
    begin
    result:=p;
    break;
    end;//end of if
except;end;
end;
//## _sort ##
procedure tdynamicrect._sort(_asc:boolean);
begin
{nil}
end;
//## __sort ##
procedure tdynamicrect.__sort(a:pdlRECT;b:pdlRECT;l,r:integer;_asc:boolean);
begin
{nil}
end;

//######################## tdynamicpointer ####################################
//## _init ##
procedure tdynamicpointer._init;
begin
try
_setparams(0,0,4,false);
ilockedBPI:=true;
itextsupported:=true;
except;end;
end;
//## _corehandle ##
procedure tdynamicpointer._corehandle;
begin
iitems:=core;
end;
//## getvalue ##
function tdynamicpointer.getvalue(_index:integer):pointer;
begin
//.check
if (_index<0) or (_index>=count) then result:=nil
else result:=items[_index];
end;
//## setvalue ##
procedure tdynamicpointer.setvalue(_index:integer;_value:pointer);
begin
//.check
if (_index<0) then exit
else if (_index>=isize) and (not atleast(_index)) then exit;
//.count
if (_index>=icount) then icount:=_index+1;
//.set
items[_index]:=_value;
end;
//## getsvalue ##
function tdynamicpointer.getsvalue(_index:integer):pointer;
begin
result:=value[sindex(_index)];
end;
//## setsvalue ##
procedure tdynamicpointer.setsvalue(_index:integer;_value:pointer);
begin
value[sindex(_index)]:=_value;
end;
//## find ##
function tdynamicpointer.find(_start:integer;_value:pointer):integer;
var
   p:integer;
begin
try
//defaults
result:=-1;
//check
if (_start<0) or (_start>=count) then exit;
//process
for p:=_start to (icount-1) do if (iitems[p]=_value) then
    begin
    result:=p;
    break;
    end;//end of if
except;end;
end;

//######################## tdynamicnotifyevent #################################
//## _init ##
procedure tdynamicnotifyevent._init;
begin
try
_setparams(0,0,sizeof(tnotifyevent),false);
ilockedBPI:=true;
itextsupported:=true;
except;end;
end;
//## _corehandle ##
procedure tdynamicnotifyevent._corehandle;
begin
iitems:=core;
end;
//## getvalue ##
function tdynamicnotifyevent.getvalue(_index:integer):tnotifyevent;
begin
//.check
if (_index<0) or (_index>=count) then result:=nil
else result:=items[_index];
end;
//## setvalue ##
procedure tdynamicnotifyevent.setvalue(_index:integer;_value:tnotifyevent);
begin
//.check
if (_index<0) then exit
else if (_index>=isize) and (not atleast(_index)) then exit;
//.count
if (_index>=icount) then icount:=_index+1;
//.set
items[_index]:=_value;
end;
//## getsvalue ##
function tdynamicnotifyevent.getsvalue(_index:integer):tnotifyevent;
begin
result:=value[sindex(_index)];
end;
//## setsvalue ##
procedure tdynamicnotifyevent.setsvalue(_index:integer;_value:tnotifyevent);
begin
value[sindex(_index)]:=_value;
end;
//## find ##
function tdynamicnotifyevent.find(_start:integer;_value:tnotifyevent):integer;
var
   p:integer;
begin
try
//defaults
result:=-1;
//check
if (_start<0) or (_start>=count) then exit;
//process
for p:=_start to (icount-1) do if (@iitems[p]=@_value) then
    begin
    result:=p;
    break;
    end;//end of if
except;end;
end;

//######################## tdynamicmsgproc #################################
//## _init ##
procedure tdynamicmsgproc._init;
begin
try
_setparams(0,0,sizeof(tmsgproc),false);
ilockedBPI:=true;
except;end;
end;
//## _corehandle ##
procedure tdynamicmsgproc._corehandle;
begin
iitems:=core;
end;
//## getvalue ##
function tdynamicmsgproc.getvalue(_index:integer):tmsgproc;
begin
//.check
if (_index<0) or (_index>=count) then result:=nil
else result:=items[_index];
end;
//## setvalue ##
procedure tdynamicmsgproc.setvalue(_index:integer;_value:tmsgproc);
begin
//.check
if (_index<0) then exit
else if (_index>=isize) and (not atleast(_index)) then exit;
//.count
if (_index>=icount) then icount:=_index+1;
//.set
items[_index]:=_value;
end;
//## getsvalue ##
function tdynamicmsgproc.getsvalue(_index:integer):tmsgproc;
begin
result:=value[sindex(_index)];
end;
//## setsvalue ##
procedure tdynamicmsgproc.setsvalue(_index:integer;_value:tmsgproc);
begin
value[sindex(_index)]:=_value;
end;
//## find ##
function tdynamicmsgproc.find(_start:integer;_value:tmsgproc):integer;
var
   p:integer;
begin
try
//defaults
result:=-1;
//check
if (_start<0) or (_start>=count) then exit;
//process
for p:=_start to (icount-1) do if (@iitems[p]=@_value) then
    begin
    result:=p;
    break;
    end;//end of if
except;end;
end;

//######################## tdynamicobject ####################################
//## _init ##
procedure tdynamicobject._init;
begin
try
_setparams(0,0,4,false);
ilockedBPI:=true;
except;end;
end;
//## _corehandle ##
procedure tdynamicobject._corehandle;
begin
iitems:=core;
end;
//## getvalue ##
function tdynamicobject.getvalue(_index:integer):tobject;
begin
//.check
if (_index<0) or (_index>=count) then result:=nil
else result:=items[_index];
end;
//## setvalue ##
procedure tdynamicobject.setvalue(_index:integer;_value:tobject);
begin
//.check
if (_index<0) then exit
else if (_index>=isize) and (not atleast(_index)) then exit;
//.count
if (_index>=icount) then icount:=_index+1;
//.set
items[_index]:=_value;
end;
//## getsvalue ##
function tdynamicobject.getsvalue(_index:integer):tobject;
begin
result:=value[sindex(_index)];
end;
//## setsvalue ##
procedure tdynamicobject.setsvalue(_index:integer;_value:tobject);
begin
value[sindex(_index)]:=_value;
end;
//## find ##
function tdynamicobject.find(_start:integer;_value:tobject):integer;
var
   p:integer;
begin
try
//defaults
result:=-1;
//check
if (_start<0) or (_start>=count) then exit;
//process
for p:=_start to (icount-1) do if (iitems[p]=_value) then
    begin
    result:=p;
    break;
    end;//end of if
except;end;
end;
//## new ##
function tdynamicobject.new(obj:tobject):integer;
var
   c,p:integer;
begin
try
//defaults
result:=-1;
//check
if (obj=nil) then exit;
//process
p:=find(0,obj);
if (p=-1) then
   begin
   p:=find(0,nil);
   if (p=-1) then
      begin
      c:=count;
      setparams(c+1,c+1,0);
      p:=c;
      end;//end of if
   //.set
   items[p]:=obj;
   end;//end of if
//return result
result:=p;
except;end;
end;
//## freeValue ##
procedure tdynamicobject.freeValue(p:integer);
var
   a:tobject;
begin
try
if (p>=0) and (p<icount) then
   begin
   a:=value[p];
   if (a<>nil) then
      begin
      value[p]:=nil;
      freeobj(@a);
      end;//end of if
   end;//end of if
except;end;
end;
//## freeValues ##
procedure tdynamicobject.freeValues;
var
   p:integer;
begin
try;for p:=0 to (icount-1) do freeValue(p);except;end;
end;

//######################## tdynamicstring ####################################
//## gettext ##
function tdynamicstring.gettext:string;
var
   p,len:integer;
begin
try
//defaults
result:='';
len:=0;
//process
for p:=0 to (count-1) do pushb(len,result,iitems[p]^+rcode);
//.finalise
pushb(len,result,'');
except;end;
end;
//## settext ##
procedure tdynamicstring.settext(x:string);
var
   tmp:string;
   p:integer;
begin
try
//defaults
p:=1;
//process
//.clear
clear;
//.set
while general.nextline(p,x,tmp) do value[count]:=tmp;
except;end;
end;
//## _init ##
procedure tdynamicstring._init;
begin
try
_setparams(0,0,4,false);
ilockedBPI:=true;
except;end;
end;
//## _corehandle ##
procedure tdynamicstring._corehandle;
begin
iitems:=core;
end;
//## _oncreateitem ##
procedure tdynamicstring._oncreateitem(sender:tobject;index:integer);
begin
try
new(iitems[index]);
inherited;
except;end;
end;
//## _onfreeitem ##
procedure tdynamicstring._onfreeitem(sender:tobject;index:integer);
begin
try
inherited;
dispose(iitems[index]);
except;end;
end;
//## getvalue ##
function tdynamicstring.getvalue(_index:integer):string;
begin
//.check
if (_index<0) or (_index>=count) then result:=''
else result:=items[_index]^;
end;
//## setvalue ##
procedure tdynamicstring.setvalue(_index:integer;_value:string);
begin
//.check
if (_index<0) then exit
else if (_index>=isize) and (not atleast(_index)) then exit;
//.count
if (_index>=icount) then icount:=_index+1;
//.set
items[_index]^:=_value;
end;
//## getsvalue ##
function tdynamicstring.getsvalue(_index:integer):string;
begin
result:=value[sindex(_index)];
end;
//## setsvalue ##
procedure tdynamicstring.setsvalue(_index:integer;_value:string);
begin
value[sindex(_index)]:=_value;
end;
//## find ##
function tdynamicstring.find(_start:integer;_value:string;_casesensitive:boolean):integer;
var
   p:integer;
begin
try
//defaults
result:=-1;
//check
if (_start<0) or (_start>=count) then exit;
//process
if _casesensitive then
   begin
   for p:=_start to (icount-1) do if (comparestr(iitems[p]^,_value)=0) then
         begin
         result:=p;
         break;
         end;//end of if
   end
else
   begin
   for p:=_start to (icount-1) do if (comparetext(iitems[p]^,_value)=0) then
         begin
         result:=p;
         break;
         end;//end of if
   end;//end of if
except;end;
end;
//## _sort ##
procedure tdynamicstring._sort(_asc:boolean);
begin
try;__sort(items,sorted.items,0,count-1,_asc);except;end;
end;
//## __sort ##
procedure tdynamicstring.__sort(a:pdlSTRING;b:pdlINTEGER;l,r:integer;_asc:boolean);
var
  p:pstring;
  tmp,i,j:integer;
begin
try
repeat
I := L;
J := R;
P := a^[b^[(L + R) shr 1]];
  repeat
  if _asc then
     begin
     while (comparetext(a^[b^[I]]^,p^)<0) do inc(I);
     while (comparetext(a^[b^[J]]^,p^)>0) do dec(J);
     end
  else
     begin
     while (comparetext(a^[b^[I]]^,p^)>0) do inc(I);
     while (comparetext(a^[b^[J]]^,p^)<0) do dec(J);
     end;//end of if
  if I <= J then
     begin
     tmp:=b^[i];
     b^[i]:=b^[j];
     b^[j]:=tmp;
     inc(I);
     dec(J);
     end;//end of if
  until I > J;
if L < J then __sort(a,b,L,J,_asc);
L := I;
until I >= R;
except;end;
end;

//######################## tdynamicname ########################################
//## _createsupport ##
procedure tdynamicname._createsupport;
begin
try
//controls
iref:=tdynamiccurrency.create;
except;end;
end;
//## _destroysupport ##
procedure tdynamicname._destroysupport;
begin
try
//controls
freeObj(@iref);
except;end;
end;
//## shift ##
procedure tdynamicname.shift(s,by:integer);
begin
try;inherited shift(s,by);iref.shift(s,by);except;end;
end;
//## _setparams ##
function tdynamicname._setparams(_count,_size,_bpi:integer;_notify:boolean):boolean;
begin
try;result:=(inherited _setparams(_count,_size,_bpi,_notify)) and iref._setparams(_count,_size,_bpi,_notify);except;end;
end;
//## setvalue ##
procedure tdynamicname.setvalue(_index:integer;_value:string);
begin
//.check
if (_index<0) then exit
else if (_index>=isize) and (not atleast(_index)) then exit;
//.count
if (_index>=icount) then icount:=_index+1;
//.set
items[_index]^:=_value;
sync(_index);
end;
//## findfast ##
function tdynamicname.findfast(_start:integer;_value:string):integer;
var
   vREF:currency;
   p:integer;
begin
try
//defaults
result:=-1;
//check
if (_start<0) or (_start>=count) then exit;
//prepare
vREF:=general.ref256U(_value);
//process
p:=_start-1;
while TRUE do
begin
p:=iref.find(p+1,vREF);
if (p=-1) or (p>=size) then break
else if (comparetext(iitems[p]^,_value)=0) then
    begin
    result:=p;
    break;
    end;//end of if
end;//end of loop
except;end;
end;
//## sync ##
procedure tdynamicname.sync(x:integer);
begin
try;iref.value[x]:=general.ref256U(items[x]^);except;end;
end;

//######################## tdynamicnamelist ####################################
//## create ##
constructor tdynamicnamelist.create;
begin
//self
inherited;
//vars
delshrink:=false;
iactive:=0;
end;
//## clear ##
procedure tdynamicnamelist.clear;
begin
try
inherited clear;
iactive:=0;
except;end;
end;
//## add ##
function tdynamicnamelist.add(x:string):integer;
begin
try;result:=addb(x,true);except;end;
end;
//## addb ##
function tdynamicnamelist.addb(x:string;newonly:boolean):integer;
var
   isnewitem:boolean;
begin
try;result:=addex(x,newonly,isnewitem);except;end;
end;
//## addex ##
function tdynamicnamelist.addex(x:string;newonly:boolean;var isnewitem:boolean):integer;
var
   p:integer;
begin
try
//defaults
result:=-1;
isnewitem:=false;
//process
if (x<>'') then
   begin
   //.find
   p:=findfast(0,x);
   if newonly and (p>=0) then exit;
   //.new
   if (p=-1) then
      begin
      p:=findfast(0,'');
      if (p=-1) then p:=count;
      //.set
      value[p]:=x;
      isnewitem:=true;
      inc(iactive);
      end;//end of if
   //successful
   result:=p;
   end;//end of if
except;end;
end;
//## addonce ##
function tdynamicnamelist.addonce(x:string):boolean;
var
   p:integer;
begin
try
//defaults
result:=false;
//process
if (x<>'') and (not have(x)) then
   begin
   p:=findfast(0,'');
   if (p=-1) then p:=count;
   value[p]:=x;
   inc(iactive);
   //successful
   result:=true;
   end;//end of if
except;end;
end;
//## replace ##
function tdynamicnamelist.replace(x,y:string):boolean;//can't prevent duplications if this proc is used
var
   p:integer;
begin
try
//defaults
result:=false;
//process
if (x<>'') and (y<>'') and have(x) then
   begin
   p:=findfast(0,x);
   if (p>=0) then
      begin
      value[p]:=y;
      result:=true;
      end;//end of if
   end;//end of if
except;end;
end;
//## del ##
function tdynamicnamelist.del(x:string):boolean;
var
   p:integer;
begin
try
//defaults
result:=false;
//process
if (x<>'') then
   begin
   p:=findfast(0,x);
   if (p>=0) then
      begin
      if delshrink then (inherited del(p)) else value[p]:='';
      iactive:=frcmin(iactive-1,0);
      result:=true;
      end;//end of if
   end;//end of if
except;end;
end;
//## delindex ##
procedure tdynamicnamelist.delindex(x:integer);//30AUG2007
begin
try;if delshrink then (inherited del(x)) else value[x]:='';except;end;
end;
//## have ##
function tdynamicnamelist.have(x:string):boolean;
begin
try;if (x='') then result:=false else result:=(findfast(0,x)>=0);except;end;
end;

//######################## tdynamicmatrix ######################################
//## create ##
constructor tdynamicmatrix.create;
begin
inherited;
icore:=tdynamicpointer.create;
icore.incsize:=10;
icore.oncreateitem:=_oncreateitem;
icore.onfreeitem:=_onfreeitem;
iwidth:=0;
ibpi:=1;
irowsize:=0;
isize:=0;
setparams(0,0,1);
end;
//## destroy ##
destructor tdynamicmatrix.destroy;
begin
try
//controls
freeObj(@icore);
//self
inherited;
except;end;
end;
//## _oncreateitem ##
procedure tdynamicmatrix._oncreateitem(sender:tobject;index:integer);
begin
try;getmemb(icore.items[index],irowsize);except;end;
end;
//## _onfreeitem ##
procedure tdynamicmatrix._onfreeitem(sender:tobject;index:integer);
begin
try;freemem(icore.items[index]);except;end;
end;
//## clear ##
procedure tdynamicmatrix.clear;
begin
try;setparams(0,0,bpi);except;end;
end;
//## setparams ##
function tdynamicmatrix.setparams(_width,_height,_bpi:integer):boolean;
label
     skipend;
var
   _oldsize,p:integer;
begin
try
//defaults
result:=false;
//enforce range
_oldsize:=iwidth*bpi;
_width:=frcmin(_width,0);
_height:=frcmin(_height,0);
_bpi:=frcmin(_bpi,1);
irowsize:=frcmin(_width*_bpi,1);
//check
if (_width=width) and (_height=height) and (_bpi=bpi) then
   begin
   result:=true;
   exit;
   end;//end of if
//process
//.height / bpi
if (_height<>height) and (not icore.setparams(_height,_height,irowsize)) then goto skipend;
//.width
if (_width<>width) then for p:=0 to (height-1) do reallocmemb(icore.items[p],_oldsize,irowsize);
//.vars
iwidth:=_width;
ibpi:=_bpi;
isize:=width*height*bpi;
//successful
result:=true;
skipend:
except;end;
end;
//## setbpi ##
procedure tdynamicmatrix.setbpi(x:integer);//bytes per item
begin
try;setparams(width,height,x);except;end;
end;
//## setwidth ##
procedure tdynamicmatrix.setwidth(x:integer);
begin
try;setparams(x,height,bpi);except;end;
end;
//## setheight ##
procedure tdynamicmatrix.setheight(x:integer);
begin
try;setparams(width,x,bpi);except;end;
end;
//## getheight ##
function tdynamicmatrix.getheight:integer;
begin
try;result:=icore.count;except;end;
end;
//## getscanline ##
function tdynamicmatrix.getscanline(x:integer):pointer;
begin
if (x<0) or (x>=height) then result:=nil else result:=icore.items[x];
end;

//##################### tdynamicbitmap #########################################
//## create ##
constructor tdynamicbitmap.create;
begin
//self
inherited;
setparams(0,0,3);
end;
//## getpixel ##
function tdynamicbitmap.getpixel(_x,_y:integer):integer;
var
   a:tint4;
   b:prgbcolor;
begin
a.val:=0;
b:=@prgbcolorrow(core.items[_y])[_x];
a.r:=b.r;
a.g:=b.g;
a.b:=b.b;
result:=a.val;
end;
//## setpixel ##
procedure tdynamicbitmap.setpixel(_x,_y,_c:integer);
var
   a:tint4;
   b:prgbcolor;
begin
a.val:=_c;
b:=@prgbcolorrow(core.items[_y])[_x];
b.r:=a.r;
b.g:=a.g;
b.b:=a.b;
end;
//## pushto ##
function tdynamicbitmap.pushto(a:tobject;dx,dy:integer;var e:string):boolean;
label
     skipend;
var
   r1,r2:prgbcolorrow;
   c:trgbcolor;
   _bmp:tbitmap;
   _bbm:tdynamicbitmap;
   w,h,dw,dh,_x,_y,x,y,maxx,maxy:integer;
begin
try
//defaults
result:=false;
e:=gecUnsupportedFormat;
_bmp:=nil;
_bbm:=nil;
//prepare
w:=width;
h:=height;
if (a is tbitmap) then
   begin
   with a as tbitmap do
   begin
   _bmp:=a as tbitmap;
   dw:=width;
   dh:=height;
   if (pixelformat<>pf24bit) then goto skipend;
   end;
   end
else if (a is tdynamicbitmap) then
   begin
   with a as tdynamicbitmap do
   begin
   _bbm:=a as tdynamicbitmap;
   dw:=width;
   dh:=height;
   end;
   end
else exit;
if (w=0) or (h=0) or (dw=0) or (dh=0) then exit;
//process
//.tbitmap
if (_bmp<>nil) then
   begin
   for y:=0 to (h-1) do
   begin
   _y:=dy+y;
   if (_y>=0) and (_y<dh) then
      begin
      r1:=scanline[y];
      r2:=_bmp.scanline[_y];
      for x:=0 to (w-1) do
      begin
      _x:=dx+x;
      if (_x>=0) and (_x<dw) then r2[_x]:=r1[x];
      end;//end of loop
      end;//end of if
   end;//end of loop
   end
//.tbbm
else if (_bbm<>nil) then
   begin
   //.set
   for y:=0 to (h-1) do
   begin
   _y:=dy+y;
   if (_y>=0) and (_y<dh) then
      begin
      r1:=scanline[y];
      r2:=_bbm.scanline[_y];
      for x:=0 to (w-1) do
      begin
      _x:=dx+x;
      if (_x>=0) and (_x<dw) then r2[_x]:=r1[x];
      end;//end of loop
      end;//end of if
   end;//end of loop
   end;//end of if
//successful
result:=true;
skipend:
except;end;
end;
//## copyfrom ##
function tdynamicbitmap.copyfrom(a:tobject;var e:string):boolean;
label
     skipend;
var
   r1,r2:prgbcolorrow;
   c:trgbcolor;
   _bmp:tbitmap;
   _bbm:tdynamicbitmap;
   _bmpFREE:boolean;
   p,x,y,w,h:integer;
begin
try
//defaults
result:=false;
e:=gecUnsupportedFormat;
_bmpFREE:=false;
_bmp:=nil;
_bbm:=nil;
//prepare
if (a is tbitmap) then
   begin
   with a as tbitmap do
   begin
   _bmp:=a as tbitmap;
   w:=width;
   h:=height;
   //.check
   if (pixelformat<>pf24bit) then goto skipend;
   end;
   end
else if (a is tpicture) then
   begin
   _bmpFREE:=true;
   _bmp:=tbitmap.create;
   _bmp.width:=frcmin((a as tpicture).width,1);
   _bmp.height:=frcmin((a as tpicture).height,1);
   _bmp.pixelformat:=pf24bit;
   _bmp.canvas.draw(0,0,(a as tpicture).graphic);
   w:=_bmp.width;
   h:=_bmp.height;
   end
else if (a is tdynamicbitmap) then
   begin
   with a as tdynamicbitmap do
   begin
   _bbm:=a as tdynamicbitmap;
   w:=width;
   h:=height;
   end;
   end
else exit;
//process
e:=gecOutOfMemory;
//.BITMAP
if (_bmp<>nil) then
   begin
   //.size
   if not setparams(w,h,bpi) then goto skipend;
   //.copy
   for y:=0 to (h-1) do
   begin
   r1:=scanline[y];
   r2:=_bmp.scanline[y];
   for x:=0 to (w-1) do
   begin
   c:=r2[x];
   r1[x]:=c;
   end;//end of loop
   end;//end of loop
   end
//.BBM
else if (_bbm<>nil) then
   begin
   //.size
   if not setparams(w,h,bpi) then goto skipend;
   //.copy
   for y:=0 to (h-1) do
   begin
   r1:=scanline[y];
   r2:=_bbm.scanline[y];
   for x:=0 to (w-1) do
   begin
   c:=r2[x];
   r1[x]:=c;
   end;//end of loop
   end;//end of loop
   end;//end of if
//successful
result:=true;
skipend:
except;end;
try;if _bmpFREE then freeObj(@_bmp);except;end;
end;
//## flush ##
procedure tdynamicbitmap.flush;
var
   r:PRGBColorRow;
   maxx,y,x:integer;
begin
try
//prepare
maxx:=width-1;
//process
for y:=0 to (height-1) do
begin
 r:=getscanline(y);
 for x:=0 to maxx do r[x]:=cl_white;
end;//end of loop
except;end;
end;

//############################## tdynamicvars ##################################
//## create ##
constructor tdynamicvars.create;
begin
inherited;
//controls
inamesREF:=tdynamiccurrency.create;
inames:=tdynamicstring.create;
ivalues:=tdynamicstring.create;
//.incsize
incsize:=10;
end;
//## destroy ##
destructor tdynamicvars.destroy;
begin
try
//controls
freeObj(@inamesREF);
freeObj(@inames);
freeObj(@ivalues);
//self
inherited;
except;end;
end;
//## roll ##
procedure tdynamicvars.roll(x:string;by:currency);
var
   a:currency;
begin
try
a:=c[x];
general.croll(a,by);
c[x]:=a;
except;end;
end;
//## getb ##
function tdynamicvars.getb(x:string):boolean;
begin
try;result:=(i[x]<>0);except;end;
end;
//## setb ##
procedure tdynamicvars.setb(x:string;y:boolean);
begin
try;c[x]:=integer(y);except;end;
end;
//## getd ##
function tdynamicvars.getd(x:string):double;
begin
try;result:=strtofloatex(value[x]);except;end;
end;
//## setd ##
procedure tdynamicvars.setd(x:string;y:double);
begin
try;value[x]:=floattostrex2(y);except;end;
end;
//## getnc ##
function tdynamicvars.getnc(x:string):currency;
var
   tmp:string;
begin
try
tmp:=value[x];
general.swapstrs(tmp,',','');
result:=strtofloatex(tmp);
except;end;
end;
//## getc ##
function tdynamicvars.getc(x:string):currency;
begin
try;result:=strtofloatex(value[x]);except;end;
end;
//## setc ##
procedure tdynamicvars.setc(x:string;y:currency);
begin
try;value[x]:=floattostrex2(y);except;end;
end;
//## getni ##
function tdynamicvars.getni(x:string):integer;
var
   tmp:string;
begin
try
tmp:=value[x];
general.swapstrs(tmp,',','');
result:=strint(tmp);
except;end;
end;
//## geti ##
function tdynamicvars.geti(x:string):integer;
begin
try;result:=strint(value[x]);except;end;
end;
//## seti ##
procedure tdynamicvars.seti(x:string;y:integer);
begin
try;c[x]:=y;except;end;
end;
//## copyfrom ##
procedure tdynamicvars.copyfrom(x:tdynamicvars);
var
   p:integer;
begin
try;for p:=0 to (x.count-1) do value[x.name[p]]:=x.valuei[p];except;end;
end;
//## copyvars ##
procedure tdynamicvars.copyvars(x:tdynamicvars;i,e:string);
var//y=include filter
   p:integer;
begin
try;for p:=0 to (x.count-1) do if general.indf(x.name[p],i,e) then value[x.name[p]]:=x.valuei[p];except;end;
end;
//## getincsize ##
function tdynamicvars.getincsize:integer;
begin
try;result:=inames.incsize;except;end;
end;
//## setincsize ##
procedure tdynamicvars.setincsize(x:integer);
begin
try
x:=frcmin(x,1);
inamesREF.incsize:=x;
inames.incsize:=x;
ivalues.incsize:=x;
except;end;
end;
//## getnettext ##
function tdynamicvars.getnettext:string;
var
   z,tmp:string;
   len,p:integer;
begin
try
//defaults
result:='';
z:='';
len:=0;
//process
for p:=0 to (count-1) do
begin
//.name
tmp:=lowercase(inames.items[p]^);
net_encode_str(tmp);
pushb(len,result,z+tmp+'=');
//.value
tmp:=ivalues.items[p]^;
net_encode_str(tmp);
pushb(len,result,tmp);
//.other
if (z='') then z:='&';
end;//end of loop
//.finalise
pushb(len,result,'');
except;end;
end;
//## setnettext ##
procedure tdynamicvars.setnettext(x:string);
var
   c:char;
   _name,tmp:string;
   xLEN,o,s,p:integer;
begin
try
//prepare
xLEN:=length(x);
s:=1;
c:='=';
tmp:='';
_name:='';
//process
//.clear
clear;
//.get
for p:=1 to xLEN do if (x[p]=c) or (p=xLEN) then
    begin
    //.get
    if (x[p]=c) then o:=0 else o:=1;
    tmp:=copy(x,s,p-s+o);
    s:=p+1;
    //.set
    if (c='=') then
       begin
       net_decode_str(tmp);
       _name:=tmp;
       c:='&';
       end
    else
        begin
        //.set
        if storerawvalue then value[_name+'_raw']:=tmp;//28FEB2008
        net_decode_str(tmp);
        value[_name]:=tmp;
        //.reset
        _name:='';
        c:='=';
        end;//end of if
    end;//end of if
except;end;
end;
//## setmultipart ##
procedure tdynamicvars.setmultipart(h:string;x:string);//26-MAY-2006
label//Now supports "name-filename" parameter
   skipend;
const
   sNil=0;
   sHeader=1;
   sContent=2;
var
   fn,b,n,tmp,bs,be:string;
   maxp,vs,ve,bsLEN,beLEN,stage,_pos,_start,_length,i3,i2,i,p,xlen:integer;
begin
try
//defaults
xlen:=length(x);
//check
if not ns.multipart(h,b) then
   begin
   nettext:=x;
   exit;
   end;//end of if
//setup
bs:='--'+b;
be:='--'+b+'--';
bslen:=length(bs);
belen:=length(be);
n:='';
fn:='';
_pos:=1;
stage:=sNil;
vs:=1;
ve:=0;
//process
while general.readline(_pos,_start,_length,x) do
begin
if (stage=sNil) then
   begin
   if (bsLEN=_length) and (bs=copy(x,_start,_length)) then stage:=sHeader;
   end
else if (stage=sHeader) then
   begin
   if (_length=0) then
      begin
      stage:=sContent;
      vs:=_pos;
      end
   else if (n='') then
      begin
      n:='';
      fn:='';
      maxp:=_start+_length-1;
      //.name
      for p:=_start to (maxp-5) do if (0=comparetext(copy(x,p,6),'name="')) then
         begin
         for i:=(p+6) to maxp do if (x[i]='"') then
            begin
            n:=copy(x,p+6,i-p-6);
            //.filename
            for i2:=(i+1) to maxp do if (0=comparetext(copy(x,i2,10),'filename="')) then
               begin
               for i3:=(i2+10) to maxp do if (x[i3]='"') then
                  begin
                  fn:=copy(x,i2+10,i3-i2-10);
                  break;
                  end;//end of if
               break;
               end;//end of if
            break;
            end;//end of if
         break;
         end;//end of if
      //.no name
      if (n='') then goto skipend;
      end;//end of if
   end
else if (stage=sContent) then
   begin
   if
     ((bsLEN=_length) and (bs=copy(x,_start,_length))) or
     ((beLEN=_length) and (be=copy(x,_start,_length))) then
      begin
      //.set
      value[n]:=copy(x,vs,ve-vs+1);
      if (fn<>'') then value[n+'-filename']:=fn;
      //.reset
      n:='';
      fn:='';
      vs:=1;
      ve:=0;
      stage:=sHeader;
      //.quit
      if (be=copy(x,_start,_length)) then break;
      end
   else ve:=_start+_length-1;
   end;//end of if
end;//end of loop
skipend:
except;end;
end;
//## pull ##
function tdynamicvars.pull(hdr:string;var data,e:string):boolean;
label
     skipend;
var
   a:tnv;
   p:integer;
begin
try
//defaults
result:=false;
data:='';
e:=gecOutOfMemory;
//prepare
a:=newnv;
a.data:=@data;
if not a.initwrite(hdr,e) then goto skipend;
//process
//.get
for p:=0 to (count-1) do if not a.write(lowercase(inames.items[p]^),ivalues.items[p]^,e) then goto skipend;
//.finalise
if not a.writeb('','',e) then goto skipend;
//successful
result:=true;
skipend:
except;end;
try;freeObj(@a);except;end;
end;
//## push ##
function tdynamicvars.push(hdr:string;var data,e:string;append:boolean):boolean;
label
     skipend;
var
   a:tnv;
   p:integer;
   n,v:string;
begin
try
//defaults
result:=false;
e:=gecOutOfMemory;
//prepare
a:=newnv;
a.data:=@data;
if not a.initread(hdr,e) then goto skipend;
//process
//.clear
if not append then clear;
//.loop
while a.canread do
begin
//.get
if not a.read(n,v,e) then goto skipend;
//.set
if (n<>'') then
   begin
   value[n]:=v;
   end;//end of if
end;//end of with
//successful
result:=true;
skipend:
except;end;
try;freeObj(@a);except;end;
end;
//## savetofile ##
function tdynamicvars.savetofile(x,hdr:string;var e:string):boolean;
var
   z:string;
begin
try
//defaults
result:=false;
e:=gecOutOfMemory;
z:='';
//process
result:=pull(hdr,z,e) and io.toFILE(x,z,e);
except;end;
end;
//## loadfromfile ##
function tdynamicvars.loadfromfile(x,hdr:string;var e:string;append:boolean):boolean;
var
   z:string;
begin
try
//defaults
result:=false;
e:=gecOutOfMemory;
z:='';
//process
result:=io.fromFILE(x,z,e) and push(hdr,z,e,append);
except;end;
end;
//## getcount ##
function tdynamicvars.getcount:integer;
begin
try;result:=inames.count;except;end;
end;
//## new ##
function tdynamicvars.new(n,v:string):integer;
begin
try;result:=_find(n,v,true);except;end;
end;
//## find ##
function tdynamicvars.find(n:string):integer;
begin
try;result:=_find(n,'',false);except;end;
end;
//## found ##
function tdynamicvars.found(n:string):boolean;
var
   i:integer;
begin
try;result:=foundb(n,i);except;end;
end;
//## foundb ##
function tdynamicvars.foundb(n:string;var i:integer):boolean;
begin
try;i:=find(n);result:=(i>=0);except;end;
end;
//## _find ##
function tdynamicvars._find(n,v:string;_newedit:boolean):integer;
var
   i:integer;
   nREF:currency;
begin
try
//defaults
result:=-1;
if (n='') then exit;
//prepare
n:=uppercase(n);
nREF:=general.ref256(n);
//process
//.get
i:=0;
repeat
i:=inamesREF.find(i,nREF);
if (i<>-1) and (0=comparetext(inames.items[i]^,n)) then
   begin
   result:=i;
   break;
   end;//end of if
if (i<>-1) then inc(i);
until (i=-1);
//.new/edit
if _newedit then
    begin
    if (result=-1) then
       begin
       //.new empty
       result:=inamesREF.find(0,0);
       //.new
       if (result=-1) then result:=inamesREF.count;
       end;//end of if
    inamesREF.value[result]:=nREF;
    inames.value[result]:=n;
    ivalues.value[result]:=v;
    end;//end of if
except;end;
end;
//## delete ##
procedure tdynamicvars.delete(x:integer);
begin
try
if (x>=0) and (x<count) then
   begin
   inamesREF.value[x]:=0;
   inames.value[x]:='';
   ivalues.value[x]:='';
   end;//end of if
except;end;
end;
//## getname ##
function tdynamicvars.getname(x:integer):string;
begin
try;if (x<0) or (x>=inames.count) then result:='' else result:=inames.value[x];except;end;
end;
//## getvaluei ##
function tdynamicvars.getvaluei(x:integer):string;
begin
try;if (x<0) or (x>=inames.count) then result:='' else result:=ivalues.value[x];except;end;
end;
//## getvalueiptr ##
function tdynamicvars.getvalueiptr(x:integer):pstring;
begin
try;if (x<0) or (x>=inames.count) then result:=nil else result:=ivalues.items[x];except;end;
end;
//## getvalue ##
function tdynamicvars.getvalue(n:string):string;
var
   p:integer;
begin
try
//.get
p:=_find(n,'',false);
if (p=-1) then
   begin
   result:='';
   if debug then showerror60(debugtitle+' - '+ntranslate(gecNotFound)+' "'+n+': "');
   end
else result:=ivalues.value[p];
except;end;
end;
//## setvalue ##
procedure tdynamicvars.setvalue(n,v:string);
begin
try;_find(n,v,true);except;end;
end;
//## clear ##
procedure tdynamicvars.clear;
begin
try
inamesREF.clear;
inames.clear;
ivalues.clear;
except;end;
end;

//######################### tdynamictext #######################################
//## create ##
constructor tdynamictext.create;
begin
//controls
ivars:=tdynamicvars.create;
end;
//## destroy ##
destructor tdynamictext.destroy;
begin
try
//controls
freeObj(@ivars);
//self
inherited;
except;end;
end;
//## savetofile ##
function tdynamictext.savetofile(x:string;var e:string):boolean;
var
   z:string;
begin
try
//defaults
result:=false;
e:=gecOutOfMemory;
//process
//.get
z:=text;
//.set
result:=io.tofile(x,z,e);
except;end;
end;
//## loadfromfile ##
function tdynamictext.loadfromfile(x:string;var e:string):boolean;
var
   z:string;
begin
try
//defaults
result:=false;
e:=gecOutOfMemory;
//process
//.clear
clear;
//.set
if io.fromfile(x,z,e) then
   begin
   text:=z;
   result:=true;
   end;//end of if
except;end;
end;
//## getvalue ##
function tdynamictext.getvalue(x:string):string;
begin
try;result:=ivars.value[x];except;end;
end;
//## setvalue ##
procedure tdynamictext.setvalue(x,y:string);
begin
try;ivars.value[x]:=y;except;end;
end;
//## getc ##
function tdynamictext.getc(x:string):currency;
begin
try;result:=ivars.c[x];except;end;
end;
//## setc ##
procedure tdynamictext.setc(x:string;y:currency);
begin
try;ivars.c[x]:=y;except;end;
end;
//## getd ##
function tdynamictext.getd(x:string):double;
begin
try;result:=ivars.d[x];except;end;
end;
//## setd ##
procedure tdynamictext.setd(x:string;y:double);
begin
try;ivars.d[x]:=y;except;end;
end;
//## geti ##
function tdynamictext.geti(x:string):integer;
begin
try;result:=ivars.i[x];except;end;
end;
//## seti ##
procedure tdynamictext.seti(x:string;y:integer);
begin
try;ivars.i[x]:=y;except;end;
end;
//## getb ##
function tdynamictext.getb(x:string):boolean;
begin
try;result:=ivars.b[x];except;end;
end;
//## setb ##
procedure tdynamictext.setb(x:string;y:boolean);
begin
try;ivars.b[x]:=y;except;end;
end;
//## gettext ##
function tdynamictext.gettext:string;
var
   tmp:string;
   len,i,p:integer;
begin
try
//defaults
result:='';
len:=0;
//process
//.get
for p:=0 to (ivars.count-1) do if (ivars.name[p]<>'') then
   begin
   pushb(len,result,ivars.name[p]+': '+general.firstline(ivars.valueiptr[p]^)+rcode);
   end;//end of if
//.finalise
pushb(len,result,'');
except;end;
end;
//## settext ##
procedure tdynamictext.settext(x:string);
begin
try;addb(x,true);except;end;
end;
//## add ##
procedure tdynamictext.add(x:string);
begin
try;addb(x,false);except;end;
end;
//## addb ##
procedure tdynamictext.addb(x:string;_clear:boolean);
var
   p,_pos,_start,_length:integer;
begin
try
//clear
if _clear then ivars.clear;
//process
_pos:=1;
while general.readline(_pos,_start,_length,x) do
begin
p:=_start;
if general.findtextL(p,p+_length-1,x,': ') then ivars.value[copy(x,_start,p-_start)]:=copy(x,p+2,_length-(p-_start)-2);
end;//end of loop
except;end;
end;
//## setnettext ##
procedure tdynamictext.setnettext(x:string);
begin
try;ivars.nettext:=x;except;end;
end;
//## getnettext ##
function tdynamictext.getnettext:string;
begin
try;result:=ivars.nettext;except;end;
end;
//## setmultipart ##
procedure tdynamictext.setmultipart(h:string;x:string);
begin
try;ivars.multipart[h]:=x;except;end;
end;
//## clear ##
procedure tdynamictext.clear;
begin
try;ivars.clear;except;end;
end;

//## tqueuestring ##############################################################
//## create ##
constructor tqueuestring.create;
begin
//self
inherited;
//controls
istate:=tdynamicbyte.create;
idata:=tdynamicstring.create;
itag:=tdynamicinteger.create;
iip:=tdynamicinteger.create;
iport:=tdynamicword.create;
end;
//## destroy ##
destructor tqueuestring.destroy;
begin
try
//controls
freeobj(@istate);
freeobj(@idata);
freeobj(@itag);
freeobj(@iip);
freeobj(@iport);
//self
inherited;
except;end;
end;
//## canclear ##
function tqueuestring.canclear:boolean;
begin
try;result:=(iactive>=1);except;end;
end;
//## clear ##
procedure tqueuestring.clear;
var
   p:integer;
begin
try
//check
if not canclear then exit;
//get
for p:=0 to (isize-1) do
begin
itag.items[p]:=0;
iport.items[p]:=0;
iip.items[p]:=0;
idata.items[p]^:='';
istate.items[p]:=0;//free
end;//end of loop
//active
syncactive;
except;end;
end;
//## syncactive ##
procedure tqueuestring.syncactive;
var
   p,c:integer;
begin
try
c:=0;
for p:=0 to (isize-1) do if (istate.items[p]<>0) then inc(c);
iactive:=c;
except;end;
end;
//## setsize ##
procedure tqueuestring.setsize(x:integer);
begin
try
//range
x:=frcmin(x,10);
//set
if (x<>size) then
   begin
   istate.setparams(x,x,x);
   idata.setparams(x,x,x);
   iip.setparams(x,x,x);
   iport.setparams(x,x,x);
   itag.setparams(x,x,x);
   isize:=istate.size;
   //active
   syncactive;
   end;//end of if
except;end;
end;
//## canpush ##
function tqueuestring.canpush:boolean;
begin
try;result:=(iactive<isize);except;end;
end;
//## push ##
function tqueuestring.push(_data:string):boolean;
begin
try;result:=pushex(_data,0,0,0);except;end;
end;
//## pushex ##
function tqueuestring.pushex(_data:string;_ip:integer;_port:word;_tag:integer):boolean;
var
   p,i:integer;
begin
try
//defaults
result:=false;
//check
if not canpush then exit;
//scan
i:=ipushpos;
for p:=0 to (isize-1) do
begin
//range
if (i<0) then i:=0
else if (i>=isize) then i:=0;
//get
if (istate.items[i]=0) then
   begin
   //set
   istate.items[i]:=1;//hold
   idata.items[i]^:=_data;
   iip.items[i]:=_ip;
   iport.items[i]:=_port;
   itag.items[i]:=_tag;
   istate.items[i]:=2;//inuse
   inc(iactive);
   //quit
   break;
   end;//end of if
//inc
inc(i);
end;//end of loop
//set
ipushpos:=i;
//successful
result:=true;
except;end;
end;
//## canpull ##
function tqueuestring.canpull:boolean;
begin
try;result:=(iactive>=1);except;end;
end;
//## pull ##
function tqueuestring.pull(var _data:string):boolean;
var
   _ip,_tag:integer;
   _port:word;
begin
try;result:=pullex(_data,_ip,_port,_tag);except;end;
end;
//## pullex ##
function tqueuestring.pullex(var _data:string;var _ip:integer;var _port:word;var _tag:integer):boolean;
var
   p,i:integer;
begin
try
//defaults
result:=false;
_data:='';
_ip:=0;
_port:=0;
_tag:=0;
//check
if not canpull then exit;
//scan
i:=ipullpos;
for p:=0 to (isize-1) do
begin
//range
if (i<0) then i:=0
else if (i>=isize) then i:=0;
//get
if (istate.items[i]=2) then//0=free,1=hold,2=inuse
   begin
   //lock
   istate.items[i]:=1;//hold
   //get
   _data:=idata.items[i]^;
   _ip:=iip.items[i];
   _port:=iport.items[i];
   _tag:=itag.items[i];
   //clear
   idata.items[i]^:='';
   iip.items[i]:=0;
   iport.items[i]:=0;
   itag.items[i]:=0;
   //free
   istate.items[i]:=0;
   //dec
   iactive:=frcmin(iactive-1,0);
   //quit
   break;
   end;//end of if
//inc
inc(i);
end;//end of loop
//set
ipullpos:=i;
//successful
result:=true;
except;end;
end;

//## tcachebasic ###############################################################
//## create ##
constructor tcachebasic.create(_bpi:integer);
begin
//defaults
title:='Untitled';
ibytesDISK:=0;
ibytesRAM:=0;
itimeout:=30;//30 minutes
//ihead
iheadsize:=sizeof(tcachehead);//stores header, ipullindex and ipushindex
//bpi
ibpi:=frcmin(_bpi,1);
if (ibpi>sizeof(tcachebuffer)) then
   begin
   showerror60('Size exceeds buffer');
   siHalt;
   end;//end of if
//vars
ifile:=nil;
ilimit:=(maxint-iheadsize) div ibpi;
istatus:=chsOffline;
fillchar(iemptybuffer,sizeof(tcachebuffer),0);
//mini
iid:=nil;
idata:=nil;
//support
_createsupport;
//defaults
_dimTIMEOUT;
//timer - once every 30sec (very slow interval)
itimer:=mt.new(_ontimer,30*1000,true);
end;
//## destroy ##
destructor tcachebasic.destroy;
begin
try
//timer
mt.del(itimer);
//close
filename:='';
//support
_destroysupport;
//controls
freeobj(@ifile);
freeobj(@iid);
freeobj(@idata);
//self
inherited;
except;end;
end;
//## _createsupport ##
procedure tcachebasic._createsupport;
begin
//nil
end;
//## _destroysupport ##
procedure tcachebasic._destroysupport;
begin
//nil
end;
//## getactive ##
function tcachebasic.getactive:integer;
begin
try;result:=iactive;except;end;
end;
//## _ontimer ##
procedure tcachebasic._ontimer(sender:tobject);
begin
try
//check
if (sysstate>=ssClosed) then exit;
//process
//.head
if iopen and iheadchanged and writehead then iheadchanged:=false;
//._dimTIMEOUT
_dimTIMEOUT;
except;end;
end;
//## settimeout ##
procedure tcachebasic.settimeout(x:integer);
begin//1..X minutes
try;if general.setint(frcmin(x,1),itimeout) then _dimTIMEOUT;except;end;
end;
//## _dimTIMEOUT ##
procedure tcachebasic._dimTIMEOUT;
begin
try;itimeoutDIM:=getDIM-itimeout;except;end;
end;
//## ioclear ##
procedure tcachebasic.ioclear;
var
   p:integer;
begin
try;if (iid<>nil) then for p:=(iid.size-1) downto 0 do iid.items[p]:=-1;except;end;
end;
//## ioclearitem ##
procedure tcachebasic.ioclearitem(x:integer);
var
   y:integer;
begin
try;if (iid<>nil) and iofind(x,y) then iid.items[y]:=-1;except;end;
end;
//## iofind ##
function tcachebasic.iofind(x:integer;var y:integer):boolean;
var
   maxp,p:integer;
begin
try
//defaults
result:=false;
y:=-1;
//check
maxp:=iosize-1;
if (iid=nil) or (maxp<0) then exit;
p:=0;
//process
repeat//faster loop (for..do..end=130ms, repeat..until=8ms for cache of 1,000 items)
//.find
if (x=iid.items[p]) then
   begin
   y:=p;
   result:=true;
   break;
   end;//end of if
//.inc
inc(p);
until (p>maxp);
except;end;
end;
//## ioread ##
function tcachebasic.ioread(x:integer;var rec):boolean;
var
   pp:pointer;
   y:integer;
begin
try
//defaults
result:=false;
//process
if (iid<>nil) and iofind(x,y) then
   begin
   pp:=pointer(y*ibpi+longint(idata.core));
   move(pp^,rec,ibpi);
   result:=true;
   end;//end of if
except;end;
end;
//## iowrite ##
function tcachebasic.iowrite(x:integer;var rec):boolean;
var
   pp:pointer;
   y:integer;
begin
try
//defaults
result:=false;
//process
if (iid<>nil) then
   begin
   //.existing/new
   if not iofind(x,y) then roll(iioindex,y,iosize);
   //.set
   pp:=pointer(y*ibpi+longint(idata.core));
   move(rec,pp^,ibpi);
   iid.items[y]:=x;
   //successful
   result:=true;
   end;//end of if
except;end;
end;
//## getiosize ##
function tcachebasic.getiosize:integer;
begin
try;if (iid=nil) then result:=0 else result:=iid.size;except;end;
end;
//## setiosize ##
procedure tcachebasic.setiosize(x:integer);
label
   redo;
var
   p:integer;
   ok:boolean;
begin
try
//range
x:=frcrange(x,0,ilimit);
//process
redo:
if (x=0) then
   begin
   //.destroy
   if (iid<>nil) then
      begin
      freeobj(@iid);
      freeobj(@idata);
      end;//end of if
   end
else
   begin
   ok:=true;
   try
   //.create
   if (iid=nil) then
      begin
      iid:=tdynamicinteger.create;
      idata:=tdynamicbyte.create;
      end;//end of if
   //.size
   idata.setparams(x*ibpi,x*ibpi,0);
   iid.setparams(x,x,0);
   //.ioclear
   ioclear;
   except;ok:=false;end;
   //.error - out of memory
   if not ok then
      begin
      x:=0;
      goto redo;
      end;//end of if
   end;//end of if
except;end;
end;
//## setfilename ##
procedure tcachebasic.setfilename(x:string);
begin
try
//check
if (0=comparetext(x,ifilename)) then exit;
//process
//HEAD - write head before closing
if iopen and iheadchanged then writehead;
//CLOSE
if (size<>0) then size:=0;//clear RAM usage
istatus:=chsOffline;
iopen:=false;
ifilename:='';
ipullindex:=0;
ipushindex:=0;
ibytesDISK:=0;
ibytesRAM:=0;
iheadchanged:=false;
freeobj(@ifile);
//.ioclear
ioclear;
//OPEN
if (x<>'') then
   begin
   //.create
   createfile(x);
   //.open
   ifile:=tfilestream.create(x,fmOpenReadWrite+fmShareDenyWrite);//open
   //.header
   if (ifile.size<iheadsize) then writehead else readhead;
   ibytesDISK:=iheadsize;
   //.vars
   ifilename:=x;
   iopen:=true;
   istatus:=chsOK;
   end;//end of if
except;end;
end;
//## setsize ##
procedure tcachebasic.setsize(x:integer);
var
   c,p,oldsize:integer;
   ok:boolean;
begin
try
//check
if not iopen then exit;
//range
x:=frcrange(x,0,ilimit);
//set
if (x<>isize) then
   begin
   //.oldsize
   oldsize:=isize;
   //.sync
   ok:=true;
   if (not sizeDISK(x)) then
      begin
      ok:=false;
      istatus:=chsOutOfDISK;
      end;//end of if
   if ok and (not sizeRAM(x)) then
      begin
      ok:=false;
      istatus:=chsOutOfRAM;
      end;//end of if
   if not ok then
      begin
      x:=0;
      sizeDISK(x);
      sizeRAM(x);
      end;//end o fif
   //.set
   isize:=x;
   //.read extra items
   c:=0;
   if (isize>oldsize) then for p:=oldsize to (isize-1) do
      begin
      readitem(p);
      //.beep
      inc(c);
      if (c>=10000) then//every 10K items
         begin
         c:=0;
         //.audio notification
         if beeponload then general.shortbeep(1);
         //.update system
         application.processmessages;
         end;//end of if
      end;//end of loop
   //.active
   activeSYNC;
   //.ok
   if ok then istatus:=chsOK;
   //.info
   ibytesDISK:=iheadsize+(isize*ibpi);
   ibytesRAM:=isize*bpiRAM;
   end;//end of if
except;end;
end;
//## activeSYNC ##
function tcachebasic.activeSYNC:integer;
var
   p:integer;
begin
try
//defaults
result:=0;
//get
if iopen then for p:=0 to (isize-1) do if inuse[p] then inc(result);
//set
iactive:=result;
except;end;
end;
//## activeinc ##
procedure tcachebasic.activeinc(up:boolean);
begin
try;iactive:=frcrange(iactive+general.aorb(-1,1,up),0,isize);except;end;
end;
//## sizeDISK ##
function tcachebasic.sizeDISK(x:integer):boolean;
label
   skipend;
var//x = number of records
   dfs:integer;
begin
try
//defaults
result:=false;
//check
if not iopen then exit;
//setup
//.dfs
dfs:=iheadsize+(x*ibpi);
//.destination size is equal/smaller than current
if (dfs<=ifile.size) then
   begin
   result:=true;
   goto skipend;
   end;//end of if
//process
//.seek - to nearest record
ifile.position:=iheadsize+((frcmin(ifile.size-iheadsize,0)) div ibpi)*ibpi;
//.enlarge & fill with blanks
while true do
begin
if (ifile.size>=dfs) then break
else if (ibpi<>ifile.write(iemptybuffer,ibpi)) then goto skipend;
end;//end of loop
//successful
result:=true;
skipend:
except;end;
end;
//## bpiRAM ##
function tcachebasic.bpiRAM:integer;
begin
try;result:=0;except;end;
end;
//## sizeRAM ##
function tcachebasic.sizeRAM(x:integer):boolean;
begin
try;result:=true;except;end;
end;
//## fromRAM ##
function tcachebasic.fromRAM(x:integer;var rec):boolean;
begin
try;result:=true;fillchar(rec,ibpi,0);except;end;
end;
//## toRAM ##
function tcachebasic.toRAM(x:integer;var rec):boolean;
begin
try;result:=true;except;end;
end;
//## valid ##
function tcachebasic.valid(x:integer):boolean;
begin
try;result:=(x>=0) and (x<isize);except;end;
end;
//## getinuse ##
function tcachebasic.getinuse(x:integer):boolean;
begin
try;result:=iopen;except;end;
end;
//## setinuse ##
procedure tcachebasic.setinuse(x:integer;y:boolean);
begin
try;{nil}except;end;
end;
//## readitem ##
function tcachebasic.readitem(x:integer):boolean;
var
   a:tcachebuffer;
begin
try;result:=iopen and valid(x) and read(x,a) and toRAM(x,a);except;end;
end;
//## readhead ##
function tcachebasic.readhead:boolean;
var
   tmp:tcachehead;
begin
try
//defaults
result:=false;
//process
if (ifile<>nil) then
   begin
   //.set
   ifile.position:=0;
   if (iheadsize=ifile.read(tmp,iheadsize)) and (string(tmp.ver)='CACH') then
      begin
      ipullindex:=frcmin(tmp.pullindex,0);
      ipushindex:=frcmin(tmp.pushindex,0);
      iheadchanged:=false;
      end;//end of if
   end;//end of if
except;end;
end;
//## read ##
function tcachebasic.read(x:integer;var rec):boolean;
begin//Note: "rec" should point to a "fixed, non-dynamic" record structure (ie. no "string")
try
//defaults
result:=false;
//process
//.set
if iopen and valid(x) then
   begin
   //.iocache
   if (iid=nil) or (not ioread(x,rec)) then
      begin
      //.position
      ifile.position:=iheadsize+(x*ibpi);
      //.get
      result:=(ibpi=ifile.read(rec,ibpi));
      //.set
      if (iid<>nil) then iowrite(x,rec);
      end;//end of if
   end;//end of if
except;end;
end;
//## writeitem ##
function tcachebasic.writeitem(x:integer):boolean;
var
   a:tcachebuffer;
begin
try;result:=iopen and valid(x) and fromRAM(x,a) and write(x,a);except;end;
end;
//## writehead ##
function tcachebasic.writehead:boolean;
var
   tmp:tcachehead;
begin
try
//defaults
result:=false;
//process
if (ifile<>nil) then
   begin
   //.iheadchanged
   iheadchanged:=false;
   //.get
   tonullstrb(@tmp.ver,sizeof(tmp.ver),'CACH');
   tmp.pullindex:=ipullindex;
   tmp.pushindex:=ipushindex;
   //.set
   ifile.position:=0;
   result:=(iheadsize=ifile.write(tmp,iheadsize));
   end;//end of if
except;end;
end;
//## write ##
function tcachebasic.write(x:integer;var rec):boolean;
var
   pp:pointer;
   tmp:integer;
begin//Note: "rec" should point to a "fixed, non-dynamic" record structure (ie. no "string")
try
//defaults
result:=false;
//process
//.set
if iopen and valid(x) then
   begin
   //.position
   ifile.position:=iheadsize+(x*ibpi);
   //.get
   result:=(ibpi=ifile.write(rec,ibpi));
   //.iocache
   if (iid<>nil) and result then iowrite(x,rec);
   end;//end of if
except;end;
end;
//## clearitem ##
function tcachebasic.clearitem(x:integer):boolean;
begin
try
result:=iopen and valid(x) and toRAM(x,iemptybuffer) and write(x,iemptybuffer);
if result then
   begin
   ioclearitem(x);
   activeinc(false);
   end;//end of if
except;end;
end;
//## clear ##
function tcachebasic.clear:boolean;
var
   p:integer;
begin
try
//defaults
result:=true;
//check
if not iopen then
   begin
   result:=false;
   exit;
   end;//end of if
//process
for p:=0 to (isize-1) do if not clearitem(p) then
   begin
   result:=false;
   break;
   end;//end of if
//active
if result then
   begin
   iactive:=0;
   ipullindex:=0;
   ipushindex:=0;
   iheadchanged:=iopen;
   end;//end of if
except;end;
end;
//## roll ##
function tcachebasic.roll(var _indexREF,_value:integer;_size:integer):boolean;
var
   tmp:integer;
begin
try
//defaults
result:=false;
_value:=0;
//process
if (_size>=1) then
   begin
   //.range 0..(size-1)
   tmp:=_indexREF;
   if (tmp<0) then tmp:=0
   else if (tmp>=_size) then tmp:=0;
   //.set
   _value:=tmp;
   //.inc
   _indexREF:=tmp+1;
   //successful
   result:=true;
   end;//end of if
except;end;
end;
//## setpullindex ##
procedure tcachebasic.setpullindex(x:integer);
begin
try;if general.setint(frcmin(x,0),ipullindex) then iheadchanged:=true;except;end;
end;
//## setpushindex ##
procedure tcachebasic.setpushindex(x:integer);
begin
try;if general.setint(frcmin(x,0),ipushindex) then iheadchanged:=true;except;end;
end;
//## pull ##
function tcachebasic.pull(var rec):boolean;
begin
try;result:=pullex(rec,5000);except;end;
end;
//## pullex ##
function tcachebasic.pullex(var rec;searchrange:integer):boolean;
var//Finds next "inuse" item within scan range
   maxp,p,tmp:integer;
begin
try
//defaults
result:=false;
tmp:=0;
//get
if iopen and (isize>=1) and (iactive>=1) then
   begin
   //range
   if (searchrange<1) then searchrange:=isize;
   maxp:=frcrange(searchrange,1,isize);
   //scan
   for p:=1 to maxp do if roll(ipullindex,tmp,isize) then
      begin
      iheadchanged:=iopen;
      if inuse[tmp] then
         begin
         //set
         result:=read(tmp,rec);//from DISK since RAM may only hold a fraction of the data
         //clear
         if result then clearitem(tmp);
         //quit
         break;
         end;//end of if
      end;//end of if
   end;//end of if
except;end;
end;
//## push ##
function tcachebasic.push(var rec):boolean;
begin
try;result:=pushex(rec,5000);except;end;
end;
//## pushex ##
function tcachebasic.pushex(var rec;searchrange:integer):boolean;
var//Finds next "not-inuse" item within scan range
   maxp,p,tmp:integer;
begin
try
//defaults
result:=false;
tmp:=0;
//get
if iopen and (isize>=1) and (iactive<isize) then
   begin
   //range
   if (searchrange<1) then searchrange:=isize;
   maxp:=frcrange(searchrange,1,isize);
   //scan
   for p:=1 to maxp do if roll(ipushindex,tmp,isize) then
      begin
      iheadchanged:=iopen;
      if (not inuse[tmp]) then
         begin
         //set
         result:=write(tmp,rec) and toRAM(tmp,rec);
         //clear
         if result and inuse[tmp] then activeinc(true);
         //quit
         break;
         end;//end of if
      end;//end of if
   end;//end of if
except;end;
end;

//## tcacheexample #############################################################
//## create ##
constructor tcacheexample.create;
begin
try
//self
inherited create(sizeof(tcacheexampleREC));
except;end;
end;
//## _createsupport ##
procedure tcacheexample._createsupport;
begin
try
//controls
iinuse:=tdynamicboolean.create;
icore:=tdynamicinteger.create;
except;end;
end;
//## _destroysupport ##
procedure tcacheexample._destroysupport;
begin
try
//controls
freeobj(@iinuse);
freeobj(@icore);
except;end;
end;
//## getinuse ##
function tcacheexample.getinuse(x:integer):boolean;
begin
try;result:=iopen and valid(x) and iinuse.items[x];except;end;
end;
//## setinuse ##
procedure tcacheexample.setinuse(x:integer;y:boolean);
begin
try
if iopen and valid(x) and (iinuse.items[x]<>y) then
   begin
   iinuse.items[x]:=y;
   writeitem(x);
   end;//end of if
except;end;
end;
//## bpiRAM ##
function tcacheexample.bpiRAM:integer;
begin
try;result:=1+4;except;end;
end;
//## sizeRAM ##
function tcacheexample.sizeRAM(x:integer):boolean;
begin
try
result:=false;
iinuse.setparams(x,x,0);
icore.setparams(x,x,0);
result:=true;
except;end;
end;
//## fromRAM ##
function tcacheexample.fromRAM(x:integer;var rec):boolean;
begin
try
//defaults
result:=false;
//process
tcacheexampleREC(rec).inuse:=iinuse.items[x];
tcacheexampleREC(rec).value:=icore.items[x];
//successful
result:=true;
except;end;
end;
//## toRAM ##
function tcacheexample.toRAM(x:integer;var rec):boolean;
begin
try
//defaults
result:=false;
//process
iinuse.items[x]:=tcacheexampleREC(rec).inuse;
icore.items[x]:=tcacheexampleREC(rec).value;
//successful
result:=true;
except;end;
end;
//## getvalue ##
function tcacheexample.getvalue(x:integer):integer;
begin
try;if iopen and valid(x) and iinuse.items[x] then result:=icore.items[x] else result:=0;except;end;
end;
//## setvalue ##
procedure tcacheexample.setvalue(x:integer;y:integer);
begin
try
if iopen and valid(x) and iinuse.items[x] then
   begin
   icore.items[x]:=y;
   writeitem(x);
   end;//end of if
except;end;
end;
//## setref ##
procedure tcacheexample.setref(x:integer;y:currency);
var
   tmp:tcacheexampleREC;
begin
try
if iopen and valid(x) and iinuse.items[x] then
   begin
   //get
   read(x,tmp);
   tmp.ref:=y;
   //set
   write(x,tmp);
   end;//end of if
except;end;
end;
//## getref ##
function tcacheexample.getref(x:integer):currency;
var
   tmp:tcacheexampleREC;
begin
try
//defaults
result:=0;
//process
if iopen and valid(x) and iinuse.items[x] then
   begin
   read(x,tmp);
   result:=tmp.ref;
   end;//end of if
except;end;
end;
//## setstr ##
procedure tcacheexample.setstr(x:integer;y:string);
var
   tmp:tcacheexampleREC;
begin
try
if iopen and valid(x) and iinuse.items[x] then
   begin
   //get
   read(x,tmp);
   tonullstr(@tmp.str,sizeof(tmp.str),y);
   //set
   write(x,tmp);
   end;//end of if
except;end;
end;
//## getstr ##
function tcacheexample.getstr(x:integer):string;
var
   tmp:tcacheexampleREC;
begin
try
//defaults
result:='';
//process
if iopen and valid(x) and iinuse.items[x] then
   begin
   read(x,tmp);
   result:=string(tmp.str);
   end;//end of if
except;end;
end;

//######################### tnotifylist ########################################
//## create ##
constructor tnotifylist.create;
begin
//vars
iupdsys:=ms64;
//controls
ievent:=tdynamicnotifyevent.create;
end;
//## destroy ##
destructor tnotifylist.destroy;
begin
try
//controls
freeObj(@ievent);
//self
inherited;
except;end;
end;
//## getcount ##
function tnotifylist.getcount:integer;
begin
try;result:=ievent.count;except;end;
end;
//## getactive ##
function tnotifylist.getactive:integer;
var
   p:integer;
begin
try
//defaults
result:=0;
//process
for p:=0 to (ievent.count-1) do if (@ievent.items[p]<>nil) then inc(result);
except;end;
end;
//## notify ##
procedure tnotifylist.notify;
begin
try;notifyb(-1);except;end;
end;
//## notifyb ##
procedure tnotifylist.notifyb(ms:currency);
var//-1=never, 0=always, 1..N every N ms's
   p:integer;
begin
try
//process
//.event
for p:=0 to (ievent.count-1) do
 if (@ievent.items[p]<>nil) and assigned(ievent.items[p]) then
    begin
    ievent.items[p](self);
    if (ms>=0) and ((ms=0) or ((ms64-iupdsys)>=ms)) then
       begin
       application.processmessages;
       iupdsys:=ms64;
       end;//end of if
    end;//end of if
except;end;
end;
//## new ##
function tnotifylist.new(_event:tnotifyevent):integer;
begin
try
//error
result:=-1;
//process
//.set
ievent.value[ievent.count]:=_event;
//return result
result:=ievent.count-1;
except;end;
end;
//## del ##
procedure tnotifylist.del(var _instance:integer);
begin
try
//process
if (_instance>=0) and (_instance<ievent.count) then
   begin
   //.free
   ievent.items[_instance]:=nil;
   //.clear
   _instance:=-1;
   end;//end of if
except;end;
end;

//########################### tvirtualstorage ##################################
//## create ##
constructor tvirtualstorage.create;
var
   tmp:string;
   p:integer;
begin
//self
inherited create;
//vars
locked:=true;
//controls
iappearance:=tdynamicboolean.create;
ivalue:=tdynamicstring.create;
idefault:=tdynamicstring.create;
irange:=tdynamicstring.create;
istyle:=tdynamicbyte.create;
iinuse:=tdynamicboolean.create;
iapplys:=tnotifylist.create;
//vars
imode:=vsmNone;
isize:=0;
icanautosave:=(sysstate=ssOK);
iid:=1;
iioid:=1;
//.font sizes
tmp:='';
for p:=5 to 100 do tmp:=tmp+';'+inttostr(p*2);
ifontsizes:=';1;2;3;4;5;6;7;8;9'+tmp;
irangeintFONTSIZES:=rangeint(1,maxword);
//timers
itimer:=mt.new(_ontimer,5000,true);
end;
//## createsys ##
constructor tvirtualstorage.createsys(sysVar:prootobject);
var
   e:string;
begin
//self
inherited createsys(sysVar);
//.system related
initsystem;
if (sysstate=ssOK) then
   begin
   load(e,true);
   iautosave:=true;
   end;//end of if
end;
//## destroy ##
destructor tvirtualstorage.destroy;
var
   e:string;
begin
try
//timer
if (fmt<>nil) then fmt.del(itimer);
//autosave/check file exists
if (not sysdeleting) and icanautosave and iautosave and ((iioid<>iid) or (not fileexists(filename))) then save(e);
//controls
freeobj(@iapplys);
freeobj(@ivalue);
freeobj(@idefault);
freeobj(@irange);
freeobj(@istyle);
freeobj(@iinuse);
freeobj(@iappearance);
//self
inherited;
except;end;
end;
//## getblock ##
function tvirtualstorage.getblock:string;
const
   size=72;
var
   line,tmp,e:string;
   p:integer;
begin
try
//init
setlength(line,size);
for p:=1 to size do line[p]:='-';
//get
result:=
 general.replacec('-- Scheme start for "'+programnameHARD+'" ',line,1)+rcode+
 io.tob64b(vs.text,size)+rcode+
 general.replacec('-- Scheme end ',line,1)+rcode;
except;end;
end;
//## setblock ##
procedure tvirtualstorage.setblock(x:string);
var
   e:string;
begin
try;setblockex(x,false,e);except;end;
end;
//## setblockex ##
function tvirtualstorage.setblockex(x:string;prompt:boolean;var e:string):boolean;
var
   z,v:string;
   c,zlen,p:integer;
   r:tmodalresult;
begin
try
//defaults
result:=false;
e:=gecUnknownFormat;
//check
if (x='') then exit;
//init
e:=gecOutOfMemory;
p:=1;
v:='';
zlen:=0;
c:=0;
//scan
while general.nextline(p,x,v) do if (v<>'') then
   begin
   if (v[1]='-') and (length(v)>=2) and (v[2]='-') then
      begin
      if (c=0) then c:=1
      else if (c>=1) then
         begin
         inc(c);
         break;
         end;//end of if
      end
   else pushb(zlen,z,v);//end of if
   end;//end of if
//finalise
pushb(zlen,z,'');
//.check
if (c<2) then e:=gecUnknownFormat
else
   begin
   //.prompt
   if prompt then
      begin
      r:=showYNC(
       ntranslate('yes')+' = '+translate('Paste entire scheme')+', '+translate('or')+rcode+
       ntranslate('no')+' = '+translate('Paste appearance only')+'.',-60);
      end
   else r:=mrOK;//end of if
   //.set
   result:=(r=mrCancel) or vs.settextb(io.fromb64b(z),(r=mrOK),e);
   end;//end of if
except;end;
try;if (not result) and prompt then showerror60(translate(e));except;end;
end;
//## copyto ##
procedure tvirtualstorage.copyto;
begin
try;clipboard.astext:=block;except;showerror60(translate(gecTaskFailed));end;
end;
//## canpastefrom ##
function tvirtualstorage.canpastefrom:boolean;
begin
try;result:=clipboard.hasformat(cf_text);except;end;
end;
//## pastefrom ##
procedure tvirtualstorage.pastefrom;
var
   e:string;
begin
try;if canpastefrom then setblockex(clipboard.astext,true,e);except;showerror60(translate(gecTaskFailed));end;
end;
//## getappearance ##
function tvirtualstorage.getappearance(x:integer):boolean;
begin
try;result:=inrange(x) and iappearance.value[x];except;end;
end;
//## setappearance ##
procedure tvirtualstorage.setappearance(x:integer;y:boolean);
begin
try;if inrange(x) then iappearance.value[x]:=y;except;end;
end;
//## inrange ##
function tvirtualstorage.inrange(x:integer):boolean;
begin
try;result:=(x>=0) and (x<isize);except;end;
end;
//## getstyle ##
function tvirtualstorage.getstyle(x:integer):tstoragestyle;
begin
try;if inrange(x) then result:=tstoragestyle(istyle.items[x]) else result:=sgsString;except;end;
end;
//## getdefault ##
function tvirtualstorage.getdefault(x:integer):string;
begin
try;if inrange(x) then result:=idefault.items[x]^ else result:='';except;end;
end;
//## setdefault ##
procedure tvirtualstorage.setdefault(x:integer;y:string);
begin
try
if inrange(x) then
   begin
   //.set
   idefault.items[x]^:=y;
   //.sync
   if not iinuse.items[x] then s[x]:=y;
   end;//end of if
except;end;
end;
//## getrange ##
function tvirtualstorage.getrange(x:integer):string;
begin
try;if inrange(x) then result:=irange.items[x]^ else result:='';except;end;
end;
//## setrange ##
procedure tvirtualstorage.setrange(x:integer;y:string);
begin
try;if inrange(x) then irange.items[x]^:=y;except;end;
end;
//## rangebol ##
function tvirtualstorage.rangebol(val:boolean):string;
begin
try;result:='b'+general.bn(val);except;end;
end;
//## rangeint ##
function tvirtualstorage.rangeint(min,max:integer):string;
var
   a,b:tint4;
begin
try
a.val:=min;
b.val:=max;
result:='i'+a.chars[0]+a.chars[1]+a.chars[2]+a.chars[3]+b.chars[0]+b.chars[1]+b.chars[2]+b.chars[3];
except;end;
end;
//## rangecur ##
function tvirtualstorage.rangecur(min,max:currency):string;
var
   a,b:tcur8;
begin
try
a.val:=min;
b.val:=max;
result:='c'+
   a.chars[0]+a.chars[1]+a.chars[2]+a.chars[3]+a.chars[4]+a.chars[5]+a.chars[6]+a.chars[7]+
   b.chars[0]+b.chars[1]+b.chars[2]+b.chars[3]+b.chars[4]+b.chars[5]+b.chars[6]+b.chars[7];
except;end;
end;
//## rangeext ##
function tvirtualstorage.rangeext(min,max:extended):string;
var
   a,b:text10;
begin
try
a.val:=min;
b.val:=max;
result:='e'+
   a.chars[0]+a.chars[1]+a.chars[2]+a.chars[3]+a.chars[4]+a.chars[5]+a.chars[6]+a.chars[7]+a.chars[8]+a.chars[9]+
   b.chars[0]+b.chars[1]+b.chars[2]+b.chars[3]+b.chars[4]+b.chars[5]+b.chars[6]+b.chars[7]+b.chars[8]+b.chars[9];
except;end;
end;
//## rangestrFONTNAME ##
function tvirtualstorage.rangestrFONTNAME:string;
begin
try;result:='sf';except;end;
end;
//## rangestrLENGTH ##
function tvirtualstorage.rangestrLENGTH(len:integer):string;
var
   a:tint4;
begin
try
a.val:=len;
result:='sl'+a.chars[0]+a.chars[1]+a.chars[2]+a.chars[3];
except;end;
end;
//## rangeb ##
function tvirtualstorage.rangeb(x:integer;y:boolean):boolean;
var
   tmp:string;
begin//No index(x) range checking, x is assumed to be within range
try
//defaults
result:=y;
//process
tmp:=irange.items[x]^;
if (tmp<>'') and (tmp[1]='b') then result:=(tmp[2]<>'0');
except;end;
end;
//## rangei ##
function tvirtualstorage.rangei(x:integer;y:integer):integer;
var
   tmp:string;
begin//No index(x) range checking, x is assumed to be within range
try
//defaults
result:=y;
//process
tmp:=irange.items[x]^;
if (tmp<>'') and (tmp[1]='i') then result:=frcrange(y,pinteger(longint(irange.items[x]^)+1)^,pinteger(longint(irange.items[x]^)+5)^);
except;end;
end;
//## rangerefi ##
procedure tvirtualstorage.rangerefi(x:string;var min,max:integer);
begin
try
//defaults
min:=0;
max:=0;
//process
if (length(x)>=9) and (x[1]='i') then
   begin
   min:=pinteger(longint(x)+1)^;
   max:=pinteger(longint(x)+5)^;
   end;//end of if
except;end;
end;
//## rangec ##
function tvirtualstorage.rangec(x:integer;y:currency):currency;
var
   tmp:string;
begin//No index(x) range checking, x is assumed to be within range
try
//defaults
result:=y;
//process
tmp:=irange.items[x]^;
if (tmp<>'') and (tmp[1]='c') then result:=frccurrange(y,pcurrency(longint(irange.items[x]^)+1)^,pcurrency(longint(irange.items[x]^)+9)^);
except;end;
end;
//## rangee ##
function tvirtualstorage.rangee(x:integer;y:extended):extended;
var
   tmp:string;
begin//No index(x) range checking, x is assumed to be within range
try
//defaults
result:=y;
//process
tmp:=irange.items[x]^;
if (tmp<>'') and (tmp[1]='e') then result:=frccurrange(y,pextended(longint(irange.items[x]^)+1)^,pextended(longint(irange.items[x]^)+11)^);
except;end;
end;
//## ranges ##
function tvirtualstorage.ranges(x:integer;y:string):string;
var
   tmp:string;
   maxlen,ylen:integer;
begin//No index(x) range checking, x is assumed to be within range
try
//defaults
result:=y;
//process
tmp:=irange.items[x]^;
if (tmp<>'') and (tmp[1]='s') then
   begin
   if (tmp[2]='f') then (if (y='') then y:='MS Sans Serif')
   else if (tmp[2]='l') then
      begin
      maxlen:=pinteger(longint(irange.items[x]^)+2)^;
      ylen:=length(y);
      if (ylen>maxlen) then result:=copy(y,1,maxlen) else result:=y;
      end;//end of if
   end;//end of if
except;end;
end;
//## setsize ##
procedure tvirtualstorage.setsize(x:integer);
begin
try
//range
x:=frcmin(x,0);
//process
ivalue.setparams(x,x,0);
idefault.setparams(x,x,0);
irange.setparams(x,x,0);
istyle.setparams(x,x,0);
iinuse.setparams(x,x,0);
isize:=ivalue.count;
except;end;
end;
//## initsystem ##
procedure tvirtualstorage.initsystem;
begin//Supports "appearance" sub-class as of 10-FEB-2006
try  //Note: "initfill" sets up var, overriding all previous information
//.integer
initfillb(vsBackground,sgsInteger,inttostr(rgb(239,240,222)),'',true);
initfillb(vsBorder,sgsInteger,inttostr(rgb(150,146,63)),'',true);
initfillb(vsHighlight,sgsInteger,inttostr(rgb(94,163,255)),'',true);
initfillb(vsFont,sgsInteger,inttostr(rgb(0,0,0)),'',true);
initfillb(vsFontHighlight,sgsInteger,inttostr(rgb(255,255,255)),'',true);
initfillb(vsFontSize,sgsInteger,'8',rangeint(6,72),true);//12OCT2007

initfillb(vsHover,sgsInteger,inttostr(rgb(196,221,255)),'',true);
initfillb(vsDisable,sgsInteger,inttostr(rgb(239,240,222)),'',true);
initfillb(vsDisableBorder,sgsInteger,inttostr(rgb(128,128,128)),'',true);
initfillb(vsDisableFont,sgsInteger,inttostr(rgb(192,192,192)),'',true);
initfillb(vsVersion,sgsInteger,'3',rangeint(0,maxint),true);//update 12-JAN-2006 - version of scheme

initfillb(vsTitleBackground,sgsInteger,inttostr(rgb(0,110,255)),'',true);
initfillb(vsTitleBorder,sgsInteger,inttostr(rgb(0,110,255)),'',true);
initfillb(vsTitleHighlight,sgsInteger,inttostr(rgb(94,163,255)),'',true);
initfillb(vsTitleFont,sgsInteger,inttostr(rgb(255,247,255)),'',true);
initfillb(vsTitleFontHighlight,sgsInteger,inttostr(rgb(238,239,221)),'',true);
initfill(vsTitleFontHeight,sgsInteger,'22',rangeint(4,maxint));
initfillb(vsTitleHover,sgsInteger,inttostr(rgb(192,192,192)),'',true);
initfillb(vsTitleDisable,sgsInteger,inttostr(rgb(128,128,128)),'',true);
initfillb(vsTitleDisableBorder,sgsInteger,inttostr(rgb(128,128,128)),'',true);
initfillb(vsTitleDisableFont,sgsInteger,inttostr(rgb(192,192,192)),'',true);

initfillb(vsScrollSizeMain,sgsInteger,'20',rangeint(8,128),true);
initfillb(vsScrollSize,sgsInteger,'16',rangeint(8,128),true);
initfillb(vsBorderSize,sgsInteger,'1',rangeint(0,1),true);
initfill(vsPort,sgsInteger,'80',rangeint(1,high(word)));//#
initfill(vsRate,sgsInteger,inttostr(vsvRateDefault),rangeint(nwMinThrottle,nwMaxThrottle));

//.boolean
initfillb(vsRound,sgsBoolean,'1','',true);
initfillb(vsBold,sgsBoolean,'0','',true);
initfillb(vsItalic,sgsBoolean,'0','',true);
initfillb(vsUnderline,sgsBoolean,'0','',true);
initfillb(vsStrikeout,sgsBoolean,'0','',true);

initfillb(vsTitleBold,sgsBoolean,'1','',true);
initfillb(vsTitleItalic,sgsBoolean,'0','',true);
initfillb(vsTitleUnderline,sgsBoolean,'0','',true);
initfillb(vsTitleStrikeout,sgsBoolean,'0','',true);
initfill(vsAutoStartup,sgsBoolean,'0','');
initfill(vsSystemTray,sgsBoolean,'0','');
initfill(vsOnTop,sgsBoolean,'0','');
initfill(vsStartMinimised,sgsBoolean,'0','');
initfill(vsShowSplash,sgsBoolean,'1','');
initfill(vsAutoScroll,sgsBoolean,'1','');
initfill(vsDblClickRun,sgsBoolean,'0','');
initfill(vs24hr,sgsBoolean,'0','');
initfill(vsUsePath,sgsBoolean,'0','');
initfill(vsUseCustomUA,sgsBoolean,'0','');
initfill(vsUseProxy,sgsBoolean,'0','');
initfillb(vsEnhanced,sgsBoolean,'1','',true);
initfillb(vsSafeArea,sgsBoolean,'1','',true);
initfillb(vsSizeFast,sgsBoolean,'1','',true);
initfillb(vsSizeBalanced,sgsBoolean,'0','',true);
initfill(vsLogs,sgsBoolean,'0','');//#
initfill(vsRequireAuthorisation,sgsBoolean,'0','');//#
initfill(vsShowClone,sgsBoolean,'1','');//#
initfill(vsShowSoft,sgsBoolean,'1','');//#
initfillb(vsCompact,sgsBoolean,'0','',true);
initfillb(vsBufferedPaint,sgsBoolean,'0','',true);
initfillb(vsAnimateIcon,sgsBoolean,'1','',true);
initfillb(vsHelp,sgsBoolean,'1','',true);
initfill(vsUseNM,sgsBoolean,'0','');//20FEB2008

//..alerts (flash & audio by default
initfill(vsAlertFlash,sgsBoolean,'1','');
initfill(vsAlertVibrate,sgsBoolean,'0','');
initfill(vsAlertShow,sgsBoolean,'0','');

//.string
initfillb(vsFontName,sgsString,'MS Sans Serif',rangestrFONTNAME,true);
initfillb(vsTitleFontName,sgsString,'MS Sans Serif',rangestrFONTNAME,true);
initfill(vsPath,sgsString,bvfportable(bvfTemp),'');
initfill(vsCustomUA,sgsString,programua,'');
initfill(vsProxy,sgsString,'','');
initfill(vsUsername,sgsString,'','');//#
initfill(vsPassword,sgsString,'','');//#
initfill(vsMimes,sgsString,'','');//#
initfill(vsBanIP,sgsString,'','');//#
initfill(vsSuptrans,sgsString,'','');//13OCT2007
initfill(vsNMIP,sgsString,'10.0.0.1','');//20FEB2008

//.cursors - string
initfillb(vsCursorArrow,sgsString,'','',true);
initfillb(vsCursorHand,sgsString,'','',true);
initfillb(vsCursorText,sgsString,'','',true);
initfillb(vsCursorBusy,sgsString,'','',true);
initfillb(vsCursorSize,sgsString,'','',true);

//.app based - override system defaults for specific applications
__appvs(self);
except;end;
end;
//## init ##
function tvirtualstorage.init(x:integer;_style:tstoragestyle):boolean;
const
   _int=#0+#0+#0+#0;
var
   tmp:string;
begin
try
//defaults
result:=false;
tmp:='';
//process
if (x>=0) then
   begin
   //.enlarge
   if (x>=isize) then size:=x+1;
   //.carry on set value
   if iinuse.items[x] then tmp:=s[x];
   //.style
   istyle.items[x]:=byte(_style);
   //.memory
   case _style of
   sgsString:ivalue.items[x]^:='';
   sgsExtended:ivalue.items[x]^:=_int+_int+copy(_int,1,2);//10 bytes
   sgsCurrency:ivalue.items[x]^:=_int+_int;
   sgsInteger:ivalue.items[x]^:=_int;
   sgsBoolean:ivalue.items[x]^:=#0;
   end;//end of case
   //.set
   if iinuse.items[x] then s[x]:=tmp;
   //successful
   result:=true;
   end;//end of if
except;end;
end;
//## initfill ##
function tvirtualstorage.initfill(x:integer;_style:tstoragestyle;_default,_range:string):boolean;
begin
try
result:=init(x,_style);
if result then
   begin
   range[x]:=_range;
   //.set
   if inrange(x) then
      begin
      idefault.items[x]^:=_default;
      //.fill
      s[x]:=_default;
      end;//end of if
   end;//end of if
except;end;
end;
//## initfillb ##
function tvirtualstorage.initfillb(x:integer;_style:tstoragestyle;_default,_range:string;_appearance:boolean):boolean;
begin
try
//init
result:=initfill(x,_style,_default,_range);
//appearance
appearance[x]:=_appearance;
except;end;
end;
//## getb ##
function tvirtualstorage.getb(x:integer):boolean;
begin
try
if inrange(x) then
   case style[x] of
   sgsBoolean:result:=rangeb(x,pboolean(longint(ivalue.items[x]^))^);//*
   sgsInteger:result:=rangei(x,pinteger(longint(ivalue.items[x]^))^)<>0;
   sgsCurrency:result:=rangec(x,pcurrency(longint(ivalue.items[x]^))^)<>0;
   sgsExtended:result:=rangec(x,pextended(longint(ivalue.items[x]^))^)<>0;
   sgsString,sgsECap:result:=strint(ranges(x,ivalue.items[x]^))<>0;
   end
else result:=false;
except;end;
end;
//## setb ##
procedure tvirtualstorage.setb(x:integer;y:boolean);
begin
try
if inrange(x) then
   begin
   case style[x] of
   sgsNil:exit;
   sgsBoolean:pboolean(longint(ivalue.items[x]^))^:=rangeb(x,y);//*
   sgsInteger:pinteger(longint(ivalue.items[x]^))^:=rangei(x,integer(y));
   sgsCurrency:pcurrency(longint(ivalue.items[x]^))^:=rangec(x,integer(y));
   sgsExtended:pextended(longint(ivalue.items[x]^))^:=rangee(x,integer(y));
   sgsString,sgsECap:ivalue.items[x]^:=ranges(x,inttostr(integer(y)));
   end;//end of case
   iinuse.items[x]:=true;
   changed;
   end;//end of if
except;end;
end;
//## geti ##
function tvirtualstorage.geti(x:integer):integer;
begin
try
if inrange(x) then
   case style[x] of
   sgsBoolean:result:=integer(rangeb(x,pboolean(longint(ivalue.items[x]^))^));
   sgsInteger:result:=rangei(x,pinteger(longint(ivalue.items[x]^))^);//*
   sgsCurrency:result:=round(rangec(x,pcurrency(longint(ivalue.items[x]^))^));
   sgsExtended:result:=round(rangee(x,pextended(longint(ivalue.items[x]^))^));
   sgsString,sgsECap:result:=strint(ranges(x,ivalue.items[x]^));
   sgsNil:result:=0;
   end
else result:=0;
except;end;
end;
//## seti ##
procedure tvirtualstorage.seti(x:integer;y:integer);
var
   tmp:string;
begin
try
if inrange(x) then
   begin
   case style[x] of
   sgsNil:exit;
   sgsBoolean:pboolean(longint(ivalue.items[x]^))^:=rangeb(x,y<>0);
   sgsInteger:pinteger(longint(ivalue.items[x]^))^:=rangei(x,y);//*
   sgsCurrency:pcurrency(longint(ivalue.items[x]^))^:=rangec(x,y);
   sgsExtended:pextended(longint(ivalue.items[x]^))^:=rangee(x,y);
   sgsString,sgsECap:ivalue.items[x]^:=ranges(x,inttostr(y));
   end;//end of case
   iinuse.items[x]:=true;
   changed;
   end;//end of if
except;end;
end;
//## getc ##
function tvirtualstorage.getc(x:integer):currency;
begin
try
if inrange(x) then
   case style[x] of
   sgsBoolean:result:=integer(rangeb(x,pboolean(longint(ivalue.items[x]^))^));
   sgsInteger:result:=rangei(x,pinteger(longint(ivalue.items[x]^))^);
   sgsCurrency:result:=rangec(x,pcurrency(longint(ivalue.items[x]^))^);//*
   sgsExtended:result:=rangee(x,pextended(longint(ivalue.items[x]^))^);//*
   sgsString,sgsECap:result:=strflt(ranges(x,ivalue.items[x]^));
   sgsNil:result:=0;
   end
else result:=0;
except;end;
end;
//## setc ##
procedure tvirtualstorage.setc(x:integer;y:currency);
begin
try
if inrange(x) then
   begin
   case style[x] of
   sgsNil:exit;
   sgsBoolean:pboolean(longint(ivalue.items[x]^))^:=rangeb(x,y<>0);
   sgsInteger:pinteger(longint(ivalue.items[x]^))^:=rangei(x,round(y));
   sgsCurrency:pcurrency(longint(ivalue.items[x]^))^:=rangec(x,y);//*
   sgsExtended:pextended(longint(ivalue.items[x]^))^:=rangee(x,y);//*
   sgsString,sgsECap:ivalue.items[x]^:=ranges(x,floattostrex2(y));
   end;//end of case
   iinuse.items[x]:=true;
   changed;
   end;//end of if
except;end;
end;
//## gete ##
function tvirtualstorage.gete(x:integer):extended;
begin
try
if inrange(x) then
   case style[x] of
   sgsBoolean:result:=integer(rangeb(x,pboolean(longint(ivalue.items[x]^))^));
   sgsInteger:result:=rangei(x,pinteger(longint(ivalue.items[x]^))^);
   sgsCurrency:result:=rangec(x,pcurrency(longint(ivalue.items[x]^))^);//*
   sgsExtended:result:=rangee(x,pextended(longint(ivalue.items[x]^))^);//*
   sgsString,sgsECap:result:=strflt(ranges(x,ivalue.items[x]^));
   sgsNil:result:=0;
   end
else result:=0;
except;end;
end;
//## sete ##
procedure tvirtualstorage.sete(x:integer;y:extended);
begin
try
if inrange(x) then
   begin
   case style[x] of
   sgsNil:exit;
   sgsBoolean:pboolean(longint(ivalue.items[x]^))^:=rangeb(x,y<>0);
   sgsInteger:pinteger(longint(ivalue.items[x]^))^:=rangei(x,round(y));
   sgsCurrency:pcurrency(longint(ivalue.items[x]^))^:=rangec(x,y);//*
   sgsExtended:pextended(longint(ivalue.items[x]^))^:=rangee(x,y);//*
   sgsString,sgsECap:ivalue.items[x]^:=ranges(x,floattostrex2(y));
   end;//end of case
   iinuse.items[x]:=true;
   changed;
   end;//end of if
except;end;
end;
//## gets ##
function tvirtualstorage.gets(x:integer):string;
begin
try
if inrange(x) then
   case style[x] of
   sgsBoolean:result:=general.bn(rangeb(x,pboolean(longint(ivalue.items[x]^))^));
   sgsInteger:result:=inttostr(rangei(x,pinteger(longint(ivalue.items[x]^))^));
   sgsCurrency:result:=floattostrex2(rangec(x,pcurrency(longint(ivalue.items[x]^))^));
   sgsExtended:result:=floattostrex2(rangee(x,pextended(longint(ivalue.items[x]^))^));
   sgsString,sgsECap:result:=ranges(x,ivalue.items[x]^);//*
   sgsNil:result:='';
   end
else result:='';
except;end;
end;
//## sets ##
procedure tvirtualstorage.sets(x:integer;y:string);
begin
try
if inrange(x) then
   begin
   //.special - empty strings trigger default value
   if (y='') then y:=idefault.items[x]^;
   //.set
   case style[x] of
   sgsNil:exit;
   sgsBoolean:pboolean(longint(ivalue.items[x]^))^:=rangeb(x,strint(y)<>0);
   sgsInteger:pinteger(longint(ivalue.items[x]^))^:=rangei(x,strint(y));
   sgsCurrency:pcurrency(longint(ivalue.items[x]^))^:=rangec(x,strcur(y));
   sgsExtended:pextended(longint(ivalue.items[x]^))^:=rangee(x,strtofloatex(y));
   sgsString,sgsECap:ivalue.items[x]^:=ranges(x,y);//*
   end;//end of case
   iinuse.items[x]:=true;
   changed;
   end;//end of if
except;end;
end;
//## changed ##
procedure tvirtualstorage.changed;
begin
try;general.irollb(iid,1,1);except;end;
end;
//## _ontimer ##
procedure tvirtualstorage._ontimer(sender:tobject);
begin
try;if (not autosavelocked) then _autosave;except;end;
end;
//## connect ##
function tvirtualstorage.connect(_event:tnotifyevent):integer;
begin
try;result:=iapplys.new(_event);except;end;
end;
//## disconnect ##
procedure tvirtualstorage.disconnect(var _instance:integer);
begin
try;iapplys.del(_instance);except;end;
end;
//## writetocontrols ##
procedure tvirtualstorage.writetocontrols;
var
   a:tvirtualform;
   p:integer;
begin
try
//check
if (sysstate<>ssOK) or locked then exit;
//write
imode:=vsmWritetocontrols;
iapplys.notify;
viSync;
//update
imode:=vsmUpdatecontrols;
iapplys.notify;
//compact
if (piggyform<>nil) and (piggyform is tvirtualform) then
   begin
   a:=(piggyform as tvirtualform);
   if (a.pages<>nil) then for p:=0 to (a.pages.count-1) do if a.pages.inuse(p) and (a.pages.pages[p]<>nil) and (a.pages.pages[p] is tvirtualpage) and (not (a.pages.pages[p] as tvirtualpage).button.oAllowCompact) then (a.pages.pages[p] as tvirtualpage).button.oAllowCompact:=true;
   end;//end of if
//safe
imode:=vsmNone;
//sync all forms
for p:=0 to (screen.formcount-1) do if (screen.forms[p] is tvirtualform) then (screen.forms[p] as tvirtualform).sync;
except;end;
end;
//## apply ##
procedure tvirtualstorage.apply;
begin
try
//check
if (sysstate<>ssOK) or locked then exit;
//read
imode:=vsmReadfromcontrols;
iapplys.notify;
//write
writetocontrols;
//changed
changed;
except;end;
end;
//## clear ##
procedure tvirtualstorage.clear;
begin
try;size:=0;changed;except;end;
end;
//## defaults ##
procedure tvirtualstorage.defaults(prompt:boolean);
begin
try;defaultsb(prompt,true);except;end;
end;
//## defaultsb ##
procedure tvirtualstorage.defaultsb(prompt,full:boolean);
var
   m:string;
begin
try
//prompt
if prompt then
   begin
   m:=ntranslate('Restore Default')+#32;
   case full of
   false:begin
        m:=m+ntranslate('Appearance')+' ('+ntranslate('Border, Fonts, Cursors and Colors')+')';
        if (not showquery60(m+'?')) then exit;
        end;//end of begin
   true:begin
        m:=m+ntranslate('Options, Settings and Appearance');
        if (not showconfirm(m+'?')) then exit;
        end;//end of begin
   end;//end of case
   end;//end of if
//defaults
_defaults(full);
//writetocontrols
writetocontrols;
except;end;
end;
//## _defaults ##
procedure tvirtualstorage._defaults(full:boolean);
var
   p:integer;
begin
try
//defaults
for p:=0 to (count-1) do if (full or appearance[p]) then s[p]:=default[p];
//changed
changed;
except;end;
end;
//## deletefinalise ##
procedure tvirtualstorage.deletefinalise;
begin
try
//disable saving
icanautosave:=false;
//read
if (sysstate=ssOK) then
   begin
   //read
   imode:=vsmReadfromcontrols;
   iapplys.notify;
   end;//end of if
//delete - special settings for clean delete from system
b[vsAutoStartup]:=false;
//write
if (sysstate=ssOK) then writetocontrols;
//changed
changed;
except;end;
end;
//## _autosave ##
function tvirtualstorage._autosave:boolean;
var
   e:string;
begin
try;if icanautosave and iautosave and (iioid<>iid) then result:=save(e) else result:=false;except;end;
end;
//## filename ##
function tvirtualstorage.filename:string;
begin
try;result:=bvfportable(bvfSettings)+programname+'.SCHEME';except;end;
end;
//## filenameb ##
function tvirtualstorage.filenameb(_programname:string):string;
begin
try;result:=bvfportable(bvfSettings)+_programname+'.SCHEME';except;end;
end;
//## pull ##
function tvirtualstorage.pull(hdr:string;var data,e:string):boolean;
label
     skipend;
var
   a:tnv;
   p:integer;
   v:string;
begin
try
//defaults
result:=false;
data:='';
e:=gecOutOfMemory;
//prepare
a:=newnv;
a.data:=@data;
if not a.initwrite(hdr,e) then goto skipend;
//process
//.values [style1+index4]=[value as string] and (style<>sgsNil)
for p:=0 to (count-1) do if (istyle.items[p]<>0) then
   begin
   //get
   v:=s[p];
   //encode binary
   if (style[p]=sgsECap) then v:=ecapbin(v,true,true);
   //set
   if not a.writeb(char(style[p])+from32bit(p),v,e) then goto skipend;
   end;//end of if
//.finalise
if not a.writeb('','',e) then goto skipend;
//successful
result:=true;
skipend:
except;end;
try;freeObj(@a);except;end;
end;
//## push ##
function tvirtualstorage.push(hdr:string;var data,e:string;append,full:boolean):boolean;
label
     skipend;
var
   a:tnv;
   ip,p:integer;
   n,v:string;
   _style:tstoragestyle;
begin
try
//defaults
result:=false;
e:=gecOutOfMemory;
//prepare
a:=newnv;
a.data:=@data;
if not a.initread(hdr,e) then goto skipend;
//process
//.defaults
if not append then
   begin
   _defaults(full);
   //.null version
   i[vsVersion]:=0;
   end;//end of if
//.loop
while a.canread do
begin
//.get
if not a.read(n,v,e) then goto skipend;
//.set [style1+index4]=[value as string]
if (n<>'') then
   begin
   _style:=tstoragestyle(n[1]);
   ip:=to32bit(copy(n,2,length(n)));
   if (ip>=0) and (ip<=vsMax) and (_style>=sgsString) and (_style<=sgsECap) and (full or appearance[ip]) then
      begin
      //init
      if (ip>=isize) then init(ip,_style);
      //decode binary
      if (_style=sgsECap) then v:=ecapbin(v,false,true);
      //set
      s[ip]:=v;
      end;//end of if
   end;//end of if
end;//end of with
//.check null version
if (i[vsVersion]<vsvVersion) then
   begin
   //.correct version
   i[vsVersion]:=vsvVersion;
   //.upgrade values
   //..border
   if not ccs.cv(i[vsBorder],i[vsBackground],35) then i[vsBorder]:=general.dc(i[vsBackground],-40);
   //..hover
   i[vsHover]:=general.dc(i[vsHighlight],5);
   i[vsTitleHover]:=i[vsTitleFontHighlight];
   //..disable border
   i[vsDisableBorder]:=general.dc(i[vsBorder],-20);
   i[vsTitleDisableBorder]:=general.dc(i[vsTitleBorder],-20);
   //..disable
   i[vsDisable]:=general.dc(i[vsBackground],-20);
   i[vsTitleDisable]:=general.dc(i[vsTitleBackground],-20);
   //..disable font
   i[vsDisableFont]:=general.dc(i[vsFont],-50);
   i[vsTitleDisableFont]:=general.dc(i[vsTitleFont],-50);
   end;//end of if
//successful
result:=true;
skipend:
except;end;
try;freeobj(@a);except;end;
end;
//## savetofile ##
function tvirtualstorage.savetofile(x:string;var e:string):boolean;
var
   hdr,z:string;
begin
try
//defaults
result:=false;
e:=gecOutOfMemory;
//process
z:='';
hdr:='STORAGE';
//process
//.save - try up to 20 times
if pull(hdr,z,e) then result:=io.tofilec(x,z,e,20);
except;end;
end;
//## loadfromfile ##
function tvirtualstorage.loadfromfile(x:string;var e:string;append,full:boolean):boolean;
var
   hdr,z:string;
begin
try
//defaults
result:=false;
e:=gecOutOfMemory;
z:='';
hdr:='STORAGE';
//process
//.load - try up to 20 times
result:=io.fromFILEc(x,z,e,20);
//.push
if result then push(hdr,z,e,append,full);
//.update
changed;
writetocontrols;
except;end;
end;
//## save ##
function tvirtualstorage.save(var e:string):boolean;
begin
try
result:=savetofile(filename,e);
iioid:=iid;//saved
except;end;
end;
//## load ##
function tvirtualstorage.load(var e:string;full:boolean):boolean;
begin
try
result:=loadfromfile(filename,e,false,full);
iioid:=iid;//loaded
except;end;
end;
//## gettext ##
function tvirtualstorage.gettext:string;
var
   e:string;
begin
try;result:='';pull('STORAGE',result,e);except;end;
end;
//## settext ##
procedure tvirtualstorage.settext(x:string);
var
   e:string;
begin
try;settextb(x,true,e);except;end;
end;
//## settextb ##
function tvirtualstorage.settextb(x:string;full:boolean;var e:string):boolean;
begin
try
//defaults
result:=false;
e:=gecOutOfMemory;
//get
result:=push('STORAGE',x,e,false,full);
//set
changed;
writetocontrols;
except;end;
end;

//########################### pixel filters ####################################
//## plfMain ##
function plfMain(var p:trgbcolor;pinfo:ppixelinfo):boolean;//30SEP2007, 23-DEC-2004
begin
//defaults
result:=true;
//process
//.transwhite - convert "transparentcolor" to "white"
if pinfo.transwhite and (pinfo.find.r=p.r) and (pinfo.find.g=p.g) and (pinfo.find.b=p.b) then
   begin
   p.r:=255;
   p.g:=255;
   p.b:=255;
   exit;
   end;//end of if
//.find2 - block color repacer (secondary filter)
if pinfo.usefind2 then
   begin
   if (p.r=pinfo.find2.r) and (p.g=pinfo.find2.g) and (p.b=pinfo.find2.b) then
      begin
      p:=pinfo.replace2;
      exit;
      end;//end of if
   end;//end of if
//.find
if (pinfo.style=plsSolid) or (pinfo.style=plsTranswhite) then
   begin
   if pinfo.filteron then result:=pinfo.filter(p,pinfo);
   end
else if (pinfo.style=plsTransparent) then
   begin
   result:=(p.r<>pinfo.find.r) or (p.g<>pinfo.find.g) or (p.b<>pinfo.find.b);
   end
else if (pinfo.style=plsReplace) then
   begin
   if (p.r=pinfo.find.r) and (p.g=pinfo.find.g) and (p.b=pinfo.find.b) then p:=pinfo.replace
   else if pinfo.filteron then result:=pinfo.filter(p,pinfo);
   end;//end of if
//.transwhite - convert "non-transparentcolor" to "never white"
if pinfo.transwhite and (p.r=255) and (p.g=255) and (p.b=255) then
   begin
   //.shift to "offwhite"
   p.r:=254;
   p.g:=254;
   p.b:=254;
   end;//end of if
end;
//## plfGrey ##
function plfGrey(var p:trgbcolor;pinfo:ppixelinfo):boolean;
var
   z:byte;
begin
//defaults
result:=true;
//get
z:=p.r;
if (z<p.g) then z:=p.g;
if (z<p.b) then z:=p.b;
//set
p.r:=z;
p.g:=z;
p.b:=z;
end;
//## plfDisabled ##
function plfDisabled(var p:trgbcolor;pinfo:ppixelinfo):boolean;
var
   z:byte;
begin
//defaults
result:=true;
//get
z:=(p.r+round(p.g*0.90)+round(p.b*0.75)) div 3;
if (z<20) then z:=20
else if (z>230) then z:=230;
//set
p.r:=z;
p.g:=z;
p.b:=z;
end;
//## plfFocused ##
function plfFocused(var p:trgbcolor;pinfo:ppixelinfo):boolean;
const
   by=40;
var
   z:word;
begin
//defaults
result:=true;
//set
z:=p.r+by;if (z>255) then z:=255;p.r:=byte(z);
z:=p.g+by;if (z>255) then z:=255;p.g:=byte(z);
z:=p.b+by;if (z>255) then z:=255;p.b:=byte(z);
end;
//## plfNil ##
function plfNil(var p:trgbcolor;pinfo:ppixelinfo):boolean;
begin
result:=true;
end;

//########################### tvirtualimage ####################################
//## create ##
constructor tvirtualimage.create;
begin
//defaults
ifind:=clNone;
ireplace:=clNone;
ifind2:=clNone;
ireplace2:=clNone;
ihlen:=0;
iwidth:=0;
iheight:=0;
ibytes:=0;
iempty:=true;
//sysinfo
general.croll(virtualimages,1);
end;
//## destroy ##
destructor tvirtualimage.destroy;
begin
try
//controls
if ilocked then unlock;
//sysinfo
general.croll(virtualimages,-1);
//self
inherited;
except;end;
end;
//## setfiltersb ##
procedure tvirtualimage.setfiltersb(_style:tpixelstyle;_find,_replace,_find2,_replace2:integer);
begin
try;setfilters(filter,_style,_find,_replace,_find2,_replace2);except;end;
end;
//## setfilters ##
procedure tvirtualimage.setfilters(_filter:tpixelfilter;_style:tpixelstyle;_find,_replace,_find2,_replace2:integer);
begin
try
filter:=_filter;
style:=_style;
find:=_find;
replace:=_replace;
find2:=_find2;
replace2:=_replace2;
except;end;
end;
//## setwidth ##
procedure tvirtualimage.setwidth(x:integer);
begin
try;setparams(x,height);except;end;
end;
//## setheight ##
procedure tvirtualimage.setheight(x:integer);
begin
try;setparams(width,x);except;end;
end;
//## setparams ##
function tvirtualimage.setparams(w,h:integer):boolean;
label
   redo;
var
   ow,oh:integer;
begin
try
//defaults
result:=false;
ow:=w;
oh:=h;
redo:
try
//range
w:=frcmin(w,0);
h:=frcmin(h,0);
if (w=0) or (h=0) then
   begin
   w:=0;
   h:=0;
   end;//end of if
//.set
iwidth:=w;
iheight:=h;
iempty:=(w<=0) or (h<=0);
ibytes:=ihlen+(w*h*3);
//successful
result:=true;
except;end;
//.restore
if (not result) and (w<>ow) and (h<>oh) then
   begin
   w:=ow;
   h:=oh;
   goto redo;
   end;//end of if
except;end;
end;
//## getpixel ##
function tvirtualimage.getpixel(x,y:integer):integer;
begin
try;result:=clwhite;except;end;
end;
//## setpixel ##
procedure tvirtualimage.setpixel(x,y:integer;z:integer);
begin
{nil}
end;
//## getscanline ##
function tvirtualimage.getscanline(y:integer):pointer;
begin
result:=nil;//nil
end;
//## xyp ##
function tvirtualimage.xyp(x,y:integer;var p:integer):boolean;//xy coordinates to linear position
begin
try
//defaults
result:=false;
//check
if iempty then exit;
//process
if (x>=0) and (y>=0) and (x<iwidth) and (y<iheight) then
   begin
   p:=ihlen+1+((y*iwidth)+x)*3;
   //successful
   result:=true;
   end;//end of if
except;end;
end;
//## settext ##
procedure tvirtualimage.settext(x:string);
begin
try;if (x='') then setparams(0,0);except;end;
end;
//## gettext ##
function tvirtualimage.gettext:string;
begin
result:='';//nil
end;
//## settep ##
function tvirtualimage.settep(x:string;var e:string):boolean;
begin
try;result:=copyfromb(nil,x,nil,e);except;end;
end;
//## setbitmap ##
function tvirtualimage.setbitmap(x:tbitmap;var e:string):boolean;
begin
try;result:=copyfromb(x,'',nil,e);except;end;
end;
//## copyfrom ##
function tvirtualimage.copyfrom(x:tobject;var e:string):boolean;
begin
try;result:=copyfromb(x,'',nil,e);except;end;
end;
//## copyfromb ##
function tvirtualimage.copyfromb(x:tobject;tep:string;pf:tpixelfilter;var e:string):boolean;
label
   skipend;
var
   tmp,a:tbitmap;
   y:integer;
   s,d:trgbcolorrow;
begin
try
//defaults
result:=false;
e:=gecUnexpectedError;
tmp:=nil;
//process
//.image
e:=gecOutOfMemory;
if (x=nil) and (tep='') then setparams(0,0)
else if (x=nil) and (tep<>'') then
   begin
   //.get
   tmp:=ccs.glyph(tep);
   tmp.pixelformat:=pf24bit;
   //.set
   setparams(tmp.width,tmp.height);
   if not empty then
      begin
      iinfo.rmax:=iheight-1;
      for y:=0 to (iheight-1) do
      begin
      iinfo.rpos:=y;
      dorow(tmp.scanline[y],scanline[y],y,0,iwidth-1,false,true);
      end;//end of loop
      end;//end of if
   end
else if (x is tvirtualimage) then text:=(x as tvirtualimage).text
else if (x is tbitmap) then
   begin
   //.get
   a:=x as tbitmap;
   a.pixelformat:=pf24bit;
   //.set
   setparams(a.width,a.height);
   if not empty then
      begin
      iinfo.rmax:=iheight-1;
      for y:=0 to (iheight-1) do
      begin
      iinfo.rpos:=y;
      dorow(a.scanline[y],scanline[y],y,0,iwidth-1,false,true);
      end;//end of loop
      end;//end of if
   end
else if (x is tpicture) then
   begin
   //.get
   tmp:=tbitmap.create;
   tmp.width:=frcmin((x as tpicture).width,1);
   tmp.height:=frcmin((x as tpicture).height,1);
   tmp.pixelformat:=pf24bit;
   tmp.canvas.draw(0,0,(x as tpicture).graphic);
   //.set
   setparams(tmp.width,tmp.height);
   if not empty then
      begin
      iinfo.rmax:=iheight-1;
      for y:=0 to (iheight-1) do
      begin
      iinfo.rpos:=y;
      dorow(tmp.scanline[y],scanline[y],y,0,iwidth-1,false,true);
      end;//end of loop
      end;//end of if
   end;//end of if
//successful
result:=true;
skipend:
except;end;
try;freeObj(@tmp);except;end;
end;
//## setcolor ##
procedure tvirtualimage.setcolor(_color:integer);
var
   x,y:integer;
   r:prgbcolorrow;
   a:tint4;
   c:trgbcolor;
begin
try
//process
if not iempty then
   begin
   //.calc
   a.val:=_color;
   c.r:=a.bytes[0];
   c.g:=a.bytes[1];
   c.b:=a.bytes[2];
   //.cls
   for y:=0 to (iheight-1) do
   begin
   //..get
   r:=scanline[y];
   //..set
   for x:=0 to (iwidth-1) do r[x]:=c;
   end;//end of loop
   end;//end of if
except;end;
end;
//## lock ##
function tvirtualimage.lock:boolean;
var
   d,c,b,a:tint4;
begin
try
//defaults
result:=false;
//process
if (not ilocked) then
   begin
   ilocked:=true;
   ibuffer:=ccs.newbmp(frcmin(iwidth,1),1);
   //.pixelinfo
   a.val:=ifind;
   b.val:=ireplace;
   c.val:=ifind2;
   d.val:=ireplace2;
   with iinfo do
   begin
   //..transwhite
   transwhite:=(istyle=plsTranswhite);
   //..find
   find.r:=a.r;
   find.g:=a.g;
   find.b:=a.b;
   //..replace
   if transwhite and (b.r=255) and (b.g=255) and (b.b=255) then
      begin//offwhite instead, since "white" is being used by "transwhite"
      b.r:=254;
      b.g:=254;
      b.b:=254;
      end;//end of if
   replace.r:=b.r;
   replace.g:=b.g;
   replace.b:=b.b;
   //..find2
   usefind2:=(ifind2<>clNone);
   find2.r:=c.r;
   find2.g:=c.g;
   find2.b:=c.b;
   //..replace2
   if transwhite and (d.r=255) and (d.g=255) and (d.b=255) then
      begin//offwhite instead, since "white" is being used by "transwhite"
      d.r:=254;
      d.g:=254;
      d.b:=254;
      end;//end of if
   replace2.r:=d.r;
   replace2.g:=d.g;
   replace2.b:=d.b;
   //..style
   style:=istyle;
   //..filter
   filterON:=assigned(ifilter);
   if filterON then filter:=ifilter;
   //.other
   rpos:=0;
   rmax:=iheight-1;
   end;//end of with
   //.successful
   result:=true;
   end;//end of if
except;end;
end;
//## unlock ##
function tvirtualimage.unlock:boolean;
begin
try
//defaults
result:=false;
//process
if ilocked then
   begin
   freeObj(@ibuffer);
   ilocked:=false;
   result:=true;
   end;//end of if
except;end;
end;
//## dorow ##
procedure tvirtualimage.dorow(s,d:prgbcolorrow;y,xmin,xmax:integer;reverse,copy:boolean);//Updated: 19-JUN-2006
var//High-speed
   xp,x:integer;
   c:trgbcolor;
begin
try
//process
if reverse then
   begin
   for x:=xmin to xmax do
   begin
   c:=s[xmax-(x-xmin)];
   if copy then d[x-xmin]:=c
   else if plfMain(c,@iinfo) then d[x-xmin]:=c;
   end;//end of loop
   end
else
   begin
   for x:=xmin to xmax do
   begin
   c:=s[x];
   if copy then d[x-xmin]:=c
   else if plfMain(c,@iinfo) then d[x-xmin]:=c;
   end;//end of loop
   end;//end of if
except;end;
end;
//## pullrow ##
function tvirtualimage.pullrow(y:integer;reverse:boolean):boolean;
begin
try;result:=pullrowb(y,0,iwidth,reverse);except;end;
end;
//## pullrowb ##
function tvirtualimage.pullrowb(y,xstart,xcount:integer;reverse:boolean):boolean;
var
   xfinish:integer;
begin
try
//defaults
result:=false;
//process
if (ibuffer<>nil) and (not empty) then
   begin
   //.range
   xstart:=frcrange(xstart,0,iwidth-1);
   xfinish:=frcrange(xstart+xcount-1,0,iwidth-1);
   xcount:=xfinish-xstart+1;
   //.sync
   if (ibuffer.width<>xcount) then ibuffer.width:=xcount;
   if (ibuffer.height<>1) then ibuffer.height:=1;
   //.set
   iinfo.rpos:=y;
   //.row
   dorow(scanline[y],ibuffer.scanline[0],y,xstart,xfinish,reverse,false);
   //successful
   result:=true;
   end;//end of if
except;end;
end;
//## pullall ##
function tvirtualimage.pullall(flip,mirror:boolean):boolean;
begin
try;result:=pullallb(0,iwidth,flip,mirror);except;end;
end;
//## pullallb ##
function tvirtualimage.pullallb(xstart,xcount:integer;flip,mirror:boolean):boolean;
begin
try;result:=pullrowsb(0,iheight,xstart,xcount,flip,mirror);except;end;
end;
//## pullrows ##
function tvirtualimage.pullrows(ystart,ycount:integer;flip,mirror:boolean):boolean;
begin
try;result:=pullrowsb(ystart,ycount,0,iwidth,flip,mirror);except;end;
end;
//## pullrowsb ##
function tvirtualimage.pullrowsb(ystart,ycount,xstart,xcount:integer;flip,mirror:boolean):boolean;
var
   ysize,yfinish,xfinish,yp,y:integer;
begin
try
//defaults
result:=false;
//process
if (ibuffer<>nil) and (not empty) then
   begin
   //.range x
   xstart:=frcrange(xstart,0,iwidth-1);
   xfinish:=frcrange(xstart+xcount-1,0,iwidth-1);
   xcount:=xfinish-xstart+1;
   //.range x
   ystart:=frcrange(ystart,0,iheight-1);
   yfinish:=frcrange(ystart+ycount-1,0,iheight-1);
   ycount:=yfinish-ystart+1;
   //.sync
   if (ibuffer.width<>xcount) then ibuffer.width:=xcount;
   if (ibuffer.height<>ycount) then ibuffer.height:=ycount;
   //.scan
   iinfo.rmax:=yfinish;
   ysize:=yfinish-ystart;
   for y:=ystart to yfinish do
   begin
   iinfo.rpos:=y;
   if flip then yp:=(ysize-(y-ystart)) else yp:=y;
   dorow(scanline[yp],ibuffer.scanline[y-ystart],y,xstart,xfinish,mirror,false);
   end;//end of loop
   //successful
   result:=true;
   end;//end of if
except;end;
end;
//## pullraw ##
function tvirtualimage.pullraw:boolean;
var
   w,h,dx,dy:integer;
   r,r2:prgbcolorrow;
   zc:trgbcolor;
begin
try
//defaults
result:=false;
//process
if (ibuffer<>nil) and (not empty) then
   begin
   //check
   if (scanline[0]=nil) then exit;
   //init
   w:=frcmax(ibuffer.width,iwidth);
   h:=frcmax(ibuffer.height,iheight);
   //copy
   for dy:=0 to (h-1) do
   begin
   r:=scanline[dy];
   r2:=ibuffer.scanline[dy];
    for dx:=0 to (w-1) do
    begin
    zc:=r[dx];
    r2[dx]:=zc;
    end;//end of loop
   end;//end of loop
   //successful
   result:=true;
   end;//end of if
except;end;
end;

//############################# tvirtualbitmap #################################
//## newvb ##
function newvb(tep:string):tvirtualbitmap;//new virtualbitmap
var
   e:string;
begin
try
result:=tvirtualbitmap.create;
if (tep<>'') then result.settep(tep,e);
except;end;
end;
//## create ##
constructor tvirtualbitmap.create;
begin
//self
inherited create;
//controls
new(idata);
//vars
ihlen:=12;
//defaults
setparams(0,0);
end;
//## destroy ##
destructor tvirtualbitmap.destroy;
begin
try
//controls
dispose(idata);
//self
inherited;
except;end;
end;
//## setparams ##
function tvirtualbitmap.setparams(w,h:integer):boolean;
label
   skipend,redo;
var
   ow,oh:integer;
   tmp:string;
begin
try
//defaults
result:=false;
ow:=w;
oh:=h;
redo:
try
//self
if (not inherited setparams(w,h)) then goto skipend;
//check
if (idata=nil) then goto skipend;
//process
//.header
tmp:='VB01'+from32bit(w)+from32bit(h);
if (length(idata^)<12) then idata^:=tmp else io.inserttext(idata^,tmp,1);
//.data
if (length(idata^)<>ibytes) then setlength(idata^,ibytes);
//successful
result:=true;
skipend:
except;end;
//.restore
if (not result) and (w<>ow) and (h<>oh) then
   begin
   w:=ow;
   h:=oh;
   goto redo;
   end;//end of if
except;end;
end;
//## getpixel ##
function tvirtualbitmap.getpixel(x,y:integer):integer;
var
   a:tint4;
   p:integer;
begin
try
//process
if xyp(x,y,p) then
   begin
   //.get (bgr -> rgb)
   a.chars[2]:=idata^[p+0];//blue
   a.chars[1]:=idata^[p+1];//green
   a.chars[0]:=idata^[p+2];//red
   a.chars[3]:=#0;
   //.set
   result:=a.val;
   end
else result:=clwhite;
except;end;
end;
//## setpixel ##
procedure tvirtualbitmap.setpixel(x,y:integer;z:integer);
var
   a:tint4;
   p:integer;
begin
try
//process
if xyp(x,y,p) then
   begin
   //.get
   a.val:=z;
   //.set (rgb -> bgr)
   idata^[p+0]:=a.chars[2];//blue
   idata^[p+1]:=a.chars[1];//green
   idata^[p+2]:=a.chars[0];//red
   end;//end of if
except;end;
end;
//## settext ##
procedure tvirtualbitmap.settext(x:string);
var
   w,h:integer;
begin
try
if (length(x)<ihlen) or (copy(x,1,4)<>'VB01') then setparams(0,0)
else
   begin
   w:=to32bit(copy(x,5,4));
   h:=to32bit(copy(x,9,4));
   if (w<=0) or (h<=0) then setparams(0,0)
   else
      begin
      idata^:=x;
      inherited setparams(w,h);
      //.size mismatch
      if (ibytes<>length(idata^)) then setparams(0,0);
      end;//end of if
   end;//end of if
except;end;
end;
//## gettext ##
function tvirtualbitmap.gettext:string;
begin
try;result:=idata^;except;end;
end;
//## getscanline ##
function tvirtualbitmap.getscanline(y:integer):pointer;
begin
try
//defaults
result:=nil;
//process
if (y>=0) and (y<iheight) then result:=pointer(longint(idata^)+ihlen+(y*iwidth*3));
except;end;
end;

//## tvirtualbitmapanimated ####################################################
//## create ##
constructor tvirtualbitmapanimated.create(_host:tvirtualcontrol);
begin
//vars
host:=_host;
irun:=true;
izeroframe:=true;
//controls
//.iimage
iimage:=tvirtualbitmap.create;
//.itimer
itimer:=mtNilTimer;
//defaults
ipai:=@iai;
ccs.aiClear(iai);
end;
//## destroy ##
destructor tvirtualbitmapanimated.destroy;
begin
try
//sysinfo
if (iai.count>=2) then general.croll(virtualanimations,-1);
//timer
mt.del(itimer);
//controls
freeobj(@iimage);
//self
inherited;
except;end;
end;
//## loadfromfile ##
function tvirtualbitmapanimated.loadfromfile(x:string;var e:string):boolean;
var
   a:tbitmapenhanced;
begin
try
//defaults
result:=false;
e:=gecOutOfMemory;
a:=nil;
//process
a:=tbitmapenhanced.create;
if ccs.fromfile(a,x,e) then result:=copyfrom(a,e);
except;end;
try;freeobj(@a);except;end;
end;
//## _ontimer ##
procedure tvirtualbitmapanimated._ontimer(sender:tobject);
var
   p:integer;
begin
try
//process
//.paint
if canpaint then
   begin
   if assigned(onprepaint) then onprepaint(self);
   if (host<>nil) then host.paint;
   if assigned(onpaint) then onpaint(self);
   if assigned(onpostpaint) then onpostpaint(self);
   end;//end of if
//.inc
if irun then
   begin
   //.range
   p:=iai.itemindex+1;
   if (p>=iai.count) then p:=0;
   //.set
   iai.itemindex:=p;
   end;//end of if
except;end;
end;
//## getempty ##
function tvirtualbitmapanimated.getempty:boolean;
begin
try;result:=(iai.count=0) or iimage.empty;except;end;
end;
//## setanimationb ##
procedure tvirtualbitmapanimated.setanimationb(x:string);
var
   e:string;
begin
try;setanimation(x,e);except;end;
end;
//## setanimation ##
function tvirtualbitmapanimated.setanimation(x:string;var e:string):boolean;
var
   a:tbitmapenhanced;
begin
try
//defaults
result:=false;
e:=gecOutOfMemory;
a:=nil;
//process
//.get
a:=tbitmapenhanced.create;
a.dtransparent:=dtransparent;
//.set
if (x='') then copyfrom(a,e)
else if ccs.fromdata(a,x,e) then result:=copyfrom(a,e);
//.paint
paint;
except;end;
try;freeobj(@a);except;end;
end;
//## copyfrom ##
function tvirtualbitmapanimated.copyfrom(x:tobject;var e:string):boolean;
var
   tmp:tanimationinformation;
begin
try
//clear
ccs.aiClear(tmp);
//get
if (x is tbitmapenhanced) then tmp:=(x as tbitmapenhanced).ai
else if (x is tvirtualbitmapanimated) then tmp:=(x as tvirtualbitmapanimated).ai;
//set
result:=copyfromb(x,'',nil,tmp.count,tmp.delay,tmp.transparent,tmp.flip,tmp.mirror,true,e);
except;end;
end;
//## copyfromb ##
function tvirtualbitmapanimated.copyfromb(x:tobject;tep:string;pf:tpixelfilter;_count,_delay:integer;_transparent,_flip,_mirror,_run:boolean;var e:string):boolean;
var
   tmp:tanimationinformation;
begin
try
//sysinfo - was an animation so decrease system counter
if (ai.count>=2) then general.croll(virtualanimations,-1);
//get
tmp:=ai;
tmp.itemindex:=0;
tmp.count:=_count;
tmp.delay:=_delay;
tmp.transparent:=_transparent;
tmp.flip:=_flip;
tmp.mirror:=_mirror;
result:=iimage.copyfromb(x,tep,pf,e);
//set
ai:=tmp;
//sysinfo - is an animation so increase system counter
if (tmp.count>=2) then general.croll(virtualanimations,1);
except;end;
end;
//## setai ##
procedure tvirtualbitmapanimated.setai(x:tanimationinformation);
begin
try;setparams(x,true);except;end;
end;
//## setparams ##
function tvirtualbitmapanimated.setparams(x:tanimationinformation;_paint:boolean):boolean;
begin
try
//defaults
result:=false;
//range
x.count:=frcmin(x.count,0);
x.itemindex:=frcrange(x.itemindex,0,x.count-1);
x.delay:=frcmin(x.delay,0);
if (x.count<=0) then x.cellwidth:=0 else x.cellwidth:=(iimage.width div x.count);
x.cellheight:=frcmin(iimage.height,0);
if (x.count<=0) or (x.delay<=0) then x.itemindex:=0;
//decide
if (x.count<>iai.count) or
   (x.itemindex<>iai.itemindex) or
   (x.cellwidth<>iai.cellwidth) or
   (x.cellheight<>iai.cellheight) or
   (x.delay<>iai.delay) or
   (x.transparent<>iai.transparent) or
   (x.flip<>iai.flip) or
   (x.mirror<>iai.mirror) then
   begin
   //set
   iai:=x;
   //modified
   result:=true;
   //paint
   if _paint then paint;
   //timer
   synctimer;
   end;//end of if
except;end;
end;
//## setrun ##
procedure tvirtualbitmapanimated.setrun(x:boolean);
begin
try
if general.setbol(x,irun) then
   begin
   paint;
   synctimer;
   end;//end of if
except;end;
end;
//## synctimer ##
procedure tvirtualbitmapanimated.synctimer;
begin
try
if irun and (iai.delay>=1) and (iai.count>=1) and (not iimage.empty) then
   begin
   if (itimer=mtNilTimer) then itimer:=mt.new(_ontimer,iai.delay,true)
   else mt.interval[itimer]:=iai.delay;
   end
else if (itimer<>mtNilTimer) then mt.del(itimer);
except;end;
end;
//## canpaint ##
function tvirtualbitmapanimated.canpaint:boolean;
begin
try;result:=(((host<>nil) and host.canpaint) or (host=nil)) and (iai.count>=1) and (not iimage.empty);except;end;
end;
//## paint ##
procedure tvirtualbitmapanimated.paint;
begin
try
//check
if not canpaint then exit;
if ipainting then exit;
//lock
ipainting:=true;
//process
if assigned(onprepaint) then onprepaint(self);
if (host<>nil) then host.paint;
if assigned(onpaint) then onpaint(self);
if assigned(onpostpaint) then onpostpaint(self);
except;end;
//unlock
try;ipainting:=false;except;end;
end;
//## getpixel ##
function tvirtualbitmapanimated.getpixel(x,y:integer):integer;
begin
try
//defaults
result:=clNone;
//process
if (not iimage.empty) then
   begin
   x:=(iai.itemindex*iai.cellwidth)+x;
   result:=iimage.pixels[x,y];
   end;//end of if
except;end;
end;
//## gettransparentcolor ##
function tvirtualbitmapanimated.gettransparentcolor:integer;
begin
try;result:=getpixel(0,0);except;end;
end;
//## drawto ##
procedure tvirtualbitmapanimated.drawto(canvas:tcanvas;area:trect;linebyline:boolean;filter:tpixelfilter;background,fontcolor:integer);
var//area: left=xstart, top=ystart, right=xcount, bottom=ycount
   //paints image independantly of "ai.itemindex", so correct painting is achieved
   s:tpixelstyle;
   tc,f,p,yp,xstart,xcount,ycount,y:integer;
begin
try
//check
if (canvas=nil) then exit;
//init
xcount:=frcrange(area.right,0,iai.cellwidth);
ycount:=frcrange(area.bottom,0,iai.cellheight);
p:=iai.itemindex;
//range
if (iai.count<=0) or (iai.delay<=0) or iimage.empty then p:=0
else if (not irun) and izeroframe then p:=0
else p:=iai.itemindex;
xstart:=p*iai.cellwidth;
//check
if (xcount<=0) or (ycount<=0) then exit;
//get
//.filters
if (not iimage.empty) then tc:=iimage.pixels[xstart,0] else tc:=clNone;
if iai.transparent then s:=plsReplace else s:=plsSolid;
if (fontcolor=clNone) then f:=clNone else f:=0;
//.setfilters
iimage.setfilters(filter,s,tc,background,f,fontcolor);
//.lock
iimage.lock;
//.get
if linebyline then
   begin
   for y:=0 to (ycount-1) do
   begin
   if iai.flip then yp:=(ycount-1)-y else yp:=y;
   iimage.pullrowb(yp,xstart,xcount,iai.mirror);
   canvas.draw(area.left,area.top+y,iimage.buffer);
   end;//end of loop
   end
else
   begin
   iimage.pullrowsb(0,ycount,xstart,xcount,iai.flip,iai.mirror);
   canvas.draw(area.left,area.top,iimage.buffer);
   end;//end of if
except;end;
//.unlock
try;iimage.unlock;except;end;
end;
//## drawtoex ##
procedure tvirtualbitmapanimated.drawtoex(dest:tbitmap;area:trect;linebyline:boolean;filter:tpixelfilter;background,fontcolor:integer);
var//area: left=xstart, top=ystart, right=xcount, bottom=ycount
   //paints image independantly of "ai.itemindex", so correct painting is achieved
   s:tpixelstyle;
   tmpx,dh,dw,dy,dx,tc,f,p,yp,xstart,xcount,ycount,y:integer;
   dr,sr:prgbcolorrow;
   t,zc:trgbcolor;
   tok:boolean;
begin
try
//check
if (dest=nil) or (not ccs.nonempty24(dest)) then exit;
//init
xcount:=frcrange(area.right,0,iai.cellwidth);
ycount:=frcrange(area.bottom,0,iai.cellheight);
p:=iai.itemindex;
tok:=false;
//range
if (iai.count<=0) or (iai.delay<=0) or iimage.empty then p:=0
else if (not irun) and izeroframe then p:=0
else p:=iai.itemindex;
xstart:=p*iai.cellwidth;
//check
if (xcount<=0) or (ycount<=0) then exit;
//get
//.filters
tok:=iai.transparent;
tc:=clNone;
if (not iimage.empty) then
   begin
   tc:=iimage.pixels[xstart,0];
   t:=ccs.intrgb(tc);
   end;//end of if
if tok then s:=plsTranswhite else s:=plsSolid;
if (fontcolor=clNone) then f:=clNone else f:=0;
//.setfilters
iimage.setfilters(filter,s,tc,background,f,fontcolor);
//.lock
iimage.lock;
//.get
dw:=dest.width;
dh:=dest.height;
for y:=0 to (ycount-1) do
begin
if iai.flip then yp:=(ycount-1)-y else yp:=y;
iimage.pullrowb(yp,xstart,xcount,iai.mirror);
sr:=iimage.buffer.scanline[0];
//.set
dy:=area.top+y;
if (dy>=0) and (dy<dh) then
   begin
   dr:=dest.scanline[dy];
   for tmpx:=0 to (iai.cellwidth-1) do
   begin
   dx:=area.left+tmpx;
   if (dx>=0) and (dx<dw) then
      begin
      zc:=sr[tmpx];
      //.draw pixel transparently if required
      if (not tok) or (not ((zc.r=255) and (zc.g=255) and (zc.b=255))) then dr[dx]:=zc;
      end;//end of if
   end;//end of loop - x
   end;//end of if
end;//end of loop - y
except;end;
//.unlock
try;iimage.unlock;except;end;
end;

//## tvirtualiconanimated ######################################################
//## create ##
constructor tvirtualiconanimated.create;
begin
//self
inherited create;
//vars
imasterrun:=true;
//controls
iicons:=tdynamicstring.create;
//timer
itimer:=mt.new(_ontimer,1000,false);
//sysinfo
general.croll(virtualanimations,1);
end;
//destroy ##
destructor tvirtualiconanimated.destroy;
begin
try
//sysinfo
general.croll(virtualanimations,-1);
//timer
mt.del(itimer);
//event
onchange:=nil;
//controls
freeobj(@iicons);
//self
inherited destroy;
except;end;
end;
//## _ontimer ##
procedure tvirtualiconanimated._ontimer(sender:tobject);
begin
try;paint;except;end;
end;
//## setanimation ##
procedure tvirtualiconanimated.setanimation(x:string);
var
   a:tvirtualbitmapanimated;
   b:tbitmapenhanced;
   c:tbitmap;
   e,z:string;
   dw,dh,p:integer;
   darea:trect;
begin
try
//defaults
a:=nil;
b:=nil;
c:=nil;
//clear
mt.enabled[itimer]:=false;
ipaintindex:=0;
iicons.clear;
a:=tvirtualbitmapanimated.create(nil);
b:=tbitmapenhanced.create;
//get
a.animation:=x;
a.run:=false;
a.zeroframe:=false;//draw specified frame even when not running
b:=tbitmapenhanced.create;
//set
for p:=0 to (a.ai.count-1) do
begin
ccs.aiClear(b.ai);
ccs.size(b,32,32);
b.ai.transparent:=a.ai.transparent;
b.ai.format:='ico';
b.ai.subformat:='';
a.pai.itemindex:=p;
if (b.width=a.ai.cellwidth) and (b.height=a.ai.cellheight) then a.drawto(b.canvas,rect(0,0,b.width,b.height),true,nil,clNone,clNone)
else
   begin
   //get
   if (c=nil) then c:=ccs.newbmp(a.ai.cellwidth,a.ai.cellheight);
   a.drawto(c.canvas,rect(0,0,c.width,c.height),true,nil,clNone,clNone);
   //calc
   ccs.scaledown(b.width,b.width,c.width,c.height,dw,dh);
   darea.left:=(b.width-dw) div 2;
   darea.top:=(b.height-dh) div 2;
   darea.right:=darea.left+dw-1;
   darea.bottom:=darea.top+dh-1;
   //copy
   if not ccs.stretchdraw(darea,b,c,clNone) then break;
   end;//end of if
//convert
if not ccs.todata(b,z,e) then break;
//store
iicons.value[iicons.count]:=z;
end;//end of loop
//restore
if (iicons.count>=2) then mt.interval[itimer]:=a.ai.delay else mt.interval[itimer]:=1000;
syncrun;
//update
if (iicons.count<2) or (a.ai.delay>=500) then paint;
except;end;
try
freeobj(@a);
freeobj(@b);
freeobj(@c);
except;end;
end;
//## paint ##
procedure tvirtualiconanimated.paint;
label
   skipend;
var
   a:ticon;
   b:tstreamstr;
   y:string;
   p:integer;
begin
try
//defaults
a:=nil;
b:=nil;
//check
if ipainting then exit else ipainting:=true;
if (iicons.count=0) then goto skipend;
//get
p:=frcrange(ipaintindex,0,iicons.count-1);
y:=iicons.value[p];
//set
a:=ticon.create;
b:=tstreamstr.create(@y);
a.loadfromstream(b);
//paint
if assigned(onchange) then onchange(self,a);
if iapp then application.icon.assign(a);
//inc
inc(p);
if (p>=iicons.count) then p:=0;
ipaintindex:=p;
skipend:
except;end;
try
ipainting:=false;
freeobj(@a);
freeobj(@b);
except;end;
end;
//## getcanrun ##
function tvirtualiconanimated.getcanrun:boolean;
begin
try;result:=(iicons.count>=2);except;end;
end;
//## getcount ##
function tvirtualiconanimated.getcount:integer;
begin
try;result:=iicons.count;except;end;
end;
//## setrun ##
procedure tvirtualiconanimated.setrun(x:boolean);
begin
try;if general.setbol(x,irun) then syncrun;except;end;
end;
//## setmasterrun ##
procedure tvirtualiconanimated.setmasterrun(x:boolean);
begin
try;if general.setbol(x,imasterrun) then syncrun;except;end;
end;
//## syncrun ##
procedure tvirtualiconanimated.syncrun;
var
   a:boolean;
begin
try
//get
a:=imasterrun and irun;
//set
if (iicons.count>=2) and (mt.enabled[itimer]<>a) then
   begin
   mt.enabled[itimer]:=a;
   if not a then ipaintindex:=0;
   paint;
   end;//end of if
except;end;
end;

//############################# tsampleint #####################################
//## create ##
constructor tsampleint.create;
begin
//controls
ivalues:=tdynamicinteger.create;
//defaults
size:=10;
clear;
end;
//## destroy ##
destructor tsampleint.destroy;
begin
try
//controls
freeObj(@ivalues);
//self
inherited;
except;end;
end;
//## clear ##
procedure tsampleint.clear;
var
   p:integer;
begin
try
ipushcount:=0;
for p:=0 to (size-1) do ivalues.items[p]:=0;
update;
except;end;
end;
//## getsize ##
function tsampleint.getsize:integer;
begin
try;result:=ivalues.size;except;end;
end;
//## setsize ##
procedure tsampleint.setsize(x:integer);
begin
try
//range
x:=frcmin(x,1);
//check
if (x=size) then exit;
//set
ivalues.setparams(x,x,0);
update;
except;end;
end;
//## push ##
procedure tsampleint.push(x:integer);
var
   p:integer;
begin
try
//check
if (size<=0) then exit;
//shift by one
for p:=(size-1) downto 1 do ivalues.items[p]:=ivalues.items[p-1];
//set
ivalues.items[0]:=x;
//inc
general.irollb(ipushcount,1,1);
//update
update;
except;end;
end;
//## getvalue ##
function tsampleint.getvalue(x:integer):integer;
begin
try
if (x>=0) and (x<size) then result:=ivalues.value[x]
else result:=0;
except;end;
end;
//## setvalue ##
procedure tsampleint.setvalue(x,y:integer);
begin
try
if (x>=0) and (x<size) then
   begin
   ivalues.value[x]:=y;
   update;
   end;//end of if
except;end;
end;
//## update ##
procedure tsampleint.update;
var
   maxp,p,tmp:integer;
begin
try
//defaults
tmp:=0;
maxp:=frcmax(ipushcount-1,size-1);
//process
if (maxp>=0) then
   begin
   //.get
   for p:=0 to maxp do if (p=0) then tmp:=ivalues.items[p] else general.iroll(tmp,ivalues.items[p]);
   //.set
   tmp:=tmp div (maxp+1);
   end;//end of if
except;end;
try;iave:=tmp;except;end;
end;

//######################## trolltext ###########################################
//## create ##
constructor trolltext.create;
begin
inherited;
//controls
iitems:=tdynamicstring.create;
//vars
ialltext:=true;
iposition:=0;
end;
//## destroy ##
destructor trolltext.destroy;
begin
try
//controls
freeObj(@iitems);
//self
inherited;
except;end;
end;
//## getsize ##
function trolltext.getsize:integer;
begin
try;result:=iitems.size;except;end;
end;
//## flush ##
procedure trolltext.flush;
var
   p:integer;
begin
try
iposition:=0;
for p:=0 to (size-1) do iitems.items[p]^:='';
except;end;
end;
//## setsize ##
procedure trolltext.setsize(x:integer);
begin
try
//enforce range
x:=frcmin(x,0);
//set
if (iitems.size<>x) then
   begin
   //.reset
   flush;
   //.set
   iitems.size:=x;
   iitems.count:=x;
   end;//end of if
except;end;
end;
//## roll
procedure trolltext.roll(x:string);
var
   p:integer;
begin
try
//process
//.check
if (size=0) then exit;
//.get
p:=iposition;
inc(p);
if (p>=size) then p:=0;
//.set
iitems.items[p]^:=x;
iposition:=p;
except;end;
end;
//## gettext ##
function trolltext.gettext:string;
var
   len,p:integer;
   tmp:string;
begin
try
//defaults
result:='';
len:=0;
//get
for p:=0 to (size-1) do
begin
tmp:=items[p];
if (ialltext or (tmp<>'')) then pushb(len,result,tmp+rcode);
end;//end of loop
//finalise
pushb(len,result,'');
except;end;
end;
//## getitemindex ##
function trolltext.getitemindex(x:integer):integer;
var
   s:integer;
begin
try
//defaults
result:=-1;
s:=size;
//get
if (s=0) or (x<0) or (x>=s) then exit;
x:=iposition-x;
if (x<0) then inc(x,s)
else if (x>=s) then dec(x,s);
//set
result:=frcrange(x,0,s-1);
except;end;
end;
//## getitem ##
function trolltext.getitem(x:integer):string;
begin
try
x:=getitemindex(x);
if (x>=0) then result:=iitems.items[x]^ else result:='';
except;end;
end;
//## getlines ##
function trolltext.getlines(x:integer;up:boolean):string;
var
   tmp:tstringlist;
   rclen,len,p:integer;
   z:string;
begin
try
//defaults
result:='';
len:=0;
tmp:=nil;
//check
if (x<=0) then exit;
//init
rclen:=length(rcode);
//get
for p:=0 to (size-1) do
begin
z:=items[p];
if ialltext or (z<>'') then
   begin
   if ((len+length(z)+rclen)<=x) then pushb(len,result,z+rcode)
   else break;
   end;//end of if
end;//end of loop
//finalise
pushb(len,result,'');
//up
if up then
   begin
   tmp:=tstringlist.create;
   tmp.text:=result;
   len:=0;
   result:='';
   for p:=(tmp.count-1) downto 0 do if (tmp.strings[p]<>'') then pushb(len,result,tmp.strings[p]+rcode);
   //.finalise
   pushb(len,result,'');
   end;//end of if
except;end;
try;freeobj(@tmp);except;end;
end;

//########################## tscrolltext #######################################
//## create ##
constructor tscrolltext.create;
begin
inherited;
//controls
icore:=tdynamicstring.create;
//vars
alltext:=true;
iposition:=-1;
end;
//## destroy ##
destructor tscrolltext.destroy;
begin
try
//controls
freeObj(@icore);
//self
inherited;
except;end;
end;
//## gettext ##
function tscrolltext.gettext:string;
var
   len,p:integer;
begin
try
//defaults
result:='';
len:=0;
//process
//.get
for p:=0 to (icore.count-1) do pushb(len,result,icore.items[p]^+rcode);
//.finalise
pushb(len,result,'');
except;end;
end;
//## settext ##
procedure tscrolltext.settext(x:string);
var
   _pos,_start,_length:integer;
begin
try
//defaults
clear;
_pos:=1;
//process
//.set
while general.readline(_pos,_start,_length,x) do if ((_length>=1) or alltext) then icore.value[icore.count]:=copy(x,_start,_length);
except;end;
end;
//## clear ##
procedure tscrolltext.clear;
begin
try
icore.clear;
iposition:=-1;
except;end;
end;
//## pull ##
function tscrolltext.pull:string;
var
   p:integer;
begin
try
//defaults
result:='';
//check
if (icore.count=0) then exit;
//process
//.inc
p:=iposition+1;
if (p<0) then p:=0 else if (p>=count) then p:=0;
//.get
result:=icore.items[p]^;
//.set
iposition:=p;
except;end;
end;
//## getcount ##
function tscrolltext.getcount:integer;
begin
try;result:=icore.count;except;end;
end;

//###################### tnamevalue ############################################
//## create ##
constructor tnamevalue.create;
begin
inherited;
//n+v
iio:=newio;
iin:=tdynamicname.create;
iiv:=tdynamicstring.create;
iionames:='';
inativeformat:=tiohLST;
end;
//## destroy ##
destructor tnamevalue.destroy;
begin
try
//controls
freeObj(@iio);
freeObj(@iin);
freeObj(@iiv);
//self
inherited;
except;end;
end;
//## copyfrom ##
procedure tnamevalue.copyfrom(s:tnamevalue;_mask:string);
begin
try;copyfromex(s,_mask,true);except;end;
end;
//## copyfromex ##
procedure tnamevalue.copyfromex(s:tnamevalue;_mask:string;_unpack:boolean);
var
   i,p:integer;
   e,v,n:string;
begin
try
//check
if (s=nil) then exit;
if (_mask='') then _mask:='*';
//scan
for p:=0 to (s.count-1) do
begin
n:=s.names[p];
if (n<>'') and general.inf(n,_mask) then
   begin
   //get
   v:=s.valuesi[p];
   //unpack
   if (not _unpack) or io.fromC(v,e) then
      begin
      i:=newname(n);
      if (i>=0) then valuesi[i]:=v;
      end;//end of if
   end;//end of if
end;//end of loop
except;end;
end;
//## setnativeformat ##
procedure tnamevalue.setnativeformat(x:integer);
begin
try
//enforce range
if not ((x=tiohEAT) or (x=tiohLST) or (x=tiohMTXT)) then x:=tiohLST;
//set
if (x<>nativeformat) then inativeformat:=x;
except;end;
end;
//## ias ##
function tnamevalue.ias(_names:string):integer;//items as size
var
   a:tstringlist;
   i,p:integer;
   z:pstring;
begin
try
//defaults
result:=0;
//prepare
a:=nil;
a:=tstringlist.create;
a.text:=_names;
//process
for p:=0 to (a.count-1) do
begin
i:=findname(a.strings[p]);
if (i>=0) then
   begin
   result:=result+length(a.strings[p]);
   z:=valuesptr[i];if (z<>nil) then result:=result+length(z^);
   end;//end of if
end;//end of loop
except;end;
try;freeobj(@a);except;end;
end;
//## getionames ##
function tnamevalue.getionames:string;
begin//used by IO system to determine what items to write
try;if (iIONAMES='') then result:=allnames else result:=iIONAMES;except;end;
end;
//## allnames ##
function tnamevalue.allnames:string;
begin
try;result:=allnamesex(rcode,false);except;end;
end;
//## allnamesex ##
function tnamevalue.allnamesex(sep:string;aslabels:boolean):string;
var
   _len,p:integer;
   z:string;
begin
try
//defaults
result:='';
_len:=0;
//process
//.get
for p:=0 to (iin.count-1) do
begin
z:=iin.items[p]^;
if (z<>'') then
   begin
   if aslabels then
      begin
      z:=extractfilename(z);
      z:=general.remlastext(z);
      z:=general.asname(z);
      end;//end of if
   if (z<>'') then pushb(_len,result,z+sep);
   end;//end of if
end;//end of loop
//.finalise
pushb(_len,result,'');
except;end;
end;
//## clear ##
procedure tnamevalue.clear;
begin
try
iin.clear;
iiv.clear;
except;end;
end;
//## getname ##
function tnamevalue.getname(x:integer):string;
begin
try;result:=iin.value[x];except;end;
end;
//## findmask ##
function tnamevalue.findmask(i,e:string):integer;
var
   a:tstringlist;
   b:tio;
   p:integer;
begin
try
//not found
result:=-1;
//prepare
a:=nil;
b:=newio;
a:=tstringlist.create;
b.mask.init(i,e);
a.text:=allnames;
//process
for p:=0 to (a.count-1) do if b.mask.inmask(a.strings[p]) then
    begin
    result:=findname(a.strings[p]);
    break;
    end;//end of if
except;end;
try;freeobj(@a);freeobj(@b);except;end;
end;
//## findname ##
function tnamevalue.findname(x:string):integer;
begin
try;if (x='') then result:=-1 else result:=_findname(x);except;end;
end;
//## _findname ##
function tnamevalue._findname(x:string):integer;
begin
try;result:=iin.findfast(0,x);except;end;
end;
//## newname ##
function tnamevalue.newname(x:string):integer;
var
   p:integer;
begin
try
//error
result:=-1;
//process
//.search
p:=findname(x);
//.new
if (p=-1) then
   begin
   //.next EMPTY item
   p:=iin.findfast(0,'');
   //.add new item
   if (p=-1) then
      begin
      p:=count;
      if (p>=limit) then exit;
      end;//end of if
   //.set
   iin.value[p]:=uppercase(x);
   iiv.value[p]:='';
   end;//end of if
//return result
result:=p;
except;end;
end;
//## getvalue ##
function tnamevalue.getvalue(x:string):string;
var
   z:pstring;
begin
try;z:=getvalueptr(findname(x));if (z=nil) then result:='' else result:=z^;except;end;
end;
//## getvaluei ##
function tnamevalue.getvaluei(x:integer):string;
begin
try;if (x>=0) and (x<count) then result:=iiv.value[x] else result:='';except;end;
end;
//## setvaluei ##
procedure tnamevalue.setvaluei(x:integer;y:string);
begin
try;if (x>=0) and (x<count) then iiv.value[x]:=y;except;end;
end;
//## getvalueptr ##
function tnamevalue.getvalueptr(x:integer):pstring;
begin
try;if (x>=0) and (x<count) then result:=iiv.items[x] else result:=nil;except;end;
end;
//## inuse ##
function tnamevalue.inuse(x:string):boolean;
var
   p:integer;
begin
try;p:=findname(x);result:=(p<>-1) and (iin.value[p]<>'');except;end;
end;
//## del ##
procedure tnamevalue.del(x:string;eatINFO:boolean);
var
   a:tstringlist;
   i,p:integer;
   z:string;
begin
try
//prepare
a:=nil;
a:=tstringlist.create;
a.text:=x;
//process
for p:=0 to (a.count-1) do
begin
z:=a.strings[p];
if (z<>'') and (z[1]<>'|') then
   begin
   i:=findname(z);
   if (i<>-1) then
      begin
      iin.value[i]:='';
      iiv.value[i]:='';
      end;//end of if
   if eatINFO then
      begin
      i:=findname('|'+z);
      if (i<>-1) then
         begin
         iin.value[i]:='';
         iiv.value[i]:='';
         end;//end of if
      end;//end of if
   end;//end of if
end;//end of loop
except;end;
try;freeobj(@a);except;end;
end;
//## setvalue ##
procedure tnamevalue.setvalue(x:string;y:string);
var
   p:integer;
begin
try
//check
if (x='') then exit;
//process
//.search
p:=findname(x);
//.new
if (p=-1) then
   begin
   //.next EMPTY item
   p:=_findname(x);
   //.add new item
   if (p=-1) then
      begin
      p:=count;
      if (p>=limit) then exit;
      end;//end of if
   //.set
   iin.value[p]:=uppercase(x);
   end;//end of if
//.set
iiv.value[p]:=y;
except;end;
end;
//## count ##
function tnamevalue.count:integer;
begin
try;result:=iin.count;except;end;
end;
//## usedcount ##
function tnamevalue.usedcount:integer;
var
   p:integer;
begin
try
//prepare
result:=0;
//process
for p:=0 to (count-1) do if (iin.value[p]<>'') then result:=result+1;
except;end;
end;
//## limit ##
function tnamevalue.limit:integer;
begin
try;result:=iin.limit;except;end;
end;
//## gettext ##
function tnamevalue.gettext:string;
var
   e:string;
begin
try;pull(tiohLST,result,e);except;end;
end;
//## settext ##
procedure tnamevalue.settext(x:string);
var
   e:string;
begin
try;push(tiohLST,x,e);except;end;
end;
//## push ##
function tnamevalue.push(_format:integer;var x,e:string):boolean;
begin
try;if (_format<0) then _format:=tiohLST;result:=iio.decode(x,self,_format,e);except;end;
end;
//## pull ##
function tnamevalue.pull(_format:integer;var x,e:string):boolean;
begin
try;if (_format<0) then _format:=tiohLST;result:=iio.encode(x,self,_format,e);except;end;
end;
//## savetofile ##
function tnamevalue.savetofile(x:string;var e:string):boolean;
label
     skipend;
var
   z,ext:string;
   _format:integer;
begin
try
//prepare
result:=false;
e:=gecOutOfMemory;
//process
//.decide
ext:=readfileext(x,true);
if (ext='EAT') then _format:=tiohEAT
else if (ext='BMP') then _format:=tiohBMP
else if (ext='C') then _format:=tiohC
else if (ext='TXT') then _format:=tiohMTXT
//LST or SCH etc...
else _format:=tiohLST;
//.get
if not pull(_format,z,e) then goto skipend;
//.set
if not iio.toFILE(x,z,e) then goto skipend;
//successful
result:=true;
skipend:
except;end;
end;
//## loadfromfile ##
function tnamevalue.loadfromfile(x:string;_format:integer;var e:string):boolean;
label
     skipend;
var
   z:string;
begin
try
//prepare
result:=false;
e:=gecOutOfMemory;
//process
//.get
if not iio.fromFILE(x,z,e) then goto skipend;
//.set
if not push(_format,z,e) then goto skipend;
//successful
result:=true;
skipend:
except;end;
end;

//###################### tmultilingual #########################################
//## create ##
constructor tmultilingual.create;
begin
inherited;
//vars
fillchar(iactive,sizeof(iactive),0);
ipactive:=@iactive;
fillchar(ihit,sizeof(ihit),0);
iphit:=@ihit;
//controls
ieng:=tdynamicnamelist.create;
ioth:=tdynamicstring.create;
iinuse:=tdynamicboolean.create;
isyserr:=tdynamicboolean.create;
//other
kc:='!#498af;JJasoae4K*B qx'' *&^124;qe]9q87HGU35';
kd:=')_9sa=-23alasr0aw-0aw9509q381h6kIQW98AOR90uu90q85]qiami]-ae5kqi0988C3590[8[098[M[OPAS';
//defaults
clear;
itimer:=mt.new(_ontimer,2000,true);
end;
//## createsys ##
constructor tmultilingual.createsys(sysVar:prootobject);
var
   e:string;
begin
inherited createsys(sysVar);
load(e);
end;
//## destroy ##
destructor tmultilingual.destroy;
begin
try
//timer
mt.del(itimer);
//controls
freeobj(@ieng);
freeobj(@ioth);
freeobj(@iinuse);
freeobj(@isyserr);
//self
inherited;
except;end;
end;
//## _ontimer ##
procedure tmultilingual._ontimer(sender:tobject);
begin
try
//syncinfo
if imustupdateinfo then
   begin
   imustupdateinfo:=false;
   syncinfo;
   end;//end of if
except;end;
end;
//## syncinfo ##
procedure tmultilingual.syncinfo;
var
   a:ttransinfo;
   p:integer;
   _syserr,_engOK,_othOK,_useOK,_specified,_notused,_undefined:boolean;
begin
try
//init
fillchar(a,sizeof(a),0);
//info
for p:=(ieng.count-1) downto 0 do if (ieng.items[p]^<>'') then
   begin
   //init
   _engOK:=(ieng.items[p]^<>'');
   _othOK:=_engOK and (ioth.items[p]^<>'');
   _useOK:=_engOK and iinuse.items[p];
   _syserr:=_engOK and isyserr.items[p];
   //set
   //.gui
   if _useOK and (not _syserr) then
      begin
      general.iroll(a.main,1);
      if _othOK then general.iroll(a.Umain,1);
      end
   //.error
   else if _engOK and _syserr then
      begin
      general.iroll(a.error,1);
      if _othOK then general.iroll(a.Uerror,1);
      end
   //.unused
   else if (not _useOK) then
      begin
      general.iroll(a.unused,1);
      if _othOK then general.iroll(a.Uunused,1);
      end;//end of if
   end;//end of if
//total
a.total:=a.main+a.error+a.unused;
a.Utotal:=frcrange(a.Umain+a.Uerror+a.Uunused,0,a.total);
//set
iactive:=a;
except;end;
end;
//## stats ##
function tmultilingual.stats(showall:boolean;colsep,linesep:string):string;
const
   ma='-- ';
   mb=' --';
   sep='/';
begin
try
//range
colsep:=general.udv(colsep,#9);
linesep:=general.udv(linesep,rcode);
//get
result:=
ma+tsInformation+mb+linesep+
tsLanguage+colsep+general.udv(caption,'-')+linesep+
linesep+
ma+tsLookup+mb+linesep+
tsSuccessful+colsep+general.curcomma(ihit.good)+linesep+
tsNotFound+colsep+general.curcomma(ihit.fail)+linesep+
tsTotal+colsep+general.curcomma(ihit.total)+linesep+
linesep+
ma+tsCoverage+mb+linesep+
tsGUI+colsep+general.thousands(iactive.Umain)+sep+general.thousands(iactive.main)+linesep+
tsRealtimeHelp+colsep+'-'+linesep+
tsError+colsep+general.thousands(iactive.Uerror)+sep+general.thousands(iactive.error)+linesep+
tsUnused+colsep+general.thousands(iactive.Uunused)+sep+general.thousands(iactive.unused)+linesep+
tsTotal+colsep+general.thousands(iactive.Utotal)+sep+general.thousands(iactive.total)+linesep;
except;end;
end;
//## sfc ##
procedure tmultilingual.sfc(var x,y,z:string;_replace:boolean);//swap first character
var
   P,MaxP:Integer;
   uY,lY:String;
begin
try
MaxP:=Length(X);
If (X='') or (Y='') then exit;
uY:=UpperCase(Y[1]);
lY:=LowerCase(Y[1]);
{Scan}
For P:=1 to MaxP Do
begin
If (X[P]=lY) or (X[P]=uY) then
   begin
   Y:=Copy(X,P+1,1);
   Case _Replace of
   True:X:=Copy(X,1,P-1)+Z+Copy(X,P+1,MaxP);
   False:X:=Copy(X,1,P-1)+Z+Copy(X,P,MaxP);
   end;//end of case
   break;
   end;//end of if
end;//end of loop
except;end;
end;
//## getcount ##
function tmultilingual.getcount:integer;
begin
try;result:=ieng.count;except;end;
end;
//## clear ##
procedure tmultilingual.clear;
begin
try
caption:='English';
tep:='';
details:='';
ka:='&^*134AFdk#a9LasmLKJnad;;aASer kaleIoa.,A.a0-9)(q9872@';
kb:='(*&12=+"az//a20-a==-q3ax;l aAaljAEOalkjmaoaE#masfpa';
ieng.clear;
ioth.clear;
iinuse.clear;
ilasteng:='';
ilastoth:='';
imustupdateinfo:=true;
except;end;
end;
//## findeng ##
function tmultilingual.findeng(x:string;var i:integer):boolean;
var
   oi:integer;
begin
try
//defaults
i:=-1;
//get
oi:=ieng.findfast(0,x);
if (oi>=0) and (ioth.value[oi]<>'') then i:=oi;
//inuse
if (oi>=0) and (not iinuse.value[oi]) then
   begin
   iinuse.value[oi]:=true;
   imustupdateinfo:=true;
   end;//end of if
//successful
result:=(i>=0);
//hit
general.croll(ihit.total,1);
if result then general.croll(ihit.good,1) else general.croll(ihit.fail,1);
except;end;
end;
//## addonce ##
function tmultilingual.addonce(_eng,_oth:string):boolean;
var
   i,p:integer;
   _new:boolean;
begin
try
//defaults
result:=false;
//check
if (_eng='') then exit;
//set
p:=ieng.addex(_eng,false,_new);
if (p>=0) and _new then
   begin
   ioth.value[p]:=_oth;
   iinuse.value[p]:=false;
   isyserr.value[p]:=general.syserrFind(_eng,i);
   imustupdateinfo:=true;
   end;//end of if
//successful
result:=true;
except;end;
end;
//## sync ##
function tmultilingual.sync(_eng,_oth:string):boolean;
var
   i,p:integer;
   _new:boolean;
begin
try
//defaults
result:=false;
//check
if (_eng='') then exit;
//set
p:=ieng.addex(_eng,false,_new);
if (p>=0) then
   begin
   ioth.value[p]:=_oth;
   if _new then
      begin
      iinuse.value[p]:=false;
      isyserr.value[p]:=general.syserrFind(_eng,i);
      end;//end of if
   imustupdateinfo:=true;
   end;//end of if
//successful
result:=true;
except;end;
end;
//## clearlast ##
procedure tmultilingual.clearlast;
begin
try
ilasteng:='';
ilastoth:='';
except;end;
end;
//## translate ##
function tmultilingual.translate(_eng:string;var _oth,e:string;_style:byte):boolean;
var
   a:tstringlist;
   tmp,sx,rx,z:string;
   i,len,p,p2,maxp2,tmpLEN:integer;
begin
try
//defaults
result:=false;
a:=nil;
e:=gecNotFound;
len:=0;
_oth:='';
//cache - last lookup
if (comparetext(_eng,ilasteng)=0) then
   begin
   _oth:=ilastoth;
   result:=true;
   exit;
   end;//end of if
//init
a:=newstringlist(_eng);
maxp2:=a.count-1;
//scan
for p2:=0 to maxp2 do
begin
//.get
tmp:=a.strings[p2];
tmpLEN:=length(tmp);
z:='';
//.strip trailing "., "
for p:=tmpLEN downto 1 do if (tmp[p]<>'.') and (tmp[p]<>',') and (tmp[p]<>' ') then
    begin
    z:=copy(tmp,p+1,tmpLEN);
    tmp:=copy(tmp,1,p);
    break;
    end;//end of if
//.strip first "&"}
sX:='&';
rX:='';
sfc(tmp,sx,rx,true);
//.once
st.addonce(tmp,'',_style);
addonce(tmp,'');
//.lookup
if st.findeng(tmp,i) then
   begin
   result:=true;
   tmp:=st.oth[i];
   end
else if findeng(tmp,i) then
   begin
   result:=true;
   tmp:=ioth.value[i];
   end;//end of if
//.re-insert "&" to same letter "F"
if (sx<>'&') then
   begin
   rx:='&';
   sfc(tmp,sx,rx,false);
   end;//end of if
//.inc
pushx(len,8192,_oth,tmp);
pushx(len,8192,_oth,z);
if (p2<maxp2) then pushbx(len,8192,_oth,rcode);
end;//end of loop
//.finalise
pushbx(len,8192,_oth,'');
//.cache result for instance re-lookup
ilasteng:=_eng;
ilastoth:=_oth;
except;end;
try;freeobj(@a);except;end;
end;
//## load ##
function tmultilingual.load(var e:string):boolean;
begin
try;result:=loadfromfile(bvfportable(bvfLanguage)+'language.ll2',e);except;end;
end;
//## loadfromfile ##
function tmultilingual.loadfromfile(x:string;var e:string):boolean;
var
   z:string;
begin
try
//defaults
result:=false;
e:=gecUnexpectedError;
//process
if io.fromFilec(x,z,e,20) then
   begin
   clear;
   result:=push(z,e);
   end;//end of if
except;end;
end;
//## push ##
function tmultilingual.push(var x,e:string):boolean;
label
     skipend;
const
     _V2='LLF2.0';//version 2.0
var
   xLEN,pos,p,maxp:integer;
   a,b,y:string;
begin
try
//error
result:=false;
e:=gecUnexpectedError;
//prepare
xLEN:=length(x);
maxp:=frcrange(xLEN,0,20);
y:='';
for p:=1 to maxp do if (x[p]=#0) then
    begin
    y:=copy(x,1,p-1);
    x:=copy(x,p+1,xLEN);
    break;
    end;//end of if
e:=gecUnknownFormat;
if (y<>_V2) then exit;
pos:=1;
//process
//ka
if not io.rsv32(pos,x,y) then goto skipend;
ka:=StdEncrypt(y,kc,0);
//kb
if not io.rsv32(pos,x,y) then goto skipend;
kb:=StdEncrypt(y,kd,0);
//count
if not io.rsv32(pos,x,y) then goto skipend;
maxp:=To32Bit(StdEncrypt(y,ka,0))-1;
if (maxp<0) then goto skipend
else maxp:=frcmax(maxp,ieng.limit-1);
//caption
if not io.rsv32(pos,x,y) then goto skipend;
caption:=StdEncrypt(y,ka,0);
//details
if not io.rsv32(pos,x,y) then goto skipend;
details:=StdEncrypt(y,ka,0);
//tep
if not io.rsv32(pos,x,y) then goto skipend;
tep:=StdEncrypt(y,ka,0);
//ex1
if not io.rsv32(pos,x,y) then goto skipend;
ex1:=StdEncrypt(y,ka,0);
//ex2
if not io.rsv32(pos,x,y) then goto skipend;
ex2:=StdEncrypt(y,ka,0);
//phrases
for p:=0 to maxp do
begin
//.Decrypt
if not io.rsv32(pos,x,a) then goto skipend;
if not io.rsv32(pos,x,b) then goto skipend;
a:=StdEncrypt(a,ka,1);
b:=StdEncrypt(b,kb,1);
//.add
if not sync(a,b) then
   begin
   e:=gecCapacityReached;
   goto skipend;
   end;//end of if
end;//end of loop
//successful
result:=true;
skipend:
except;end;
try;imustupdateinfo:=true;except;end;
end;
//## pull ##
function tmultilingual.pull(var x,e:string):boolean;
label
     skipend;
const
     _V2='LLF2.0';//version 2.0
var
   p:integer;
   a,b:string;
begin
try
//defaults
result:=false;
e:=gecOutOfMemory;
x:='';
//process
//.header
x:=_v2+#0;
//.keys a/b
if not io.wsvb32(x,StdEncrypt(ka,kc,1)) then goto skipend;
if not io.wsvb32(x,StdEncrypt(kb,kd,1)) then goto skipend;
//.count
if not io.wsvb32(x,StdEncrypt(From32Bit(ieng.count),ka,1)) then goto skipend;
//.caption
if not io.wsvb32(x,StdEncrypt(caption,ka,1)) then goto skipend;
//.details
if not io.wsvb32(x,StdEncrypt(details,ka,1)) then goto skipend;
//.tep
if not io.wsvb32(x,StdEncrypt(tep,ka,1)) then goto skipend;
//.ex1
if not io.wsvb32(x,StdEncrypt(ex1,ka,1)) then goto skipend;
//.ex2
if not io.wsvb32(x,StdEncrypt(ex2,ka,1)) then goto skipend;
//.items
for p:=0 to (ieng.count-1) do if (ieng.items[p]^<>'') and (ioth.items[p]^<>'') then
   begin
   a:=StdEncrypt(ieng.items[p]^,ka,0);
   b:=StdEncrypt(ioth.items[p]^,kb,0);
   if not io.wsvb32(x,a) then goto skipend;
   if not io.wsvb32(x,b) then goto skipend;
   end;//end of if
//successful
result:=true;
skipend:
except;end;
end;

//############################ tsplash #########################################
//## create ##
constructor tsplash.create;
begin
inherited;
//help
help:=rthtranslate('Program About Window')+rcode+rthtranslate('Press "Esc" key to close Window')+rcode+rthtranslate('Click to visit Blaiz Enterprises'' Portal - http://www.blaizenterprises.com');
//iimg
iimg:=ccs.newbmp(1,1);
iph:=0;
ipt:=100;
newv:=false;
imode:=cpscSplash;
ibgcolor:=clNone;
ipse:=true;
showname:=false;

//iform
iform:=tform.create(nil);
iform.vertscrollbar.visible:=false;
iform.horzscrollbar.visible:=false;
iform.borderstyle:=bsSingle;
iform.bordericons:=[biSystemMenu];
iform.width:=0;
iform.height:=0;
//link
iform.hint:=translate('Click to visit');
iform.showhint:=true;
iform.cursor:=crHandPoint;
//events
//.iform
iform.onpaint:=_onpaint;
iform.onactivate:=_onshow;
iform.onclick:=_onclick;
iform.onmousemove:=_onmousemove;
//defaults
ifont:=tfont.create;
fill('Arial',clGray,clWhite,8,[fsBold],7,7);
_onum(self);
end;
//## destroy ##
destructor tsplash.destroy;
begin
try
//controls
//.iform
iform.visible:=false;
iform.parent:=nil;
freeObj(@iform);
freeObj(@ifont);
freeObj(@iimg);
//self
inherited;
except;end;
end;
//## read ##
function tsplash.read(var eat,e:string):boolean;
label//Supports 5 image formats
     skipend;
const
   ext:array[0..4] of string=('bmp','jpg','jpgt','omi','tep');
var
   a:tnamevalue;
   p,i:integer;
begin
try
//defaults
result:=false;
a:=nil;
//check
e:=gecUnexpectedError;
if (length(eat)=0) then exit;
//IMAGE
if ccs.fromdata(img,eat,e) then
   begin
   img:=img;
   result:=true;
   goto skipend;
   end;//end of if
//EAT
//.init
a:=tnamevalue.create;
a.nativeformat:=tiohEAT;
//.get
if not a.push(tiohEAT,eat,e) then goto skipend;
//.set
for i:=0 to high(ext) do
begin
p:=a.findmask('*a.'+ext[i],'|*');
if (p>=0) and ccs.fromdata(img,a.valuesptr[p]^,e) then
   begin
   img:=img;
   //successful
   result:=true;
   //quit
   break;
   end;//end of if
end;//end of loop
skipend:
except;end;
try;freeobj(@a);except;end;
end;
//## fill ##
procedure tsplash.fill(_name:string;_shadecolor,_color,_size:integer;_style:tfontstyles;_x,_y:integer);
begin
try
//process
if (_name<>'') then ifont.name:=_name;
if (_shadecolor<>clNone) then ishadecolor:=_shadecolor;
if (_color<>clNone) then ifont.color:=_color;
if (_size>=1) then ifont.size:=_size;
ifont.style:=_style;
ix:=_x;
iy:=_y;
//um
_onum(self);
//paint
paint;
except;end;
end;
//## loadfromfile ##
function tsplash.loadfromfile(x:string;var e:string):boolean;
label
     skipend;
begin
try
//error
result:=false;
//check
e:=gecFileNotFound;
if not fileexists(x) then goto skipend;
//process
//.load
e:=gecUnknownFormat;
iimg.loadfromfile(x);
//.sync
paint;
//successful
result:=true;
skipend:
except;end;
end;
//## setimg ##
procedure tsplash.setimg(x:tbitmap);
begin
try
//prepare
iimg.pixelformat:=pf24bit;
//process
case (x=nil) of
true:begin
    iimg.width:=400;
    iimg.height:=350;
    iimg.canvas.brush.color:=clWhite;
    iimg.canvas.fillrect(rect(0,0,iimg.width,iimg.height));
    end;//end of begin
false:begin
    iimg.width:=x.width;
    iimg.height:=x.height;
    iimg.canvas.copyrect(rect(0,0,iimg.width,iimg.height),x.canvas,rect(0,0,x.width,x.height));
    end;//end of begin
end;//end of case
//paint
paint;
except;end;
end;
//## year ##
Function tsplash.year(Min:Integer):Integer;
Var
   Yr,Mn,Dy:Word;
begin
try
DecodeDate(Now,Yr,Mn,Dy);
If (Yr<Min) then Yr:=Min;
{Return Result}
Result:=Yr;
except;end;
end;
//## _onum ##
procedure tsplash._onum(sender:tobject);
begin
try
//.set
ibgcolor:=clNone;
iform.font.assign(ifont);
except;end;
end;
//## _onpaint ##
procedure tsplash._onpaint(sender:tobject);
begin
try;paint;except;end;
end;
//## paint ##
procedure tsplash.paint;
var
   a:tstringlist;
   h,_pt,_ph,p,dx,dy:integer;
   z:string;
begin
try
//defaults;
a:=nil;
a:=tstringlist.create;
//range
_ph:=frcrange(iph,0,100);
if (_ph>=100) then h:=iimg.height else h:=round(iimg.height*_ph*0.01);
_pt:=frcrange(ipt,0,100);
//.size
if ionce then
   begin
   ionce:=false;
   general.center(iform,iimg.width+(iform.width-iform.clientwidth),h+(iform.height-iform.clientheight),false);
   end
else iform.setbounds(iform.left,iform.top,iimg.width+(iform.width-iform.clientwidth),h+(iform.height-iform.clientheight));
//.name
if showname then a.add(misc.dt(name));
//.version
a.add('Version: '+programversion);
//.licensedto
a.add('License: MIT License');//12aug2025
//.copyright
a.add('Copyright (c) 1997-2025 Blaiz Enterprises');
//.internet
a.add(ntranslate('Portal')+': www.blaizenterprises.com');//translate('Portal');
//process
//.background style+color
if (ibgcolor=clnone) then iform.canvas.brush.style:=bsClear else iform.canvas.brush.color:=ibgcolor;
//.draw image
iform.canvas.draw(0,0,iimg);
//.draw text
dx:=ix+round(0.01*_pt*iimg.width);
dy:=iimg.height-iy;
for p:=(a.count-1) downto 0 do
begin
z:=#32+a.strings[p]+#32;
dy:=dy-iform.canvas.textheight(z);
iform.canvas.textout(dx,dy,z);
end;//end of loop
iform.canvas.brush.style:=bsSolid;
except;end;
try;freeobj(@a);except;end;
end;
//## noimage ##
procedure tsplash.noimage;
label
     redo;
var
   e,n:string;
   p,w,h:integer;
begin
try
with iimg do
begin
if (width<=2) or (height<=2) then
   begin
   n:=ecap(self.name,false);
   //.size
   iimg.width:=450;
   iimg.height:=250;
   //.shade
   ccs.shadevex(iimg,ishadecolor,40,15,false,e);
   //.font
   canvas.font.color:=ifont.color;
   canvas.font.name:='arial';
   canvas.font.size:=72;
redo:
   w:=canvas.textwidth(n);
   h:=canvas.textheight(n);
   if (w>=round(width*0.8)) or (h>=round(height*0.6)) and (canvas.font.size>=12) then
      begin
      canvas.font.size:=canvas.font.size-2;
      goto redo;
      end;//end of if
   //.text
   ccs.shadetexth(iimg,n,canvas.font.color,ishadecolor,3,(iimg.width-w) div 2,(iimg.height-h) div 2,0,-1,e);
   //.frame
   canvas.brush.style:=bsSolid;
   canvas.brush.color:=ccs.sc(ishadecolor,clBlack,70);
   canvas.framerect(rect(0,0,iimg.width,iimg.height));
   //.update
   img:=iimg;
   end;//end of if
end;//end of with
except;end;
end;
//## _onshow ##
procedure tsplash._onshow(sender:tobject);
begin
try;pse;except;end;
end;
//## _onclick ##
procedure tsplash._onclick(sender:tobject);
begin
try
if (sender=iform) then
   begin
   screen.cursor:=crappstart;
   application.processmessages;
   run('http://www.blaizenterprises.com','');
   general.wait(100);
   end;//end of if
except;end;
try;screen.cursor:=crdefault;except;end;
end;
//## pse ##
procedure tsplash.pse;//perform special effects
var
   ox,x,maxp,p:integer;
begin
try
//check
if (not ipse) or (not ipseonce) then
   begin
   iph:=100;
   ipt:=0;
   ionce:=true;
   paint;
   exit;
   end;//end of if
//prepare
ipseonce:=false;
maxp:=5;//faster on screen appearance - 11-SEP-2006
//process
//.image
for p:=0 to maxp do
begin
iph:=(p*100) div maxp;
ionce:=true;
paint;
general.wait(15);
end;//end of loop
//.text
for p:=maxp downto 0 do
begin
ipt:=(p*100) div maxp;
paint;
general.wait(25);
end;//end of loop
except;end;
end;
//## splash ##
procedure tsplash.splash;
begin
try;imode:=cpscSplash;_show;except;end;
end;
//## about ##
procedure tsplash.about;
begin
try;imode:=cpscAbout;_show;except;end;
end;
//## _show ##
procedure tsplash._show;
var
   c:integer;
begin
try
//check (v2 or later)
if not newv then ShowError60(misc.dt('5<96:<H90F/(+<84a{'));
//defaults
ipseonce:=true;
noimage;
iph:=0;
ipt:=100;
ionce:=true;
paint;//size (so fonshow has full size)
//fonshow
if assigned(fonshow) then fonshow(self);
//show
case imode of
cpscSplash:begin
    //setup
    iform.bordericons:=[];
    iform.borderstyle:=bsNone;
    iform.onkeydown:=nil;
    //.null
    iform.width:=0;
    iform.height:=0;
    ionce:=true;
    paint;
    //show
    iform.show;
    end;//end of begin
cpscAbout:begin
    //setup
    iform.caption:=misc.dt(name);//Translate('About ')
    iform.bordericons:=[biSystemMenu];
    iform.borderstyle:=bsSingle;
    iform.onkeydown:=_OnKey;
    //.null
    iform.width:=0;
    iform.height:=0;
    ionce:=true;
    paint;
    //.show form - modal 15-JUL-2005
    pg.modal(true);
    if viOnTop then iform.formstyle:=fsStayOnTop;//force to be "OnTop", since it needs the boost in some instances - very important do not remove!
    iform.showmodal;
    pg.modal(false);
    end;//end of begin
end;//end of case
except;end;
end;
//## hide ##
procedure tsplash.hide;
begin
try
//check
if not iform.showing then exit;
//stop for 1 second
sleep(1000);
//hide
_hide;
except;end;
end;
//## _hide ##
procedure tsplash._hide;
begin
try
//hide
case imode of
cpscSplash:iform.hide;
cpscAbout:iform.modalresult:=mrcancel;
end;//end of case
except;end;
end;
//## _onkey ##
procedure tsplash._onkey(Sender: TObject; var Key: Word; Shift: TShiftState);
begin
try;if (key=vk_escape) then _hide;except;end;
end;
//## _onmousemove ##
procedure tsplash._onmousemove(sender:tobject;shift:tshiftstate;x,y:integer);
begin
try;if (help<>'') then pg.help:=help;except;end;
end;

//###################### TMasks ################################################
//## create ##
constructor TMasks.create;
begin
inherited;
//pads
prepad:='';
postpad:='';
{iisc}
iisc:=false;
{iinfo}
iinfo.c:=0;
ipinfo:=@iinfo;
{ipfm}
ipfm:=@ifm;
{defaults}
iinfo.all:=false;
iinfo.m:='';
iinfo.dm:=cmAllFiles;
iinfo.bm:='';
with ifm do
begin
Archive:=true;
ReadOnly:=true;
Hidden:=true;
System:=true;
Volume:=true;
end;//end of with
mask:='';
end;
//## clear ##
procedure TMasks.clear;
begin
try;mask:='';except;end;
end;
//## cm ##
function TMasks.cm(x:string):string;//clean mask
var
   maxp,p:integer;
begin
try
//include slash count
if isc then
   begin
   result:=x;
   exit;
   end;
{default}
result:='';
{prepare}
maxp:=length(x);
{process}
for p:=maxp downto 1 do if (x[p]='\') or (x[p]='/') then
    begin
    x:=copy(x,p+1,maxp);
    break;
    end;//end of if
{return result}
result:=x;
except;end;
end;
//## aemd ##
function TMasks.aemd(x:string):string;//as expanded mask data
var
   a:tstringlist;
   p:integer;
begin
try
{prepare}
result:='';
a:=nil;
{process}
//uppercase
x:=uppercase(x);
//a
a:=tstringlist.create;
general.swapstrs(x,'*',RCode+'*'+RCode);
general.swapstrs(x,'?',RCode+'?'+RCode);
a.text:=x;
//filter out blank lines
for p:=(a.count-1) downTo 0 Do if (a.strings[p]='') then a.delete(p);
{return result}
result:=a.text;
except;end;
try;freeobj(@a);except;end;
end;
//## GetMask ##
function TMasks.GetMask:string;
begin
try;result:=iinfo.m;except;end;
end;
//## SetMask ##
procedure TMasks.SetMask(x:string);
begin
try
{enforce range}
x:=cm(x);
{check}
if (x=mask) then exit;
{set}
iinfo.m:=x;
{update}
dc;
except;end;
end;
//## GetDefMask ##
function TMasks.GetDefMask:string;
begin
try;result:=iinfo.dm;except;end;
end;
//## SetDefMask ##
procedure TMasks.SetDefMask(x:string);
begin
try
{enforce range}
x:=cm(x);
{check}
if (x=dmask) then exit;
{set}
iinfo.dm:=x;
{update}
dc;
except;end;
end;
//## GetBaseMask ##
function TMasks.GetBaseMask:string;
begin
try;result:=iinfo.bm;except;end;
end;
//## SetBaseMask ##
procedure TMasks.SetBaseMask(x:string);
begin
try
{enforce range}
x:=cm(x);
{check}
if (x=bmask) then exit;
{set}
iinfo.bm:=x;
{update}
dc;
except;end;
end;
//## mia ##
function TMasks.mia(x:string):boolean;//mask is ALL
begin
try;result:=(x='*') or (x='*.*');except;end;
end;
//## fi ##
procedure TMasks.fi;//fill items
var
   a:tstringlist;
   y,z:string;
   p2,p:integer;
begin
try
{prepare}
a:=nil;
a:=tstringlist.create;
{process}
//get
z:=mask;
if (z='') then z:=dmask;
z:=bmask+mktcSep+z;
general.swapchars(z,mktcSep,#13);
a.text:=z;
//set
iinfo.c:=0;
iinfo.all:=false;
for p:=0 to (a.count-1) do if (a.strings[p]<>'') then
    begin
    //all - special case
    if mia(a.strings[p]) then
       begin
       iinfo.all:=true;
       iinfo.c:=0;
       break;
       end;//end of if
    //expanded mask data
    iinfo.i[iinfo.c]:=aemd(prepad+a.strings[p]+postpad);
    iinfo.sc[iinfo.c]:=general.sc(a.strings[p]);//slash count
    y:=copy(a.strings[p],length(a.strings[p]),1);
    iinfo.ews[iinfo.c]:=(y='/') or (y='\');//ends with slash
    iinfo.c:=iinfo.c+1;
    if (iinfo.c>mktcMax) then break;
    end;//end of if
except;end;
try;freeobj(@a);except;end;
end;
//## dc ##
procedure TMasks.dc;
begin
try
{fi}
fi;
{OnChange}
if assigned(FOnChange) then FOnChange(self);
except;end;
end;
//## cancel ##
procedure TMasks.cancel;
begin
try;icancelled:=true;except;end;
end;
//## fl ##
function TMasks.fl(x:string;_sd:boolean;var r:TMaskFileList;_nameonly:boolean):string;
var
   a:tstringlist;
   b:TMaskAttr;
   len,p:integer;
   tmpz:string;
begin
try
{defaults}
result:='';
a:=nil;
len:=0;
{prepare}
with r do
begin
fb:=0;
fc:=0;
dc:=0;
end;//end of with
b:=ifm;
tmpz:='';
{process}
a:=tstringlist.create;
a.text:=x;
{return result}
for p:=0 to (a.count-1) do if (a.strings[p]<>'') then pushb(len,result,_fl(a.strings[p],_sd,b,r,_nameonly));
{finalise}
pushb(len,result,'');
except;end;
try;freeobj(@a);except;end;
end;
//## _fl ##
function TMasks._fl(x:string;_sd:boolean;_fm:TMaskAttr;var r:TMaskFileList;_nameonly:boolean):string;
var{_sd=sub. directories}
   d:tstringlist;
   i:integer;
   sr:TSearchRec;
   z:string;
   len,p,a:integer;
begin
try
{default}
result:='';
d:=nil;
len:=0;
{prepare}
icancelled:=false;
//attr
a:=0;
if _fm.ReadOnly then a:=a+faReadOnly;
if _fm.Hidden then a:=a+faHidden;
if _fm.System then a:=a+faSysFile;
if _fm.Archive then a:=a+faArchive;
if _fm.Volume then a:=a+faVolumeID;
a:=a+faDirectory;
//x
x:=extractfilepath(x);
{process}
//scan
i:=findfirst(x+cmAllFiles,a,sr);
while (i=0) do
begin
//update
general.updsys;
//canceled
if icancelled then break;
//decide
case ((sr.attr and faDirectory)>0) of
true:if _sd and (sr.name<>'.') and (sr.name<>'..') then//directory
        begin
        if (d=nil) then d:=tstringlist.create;
        d.add(x+sr.name+'\');
        end;//end of if
false:if wm(sr.name) then//file
        begin
        //name
        case _nameonly of
        true:pushb(len,result,sr.name+rcode);
        false:pushb(len,result,x+sr.name+rcode);
        end;//end of case
        //bytes
        general.incCur(r.fc);
        general.incxCur(r.fb,sr.size);
        end;//end of if
end;//end of case
//next
i:=findnext(sr);
end;
except;end;
try;findclose(sr);except;end;
try
//directories
if (d<>nil) then
   begin
   d.sort;
   for p:=0 to (d.count-1) do
   begin
   pushb(len,result,_fl(d.strings[p],_sd,_fm,r,_nameonly));
   general.incCur(r.dc);
   end;//end of loop
   end;//end of if
//finalise
pushb(len,result,'');
except;end;
try;freeobj(@d);except;end;
end;
//## wm ##
function TMasks.wm(x:string):boolean;//within mask
var
   p:integer;
begin
try
{no}
result:=false;
{check}
if iinfo.all then
   begin
   result:=true;
   exit;
   end;//end of if
{prepare}
x:=uppercase(x);
{process}
for p:=0 to (iinfo.c-1) do if nwm(x,iinfo.i[p]) then
    begin
    //include slash count
    if isc and iinfo.ews[p] and (iinfo.sc[p]<>general.sc(x)) then break;
    {yes}
    result:=true;
    break;
    end;//end of if
except;end;
end;
//## nwm ##
function TMasks.nwm(_n:string;var _m:string):boolean;//name within mask
label{_n-uppercase filename, _m=uppercase expanded mask data "aemd"}
     skipone,skipend;
var
   a:tstringlist;
   maxp,np,nmax,n,lenn,lenx,p:integer;
   x:string;
   roam,ok:boolean;
begin
try
{no}
result:=false;
a:=nil;
{check}
if iinfo.all then
   begin
   result:=true;
   exit;
   end;//end of if
{prepare}
a:=tstringlist.create;
a.text:=_m;
lenn:=length(_n);
np:=1;
maxp:=a.count-1;
roam:=false;
{process}
//scan
for p:=0 to maxp Do
begin
x:=a.strings[p];
lenx:=length(x);
//special
if (x='*') then
   begin
   if (p=maxp) then break;
   roam:=true;
   goto skipone;
   end
else if (x='?') then
   begin
   np:=np+1;
   goto skipone;
   end;//end of if
//other
if (np>lenn) then goto skipend;
ok:=False;
if roam then nmax:=lenn else nmax:=np;
for n:=np to nmax do if (copy(_n,n,lenx)=x) then
    begin
    np:=n+lenx;
    ok:=true;
    break;
    end;//end of if
if (p=maxp) and (np<=lenn) then goto skipend;
if not ok then goto skipend;
if ok then roam:=false;
skipone:
end;//end of loop
{successful}
result:=true;
skipend:
except;end;
try;freeobj(@a);except;end;
end;

//############################### talerts ######################################
//## create ##
constructor talerts.create;
begin
inherited;
//defaults
_onsystem(self);
isystem:=vs.connect(_onsystem);
//itimer
itimer:=mt.new(_ontimer,1000,true);
end;
//## destroy ##
destructor talerts.destroy;
begin
try
//itimer
mt.del(itimer);
//system
vs.disconnect(isystem);
//stop
active:=0;
//self
inherited;
except;end;
end;
//## _onsystem ##
procedure talerts._onsystem(sender:tobject);
var
   z:integer;
begin
try
//process
if (ivsID<>vs.ID) then
   begin
   //.reset
   ivsID:=vs.ID;
   //.can
   icanvibrate:=vs.b[vsAlertVibrate];
   icanshow:=vs.b[vsAlertShow];
   end;//end of if
except;end;
end;
//## setvibrate ##
procedure talerts.setvibrate(x:integer);
begin
try
if not icanvibrate then x:=0;
ivibrate:=x;
except;end;
end;
//## setshow ##
procedure talerts.setshow(x:integer);
begin
try
if not icanshow then x:=0;
ishow:=x;
//.show
if (ishow<>0) and pg.minimized then pg.minimized:=false;
except;end;
end;
//## setactive ##
procedure talerts.setactive(x:integer);
begin
try
if general.setint(x,iactive) then
   begin
   //.once
   vibrate:=x;
   show:=x;
   end;//end of if
except;end;
end;
//## isactive ##
function talerts.isactive:boolean;
begin
try;result:=(vibrate<>0) or (show<>0);except;end;
end;
//## _dec ##
procedure talerts._dec(var x:integer);
begin
try;if (x>0) then dec(x);except;end;
end;
//## _ontimer ##
procedure talerts._ontimer(sender:tobject);
begin
try
//.shake
if (ivibrate<>0) and (piggyform<>nil) and piggyform.showing then
   begin
   general.vibratecontrol(piggyform);
   _dec(ivibrate);
   end;//end of if
except;end;
end;

//## tvirtualhelp ##############################################################
//## create ##
constructor tvirtualhelp.create(_gui:tvirtualform);
var
   p:integer;
begin
//self
inherited create(_gui);
oHeight:=vhsFont;
normal:=false;
bordersize:=0;
shape:=vcsSquare;
buffer:=true;
ideftext:=rthtranslate('Hover mouse cursor over any part of program for instance realtime help');
//.effects (off)
fFontcolor:=false;
fUnderline:=false;
fDisable:=false;
fBackground:=false;
ipos:=1;
//controls
iimg:=client.newllink('','T2G00G0003CmWAu8))F0~'+'0000000000000050000a1000G6GLLLf1fggg6aggggHggggQfgggQagggQGLLLf1000a1000G6000050000000#','',nil) as tvirtuallink;
iimg.fBackground:=false;
iimg.fDown:=false;
iimg.cursor:=cursor;
//timer
timer:=250;
//defaults
text:=rcode;
end;
//## destroy ##
destructor tvirtualhelp.destroy;
begin
try
//init
destroyinit;
//self
inherited;
except;end;
end;
//## settext ##
procedure tvirtualhelp.settext(x:string);
const
   sep='  |  ';
var
   p:integer;
   tmp,z:string;
begin
try
if (x<>itext) then
   begin
   //get
   itext:=x;
   //set
   z:='';
   p:=1;
   while general.nextline(p,x,tmp) do if (tmp<>'') then z:=z+general.insstr(sep,z<>'')+translate(tmp);
   //range
   if (z='') then z:=translate(ideftext);
   ittext:=z;
   //reset
   ipostime:=ms64+2000;
   ipos:=1;
   paint;
   end;//end of if
except;end;
end;
//## _ontimer ##
procedure tvirtualhelp._ontimer(sender:tobject);
begin
try
if (itext<>'') and (ms64>ipostime) then paintscroll;//time reset internally
except;end;
end;
//## paintscroll ##
procedure tvirtualhelp.paintscroll;
var
   i,p:integer;
begin
try
//check
if (ittext='') then exit;
//scan - never to end (as we should always have content)
i:=ipos+3;//6 chars per second
if (i>=length(ittext)) then i:=1;
ipos:=i;
ipostime:=ms64+general.aorb(500,2000,ipos=1);
//paint
paint;
except;end;
end;
//## _onpaint ##
procedure tvirtualhelp._onpaint(sender:tobject;canvas:tcanvas);
var
   e,z:string;
   dx:integer;
begin
try
//init
if (iimg=nil) then exit;
dx:=iimg.left+iimg.width+1;
//cls
if viEnhanced then ccs.shadevex(canvas,canvas.brush.color,12,12,true,e) else canvas.fillrect(clientrect);
//text
z:=copy(ittext,ipos,length(ittext));
canvas.brush.style:=bsClear;
canvas.textout(dx,0,z);
except;end;
end;

//## tstripscroll ##############################################################
//## create ##
constructor tstripscroll.create(_gui:tvirtualform);
var
   p:integer;
begin
//self
inherited create(_gui);
buffer:=true;
bordersize:=0;
cursor:=vcLink;
shape:=vcsSquare;
//.effects (off)
fFontcolor:=false;
fUnderline:=false;
fDisable:=false;
fBackground:=false;
//vars
iwaiting:=true;
imax:=high(icore.items);
icore.xstep:=60;
icore.ispace:=2;
icore.hspace:=20;
for p:=0 to imax do icore.items[p].image:=nil;
//events
onclick:=_onclick;
//defaults
clear;
//timer
timer:=2000;
end;
//## destroy ##
destructor tstripscroll.destroy;
begin
try
//init
destroyinit;
//controls
clear;
//self
inherited;
except;end;
end;
//## _onclick ##
procedure tstripscroll._onclick(sender:tobject);
var
   xlen,tmp,x1,x2,v,i,p:integer;
   z:string;
   ok:boolean;
begin
try
//check
xlen:=length(iclickindex);
if (xlen<9) then exit;
//scan
v:=-1;
for p:=1 to (xlen div 9) do
begin
i:=(p-1)*9+1;
x1:=to32bit(copy(iclickindex,i,4));
x2:=to32bit(copy(iclickindex,i+4,4));
if (x>=x1) and (x<=x2) then
   begin
   if ((i+8)<=xlen) then
      begin
      tmp:=byte(iclickindex[i+8]);
      if (tmp>=0) and (tmp<icore.count) then v:=tmp;
      break;
      end;//end of if
   break;
   end;//end of if
end;//end of loop
//set
if (v>=0) then
   begin
   imousedown:=true;
   paint;
   //.append data source (only if url has no existing "?data..."
   ok:=true;
   z:=icore.items[v].url;
   for p:=1 to length(z) do if (z[p]='?') then
      begin
      ok:=false;
      break;
      end;//end of if
   if ok then z:=z+'?referrer='+net_encode_str_b(programnameHARD+' v'+programversion);
   //.run
   run(z,'');
   imousedown:=false;
   paint;
   end;//end of if
except;end;
end;
//## _onnotify ##
procedure tstripscroll._onnotify(sender:tobject);
begin
try
//self
inherited;
//click
if gui.ismouse then paint;
except;end;
end;
//## readwrite ##
procedure tstripscroll.readwrite(mode:tvirtualstoragemode);
var
   obup,ourl,tmp:string;
   mustload:boolean;
begin
try
case mode of
vsmReadfromcontrols:;
vsmWritetocontrols:;
vsmUpdatecontrols:begin
   sync;
   end;//end of begin
end;//end of case
except;end;
end;
//## clear ##
procedure tstripscroll.clear;
var
   p:integer;
begin
try
//.items
for p:=0 to imax do with icore.items[p] do
begin
url:='';
text:='';
width:=0;
height:=0;
freeobj(@image);
end;//end of with
//.core
icore.count:=0;
icore.left:=0;
//.sync
sync;
except;end;
end;
//## sync ##
procedure tstripscroll.sync;
var
   iw,ih,w,p:integer;
begin
try
//defaults
w:=0;
//process
//GET
for p:=0 to (icore.count-1) do
begin
//.item
iw:=0;
ih:=0;
//.image
if (icore.items[p].image<>nil) then
   begin
   inc(iw,icore.items[p].image.pai.cellwidth);
   if (icore.items[p].text<>'') then inc(iw,icore.ispace);//space between image and text (both must be present)
   end;//end of if
//.text
if (icore.items[p].text<>'') then inc(iw,info^.fontmap.textwidth(icore.items[p].text));
//.width (for item in total including hspace)
inc(iw,icore.hspace);
icore.items[p].width:=iw;
//.inc (core.width)
inc(w,icore.items[p].width);
end;//end of loop
//.set
icore.width:=w;
//.mustpaint
icore.mustpaint:=true;
except;end;
end;
//## addall ##
function tstripscroll.addall(x:string):boolean;//29FEB2008
var
   a:tstringlist;
   _tep,_text,_url,tmp:string;
   c,p2,p:integer;
   ver2:boolean;
begin
try
//defaults
result:=false;
//lock - prevents painting while adding
if iadding then exit else iadding:=true;
//defaults
a:=nil;
a:=tstringlist.create;
//process
//.get - Note: Lines begining with "//" are ignored, and considered comments
p:=1;
while general.nextline(p,x,tmp) do if (copy(tmp,1,2)<>'//') and (tmp<>'') then
   begin
   //version
   ver2:=true;
   c:=0;
   for p2:=1 to length(tmp) do if (tmp[p2]='|') then
      begin
      inc(c);
      if (c>=2) then
         begin
         ver2:=false;
         break;
         end;//end of if
      end;//end of if
   //get
   //.ver 2
   if ver2 then
      begin
      if (_text='') then _text:=tmp
      else if (_url='') then _url:=tmp
      else if (_tep='') then _tep:=tmp;
      end
   //.ver 1
   else
      begin
      //clear
      _text:='';
      _url:='';
      _tep:='';
      //get
      a.text:=general.swapstrsb(tmp,'|',rcode);
      if (a.count>=1) then
         begin
         _text:=a.strings[0];
         if (a.count>=2) then
            begin
            _url:=a.strings[1];
            if (a.count>=3) then _tep:=a.strings[2];
            end;//end of if
         end;//end of if
      end;//end of if
   //add
   if (_tep<>'') and (_text<>'') and (_url<>'') then
      begin
      //set
      if _add(_tep,_text,_url) then result:=true;
      //clear
      _text:='';
      _url:='';
      _tep:='';
      end;//end of if
   end;//end of if
//.sync
sync;
except;end;
try//unlock
iadding:=false;
freeobj(@a);
except;end;
end;
//## add ##
function tstripscroll.add(_tep,_text,_url:string):boolean;
begin
try
//defaults
result:=false;
//lock - prevents painting while adding
if iadding then exit else iadding:=true;
//.add
result:=_add(_tep,_text,_url);
//.sync
sync;
except;end;//unlock
try;iadding:=false;except;end;
end;
//## _add ##
function tstripscroll._add(_tep,_text,_url:string):boolean;
var
   ui:tparseurl;
   e:string;
   p:integer;
begin
try
//defaults
result:=false;
//check
if (icore.count>imax) then exit;
if (_tep='') and (_text='') then exit;
//process
//url
if (_url<>'') then
   begin
   general.pu('http://'+_url,'',ui,[]);
   _url:='http://'+ui.cu;
   end;//end of if
//GET
p:=icore.count;
with icore.items[p] do
begin
//.image
if (_tep<>'') then
   begin
   image:=tvirtualbitmapanimated.create(self);
   image.dtransparent:=true;
   image.setanimation(_tep,e);
   end;//end of if
//.text
text:=_text;
//.url
url:=_url;
end;//end of with
//.count
icore.count:=p+1;
//successful
result:=true;
except;end;
end;
//## _ontimer ##
procedure tstripscroll._ontimer(sender:tobject);
var
   _mustpaint:boolean;
   sx,x:integer;
begin
try
//check - prevent scrolling until program has loaded and is visible tp user
if pg.booting or (not showing) then exit;
//defaults
_mustpaint:=false;
//scroll
if (not ipainting) and (not iadding) then
   begin
   //.inc
   if iwaiting or (icore.count=0) then icore.left:=0
   else
      begin
      //get
      x:=icore.left-icore.xstep;
      sx:=clientwidth+1;
      if (x<-icore.width) then x:=0;
      //set
      icore.left:=x;
      //paint
      _mustpaint:=true;
      end;//end of if
   //.paint
   if icore.mustpaint or _mustpaint then
      begin
      icore.mustpaint:=false;
      paint;
      end;//end of if
   end;//end of if
//info
if iwaiting then
   begin
   //turn "waiting" off when form becomes visible to user, ensuring entire first ad is visible to user - 05MAR2008
   if gui.showing then iwaiting:=false;
   end;//end of if
except;end;
end;
//## _onpaint ##
procedure tstripscroll._onpaint(sender:tobject;canvas:tcanvas);
var
   img:tvirtualbitmapanimated;
   o,obc,mx,p,lastx,ix,oh,cw,ch,dx:integer;
   _mouse,_visible:boolean;
   _clickindex:string;
   f:tpixelfilter;
begin
try
//lock
if ipainting then exit else ipainting:=true;
//init
cw:=clientwidth;
ch:=clientheight;
dx:=icore.left;
lastx:=dx;
_clickindex:='';
mx:=-1;
//.mouse
p:=self.y;
if (p>=0) and (p<=ch) then
   begin
   p:=self.x;
   if (p>=0) and (p<=cw) then mx:=p;
   end;//end of if
//process
//.cls
canvas.fillrect(clientrect);
//.init
for p:=0 to (icore.count-1) do icore.items[p].canrun:=false;
//ITEMS
while TRUE do
begin
for p:=0 to (icore.count-1) do
begin
//.init
img:=icore.items[p].image;
ix:=0;
_visible:=((dx+icore.items[p].width)>=0) and (dx<=cw);
//.canrun
if (img<>nil) and _visible then icore.items[p].canrun:=true;
//.draw
if _visible then
   begin
   //.mouse higlight
   _mouse:=(mx>=0) and (mx>=dx) and (mx<=(dx+icore.items[p].width-icore.hspace));
   if _mouse then f:=plfFocused else f:=nil;
   if _mouse and imousedown then o:=1 else o:=0;
   //.image
   if (img<>nil) then
      begin
      oh:=(ch-img.pai.cellheight) div 2;
      img.drawto(canvas,rect(o+dx,o+oh,img.pai.cellwidth,img.pai.cellheight),true,f,canvas.brush.color,clNone);
      inc(ix,img.pai.cellwidth);
      if (icore.items[p].text<>'') then inc(ix,icore.ispace);//space between image and text
      end;//end of if
   //.text
   oh:=(ch-info^.fontmap.maxH) div 2;
   canvas.textout(o+dx+ix,o+oh,icore.items[p].text);
   //.mouse
   if _mouse then
      begin
      obc:=canvas.brush.color;
      canvas.brush.color:=canvas.font.color;
      canvas.framerect(
        rect(o+dx+ix,o+frcmax(ch-oh+0,ch),o+dx+icore.items[p].width-icore.hspace+1,o+frcmax(ch-oh+1,ch))
      );
      canvas.brush.color:=obc;
      end;//end of if
   //.click index (0..255 items)
   if (p<=255) and (icore.items[p].url<>'') then _clickindex:=_clickindex+from32bit(lastx)+from32bit(dx+icore.items[p].width-icore.hspace)+char(p);
   end;//end of if
//.inc
inc(dx,icore.items[p].width);
lastx:=dx;
end;//end of loop
//.quit
if (dx>cw) then break;
end;//end of loop
//.set
iclickindex:=_clickindex;
//.run
for p:=0 to (icore.count-1) do if (icore.items[p].image<>nil) and (icore.items[p].image.run<>icore.items[p].canrun) then
   begin
   icore.items[p].image.run:=icore.items[p].canrun;
   end;//end of if
except;end;//unlock
try;ipainting:=false;except;end;
end;

//############################# tpg  ###########################################
//## create ##
constructor tpg.create;
begin
inherited;
//vars
iapp:=nil;
ilockwnd:=0;
cansplash:=true;
ilastapp:=0;
itime:=ms64;
//..paths
setlength(imaxpath,max_path);
setlength(imaxcomputer,MAX_COMPUTERNAME_LENGTH);
//..systray
isystray:=false;
fillchar(isystrayinfo,sizeof(isystrayinfo),0);
//..titles
imodified:=false;
ifilename:='';
ishortfilename:='';
//..icons
iicons:=tvirtualiconanimated.create;
iicons.app:=true;
iicons.masterrun:=false;//viSync->appSync->vs.b[vsAnimateIcon]
iicons.animation:=programanimatedicon;
iicons.run:=(iicons.count>=1);
//..alerts
ialerts:=talerts.create;
//controls
imsg:=tliteform.create(WS_DEFAULT,WS_EX_DEFAULT,0);
imsg.onwndproc:=_wndproc;
ihandle:=imsg.handle;
//vars
icursorlast:=point(0,0);
icursortime:=ms64;
//events
ionminimize:=application.onminimize;application.onminimize:=_onminimize;
ionrestore:=application.onrestore;application.onrestore:=_onrestore;
ionicon:=application.icon.onchange;application.icon.onchange:=_onicon;
//defaults
settitles;

//itimer - 200ms
itimer:=mt.new(_ontimer,200,true);
end;
//## destroy ##
destructor tpg.destroy;
begin
try
//itimer
mt.del(itimer);
//vars
systray:=false;
ihandle:=0;
//.controls
freeobj(@iicons);
freeobj(@ialerts);
freeobj(@imsg);
//.help
delhelp;
//.appactive
apprelease;
//self
inherited;
except;end;
end;
//## cansyncsupportfolders ##
function tpg.cansyncsupportfolders:boolean;
begin
try;result:=(programportablepath<>'');except;end;
end;
//## syncsupportfolders ##
procedure tpg.syncsupportfolders;
label
   skipend;
var//Internal Error Handling
   a:tvirtualdlg;
   tick:array[0..99] of tvirtualtick;
   folder:array[0..99] of string;//sub-folder name (animations, cursors, etc)
   tmpe,e,z:string;
   maxp,p,fcount,count,ecount,c,ec:integer;
   _label,_foldername,_realtimehelp:string;
   _promptok:boolean;
begin
try
//defaults
a:=nil;
_promptok:=false;
//check
e:='';
count:=0;
ecount:=0;
fcount:=0;//folder count
if not cansyncsupportfolders then exit;
//init
for p:=0 to high(tick) do
begin
tick[p]:=nil;
folder[p]:='';
end;//end of if
//PROMPT
a:=tvirtualdlg.create(nil);
a.caption:=ntranslate('synchronise');
a.scroll;//scrolling page
//.cancel
a.newbutton(translate('&Cancel'),tepCancel20,mrCancel).autoclick:=-60;
//.ok
a.newbutton(translate('&OK'),tepYes20,mrOK);
//message
a.newlabel(translate('Bullet Support Folders to synchronise'),'');
//options
maxp:=frcmax(misc.supportcount-1,high(tick));
for p:=0 to maxp do if misc.supportinfo(p,_label,_foldername,_realtimehelp) then
   begin
   tick[p]:=a.newtick(_label,'');
   tick[p].help:=_realtimehelp;
   folder[p]:=_foldername;
   tick[p].enabled:=misc.cansyncfolder(bvfportableex(_foldername,false),bvfolderb(_foldername,false));
   end
else
   begin
   maxp:=p-1;
   break;
   end;//end of if
//prompt
a.head.image.animation:=tepInfo32;
a.head.image.run:=viEnhanced;
if viShowSoft then _promptok:=a.showwait else _promptok:=(modaloc(a.showmodal)=mrOK);
freeobj(@a);
if not _promptok then goto skipend;
//FOLDERS
for p:=0 to maxp do if tick[p].enabled and tick[p].ticked then
   begin
   z:=folder[p];
   //set - store first error only
   if (not misc.syncfolderex(bvfportableex(z,false),bvfolderb(z,false),c,ec,tmpe)) and (e='') then e:=tmpe;
   //inc
   if (c>=1) then inc(fcount);
   inc(count,c);
   inc(ecount,ec);
   end;//end of if
skipend:
except;end;
try
if _promptok then
   begin
   z:=general.thousands(count)+#32+translate('files in')+#32+general.thousands(fcount)+#32+translate('folders synchronised')+
      general.insstr(#32+translate('with')+#32+general.thousands(ecount)+#32+translate('error/s of')+':'+rcode+'"'+translate(e)+'"',ecount>=1);
   showinfo60(z);
   end;//end of if
except;end;
try;freeobj(@a);except;end;
end;
//## visyncnow ##
procedure tpg.visyncnow;
begin
try
iicons.masterrun:=vs.b[vsAnimateIcon];
if (ihelp<>nil) then ihelp.visible:=viHelp;
except;end;
end;
//## appactivefilename ##
function tpg.appactivefilename:string;//CDROM compatiable - 12JAN2008
begin
try
case programreadwrite of
true:result:=bvfportable(bvfActive)+programname;
false:result:=wintemp+general.safeprogramname(application.exename)+'.active';
end;//end of case
except;end;
end;
//## appactive ##
function tpg.appactive:boolean;//12JAN2008
var
   f:string;
begin
try
//defaults
result:=true;
//process
//.get
f:=appactivefilename;
//.clear
freeObj(@iapp);
//.delete
remfile(f);
//.set
iapp:=tfilestream.create(f,fmcreate);
//running
result:=false;
except;end;
end;
//## apprelease ##
procedure tpg.apprelease;
begin
try
if (iapp<>nil) then
   begin
   //.clear
   freeobj(@iapp);
   //.delete
   remfile(appactivefilename);//12JAN2008
   end;//end of if
except;end;
end;
//## helppath ##
function tpg.helppath:string;//12JAN2008
begin
try;if programreadwrite then result:=bvfportable(bvfHelp) else result:=wintemp;except;end;
end;
//## canhelp ##
function tpg.canhelp:boolean;
begin
try;result:=(programhelp<>'');except;end;
end;
//## delhelp ##
procedure tpg.delhelp;//12JAN2008
var
   tmp:string;
begin
try
tmp:=helppath;
remfile(tmp+programnameHARD+'.txt');
remfile(tmp+programnameHARD+'.html');
except;end;
end;
//## showhelp ##
procedure tpg.showhelp(text:boolean);//03JAN2008
label
   skipend;
var
   e,f,tmp:string;
begin
try
//defaults
e:=gecOutOfMemory;
if not canhelp then
   begin
   e:=gecUnexpectedError;
   goto skipend;
   end;//end of if
//process
//.script/text or html
tmp:=misc.helpise(programhelp,not text);
//.set
f:=helppath+programnameHARD+general.aorbstr('.html','.txt',text);
if not io.tofile(f,tmp,e) then goto skipend;
//.run
run(f,'');
//successful
e:='';
skipend:
except;end;
try;if (e<>'') then ShowError60(translate(e));except;end;
end;
//## gethelp ##
function tpg.gethelp:string;
begin
try;if (ihelp<>nil) then result:=ihelp.text;except;end;
end;
//## sethelp ##
procedure tpg.sethelp(x:string);
begin
try;if (ihelp<>nil) then ihelp.text:=x;except;end;
end;
//## modal ##
procedure tpg.modal(lock:boolean);
begin
try
//.update system - absorbs any keystrokes prior (ie from "showmessage")
application.processmessages;
//set
if lock then inc(imodalcount) else dec(imodalcount);
//mode
if lock then application.normalizealltopmosts else application.restoretopmosts;
except;end;
end;
//## setuc ##
procedure tpg.setuc(x:string);
begin//String must be "ecap" encoded and "non-empty"
try
if (ecap(x,false)<>'') and (iuc<>x) then
   begin
   //.set
   iuc:=x;
//yyyyyyyyyyyyy//xxx   if (ihUNLOCK<>nil) then ihUNLOCK.caption:=ecap(x,false);
   end;//end of if
except;end;
end;
//## setup ##
procedure tpg.setup(va,vb,splX,splY:integer;_style:tpgsetup;shadecolor,fontcolor:integer);
var//Note: "uw" module must be called before running this procedure for "ihUNLOCK" to be created
   //Shortcuts: F1=help, F2=unlock, F3=about
   tmp,used,e:string;
   v,maxp,i,p:integer;
   ok:boolean;
begin//stc=splash text color
try
//process
isetup:=91458724;
istyle:=_style;
//critical - disable critical functions while booting
ibooting:=true;
//.settitles
settitles;
//virus scan
//io.scan(va,vb);//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx//yyyyyyyyyyyyy
//.onecopy
if programonecopy and appactive then siHalt;

//INTERACTIVE HELP
ihelp:=tvirtualhelp.create(piggyform as tvirtualform);
with ihelp do
begin
setup((piggyform as tvirtualform).root);
align:=valTop;
normal:=false;
end;//end of with
//ADS

//.enforce range requirements (1000-9000 and 799 MUST have ads present, else optional)
ok:=false;
v:=strint(misc.dt(programid));
{
if (programads<>'') then
   begin
   if lc.l then ok:=true//don't create ads if Licensed - 10-MAY-2007
   else
      begin
      iads:=tstripscroll.create(piggyform as tvirtualform);
      with iads do
      begin
      setup((piggyform as tvirtualform).root);
      align:=valTop;
      normal:=false;
      ok:=addall(programads);
      help:=
       rthtranslate('Fixed, built-in, content static scrolling logos')+rcode+
       rthtranslate(
       'If you do wish to remove scrolling logos / hyperlinks from Program, this will require a small fee for licensing, to help sustain our further research and development. '+
       '(See "Help/Information >  License > Purchase License" link for ordering/additional information)'
       );
      end;//end of with
      end;//end of if
   end;//end of if
}

//SPLASH
//.range - 19FEB2008
if (shadecolor=clNone) then shadecolor:=misc.rndsplashbc;
if (fontcolor=clNone) then fontcolor:=clWhite;
//.name
splash.Name:=ecap(programnameHARD,true);
//.read - handled by unlock window: splash.licensedto
splash.read(programsplash,e);
//.other
if (splX<=-1) then splX:=20;
if (splY<=-1) then splY:=20;
if (splash.img.width<=460) then splash.fill('small fonts',shadecolor,fontcolor,7,[fsBold],splX,splY)
else splash.fill('',shadecolor,fontcolor,8,[fsbold],splX,splY);
splash.newv:=true;
//.show
if not (pstNoSplash in istyle) then showsplash;//.auto cursorisenow
//.unpack support
if shouldus then us(e);
except;general.startfailure;end;
end;
//## getcanus ##
function tpg.getcanus:boolean;//can unpack support
begin
try;result:=programreadwrite and ((length(programschemes)>=1) or (length(programdata1)>=1) or (length(programdata2)>=1));except;end;
end;
//## getshouldus ##
function tpg.getshouldus:boolean;//should unpack support
begin
try;result:=canus and (io.snippet['ver']<>programversion);except;end;
end;
//## usprompt ##
procedure tpg.usprompt(prompt:boolean);//prompt to unpack
var//translate('Extract support files to')
   z,e:string;
begin
try
//prompt
if prompt then
   begin
   //get
   case (programportablepath='') of
   true:z:=ntranslate('start')+' > '+ntranslate('programs')+' > '+ntranslate('blaiz enterprises')+' > '+ntranslate('files');
   false:z:=ntranslate('blaiz enterprises')+' > '+ntranslate('files');
   end;//end of case
   //set
   if not showquery(translate(ecap('%J<(>=0:650?J~R',false))+rcode+z+' ?',-60) then exit;
   end;//end of if
//process
if not us(e) then showerror60(translate(e));
except;end;
end;
//## us ##
function tpg.us(var e:string):boolean;//unpack support
var
   total,count:integer;
   ok:boolean;
begin
try
//defaults
result:=false;
e:=gecUnexpectedError;
//process
if canus then
   begin
   //.get - do not overwrite
   ok:=true;
   if (length(programschemes)>=1) then ok:=io.unpackto(programschemes,'',count,total,[ioupTitleName,ioupAutoPath,ioupPersistWithErrors],e);
   if (length(programdata1)>=1) then ok:=io.unpackto(programdata1,'',count,total,[ioupTitleName,ioupAutoPath,ioupPersistWithErrors],e);
   if (length(programdata2)>=1) then ok:=io.unpackto(programdata2,'',count,total,[ioupTitleName,ioupAutoPath,ioupPersistWithErrors],e);
   result:=ok;
   //.ver
   io.snippet['ver']:=programversion;
   end;//end of if
except;end;
end;
//## done ##
procedure tpg.done(width,height:integer);//24JAN2008
var
   a:trect;
begin
try
//.settitles
settitles;
//.mainform - size & center
if (piggyform<>nil) then
   begin
   //.get
   a:=workarea;
   //.enforce range
   width:=frcmax(width,frcmin(a.right-a.left,200));
   height:=frcmax(height,frcmin(a.bottom-a.top,200));
   //.size
   piggyform.setbounds(piggyform.left,piggyform.top,width,height);
   //.center
   general.center(piggyform,piggyform.width,piggyform.height,false);
   mainformwidth:=piggyform.width;
   mainformheight:=piggyform.height;
   end;//end of if
//.system settings
vs.writetocontrols;
//.start button
if not (pstNoPlacement in istyle) then pg.place(programcategoryHARD);
//.hide splash
pg.hidesplash;
except;general.startfailure;end;
try
//sync - for "pg.place" => "vsAutoStartup"
if application.showmainform and (piggyform<>nil) then
   begin
   //pages=0
   if (piggyform is tvirtualform) and ((piggyform as tvirtualform).pages<>nil) then (piggyform as tvirtualform).pages.pageinit:=0;
   //show form NOW, so viSync will work correctly (allows for form/control work by
   //controls or object before program has displayed with GUI corruption or
   //main paint failures) - 13-DEC-2006.
   application.mainform.visible:=true;
   end;//end of if
viSync;
//critical - enable critical functions if not booting
ibooting:=false;
if (sysstate=ssOK) then sysbooted:=true;
except;end;
end;
//## getcursoridle ##
function tpg.getcursoridle:currency;
var
   a:tpoint;
   z:currency;
begin
try
//process
//.time
z:=ms64;
//.get
getcursorpos(a);
//.set
if (a.x<>icursorlast.x) or (a.y<>icursorlast.y) then icursortime:=z;
icursorlast:=a;
//return result
result:=frccurmin(z-icursortime,0);
except;end;
end;
//## rerun ##
procedure tpg.rerun;
var
   a:tpoint;
   ok:boolean;
begin
try
//decide
getcursorpos(a);
ok:=(a.x>=32) or (a.y>=32);
//hide
minimized:=false;
application.processmessages;
sleep(1000);
//run new instance
if ok then
   begin
   //alert user
   general.shortbeep(1);
   //unlock app
   apprelease;
   //check
   if (piggyform=nil) then
      begin
      showinfo('no form');
      siHalt;
      end;//end of if
   //run new copy
   run(application.exename,'');
   //close
   siClose;
   end;//end of if
except;end;
end;
//## showsplash ##
procedure tpg.showsplash;
begin
try
//.show
if ishowingsplash or (not cansplash) or (not vs.b[vsShowSplash]) then exit;
ishowingsplash:=true;
splash.splash;
except;end;
end;
//## hidesplash ##
procedure tpg.hidesplash;
begin
try
//allow system to breath - prevents splash from staying up (if during booting, intense
//mouse clicking occur on the taskbar/system tray icon for minimise/restore - 13-JUL-2005
//Note: 03-JUL-2006 "application.restore" re-displays minimised application (user trigger by mouse)
//      so splash can be succesfully hidden, otherwise splash will remain up even though requests for
//      it to be hidden have been issued.
application.processmessages;
application.restore;
application.processmessages;
//hide
if ishowingsplash then splash.hide;
//view - separate since splash may not have been showing
if startminimised then hidefromview;
except;end;
end;
//## _onicon ##
procedure tpg._onicon(sender:tobject);
var
   p:integer;
begin
try
update;
//fireevent(ionicon,sender);//don't animated the taskbar icon -> not stable - 12aug2025
fireevent(onicon,self);
//sync all forms
for p:=0 to (screen.formcount-1) do if (screen.forms[p] is tvirtualform) then fireevent(screen.forms[p].icon.onchange,self);
except;end;
end;
//## geticon ##
function tpg.geticon:ticon;
begin
try;result:=application.icon;except;end;
end;
//## setfilename ##
procedure tpg.setfilename(x:string);
begin
try
//check
if (x=ifilename) then exit;
//process
ifilename:=x;
ishortfilename:=extractfilename(x);
settitles;
except;end;
end;
//## setmodified ##
procedure tpg.setmodified(x:boolean);
begin
try
//check
if (x=imodified) then exit;
//process
imodified:=x;
settitles;
except;end;
end;
//## settitles ##
procedure tpg.settitles;
var
   a,b:string;
begin
try
//caption
if (piggyform<>nil) then
   begin
   if imodified then a:='*' else a:='';
   if (ishortfilename<>'') then b:=' - '+ishortfilename else b:='';
   (piggyform as tvirtualform).caption:=a+programnameHARD+b;
   end;//end of if
except;end;
end;
//## getlockupdate ##
function tpg.getlockupdate:boolean;
begin
try;result:=(ilockwnd<>0);except;end;
end;
//## setlockupdate ##
procedure tpg.setlockupdate(x:boolean);
begin
try
if x then
   begin
   if (piggyform<>nil) then
      begin
      ilockwnd:=piggyform.handle;
      lockwindowupdate(ilockwnd);
      end;//end of if
   end
else if (ilockwnd<>0) then
   begin
   ilockwnd:=0;
   lockwindowupdate(0);
   end;//end of if
except;end;
end;
//## getcomputer ##
function tpg.getcomputer:string;
var
  a:pchar;
  c:integer;
begin
try
//defaults
result:='';
//process
a:=pchar(imaxcomputer);
c:=16;{15+1}
//return result
if getcomputername(a,c) then result:=copy(a,1,c);
except;end;
end;
//## getuser ##
function tpg.getuser:string;
var
  a:pchar;
  c:integer;
begin
try
//defaults
result:='';
//process
a:=pchar(imaxcomputer);
c:=16;{15+1}
//return result
if getusername(a,c) then result:=copy(a,1,c);
except;end;
end;
//## getcanclone ##
function tpg.getcanclone:boolean;
begin
try;result:=programrename;except;end;
end;
//## clone ##
procedure tpg.clone;
label//Note: enforces name format of "name>~_" => "name" + "~portable" + "_clone"
   skipend,redo;
var
   a:tstringlist;
   z,_list,tmp,e,xfile,xname:string;
   zlen,p:integer;
begin
try
//defaults
a:=nil;
zlen:=0;
z:='';
//check
if not canclone then exit;
//LIST - list of suggested clone names
//get
a:=tstringlist.create;
tmp:=exeCategory+'*_.EXE';
a.text:=general.files(tmp,false);
//remove "clone symbol" and ".exe" extension
for p:=0 to (a.count-1) do pushb(zlen,z,#1+general.remcharb(general.copyuptob(a.strings[p],pcSymClone),pcSymPortable));
//finalise
pushb(zlen,z,'');
_list:=z;
a.clear;
//PROMPT USER
redo:
xname:='';
xfile:='';
if not showdroplist60(xname,_list,'',ntranslate('clone'),translate('Name for cloned copy of')+#32+'"'+programnameHARD+'"',ntranslate('cl&one')) then goto skipend;
//SET
xname:=general.safeprogramname(xname);
if (xname='') then
   begin
   showerror60(translate('Name could not be used, please try again.'));
   goto redo;
   end;//end of if
//.portable indicator
if (programportablepath<>'') then xname:=xname+pcSymPortable;
//.clone indicator
xname:=xname+pcSymClone;
//.file
xfile:=exeCategory+xname+'.EXE';
//set
if showreplacefileb(xfile,translate('program'),false) then
   begin
   //.exe
   if not general.copyto(application.exename,xfile) then
      begin
      showerror60(ntranslate(gecTaskFailed));
      goto redo;
      end;//end of if
   //.current scheme
   tmp:=vs.filenameb(xname);
   if showreplacefileb(tmp,translate('scheme'),false) then
      begin
      __appclonescheme(true);//26JAN2008
      vs.savetofile(tmp,e);
      __appclonescheme(false);//26JAN2008
      end;//end of if
   //.run
   if showquery60(translate('Run cloned copy')+'?') then run(xfile,'');
   end;//end of if
skipend:
except;end;
try;freeobj(@a);except;end;
end;
//## getcandelete ##
function tpg.getcandelete:boolean;
begin
try;result:=(fmt<>nil) and (sysstate=ssOK) and (not sysdeleting) and (programBLAIZDEL<>'');except;end;
end;
//## delete ##
procedure tpg.delete;
var
   p:integer;
   r,z,tmp:string;
begin
try
//check
if not candelete then exit;
//process
//.init
tmp:=translate('You have chosen to permanently delete this program (*) and all it''s directly associated files (scheme, settings and core files).');
general.swapstrs(tmp,'*',programname);
//.prompt
if not showqueryex(ntranslate('delete program'),
  //.warning
  uppercase(translate('warning'))+': '+tmp+rcode+
  rcode+
  //.ask
  translate('Are you sure you wish to proceed with deletion')+'?'+
  //.close all
  general.insstr(
     #32+translate('If so, close all running instances of program before proceeding.')+rcode+rcode,
     not programonecopy)
  ,-60,false) then exit;

//.confirm
z:='';
r:='';
for p:=1 to 4 do z:=z+inttostr(random(10));
showedit60(
 r,
 ntranslate('confirm')+#32+ntranslate('delete program'),
 translate('Type 4-digit code in box below ['+z+']'),
 ntranslate('confirm')
 );
if (r<>z) then
   begin
   showinfo(ntranslate(gecTaskCancelled));
   exit;
   end;//end of if
//.close prompt
if (sysstate=ssOK) and appprompt then
   begin
   //START
   sysdeleting:=true;

   //PREPARE - system critical setup for proper disconnection
   //.vs - "automatic startup = FALSE"
   vs.deletefinalise;

   //FINISH
   //.get files
   sysdeletelist:=tstringlist.create;
   _appdeletelist(sysdeletelist);
   //.close - Note: actual deletion takes place after "siClose" has finished.
   siClose;
   end;//end of if
except;end;
end;
//## place ##
procedure tpg.place(category:string);
var//Only place copy on start button if "not" portable
   orgZ,z:string;
begin
try
//check
if (programportablepath<>'') then exit;
//process
//.get
z:=bvfolder(programcategoryHARD)+programname+'.EXE';
//.place on start button
//..copy - used defined name
general.copyto(application.exename,z);
//..original copy - proper name
if (0<>comparetext(programname,programnameHARD)) then general.copyto(application.exename,bvfolder(programcategoryHARD)+programnameHARD+'.EXE');
//.once only
if (programsbfilename='') and fileexists(z) then
   begin
   //..start button filename
   programsbfilename:=z;
   //..startup filename
   programsufilename:=winstartup+programname+'.lnk';
   end;//end of if
except;end;
end;
//## getboot ##
function tpg.getboot:boolean;
begin
try;result:=(programsufilename<>'') and fileexists(programsufilename);except;end;
end;
//## setboot ##
procedure tpg.setboot(x:boolean);
var{ShlObj, ActiveX, ComObj}
  iObject:IUnknown;
  iSLink:IShellLink;
  iPFile:IPersistFile;
begin//Note: can only successfully run after "pg.place" otherwise we have no idea
try  //      required critical information (start button EXE name)
//check
if (programsufilename='') then exit;
//process
//.delete
remfile(programsufilename);
//.set
case x of
false:exit;
true:begin
   //.objects
   iObject:=CreateComObject(CLSID_ShellLink);
   iSLink:=iObject as IShellLink;
   iPFile:=iObject as IPersistFile;
   //.link
   with iSLink do
   begin
   SetArguments('');
   SetPath(pchar(programsbfilename));
   SetWorkingDirectory(pchar(bvfportable('')));//.. Start > Programs > Blaiz Enterprises
   end;//end of begin
   //.link.save
   iPFile.save(pwchar(widestring(programsufilename)),false);
   end;//end of begin
end;//end of case
except;end;
end;
//## setsystray ##
procedure tpg.setsystray(x:boolean);
begin
try
//check
if (piggyform=nil) or (x=isystray) then exit;
//process
//.set
isystray:=x;
//.icon
case x of
true:update;
false:begin
    Shell_NotifyIcon(NIM_DELETE,@isystrayinfo);
    isystrayinfo.wnd:=0;
    isystrayinfo.hIcon:=0;{not false}
    end;//end of begin
end;//end of case
//.syncapp
syncapp;
except;end;
end;
//## setontop ##
procedure tpg.setontop(x:boolean);
begin//Note: it's not possible as of 29MAR2007 to have 2 windows with "OnTop",
try  //      they both loose their ontop power, so only ever the MainForm is to be set.
//check
if (application.mainform=nil) or (x=iontop) then exit;
//process
//.set
iontop:=x;
//.icon
case x of
false:application.mainform.formstyle:=fsNormal;
true:application.mainform.formstyle:=fsStayOnTop;
end;//end of case
//.syncapp
syncapp;
except;end;
end;
//## update ##
procedure tpg.update;
var
   m:longint;
begin
try
//check
if not systray then exit;
//process
//.mode
if (isystrayinfo.wnd=0) then m:=NIM_ADD else m:=NIM_MODIFY;
//.info
with isystrayinfo do
begin
cbSize:=sizeof(isystrayinfo);
hIcon:=application.icon.handle;
ucallbackmessage:=cm_systraymessage;
wnd:=imsg.handle;
uID:=0;
uFlags:=NIF_ICON or NIF_MESSAGE or NIF_TIP;
end;//end of with
//.set
StrPCopy(isystrayinfo.szTip,application.title);
Shell_NotifyIcon(m,@isystrayinfo);
except;end;
end;
//## syncapp ##
procedure tpg.syncapp;
var
   wm:longint;
begin
try
if (isystray=iswindowvisible(application.handle)) then
   begin
   if isystray then wm:=sw_hide else wm:=sw_show;
   showwindow(application.handle,wm);
   end;//end of if
except;end;
end;
//## _onminimize ##
procedure tpg._onminimize(sender:tobject);
begin
try
//process
minimized:=true;
fireevent(ionminimize,sender);
fireevent(onminimize,self);
except;end;
end;
//## _onrestore ##
procedure tpg._onrestore(sender:tobject);
begin
try
//check
if ibooting then exit;
//process
minimized:=false;
fireevent(ionrestore,sender);
fireevent(onrestore,self);
except;end;
end;
//## hidefromview ##
procedure tpg.hidefromview;
begin
try
application.showmainform:=false;
minimized:=true;
except;end;
end;
//## getminimized ##
function tpg.getminimized:boolean;
begin
try;result:=isiconic(application.handle);except;end;
end;
//## setminimized ##
procedure tpg.setminimized(x:boolean);
var
   a:tform;
   p:integer;
begin//note: allow repeats
try
if x then
   begin
   application.minimize;
   syncapp;
   end
else
   begin
   application.restore;
   //.unlock "hide"
   if not application.showmainform then application.showmainform:=true;
   //.show
   if (application.mainform<>nil) then a:=application.mainform
   else a:=nil;
   if (a<>nil) then a.show;
   syncapp;
   application.bringtofront;
   end;//end of if
except;end;
end;
//## _wndproc ##
function tpg._wndproc(hWnd:HWND;Msg:UINT;wParam:WPARAM;lParam:LPARAM):LRESULT;
begin
try
//defaults
result:=0;
//check
if (sysstate>=ssClosed) or (hwnd<>imsg.handle) then exit;
//process
//.split
case msg of
cm_socketmessage:if (fnw<>nil) then nw.internalwndproc(hwnd,msg,wparam,lparam);
cm_systraymessage:if (not ibooting) and (imodalcount=0) and ((lparam=WM_LBUTTONUP) or (lparam=WM_RBUTTONUP)) then
   begin
   //.check
   if (isyslockcount<>0) then exit;
   //.lock - prevents multiple requests which cause system failure 13-JUL-2005
   inc(isyslockcount);
   //.show/hide
   if (not minimized) and application.showmainform and (ilastapp<>application.handle) and (not application.active) then
      begin
      minimized:=false;
      //.reset
      itime:=ms64;
      ilastapp:=application.handle;
      end
   else minimized:=not minimized;
   //.unlock
   dec(isyslockcount);
   end;//end of if
end;//end of case
except;end;
end;
//## _ontimer ##
procedure tpg._ontimer(sender:tobject);
var
   b,a:integer;
begin
try
if ((ms64-itime)>=500) then
   begin
   //.reset
   itime:=ms64;
   //.lastapp
   a:=getforegroundwindow;
   if (a<>0) then
      begin
      b:=getwindow(a,GW_OWNER);
      if (b<>0) then a:=b;
      end;//end of if
   if (a<>0) and (ilastapp<>a) then ilastapp:=a;
   syncapp;
   end;//end of if
except;end;
end;

//########################### tdebug ###########################################
//## destroy ##
destructor tdebug.destroy;
begin
try
//controls
freeobj(@iform);
//self
inherited;
except;end;
end;
//## showalldlgs ##
procedure tdebug.showalldlgs;
var
   _url,_username,_password,tmplist,tmp,z:string;
begin
try
//init
z:='Sample text message';
tmplist:='1'+rcode+'22222222'+rcode+z+rcode+'333333333333'+rcode+'444444444';
//get
showYNC('showync:'+z,-60);

showinfo60('showinfo60:'+z);

showquery60('showquery:'+z);

tmp:='newfilename60:'+z;
newfilename60(tmp,tmp);

tmp:=z;
showedit60(tmp,'showedit60','caption','');

tmp:=z;
showdroplist60(tmp,tmplist,tepCopy20,'showdroplist60','select item','');

_url:='http://www.blaizenterprises.com';
_username:='<user name>';
_password:='<password>';
showUUP60(_url,_username,_password,'showUUP60','');

tmp:=z;
showlist60(tmplist,tmp,'showlist60','select item','',true,true,true);

tmp:=z;
showfind(nil,tmp,nil,0);
except;end;
end;
//## gettext ##
function tdebug.gettext:string;
begin
try
//defaults
result:='';
//get
if (itext<>nil) then result:=itext.text;
except;end;
end;
//## settext ##
procedure tdebug.settext(x:string);
begin
try
if (x='') then freeobj(@iform)
else
   begin
   //get
   if (iform=nil) then
      begin
      iform:=tvirtualform.create(nil);
      iform.head.visible:=false;
      iform.setbounds(0,0,300,80);
      iform.root.bordersize:=2;
      itext:=iform.new('text','','','',valTop,nil,nil) as tvirtualtext;
      itext.readonly:=true;
      iform.show;
      end;//end of if
   //set
   itext.text:=x;
   end;//end of if
except;end;
end;
//## srect ##
function tdebug.srect(x,y,w,h:integer;digpad:integer):string;
begin
try
result:=
 '[x:'+general.digpad(x,digpad)+
 ',y:'+general.digpad(y,digpad)+
 ',w:'+general.digpad(w,digpad)+
 ',h:'+general.digpad(h,digpad)+']';
except;end;
end;
//## scontrolrect ##
function tdebug.scontrolrect(x:twincontrol;digpad:integer):string;
begin
try;if (x<>nil) then result:=srect(x.left,x.top,x.width,x.height,digpad) else result:=srect(0,0,0,0,digpad);except;end;
end;
//## sarea ##
function tdebug.sarea(x:trect;digpad:integer):string;
begin
try;result:=srect(x.left,x.top,x.right,x.bottom,digpad);except;end;
end;
//## sint2 ##
function tdebug.sint2(a,b:integer):string;
begin
try;result:=inttostr(a)+', '+inttostr(b)+', ';except;end;
end;
//## sint3 ##
function tdebug.sint3(a,b,c:integer):string;
begin
try;result:=inttostr(a)+', '+inttostr(b)+', '+inttostr(c)+', ';except;end;
end;
//## sint4 ##
function tdebug.sint4(a,b,c,d:integer):string;
begin
try;result:=inttostr(a)+', '+inttostr(b)+', '+inttostr(c)+', '+inttostr(d)+', ';except;end;
end;
//## rgb1 ##
function tdebug.rgb1(x:trgbcolor):string;
begin
try;result:=inttostr(x.r)+'r '+inttostr(x.g)+'g '+inttostr(x.b)+'b, ';except;end;
end;
//## msstart ##
procedure tdebug.msstart;
begin
try;ims:=ms64;except;end;
end;
//## msstop ##
procedure tdebug.msstop;
begin
try;imsvalue:=ms64-ims;except;end;
end;
//## msshow ##
procedure tdebug.msshow;
begin
try
msstop;
messagebox(application.handle,floattostrex2(msvalue)+'ms','debug',mbInformation);
except;end;
end;
//## msstr ##
function tdebug.msstr:string;
begin
try
msstop;
result:=floattostrex2(msvalue)+'ms';
except;end;
end;
//## chars ##
function tdebug.chars(x,sep,linesep:string):string;
var
   c:string;
   p,len:integer;
begin
try
//defaults
result:='';
len:=0;
if (sep='') then sep:='=';
if (linesep='') then linesep:=',';
//process
for p:=1 to length(x) do
begin
case byte(x[p]) of
14..255:c:=x[p];
else
c:='#'+inttostr(byte(x[p]));
end;//end of case
pushb(len,result,c+sep+inttostr(ord(x[p]))+linesep);
end;//end of loop
pushb(len,result,'');
except;end;
end;
//## showfiles2 ##
function tdebug.showfiles2(f1,f2:string;s,f:integer):string;
var
   e,v1,v2,x1,x2:string;
   p,len,len1,len2,maxp:integer;
begin
try
//defaults
result:='';
len:=0;
//range
s:=frcmin(s,1);
f:=frcmin(f,s);
//process
//.get
if io.fromfile(f1,x1,e) and io.fromfile(f2,x2,e) then
   begin
   len1:=length(x1);
   len2:=length(x2);
   //.set
   for p:=s to f do
   begin
   if (p>=1) and (p<=len1) then v1:=inttostr(ord(x1[p])) else v1:='-';
   if (p>=1) and (p<=len2) then v2:=inttostr(ord(x2[p])) else v2:='-';
   pushb(len,result,inttostr(p)+'=>'+v1+','+v2+general.insstr('#',v1<>v2)+rcode);
   end;//end of loop
   //.finalise
   pushb(len,result,'');
   end;//end of if
except;end;
end;


//############################# wec ############################################
//## create ##
constructor twec.create;
begin
inherited;
//vars
admincontact:='';
//defaults
update;
end;
//## destroy ##
destructor twec.destroy;
begin
try
//self
inherited;
except;end;
end;
//## find ##
function twec.find(code:integer;var z:string):boolean;//22FEB2008
begin
try
//defaults
result:=false;
z:='';
//get
case code of
400:z:=e400BadRequest;
401:z:=e401AuthorizationRequired;
403:z:=e403Forbidden;
404:z:=e404NotFound;
405:z:=e405MethodNotAllowed;
416:z:=e416RequestedRangeNotSatisfiable;
504:z:=e5041ConnectionTimeout;
910:z:=e910TaskFailed;
end;//end of case
//successful
result:=(z<>'');
except;end;
end;
//## honeypotLINK ##
function twec.honeypotLINK:string;
var
   u:string;
begin
try
//defaults
result:='';
u:=ihoneypoturl;
//get
if (u<>'') then result:='<a href="'+u+'"></a>'+rcode;
except;end;
end;
//## sethoneypoturl ##
procedure twec.sethoneypoturl(x:string);
begin
try
//filter
if (x<>'') then
   begin
   if (comparetext('http://',copy(x,1,7))<>0) then x:='http://'+x;
   end;//end of if
//set
if general.setSTRING(x,ihoneypoturl) then update;
except;end;
end;
//## create ##
function twec.format(code:integer;typ,msg,des:string):string;
var
   ui:tparseurl;
   i,c,csm,mc,sc:string;
begin
try
//process
//.code
mc:=inttostr(general.posn(code));
sc:=copy(mc,4,length(mc));
if (sc<>'') then sc:='.'+sc;
mc:=copy(mc,1,3);
//.typ
if (typ<>'') then typ:=typ+#32;
//.c - contact (admin)
if (admincontact<>'') then
   begin
   if misc.IsWebService(admincontact) then
      begin
      general.pu('http://'+admincontact,'',ui,[]);
      //.full or relative url
      if (ui.h='') then c:=ui.cu else c:='http://'+ui.cu;
      end
   else c:='mailto:'+admincontact;
   c:=' | <a href="'+c+'">'+translate('Contact Administrator')+'</a>'
   end
else c:='';
//.i - info
i:=info;
if (i<>'') then i:='<pre>'+i+'</pre>';
//.csm - code short message
csm:='';
case strint(mc) of
304:csm:=translate('Not Modified');
400:csm:=translate('Bad Request');
401:csm:=translate('Authorization Required');
403:csm:=translate('Access Forbidden');
404:csm:=translate('Not Found');
405:csm:=translate('Method Not Allowed');
500:csm:=translate('Internal Server Error');
502:csm:=translate('Bad Gateway');
503:csm:=translate('Service Unavailable');
504:csm:=translate('Timeout');
910:csm:=translate('Task Failed');
end;//end of case
//.msg
if (msg='') then msg:='<p><strong>'+mc+sc+#32+csm+'</strong></p>'+rcode
else msg:='<p><strong>'+mc+sc+#32+csm+': '+msg+'</strong></p>'+rcode;
//.des
if (des<>'') then des:='<p>'+des+'</p>'+rcode;
//.set
result:=
 '<html>'+rcode+
 '<head>'+rcode+
 '<title>'+typ+ntranslate('Error')+#32+mc+'</title>'+rcode+
 '<meta name="robots" content="noindex,nofollow">'+rcode+//23DEC2007
 '<meta http-equiv="content-type" content="text/html; charset=iso-8859-1">'+rcode+
 '</head>'+rcode+
 viNormal.hbody+rcode+
 '<h2>'+typ+ntranslate('Error')+#32+mc+'</h2>'+rcode+
 msg+des+rcode+
 '<hr><i>'+programnameHARD+' v'+programversion+'</i>'+c+rcode+i+rcode+
 //honeypot url - 23DEC2007
 honeypotLINK+
 '</body>'+rcode+
 '</html>'+rcode;
except;end;
end;
//## update ##
procedure twec.update;
var
   typ:string;
begin
try
//HTTP
typ:='HTTP';
//400
e400BadRequest:=format(400,typ,
 '',
 translate('Request is not supported.')
 );
//401
e401AuthorizationRequired:=format(401,typ,
 translate('Incorrect user name/password'),
 translate('Server could not verify that you are authorized to access the requested resource.')
 );
//403
e403Forbidden:=format(403,typ,'','');
e4031ClientBanned:=format(4031,typ,
 translate('Client address banned'),
 translate('Your access to this server is not permitted.')
 );
e4032UrlBanned:=format(4032,typ,
 translate('Url banned'),
 translate('The requested url is not permitted.')
 );
e4033ProtocolNotSupported:=format(4033,typ,
 translate('Protocol not supported'),
 translate('Requested protocol is not supported.')
 );
e4034FeedbackLoopDetected:=format(4034,typ,
 translate('Feedback loop detected'),
 translate('Destination url points to self.')
 );
e4035PasswordRequired:=format(4035,typ,
 translate('Incorrect password'),
 translate('Password is required for access.')
 );
e4036ServiceDisabled:=format(4036,typ,
 translate('Service disabled'),
 translate('Requested resource/service is not available.')
 );
//404
e404NotFound:=format(404,typ,
 '',
 translate('Requested resource could not be found.')
 );
//405
e405MethodNotAllowed:=format(405,typ,
 '',
 translate('Specified method is not permitted.')
 );
//416
e416RequestedRangeNotSatisfiable:=format(416,typ,
 '',
 translate('Requested range not satisfiable.')
 );
//503
e5031TooManyUsers:=format(5031,typ,
 translate('Too many users connected'),
 translate('Request cannot be processed due to excessive traffic. Please try again later.')
 );
e5032NoConnection:=format(5032,typ,
 translate('No connection'),
 translate('Cannot establish a network connection.')
 );
e5033NoGateway:=format(5033,typ,
 translate('No gateway'),
 translate('Cannot establish a gateway connection.')
 );
//504
e5041ConnectionTimeout:=format(5041,typ,
 translate('Connection timeout'),
 translate('Connection to remote server/site timed out.')
 );
e5042GatewayTimeout:=format(5042,typ,
 translate('Gateway timeout'),
 translate('Remote gateway did not respond promptly.')
 );
//910
e910TaskFailed:=format(910,typ,
 '',
 translate('Out of memory/disk space.')
 );
except;end;
end;

//########################### tgeneral #########################################
//## create ##
constructor tgeneral.create;
begin
inherited;
//iupdsys
iunique_system_id:=0;//1..N (-N..0=empty/invalid, 1..N=valid)
iupdsys:=ms64;
//defaults
//.serials (never = 0)
//..machine
imachineserial:=serial('c');
if (imachineserial=0) then imachineserial:=1;
imachineserialSTR:=inttostr(imachineserial);
//..program
iprogramserial:=ms64;
croll(iprogramserial,application.handle);
if (iprogramserial=0) then iprogramserial:=1;
iprogramserialSTR:=floattostrex2(iprogramserial);
end;
//## destroy ##
destructor tgeneral.destroy;
begin
try
//controls
freeobj(@ierrlist);
//self
inherited;
except;end;
end;
//## fromcents ##
function tgeneral.fromcents(x:integer):string;
begin
try;result:=general.strdec(floattostrex2(x/100),2,true);except;end;
end;
//## tocents ##
function tgeneral.tocents(x:string):integer;
var
   a:currency;
begin
try
//defaults
result:=0;
//process
//.get
a:=fromcc(x);
//.range
if (a<0) then a:=0;
//.set
result:=round(a*100);
except;end;
end;
//## fromcc ##
function tgeneral.fromcc(x:string):currency;
begin
try
general.swapstrs(x,',','');
general.swapstrs(x,#32,'');
result:=strflt(x);
except;result:=0;end;
end;
//## fromci ##
function tgeneral.fromci(x:string):integer;
begin
try
general.swapstrs(x,',','');
general.swapstrs(x,#32,'');
result:=strint(x);
except;result:=0;end;
end;
//## safeprogramname ##
function tgeneral.safeprogramname(x:string):string;//09-FEB-2007
var//Safe for "cloning" and "portable" excludes these trigger characters (_ and ~)
   a:char;
   p:integer;
begin
try
//defaults
result:=x;
//process
for p:=1 to length(result) do
begin
//.get
a:=result[p];
//.filter
if (a='\') or (a='/') or (a='*') or (a='?') or (a='"') or (a='<') or (a='>') or (a='|') or (a=':') or (a=pcSymClone) or (a=pcSymPortable) then result[p]:=pcSymSafe;
end;//end of loop
except;end;
end;
//## objin ##
function tgeneral.objin(x:tobject;y:array of tobject):boolean;
var
   p:integer;
begin
try
//defaults
result:=false;
//process
for p:=low(y) to high(y) do if (x=y[p]) then
   begin
   result:=true;
   break;
   end;//end of if
except;end;
end;
//## findcontrol ##
function tgeneral.findcontrol(x:twincontrol;y:tpoint;allowdisabled:boolean):tcontrol;
var
   p:integer;
   tmp:tcontrol;
begin
try
//defaults
result:=nil;
//check
if (x=nil) or (x.controlcount=0) then exit;
//process
for p:=(x.controlcount-1) downto 0 do
   begin
   tmp:=x.controls[p] as twincontrol;
   if tmp.visible and (tmp.enabled or allowdisabled)  and
      (y.x>=tmp.left) and (y.y>=tmp.top) and
      (y.x<=(tmp.left+tmp.width)) and (y.y<=(tmp.top+tmp.height)) then
      begin
      result:=tmp;
      break;
      end;//end of if
   end;//end of if
except;end;
end;
//## controlstable ##
function tgeneral.controlstable(x:twincontrol):boolean;
begin
try
//defaults
result:=false;
//process
result:=(x<>nil) and (
 (x is tcustomform)
 or
 ((x.parent<>nil) and x.parent.handleallocated)
 );
except;end;
end;
//## replacec ##
function tgeneral.replacec(n,s:string;index:integer):string;
var
   schange,count:integer;
begin
try;
//defaults
result:='';
//set
count:=length(n);
replace(n,s,index,count,schange);
result:=s;
except;end;
end;
//## replaceb ##
function tgeneral.replaceb(n:string;var s:string;index,count:integer;var schange:integer):boolean;//modify sub-string
begin
try;result:=replace(n,s,index,count,schange);except;end;
end;
//## replace ##
function tgeneral.replace(var n,s:string;index,count:integer;var schange:integer):boolean;//modify sub-string
     //n=new sub-string content
     //index=start position, count=length => old sub-string to be replaced with "n"
     //s=full string
     //schange=difference in size of "s"
var
   slen:integer;
begin
try
//defaults
result:=false;
slen:=length(s);
//process
if (index>=1) and (index<=slen) then
   begin
   if (count>=1) then delete(s,index,count);
   if (n<>'') then insert(n,s,index);
   schange:=schange+(length(s)-slen);
   //successful
   result:=true;
   end;//end of if
except;end;
end;
//## selfGTI ##
function tgeneral.selfGTI(t:integer):string;//self as Global Task ID
begin
try;result:=imachineserialSTR+'-'+iprogramserialSTR+'-'+inttostr(t);except;end;
end;
//## toGTI ##
function tgeneral.toGTI(m,p,t:integer):string;//to Global Task ID
begin
try;result:=inttostr(m)+'-'+inttostr(p)+'-'+inttostr(t);except;end;
end;
//## fromGTI ##
function tgeneral.fromGTI(x:string;var m,p,t:integer):boolean;//from Global Task ID
var
   om:boolean;
   o,v,c,s,xLEN,i:integer;
begin
try
//defaults
result:=false;
m:=0;
p:=0;
t:=0;
xLEN:=length(x);
s:=1;
c:=0;
//process
for i:=1 to xLEN do
begin
o:=byte(x[i]<>'-');
if (o=0) or (i=xLEN) then
   begin
   //.get
   v:=strint(copy(x,s,i-s+o));
   s:=i+1;
   //.set
   case c of
   0:m:=v;
   1:p:=v;
   2:begin
     t:=v;
     break;
     end;//end of begin
   end;//end of case
   //.inc
   inc(c);
   end;
end;//end of loop
//successful
result:=(c>=2);
except;end;
end;
//## fle ##
function tgeneral.fle(n:string;list:tstringlist):integer;//find list element
var
   p,nlen:integer;
begin
try
//defaults
result:=-1;
nlen:=length(n);
//check
if (list=nil) then exit;
//process
for p:=0 to (list.count-1) do if (0=comparetext(n,copy(list.strings[p],1,nlen))) then
    begin
    result:=p;
    break;
    end;//end of if
except;end;
end;
//## clean ##
function tgeneral.clean(_pathmask:string;_hours:integer):boolean;
var
   iinfo:tsearchrec;
   _path:string;
   _tmp2,p,_style:integer;
   _by:double;
   _tmp:tfiletime;
   _now,_file:tdatetime;
begin
try
//error
result:=false;
//check
_path:=extractfilepath(_pathmask);
if not directoryexists(_path) then exit;
//prepare
_style:=faReadOnly or faHidden or faSysFile or faArchive;
if (_hours<1) then _hours:=1;
_by:=(_hours/24);
_now:=now;
//process
p:=findfirst(_pathmask,_style,iinfo);
while (p=0) do
begin
//.ftLastWriteTime => tdatetime
FileTimeToLocalFileTime(iinfo.finddata.ftLastWriteTime,_tmp);
FileTimeToDosDateTime(_tmp,LongRec(_tmp2).hi,LongRec(_tmp2).lo);
_file:=FileDateToDateTime(_tmp2);
//.compare
if ((_now-_file)>_by) or ((_file-_now)>_by) then remfile(_path+iinfo.name);
//.inc
p:=findnext(iinfo);
end;
except;end;
try;findclose(iinfo);except;end;
end;
//## sc ##
function tgeneral.sc(x:string):integer;//slash count
var
   p:integer;
begin
try
{default}
result:=0;
{process}
for p:=1 to length(x) do if (x[p]='/') or (x[p]='\') then result:=result+1;
except;end;
end;
//## etls ##
function tgeneral.etls(x:string;bs:boolean):string;//extract to last slash
var{bs = "before slash"}
   maxp,p:integer;
begin
try
{defaults}
result:='';
{prepare}
maxp:=length(x);
{process}
for p:=maxp downto 1 do if (x[p]='\') or (x[p]='/') then
    begin
    case bs of
    true:result:=copy(x,1,p);
    false:result:=copy(x,p+1,maxp);
    end;//end of case
    break;
    end;//end of if
except;end;
end;
//## ednf ##
function tgeneral.ednf(var x:string;y:integer):string;//extract dir name fragment, "left to right"
var
   c,s,maxp,p:integer;
begin
try
{defaults}
result:='';
{prepare}
if (y<1) then y:=1;
maxp:=length(x);
s:=1;
c:=0;
{process}
for p:=1 to maxp do if (x[p]='\') or (x[p]='/') then
    begin
    //get
    if (c>=y) then
       begin
       result:=copy(x,s+1,p-s-1);
       break;
       end;//end of if
    //s
    s:=p;
    //inc
    c:=c+1;
    end;//end of if
except;end;
end;
//## rsf ##
function tgeneral.rsf(x:string;var os,ns:longint;_inc:longint;_style:trsfSTYLE;var e:string):boolean;//resize file 03-OCT-2004
var
   a:tfilestream;
begin
try
//defaults
result:=false;
a:=nil;
os:=-1;
ns:=-1;
//check
e:=gecFileNotFound;
if not fileexists(x) then exit;
//process
e:=gecFileInUse;
a:=tfilestream.create(x,fmOpenReadWrite+fmShareDenyNone);
os:=a.size;
e:=gecOutOfDiskSpace;
try
//size
if (rsfIncBy in _style) then ns:=frcmin(a.size+_inc,0)
else if (rsfSize in _style) then ns:=frcmin(_inc,0)
else ns:=a.size;//un-altered
a.size:=ns;
//revert
if (rsfTestOnly in _style) then a.size:=os;
//successful
result:=true;
except;
//revert - only on error
a.size:=os;
end;
except;end;
try;a.free;except;end;
end;
//## RemLastExt ##
Function tgeneral.RemLastExt(X:String):String;
Var
   P:integer;
begin
try
For P:=Length(X) DownTo 1 Do
begin
If (X[P]='.') then
   begin
   X:=Copy(X,1,P-1);
   Break;
   end;//end of if
end;
except;end;
try;Result:=X;except;end;
end;
//## forceEXT ##
function tgeneral.forceEXT(x,_ext:string;_override:boolean):string;
label
     skipend;
var
   _n,_e:string;
begin
try
//defaults
result:='';
//check
if (_ext='') then goto skipend;
//process
_ext:=readfileext('.'+_ext,false);
fane(x,_n,_e);
if (uppercase(_e)<>uppercase(_ext)) then
   begin
   if _override then x:=_n+'.'+_ext else x:=x+'.'+_ext;
   end;//end of if
skipend:
//return result
result:=x;
except;end;
end;
//## CopyTo ##
Function tgeneral.CopyTo(Source,Dest:String):Boolean;
Var
   DPath:String;
begin
try
{Error}
Result:=False;
If Not FileExists(Source) then exit;
{Enforce Path}
DPath:=ExtractFilePath(Dest);
If Not DirectoryExists(DPath) then ForceDirectories(DPath);
{Remove File}
RemFile(Dest);
{Copy}
Result:=CopyFile(PChar(Source),PChar(Dest),False);
except;end;
end;
//## copytoex ##
function tgeneral.copytoex(s,d:string;var e:string):boolean;
var
   dpath:string;
begin
try
//defaults
result:=false;
e:=gecFileNotFound;
//check
if not fileexists(s) then exit;
//get
e:=gecPathNotFound;
dpath:=extractfilepath(d);
if not crfolder(dpath) then exit;
//set
e:=gecFileInUse;
if not remfile(d) then exit;
//copy
e:=gecOutOfDiskSpace;
result:=copyfile(pchar(s),pchar(d),false);
except;end;
end;
//## serial ##
function tgeneral.serial(x:char):integer;
Var
  NotUsed,VolFlags,SerialNo:Integer;
  SerialNo_Address:PDWord;
  Drive:String;
begin
try
{Error}
Result:=0;
Drive:=X+':\';
If Not DirectoryExists(Drive) then exit;
VolFlags:=0;NotUsed:=0;SerialNo:=0;SerialNo_Address:=@SerialNo;
GetVolumeInformation(PChar(Drive),Nil,0,SerialNo_Address,NotUsed,VolFlags,Nil,0);
{Return Result}
result:=SerialNo;
except;end;
end;
//## MkFile ##
Function tgeneral.MkFile(X:String;Y:Integer):Boolean;
Var
   A:TFileStream;
begin{Sizes existing/new file to Y, if Y>FileSize}
try
{Ignore}
Result:=True;
If (Y<0) then exit;
{Error}
Result:=False;
A:=nil;
{Size File}
Case FileExists(X) of
True:begin
    A:=TFileStream.Create(X,fmOpenWrite+fmShareDenyNone);
    If (Y>A.Size) then A.Size:=Y;
    end;//end of begin
False:begin
    A:=TFileStream.Create(X,fmCreate);
    A.Size:=Y;
    end;//end of begin
end;//end of case
{Successful}
Result:=True;
except;end;
try;A.Free;except;end;
end;
//## createid ##
function tgeneral.createid:integer;//1..N (-N..0=empty/invalid, 1..N=valid) - 09-MAY-2005
begin//generates a new ID for each request, resets to zero and starts over
     //Range: 0..MaxInt -> 0..MaxInt (re-cycles)
try
irollb(iunique_system_id,1,1);
result:=iunique_system_id;
except;end;
end;
//## lsp ##
function tgeneral.lsp(xsize:integer;x:string):string;//left-align string padding
const//pads upto 30 characters
   z='                              ';
begin
try;result:=copy(x+copy(z,1,xsize-length(x)),1,xsize);except;end;
end;
//## rsp ##
function tgeneral.rsp(xsize:integer;x:string):string;//right-align string padding
const//pads upto 30 characters
   z='                              ';
begin
try;result:=copy(copy(z,1,xsize-length(x))+x,1,xsize);except;end;
end;
//## udv ##
function tgeneral.udv(v,dv:string):string;//use default value
begin
try
result:=v;
if (result='') then result:=dv;
except;end;
end;
//## viewb ##
function tgeneral.viewb(app,x,dv:string;var e:string):boolean;
begin
try;result:=view(app,x,dv,e);except;end;
end;
//## view ##
function tgeneral.view(app,x:string;var dv,e:string):boolean;
begin
try
//defaults
result:=false;
//.set
if (not fileexists(x)) and (not io.toFILE(x,dv,e)) then exit;
//.get
if (app<>'-') then
   begin
   if (app='') then run(x,'') else run(app,x);
   end;//end of if
//successful
result:=true;
except;end;
end;
//## dim ##
function tgeneral.dim(x:tdatetime):integer;//date in minutes (always >0)
begin//30% faster
try
result:=round(x*1440);
if (result<1) then result:=1;
except;end;
end;
//## dayofyear ##
function tgeneral.dayofyear(x:tdatetime):integer;//v1.00.009/30-DEC-2004
const//measures the number of days from 01-JAN-2004 (never zero, always >=1)
     dpm:array[1..12] of integer=(31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31);
var
   p:integer;
   y,m,d:word;
begin
try
//defaults
result:=1;
//process
decodedate(x,y,m,d);
//.check
if (y<2004) then exit;
//.set
for p:=1 to (m-1) do inc(result,dpm[p]);
inc(result,d);
inc(result,(y-2004)*365);
result:=frcrange(result,1,high(word));
except;end;
end;
//## rdfs ##
procedure tgeneral.rdfs(x:string;var i,e:string);//read dual filters
begin
try;rdfsb(x,i,e,'|');except;end;
end;
//## rdfsb ##
procedure tgeneral.rdfsb(x:string;var i,e:string;sep:char);//read dual filters
var
   p:integer;
begin
try
//sep
if (sep=#0) then sep:='|';
//get
p:=1;
if findtext(p,x,sep) then
   begin
   i:=copy(x,1,p-1);
   e:=copy(x,p+1,length(x));
   end
else
   begin
   i:=x;
   e:='';
   end;//end of if
except;end;
end;
//## aslf ##
function tgeneral.aslf(x:string):string;//as single line filter
var
   _pos,_start,_length,len,p:integer;
begin
try
//defaults
result:='';
len:=0;
_pos:=1;
//process
while readline(_pos,_start,_length,x) do pushb(len,result,copy(x,_start,_length)+';');
//.finalise
pushb(len,result,'');
except;end;
end;
//## indf ##
function tgeneral.indf(x:string;var i,e:string):boolean;//in dual filter
begin
try;result:=indfb(x,';',i,e);except;end;
end;
//## indfb ##
function tgeneral.indfb(x:string;sep:char;var i,e:string):boolean;//in dual filter
begin
try;result:=infb(x,sep,i) and ((e='') or (not infb(x,sep,e)));except;end;
end;
//## inf ##
function tgeneral.inf(x:string;var f:string):boolean;
begin
try;result:=infb(x,';',f);except;end;
end;
//## _infb ##
function tgeneral._infb(var x:string;xlen:integer;var m:string;ms,mf:integer):boolean;
label//High speed "single filteret" scanner (~2..14x faster than original version) -> 13-OCT-2006 (final version)
     //* = #42
     //Note: [XXX]=findfirst(once only), [*XXX]=findlast(multiple, middle) and [*]=findstop (end, once only)
     //Example: a*blaiz*fred* => [a] [*blaiz] [*fred] [*] => findfirst+findlast+findlast+findstop
     //Precision: 100% (confirmed, with some speed loss, but can now perform very complex masking)
   skipend,startmask,redo;
const
   mlimit=2000;
var
   //mask
   md:array[1..mlimit] of byte;//temp data list of UPPER values of mask (excludes *)
   mref,mp,mlen:integer;
   maskcount:byte;
   findlast:boolean;
   //text
   msp,xp:integer;
   //other
   v:byte;
   ok:boolean;
begin//Compates x in m where "m" is a single filteret (*cam*)
try
//defaults
result:=false;
if (xlen<=0) or (mf<ms) then exit;
//process
//INIT
//.mask
mp:=ms;
mlen:=0;
//.text
xp:=1;//force init

//MASK
startmask:
//.reset
maskcount:=0;
findlast:=false;
mlen:=0;
mref:=mp;
if (mp>mf) then goto skipend;
repeat
//.get
v:=ord(m[mp]);
if (v>=97) and (v<=122) then v:=v-32;//upper
//.decide
if (v<>42) then
   begin
   inc(mlen);
   md[mlen]:=v;
   end
else
   begin
   //FINDSTOP - mask-ett is a single trailing "*"
   if (mp>=mf) and (mlen=0) then
      begin
      result:=true;
      goto skipend;
      end;//end of if
   //FINDLAST
   if (mp=mref) then
      begin
      findlast:=true;
      //.ignore duplicate "*", shift right one position
      mref:=mp+1;
      end;//end of if
   //STOP looking at mask
   if (mp>mref) then break;
   end;//end of if
//.inc
inc(mp);
until (mp>mf) or (mlen>=mlimit);
//.check
if (mlen=0) or (mlen>(xlen-xp+1)) then goto skipend;

//TEXT
msp:=1;//start position of mask info
ok:=false;
repeat
//.get
v:=ord(x[xp]);
if (v>=97) and (v<=122) then v:=v-32;//upper
//.scan
if (md[msp]=v) then
   begin
   if (msp=mlen) then
      begin
      ok:=true;
      break;
      end;//end of if
   end
else
   begin
   //.restart search
   if findlast then
      begin
      if (msp=1) then msp:=0//just reset mask, since we have yet to match even first letter of mask
      else
         begin//atleast one letter of mask matched, but as whole not, so shift back till 1 after start position
         xp:=xp-msp+1;
         msp:=0;
         end;//end of if
      end
   else break;//ERROR, not found
   end;//end of if
//.inc
inc(xp);
inc(msp);
until (xp>xlen) or (msp>mlen);
//.decide
if ok then
   begin
   if (xp>=xlen) then result:=true//OK and finished all mask-etts
   else goto startmask;//OK, but use next mask-ett
   end;//end of if
skipend:
except;end;
end;
//## infb ##
function tgeneral.infb(x:string;sep:char;var f:string):boolean;
var//High speed "multiple filter" scanner (~7x faster than previous version) - 15-SEP-2006
   xlen,lp,o,flen,ff,fp:integer;
begin
try
//defaults
result:=false;
xlen:=length(x);
flen:=length(f);
if (xlen=0) or (flen=0) then exit;
//range
if (sep='*') then sep:=';';
//process
//.scan
fp:=1;
lp:=1;
repeat
if (f[fp]=sep) or (fp=flen) then
   begin
   if (f[fp]=sep) then o:=0 else o:=1;
   ff:=fp-1+o;
   if (ff>=lp) then
      begin
      //.set
      if _infb(x,xlen,f,lp,ff) then
         begin
         result:=true;
         break;
         end;//end of if
      end;//end of if
   //.store
   lp:=fp+1;
   end;//end of if
//.inc
inc(fp);
until (fp>flen);
except;end;
end;
//## inps ##
function tgeneral.inps(x:string;sep:char;var f:string;matchcase:boolean):integer;//in partial set (v1.00.023/22-SEP-2005)
var
   pos:integer;
begin
try;inpsb(x,sep,f,matchcase,pos,result);except;end;
end;
//## inpsb ##
function tgeneral.inpsb(var x:string;sep:char;var f:string;matchcase:boolean;var _fpos,_flen:integer):boolean;//in partial set (v1.00.023/22-SEP-2005)
var//Ultra high speed partial string compare
   //Stats: filter of 120c's "f" with 9c key "x" performs 50,000 full comparisons per seconds @ 200Mhz
   //Virtual speed of 54 million characters/second
   //Note: "x" must always be equal or larger in length than destination sub-string of filter "f"
   i,l,lp,p,flen,xlen:integer;
   tmp1,tmp2:byte;
   ok:boolean;
begin
try
//defaults
result:=false;
_fpos:=1;
_flen:=0;
xlen:=length(x);
flen:=length(f);
lp:=1;
//check
if (xlen=0) or (flen=0) then exit;
//process
//.scan
for p:=1 to flen do if (f[p]=sep) or (p=flen) then
   begin
   //.get
   l:=p-lp;
   if (p=flen) and (f[p]<>sep) then inc(l);
   //.decide - only if new filter sub-string is larger than previous sub-string
   if (l>_flen) and (l<=xlen) then
      begin
      //.compare two strings (case insensitive)
      ok:=true;
      for i:=1 to l do
      begin
      tmp1:=byte(x[i]);
      tmp2:=byte(f[lp+i-1]);
      if (not matchcase) then
         begin
         if (tmp1>=97) and (tmp1<=122) then dec(tmp1,32);
         if (tmp2>=97) and (tmp2<=122) then dec(tmp2,32);
         end;//end of if
      if (tmp1<>tmp2) then
         begin
         ok:=false;
         break;
         end;//end of if
      end;//end of loop
      //.strings matched
      if ok then
         begin
         _fpos:=lp;
         _flen:=l;
         //.exact match - stop scaning
         if (_flen=xlen) then break;
         end;//end of if
      end;//end of if
   lp:=p+1;
   end;//end of if
//successful
result:=(_flen>=1);
except;end;
end;
//## robotnv ##
function tgeneral.robotnv(x:string;var n,v:string):boolean;
var
   xlen,i,s,f,p:integer;
   nok:boolean;
begin
try
//defaults
result:=false;
n:=x;
v:='';
xlen:=length(x);
i:=-1;
s:=-1;
f:=-1;
nok:=false;
//process
//.get
for p:=1 to xlen do
   if nok then
      begin
      if (s=-1) and ((x[p]<>#32) and (x[p]<>#9)) then
         begin
         if (x[p]='#') then break;
         s:=p;
         f:=p;
         end
      else if (s>=1) and ((x[p]=#32) or (x[p]=#9) or (x[p]='#')) then
         begin
         f:=p-1;
         break;
         end
      else if (s>=1) and (p=xlen) then
         begin
         f:=p;
         break;
         end;//end of if
      end
   else
      begin
      if (i=-1) and (x[p]<>#32) and (x[p]<>#9) then
         begin
         //.comment
         if (x[p]='#') then
            begin
            n:='';
            v:='';
            break;
            end;//end of if
         i:=p;
         end;//end of if
      if (x[p]=':') then
         begin
         n:=copy(x,i,p-i);
         nok:=true;
         //successful
         result:=true;
         end;//end of if
      end;//end of if
//.set
if (s>=1) and (f>=1) then v:=copy(x,s,f-s+1);
except;end;
end;
//## fromrobots ##
procedure tgeneral.fromrobots(var x,f:string;agent:string;sep:char;flimit:integer);//updated 12-OCT-2005
const
   mNil=-1;
   mDefault=0;
   mAgent=1;
var
   p,mode,_pos,_start,_length:integer;
   agentOK,dOK,aOK:boolean;
   filters:array[0..1] of string;
   n,v:string;
begin
try
//defaults
if (flimit<1) then flimit:=maxint;
f:='';
n:='';
v:='';
_pos:=1;
mode:=mNil;
dOK:=false;
aOK:=false;
agentOK:=(agent<>'');
for p:=low(filters) to high(filters) do filters[p]:='';
//process
//.get
while general.readline(_pos,_start,_length,x) do if robotnv(copy(x,_start,_length),n,v) then
   begin
   //.user-agent
   if (0=comparetext(n,'user-agent')) then
      begin
      if (not dOK) and (v='*') then
         begin
         mode:=mDefault;
         dOK:=true;
         end
      else if agentOK and (not aOK) and (0=comparetext(v,agent)) then
         begin
         mode:=mAgent;
         aOK:=true;
         end
      else
         begin
         if dOK and (aOK or (not agentOK)) then break;
         mode:=mNil;
         end;//end of if
      end
   //.disallow
   else if (mode<>mNil) and (0=comparetext(n,'disallow')) and (v<>'') then
      begin//format of: "/cgi-bin/<sep>"
      //.enforce "initial forward slash"
      if (v[1]<>'/') then v:='/'+v;
      //.range
      if (length(filters[mode]+v+sep)>flimit) then mode:=mNil
      else filters[mode]:=filters[mode]+v+sep;
      end;//end of if
   end;//end of if
//.set
if (filters[mAgent]<>'') or aOK then f:=filters[mAgent]
else f:=filters[mDefault];
except;end;
end;
//## fromrobotsb ##
procedure tgeneral.fromrobotsb(x:string;var f:string;agent:string;sep:char;flimit:integer);
begin
try;fromrobots(x,f,agent,sep,flimit);except;end;
end;
//## binary ##
function tgeneral.binary(var x:string):integer;
var//Returns a value between 0..100% (0%=none binary, 100%=all binary)
   //Note: counts additional character: &
   v:byte;
   b,p,xlen:integer;
begin
try
//defaults
result:=0;
xlen:=length(x);
b:=0;
//check
if (xlen=0) then exit;
//process
//.get
for p:=1 to xlen do
begin
v:=ord(x[p]);
if (v<=31) or (v>=127) or (v=38) then inc(b);
end;//end of loop
//.set
result:=(b*100) div xlen;
except;end;
end;
//## sortINT ##
procedure tgeneral.sortINT(var a:array of integer;l,r:integer;_asc:boolean);//ascending
var
  tmp,p,i,j:integer;
begin
try
repeat
I := L;
J := R;
P := a[(L + R) shr 1];
  repeat
  if _asc then
     begin
     while (a[I]<P) do inc(I);
     while (a[J]>P) do dec(J);
     end
  else
     begin
     while (a[I]>P) do inc(I);//* ">"
     while (a[J]<P) do dec(J);//* "<"
     end;//end of if
  if I <= J then
     begin
     tmp:=a[i];
     a[i]:=a[j];
     a[j]:=tmp;
     inc(I);
     dec(J);
     end;//end of if
  until I > J;
if L < J then sortINT(a,l,j,_asc);
L := I;
until I >= R;
except;end;
end;
//## dualsortINT ##
procedure tgeneral.dualsortINT(var a,b:array of integer;l,r:integer;_asc:boolean);//ascending
var
  tmp,p,i,j:integer;
begin
try
repeat
I := L;
J := R;
P := a[(L + R) shr 1];
  repeat
  if _asc then
     begin
     while (a[I]<P) do inc(I);
     while (a[J]>P) do dec(J);
     end
  else
     begin
     while (a[I]>P) do inc(I);//* ">"
     while (a[J]<P) do dec(J);//* "<"
     end;//end of if
  if I <= J then
     begin
     //.a
     tmp:=a[i];
     a[i]:=a[j];
     a[j]:=tmp;
     //.b
     tmp:=b[i];
     b[i]:=b[j];
     b[j]:=tmp;
     inc(I);
     dec(J);
     end;//end of if
  until I > J;
if L < J then dualsortINT(a,b,l,j,_asc);
L := I;
until I >= R;
except;end;
end;
//## parseexts ##
procedure tgeneral.parseexts(x:string;y:tdynamicname);//parse extensions list
var
   a:tstringlist;
   p:integer;
begin
try
//check
if (x='') or (y=nil) then exit;
//prepare
a:=nil;
a:=tstringlist.create;
//process
//.split
swapstrs(x,';',rcode);
//.get
a.text:=x;
//.set
for p:=0 to (a.count-1) do if (a.strings[p]<>'') and (-1=y.findfast(0,a.strings[p])) then y.value[y.count]:=a.strings[p];
except;end;
try;freeobj(@a);except;end;
end;
//## urlAUTODATA ##
procedure tgeneral.urlAUTODATA(getpost,url:string;var u,content:string);
var
   tmp:string;
begin
try
if (0=comparetext(getpost,'GET')) then urlDATAb(url,u,content)
else urlDATAb(url,u,tmp);
except;end;
end;
//## urlDATA ##
function tgeneral.urlDATA(u:string):string;
var
   tmp:string;
begin
try;urlDATAb(u,tmp,result);except;end;
end;
//## urlDATAb ##
procedure tgeneral.urlDATAb(url:string;var u,d:string);
var
   urllen,p:integer;
begin
try
//defaults
urllen:=length(url);
u:=url;
d:='';
//process
for p:=1 to urllen do if (url[p]='?') then
   begin
   u:=copy(url,1,p-1);
   d:=copy(url,p+1,urllen);
   break;
   end;//end of if
except;end;
end;
//## urlEXT ##
function tgeneral.urlEXT(u:string):string;//date: 01-FEB-2005
var
   pos:integer;
begin
try;result:=urlEXTb(u,pos);except;end;
end;
//## urlEXTb ##
function tgeneral.urlEXTb(u:string;var pos:integer):string;//date: 01-FEB-2005
var//Assumes url is of format "http://xyz.com/dir/filename.ext" or "/filename.ext",
   //requires atleast one slash (/ or \) to mark end of domain+path and start of filename.ext,
   //jumps over ? and #, ie. http://www.blaiz.net/index.html?abc.com#smiths.rtf => html
   once,sOK:boolean;
   es,ef,uLEN,p:integer;
   e:string;
begin
try
//defaults
result:='';
//prepare
once:=true;
sOK:=false;
uLEN:=length(u);
ef:=uLEN;
es:=uLEN+1;
pos:=uLEN+1;
//process
//.get
for p:=uLEN downto 1 do
  if (u[p]='/') or (u[p]='\') then
     begin
     if (p>=2) and ((u[p-1]='/') or (u[p-1]='\'))then break;
     sOK:=true;
     break;
     end
  else if (u[p]='?') or (u[p]='#') then
     begin
     ef:=p-1;
     once:=true;
     end
  else if once and (u[p]='.') then
     begin
     es:=p+1;
     pos:=p;
     once:=false;
     end;//end of if
//.set (uppercase filtering = 2x slower, instead use "comparetext")
if sOK then result:=copy(u,es,ef-es+1);
except;end;
end;
//## chop ##
procedure tgeneral.chop(var x:string;var xlen:integer;index,count:integer);
var
   p:integer;
begin
try
for p:=index to (xlen-count) do x[p]:=x[p+count];
dec(xlen,count);
except;end;
end;
//## urlcpath ##
function tgeneral.urlcpath(x:string):string;//collapse url path
var//Accepts: "/abc/...\../.\../xyz/index.html"
   xs:boolean;
   s,n,xLEN,p:integer;
begin
try
//defaults
result:='';
xLEN:=length(x);
n:=0;
s:=-1;
//process
//.force one slash style
for p:=1 to xLEN do if (x[p]='\') then x[p]:='/';
//.scan
p:=xLEN;
repeat
xs:=(x[p]='/');
// "/../"
if xs and (p>=4) and (x[p-3]='/') and (x[p-2]='.') and (x[p-1]='.') then
   begin
   chop(x,xLEN,p-3,3);
   dec(s,3);
   dec(p,2);
   inc(n);
   xs:=(p>=1) and (x[p]='/');
   end
// "/./"
else if xs and (p>=3) and (x[p-2]='/') and (x[p-1]='.') then
   begin
   chop(x,xLEN,p-2,2);
   dec(s,2);
   dec(p,1);
   xs:=(p>=1) and (x[p]='/');
   end;//end of if
// "/xyz/"
if xs and (n>=1) and (s<>p) then
   begin
   if (s<=0) then s:=p
   else if ((s-p)<=1) then s:=p
   else
       begin
       chop(x,xLEN,p,s-p);
       dec(n);
       inc(p);
       if (n>=1) then s:=p-1 else s:=-1;
       end;//end of if
   end;//end of if
//.inc
dec(p);
until (p<=0) or (xLEN<=0);
//return result
setlength(x,xLEN);
result:=x;
except;end;
end;
//## fqb ##
function tgeneral.fqb(var x:string;var ri,rc:integer):boolean;//find quote boundaries
var
   o,v,p,s,a:integer;
begin
try
//defaults
result:=false;
if (ri<1) then ri:=1;
if (rc<1) then rc:=length(x);
//check
if (rc<1) or (ri<1) or (ri>rc) then exit;
//prepare
p:=ri;
s:=0;
a:=0;
//process
//.scan
repeat
v:=ord(x[p]);
//.ignore
if (v<>32) or (s<>0) then
   begin
   //..start
   if (v=32) or (v=34) or (v=39) or (p=rc) then
      begin
      if (s=0) then
         begin
         a:=v;
         s:=p+1;
         end
      else
         begin
         //.prepare
         o:=99;
         //.marked stop
         if (s<>0) then
            begin
            if (a<>0) then
               begin
               if (a=v) then o:=-1
               else if (p=rc) then o:=0;
               end
            else if ((v<>34) and (v<>39)) then o:=0;//non-marked stop
            end;//end of if
         //.stop
         if (o<>99) then
            begin
            ri:=s;
            rc:=p-s+1+o;
            result:=true;
            break;
            end;//end of if
         end;//end of if
   end else if (s=0) then s:=p;//end of if
   end;//end of if
//.inc
inc(p);
until (p>rc);
except;end;
end;
//## sdigpad ##
function tgeneral.sdigpad(v:string;s:integer):string;//1 -> 01
const
   p='0000000000000000000000000000000000000000';//40
begin
try
result:=v;
result:=copy(p,1,frcmin(s-length(result),0))+result;
except;end;
end;
//## digpad ##
function tgeneral.digpad(v,s:integer):string;//1 -> 01
const
   p='0000000000';//10
begin
try
result:=inttostr(v);
result:=copy(p,1,frcmin(s-length(result),0))+result;
except;end;
end;
//## src ##
function tgeneral.src(var x:string):integer;//server reply code
begin
try;result:=srcb(x,wecOK);except;end;
end;
//## srcb ##
function tgeneral.srcb(var x:string;defcode:integer):integer;//server reply code
var
   p,_pos,_start,_length:integer;
begin
try
//defaults
result:=defcode;
//process
//.get first line
_pos:=1;
if readline(_pos,_start,_length,x) then for p:=_start to (_start+_length-1) do if (x[p]=#32) then
   begin
   result:=strint(copy(x,p+1,3));
   break;
   end;//end of if
except;end;
end;
//## remdupc ##
procedure tgeneral.remdupc(var x:string;c:char);//remove duplicate characters
var
   cv,v:byte;
   i,p,xLEN:integer;
   ok:boolean;
begin
try
//defaults
xLEN:=length(x);
if (xLEN=0) then exit;
cv:=byte(c);
ok:=false;
//process
//.get
i:=0;
for p:=1 to xLEN do
begin
v:=ord(x[p]);
if (v=cv) then
   begin
   if ok then inc(i)
   else if (i<>0) then x[p-i]:=x[p];
   ok:=true;
   end
else
   begin
   ok:=false;
   if (i<>0) then x[p-i]:=x[p];
   end;//end of if
end;//end of loop
//.set
if (i<>0) then setlength(x,xLEN-i);
except;end;
end;
//## remsymbols ##
procedure tgeneral.remsymbols(var x:string);//remove html symbols - &amp; &nbsp; &mdash; "&ABCDEFG;"
var//Note: &=38, ;=59
   v:byte;
   o,i,s,p,orglen,xLEN:integer;
   ok:boolean;
begin
try
//defaults
xLEN:=length(x);
if (xLEN=0) then exit;
//init
orglen:=xlen;
ok:=false;
p:=1;
s:=1;
//scan
repeat
v:=ord(x[p]);
case v of
160:begin
   x[p]:=#32;
   ok:=false;
   end;//end of begin
9,10,13,32:ok:=false;
38:begin
   s:=p;
   ok:=true;
   end;//end of begin
59:if ok then
      begin
      o:=p-s;
      //.replace with space
      x[s]:=#32;
      //.shift data down
      for i:=(p+1) to xlen do x[i-o]:=x[i];
      //.trim
      dec(xlen,o);
      //.reset
      ok:=false;
      p:=s;
      end;//end of if
end;//end of case
//inc
inc(p);
until (p>xlen);
//trim
if (orglen<>xlen) then setlength(x,xlen);
except;end;
end;
//## rembinary ##
procedure tgeneral.rembinary(var x:string);//remove binary characters
var
   v:byte;
   i,p,xLEN:integer;
begin
try
//defaults
xLEN:=length(x);
if (xLEN=0) then exit;
//process
//.get
i:=0;
for p:=1 to xLEN do
begin
v:=ord(x[p]);
case v of
0..8,11..12,14..31:inc(i)
else if (i<>0) then x[p-i]:=x[p];
end;//end of case
end;//end of loop
//.set
if (i<>0) then setlength(x,xLEN-i);
except;end;
end;
//## rcrb ##
procedure tgeneral.rcrb(var x:string;f:string);//remove characters defined by "f"
var
   v:char;
   flen,fp,i,p,xLEN:integer;
   ok:boolean;
begin
try
//defaults
xLEN:=length(x);
if (xLEN=0) then exit;
flen:=length(f);
if (flen=0) then exit;
//process
//.get
i:=0;
p:=1;
repeat
v:=x[p];
//.scan
ok:=false;
for fp:=1 to flen do if (f[fp]=v) then
   begin
   ok:=true;
   break;
   end;//end of if
//.decide
if ok then inc(i)
else if (i<>0) then x[p-i]:=v;
//.inc
inc(p);
until (p>xLEN);
//.set
if (i<>0) then setlength(x,xLEN-i);
except;end;
end;
//## rcr ##
procedure tgeneral.rcr(var x:string;s,f:byte);//remove character range
var
   v:byte;
   i,p,xLEN:integer;
begin
try
//check
if (s>f) then exit;
//defaults
xLEN:=length(x);
if (xLEN=0) then exit;
//process
//.get
i:=0;
for p:=1 to xLEN do
begin
v:=ord(x[p]);
if (v>=s) and (v<=f) then inc(i)
else if (i<>0) then x[p-i]:=x[p];
end;//end of loop
//.set
if (i<>0) then setlength(x,xLEN-i);
except;end;
end;
//## networkcodes ##
function tgeneral.networkcodes(sep,eol:string):string;
const//Note: eol=end of line
   ma='-- ';
   mb=' --';
var
   p,len:integer;
   thsep,tlsep,z:string;
   once:boolean;
begin
try
//defaults
result:='';
once:=false;
len:=0;
tlsep:='';//text line sep
thsep:='';//text header sep
if (sep='') then sep:=#9;
if (eol='') then eol:=rcode;
if (eol=#10) or (eol=rcode) then tlsep:=eol;
if (sep=#9) or (sep=#0) then thsep:=sep;
//process
//.get
for p:=0 to 999 do
begin
//.headers
if (p=0) then pushb(len,result,ma+tsServer+#32+tsOrientated+mb+thsep+eol)
else if (p=900) then pushb(len,result,tlsep+ma+tsClient+#32+tsOrientated+mb+thsep+eol);
if (p=0) or (p=900) then pushb(len,result,tlsep+tsCode+sep+tsDescription+eol);
//.content
if ecdc(p,z) then pushb(len,result,inttostr(p)+sep+z+eol);
end;//end of loop
//.finalise
pushb(len,result,'');
//.trim last eol
if (copy(result,length(result)-length(eol)+1,length(eol))=eol) then setlength(result,length(result)-length(eol));
except;end;
end;
//## ecd ##
function tgeneral.ecd(c:integer):string;//error code description
begin
try;if not ecdc(c,result) then result:=weclUndefinedError;except;end;
end;
//## ecdb ##
function tgeneral.ecdb(c:integer;t:boolean):string;//error code description
begin
try;result:=inttostr(c)+' - '+general.aorbstr(ecd(c),translate(ecd(c)),t);except;end;
end;
//## ecdc ##
function tgeneral.ecdc(c:integer;var d:string):boolean;
begin
try
//defaults
result:=true;
d:='';
//process
case c of
//internal error codes
wecRedirectLimit:d:=weclRedirectLimit;
wecDownloadExceedsLimit:d:=weclDownloadExceedsLimit;
wecUnstable:d:=weclUnstable;
wecTransferBroken:d:=weclTransferBroken;
wecSkipped:d:=weclSkipped;
wecFileExists:d:=weclFileExists;
wecHeaderExceedsLimit:d:=weclHeaderExceedsLimit;
wecInvalidUrl:d:=weclInvalidUrl;
wecBotBanned:d:=weclBotBanned;
wecTaskFailed:d:=weclTaskFailed;
wecIPBanned:d:=weclIPBanned;
wecOutOfMemory:d:=weclOutOfMemory;
wecOutOfDiskSpace:d:=weclOutOfDiskSpace;
wecFileInUse:d:=weclFileInUse;
wecBadFileName:d:=weclBadFileName;
wecCancelled:d:=weclCancelled;
wecTimedOut:d:=weclTimedOut;
wecConnectionFailed:d:=weclConnectionFailed;
wecAddressNotFound:d:=weclAddressNotFound;
wecNoData:d:=weclNoData;
//http error codes
wecOK:d:=weclOK;
wecPartial:d:=weclPartial;
wecMoved:d:=weclMoved;
wecMovedPermanently:d:=weclMovedPermanently;
wecMovedTemporarily:d:=weclMovedTemporarily;
wecMovedTemporarily2:d:=weclMovedTemporarily2;
wecUseProxy:d:=weclUseProxy;
wecTemporaryRedirect:d:=weclTemporaryRedirect;
wecNotModified:d:=weclNotModified;
wecBadRequest:d:=weclBadRequest;
wecAuthorizationRequired:d:=weclAuthorizationRequired;
wecForbidden:d:=weclForbidden;
wecNotFound:d:=weclNotFound;
wecMethodNotAllowed:d:=weclMethodNotAllowed;
wecRequestedRangeNotSatisfiable:d:=weclRequestedRangeNotSatisfiable;
wecInternalServerError:d:=weclInternalServerError;
wecBadGateway:d:=weclBadGateway;
wecServiceUnavailable:d:=weclServiceUnavailable;
wecGatewayTimeout:d:=weclGatewayTimeout;
wecNotUsed:d:=weclNotUsed;
wecCapacityReached:d:=weclCapacityReached;
else result:=false;
end;//end of case
except;end;
end;
//## neterrCount ##
function tgeneral.neterrCount:integer;
begin
try;result:=1000;except;end;
end;
//## neterr ##
function tgeneral.neterr(c:integer;var d:string):boolean;//network error codes
begin
try;result:=ecdc(c,d);except;end;
end;
//## syserrFind ##
function tgeneral.syserrFind(x:string;var i:integer):boolean;
var
   p:integer;
   tmp:string;
begin
try
//defaults
result:=false;
i:=-1;
//init
if (ierrlist=nil) then
   begin
   ierrlist:=tdynamicnamelist.create;
   for p:=0 to (syserrCount-1) do
   begin
   syserr(p,tmp);
   ierrlist.add(tmp);
   end;//end of loop
   end;//end of if
//scan
i:=ierrlist.findfast(0,x);
result:=(i>=0);
except;end;
end;
//## syserrCount ##
function tgeneral.syserrCount:integer;
begin
try;result:=50;except;end;
end;
//## syserr ##
function tgeneral.syserr(c:integer;var d:string):boolean;//system error codes
begin
try
//defaults
result:=true;
d:='';
//decide
case c of
0:d:=gecUnexpectedError;
1:d:=gecFileInUse;
2:d:=gecNotFound;
3:d:=gecBadFileName;
4:d:=gecFileNotFound;
5:d:=gecUnknownFormat;
6:d:=gecTaskCancelled;
7:d:=gecPathNotFound;
8:d:=gecOutOfMemory;
9:d:=gecIndexOutOfRange;
10:d:=gecDataCorrupt;
11:d:=gecUnsupportedFormat;
12:d:=gecAccessDenied;
13:d:=gecOutOfDiskSpace;
14:d:=gecAProgramExistsWithThatName;
15:d:=gecUseAnother;
16:d:=gecSendToFailed;
17:d:=gecCapacityReached;
18:d:=gecNoFilesFound;
19:d:=gecUnsupportedEncoding;
20:d:=gecUnsupportedDecoding;
21:d:=gecEmpty;
22:d:=gecLocked;
23:d:=gecTaskFailed;
24:d:=gecTaskSuccessful;
//New 16/08/2002
25:d:='??';//12aug2025
26:d:=gecTaskTimedOut;
27:d:=gecIncorrectUnlockInformation;
28:d:=gecOk;
29:d:=gecReadOnly;
30:d:=gecRepeat;
31:d:=gecBusy;
32:d:=gecReady;
33:d:=gecWorking;
34:d:=gecSearching;
35:d:=gecNoFurtherMatchesFound;
36:d:=gecAccessGranted;
37:d:=gecFailed;
38:d:=gecDeleted;
39:d:=gecSkipped;
40:d:=gecEXTnotAllowed;
41:d:=gecSaved;
42:d:=gecNoContentPresent;
43:d:=gecSyntaxError;
44:d:=gecUnterminatedLine;
45:d:=gecUnterminatedString;
46:d:=gecUndefinedObject;
47:d:=gecPrivilegesModified;
48:d:=gecConnectionFailed;
49:d:=gecTimedOut;
end;//end of case
//successful
result:=(d<>'');
except;end;
end;
//## whXXX ##
procedure tgeneral.whXXX(var x:string;sn,lastmodified,e,mimedef:string;c:integer;nocache:boolean);
var//Version: HTTP/1.0 -> 01-JUL-2005, e=extension
   tmp,cc,z:string;
begin
try
//.code + code comment (-1=200, -200..-504 => 200..504)
if (c<=-2) then c:=-c
else if (c=-1) then c:=200;
//.decide
case c of
200:cc:='OK';
304:cc:='Not Modified';
400:cc:='Bad Request';
401:cc:='Authorization Required';
403:cc:='Forbidden';
404:cc:='Not Found';
405:cc:='Method Not Allowed';
500:cc:='Internal Server Error';
502:cc:='Bad Gateway';
503:cc:='Service Unavailable';
504:cc:='Gateway Timeout';
end;//end of case
//.server name
if (sn='') then sn:='-';
//.date
if (lastmodified<>'') then lastmodified:='Last-Modified: '+lastmodified+rcode;
//.data
tmp:='';
if (c=401) then tmp:=tmp+'WWW-Authenticate: Basic realm="'+programtitle+'"'+rcode;
z:=
'HTTP/1.0 '+inttostr(c)+#32+cc+rcode+
'Date: '+dates.gmtnow+rcode+
lastmodified+
'Server: '+sn+rcode+
'Content-Type: '+mimes.emb(e,mimedef)+rcode+
'Content-Length: '+inttostr(length(x))+rcode+
//..cache control
insstr(
 'Expires: -1'+rcode+
 'Cache-Control: no-cache, must-revalidate'+rcode+
 'Pragma: no-cache'+rcode
 ,nocache)+
'Connection: close'+rcode+
tmp+rcode;
insert(z,x,1);
except;end;
end;
//## whCODE ##
procedure tgeneral.whCODE(var header,content:string;code:integer);//write coded server response - 22FEB2008
begin
try
header:='';
//get - find code and it's response, if code not supported then switch to "404", since "wec.find" supports only a few basic codes
if not wec.find(code,content) then
   begin
   code:=404;
   wec.find(code,content);
   end;//end of if
whBUFFERS(header,content,servername,dates.gmtnow,'html','',code,true);
except;end;
end;
//## whREPLY ##
procedure tgeneral.whREPLY(var header,content:string;data,dataext:string);//automatically write server reply - 22FEB2008
begin
try
//defaults
header:='';
content:='';
//get
if (data='') then whCODE(header,content,wecNotFound)
else
   begin
   content:=data;
   whBUFFERS(header,content,servername,dates.gmtnow,udv(dataext,'html'),'',wecOK,true);
   end;//end of if
except;end;
end;
//## whBUFFERS ##
procedure tgeneral.whBUFFERS(var _header,_content:string;sn,lastmodified,ext,mimedef:string;c:integer;nocache:boolean);//write header to header buffer
begin
try;whBUFFERSb(_header,_content,sn,lastmodified,ext,mimedef,c,nocache,true);except;end;
end;
//## whBUFFERSb ##
procedure tgeneral.whBUFFERSb(var _header,_content:string;sn,lastmodified,ext,mimedef:string;c:integer;nocache,contentlength:boolean);//write header to header buffer
var//Version: HTTP/1.0 -> 01-JUL-2005
   //Updated: 13-APR-2006 (401 - realm now automatically part of security header, allowing OPERA-7 to login)
   tmp,cc,z:string;
begin
try
//.code + code comment (-1=200, -200..-504 => 200..504)
if (c<=-2) then c:=-c
else if (c=-1) then c:=200;
//.decide
case c of
200:cc:='OK';
304:cc:='Not Modified';
400:cc:='Bad Request';
401:cc:='Authorization Required';
403:cc:='Forbidden';
404:cc:='Not Found';
405:cc:='Method Not Allowed';
500:cc:='Internal Server Error';
502:cc:='Bad Gateway';
503:cc:='Service Unavailable';
504:cc:='Gateway Timeout';
end;//end of case
//.server name
if (sn='') then sn:='-';
//.date
if (lastmodified<>'') then lastmodified:='Last-Modified: '+lastmodified+rcode;
//.data
tmp:='';
if (c=401) then tmp:=tmp+'WWW-Authenticate: Basic realm="'+programtitle+'"'+rcode;
z:=
'HTTP/1.0 '+inttostr(c)+#32+cc+rcode+
'Date: '+dates.gmtnow+rcode+
lastmodified+
'Server: '+sn+rcode+
'Content-Type: '+mimes.emb(ext,mimedef)+rcode+
//..contentlength
insstr('Content-Length: '+inttostr(length(_content))+rcode,contentlength)+
//..cache control
insstr(
 'Expires: -1'+rcode+
 'Cache-Control: no-cache, must-revalidate'+rcode+
 'Pragma: no-cache'+rcode
 ,nocache)+
'Connection: close'+rcode+
tmp+rcode;
insert(z,_header,1);
except;end;
end;
//## safefilename ##
function tgeneral.safefilename(x:string;allowpath:boolean):string;
var
   minp,p:integer;
   c:char;
begin
try
//defaults
result:=x;
//process
if allowpath then
   begin
   //.get
   if (copy(x,1,2)='\\') then minp:=3 else minp:=1;
   //.set
   for p:=minp to length(result) do
   begin
   c:=result[p];
   if (c='/') then result[p]:='\'
   else if (c='*') or (c='?') or (c='"') or (c='<') or (c='>') or (c='|') then result[p]:=pcSymSafe;
   end;//end of loop
   end
else
   begin
   //.set
   for p:=1 to length(result) do
   begin
   c:=result[p];
   if (c='\') or (c='/') or (c=':') or (c='*') or (c='?') or (c='"') or (c='<') or (c='>') or (c='|') then result[p]:=pcSymSafe;
   end;//end of loop
   end;//end of if
except;end;
end;
//## ufnSTRING ##
function tgeneral.ufnSTRING(x:string):string;
var
   p:integer;
begin
try
//defaults
result:=x;
//process
for p:=1 to length(result) do
    case ord(result[p]) of
    65..90,97..122,48..57,45,95:;//[A-Z,a-z,0-9,-,_]
    else result[p]:=pcSymSafe;
    end;//end of case
except;end;
end;
//## ufn ##
function tgeneral.ufn(url:string):string;//url as filename (http://google.com/index.html -> google_com_index.html)
begin
try;result:=ufnb(url,true);except;end;
end;
//## ufnb ##
function tgeneral.ufnb(url:string;includeURL:boolean):string;//url as filename (http://google.com/index.html -> google_com_index.html)
var
   i:tparseurl;
   tmp:string;
begin
try
//defaults
result:='';
//process
//.get
pu('http://'+url,'',i,[pusExcludeData,pusExcludeMark]);
//.set
if includeURL then
   begin
   if (i.h<>'') then result:=result+ufnSTRING(i.h);//+'-';
   if (i.pt<>80) then result:=result+inttostr(i.pt)+pcSymSafe;
   end;//end of if
if (i.p<>'') then
   begin
   if (not includeURL) and (i.p<>'') and ((i.p[1]='\') or (i.p[1]='/')) then i.p:=copy(i.p,2,length(i.p));
   result:=result+ufnSTRING(i.p);//+'-';
   end;//end of if
if (i.f<>'') then result:=result+i.f;
except;end;
end;
//## putb ##
function tgeneral.putb(x:string):string;
var
   r,rLEN:integer;
begin
try
//defaults
r:=0;
rLEN:=0;
//process
if put(x,r,rLEN,true) then result:=copy(x,r,rLEN) else result:='';
except;end;
end;
//## put ##
function tgeneral.put(var x:string;var r,rLEN:integer;all:boolean):boolean;//parse url type "X..Z://" ie. "http://, https://, ftp://" etc
var//0=error, 1..4..X=end of web url type
   s,sLEN,p:integer;
begin
try
//defaults
result:=false;
s:=r;
sLEN:=rLEN;
if (s<1) then s:=1;
if (sLEN<1) then sLEN:=length(x);
//process
for p:=s to (s+sLEN-3) do
  if (x[p]=':') and (x[p+1]='/') and (x[p+2]='/') then
     begin
     r:=p+3;
     if not all then break;
     end
  else if (x[p]='?') or (x[p]='#') then break;//stop on "data" or "mark"
  //end of if
//.rLEN
if (s<>r) then
   begin
   result:=true;
   dec(rLEN,r-s);
   end;//end of if
except;end;
end;
//## puCLEAR ##
procedure tgeneral.puCLEAR(var x:tparseurl);
begin
try
x.u:='';
x.h:='';
x.p:='';
x.f:='';
x.e:='';
x.d:='';
x.m:='';
x.pt:=0;
x.cu:='';
x.ca:='';
except;end;
end;
//## pu ##
procedure tgeneral.pu(u,ou:string;var i:tparseurl;s:tparseurlstyle);//parse url 11-MAR-2005
begin
try;pub(u,ou,i,s,80);except;end;
end;
//## pub ##
procedure tgeneral.pub(u,ou:string;var i:tparseurl;s:tparseurlstyle;dp:word);
begin
try;puc(u,ou,i,s,dp,0);except;end;
end;
//## puc ##
procedure tgeneral.puc(u,ou:string;var i:tparseurl;s:tparseurlstyle;dp,fp:word);//parse url 05-JUL-2005, updated 03-FEB-2007
label//fast version: 3,000+ complex parse/split/collapse per second (420% faster) @ 200Mhz
     //supports: http, https, ftp etc (converts service name to port number, ie ftp://www.blaiz.net/index.html => www.blaiz.net:21/index.html
     //dp: = default port if none specified
     host_start,host_end,port_end,path_end,data_end,mark_end,skipend;
var
   a,a2:char;
   o:tparseurl;
   os:tparseurlstyle;
   tmpp,uLEN,z,ap,lp,op,p:integer;
begin
try
//defaults
with i do
begin
u:='';
h:='';
p:='/';
f:='';
e:='';
d:='';
m:='';
cu:='';
ca:='';
pt:=dp;
end;//end of with
uLEN:=length(u);
//process
//.quotes
if not (pusExcludeQuotes in s) then
   begin
   p:=1;
   ap:=uLEN;
   if fqb(u,p,uLEN) then
      begin
      if (p<>1) or (uLEN<>ap) then u:=copy(u,p,uLEN);
      end
   else exit;
   end;//end of if
//.re-check
if (uLEN=0) then exit;
//.split
tmpp:=1;
p:=1;
lp:=1;
ap:=0;
host_start:
op:=p;
if ((p+7)<=uLEN) and (u[p+5]=':') and (u[p+6]='/') then inc(p,7)// "ABCDE://"
else if ((p+6)<=uLEN) and (u[p+4]=':') and (u[p+5]='/') then inc(p,6)// "ABCD://"
else if ((p+5)<=uLEN) and (u[p+3]=':') and (u[p+4]='/') then inc(p,5)// "ABC://"
else if ((p+1)<=uLEN) and ((u[p]='\') or (u[p]='/')) and ((u[p+1]='\') or (u[p+1]='/')) then inc(p,1)// "\\" or "//"
else if ((p+2)<=uLEN) and (u[p+1]=':') and ((u[p+2]='\') or (u[p+2]='/')) then// "X:\" or "X:/"
     begin
     i.h:=u[p];//host is "drive letter"
     inc(p,2);
     lp:=p;
     goto path_end;
     end;//end of if
if (op=p) then
   begin
   lp:=p;
   if (p=1) then goto path_end
   else goto host_end;
   end
else
   begin
   if ((p-tmpp)>=4) and (u[p-2]=':') then i.pt:=netsession.findservice(dp,dp,copy(u,tmpp,p-tmpp-2));
   tmpp:=p+1;
   end;//end of if
//.inc
inc(p);
if (p<=uLEN) then goto host_start else goto skipend;

host_end:
if (u[p]='/') or (u[p]='\') or (u[p]=':') then
   begin
   i.h:=copy(u,lp,p-lp);
   lp:=p;
   if (u[p]=':') then
      begin
      inc(lp);
      goto port_end
      end
   else goto path_end;
   end
else if (p>=uLEN) then i.h:=copy(u,lp,uLEN);
//.inc
inc(p);
if (p<=uLEN) then goto host_end else goto skipend;

port_end:
if (u[p]='/') or (u[p]='\') then
   begin
   i.pt:=strint(copy(u,lp,p-lp));
   lp:=p;//include slash
   goto path_end;
   end
else if (p>=uLEN) then i.pt:=strint(copy(u,lp,uLEN));
//.inc
inc(p);
if (p<=uLEN) then goto port_end else goto skipend;

path_end:
if (u[p]='/') or (u[p]='\') then ap:=p;
if (u[p]='?') or (u[p]='#') then
   begin
   i.p:=copy(u,lp,ap-lp+1);
   i.f:=copy(u,ap+1,p-ap-1);
   lp:=p;
   if (u[p]='?') then goto data_end
   else if (u[p]='#') then goto mark_end;
   end
else if (p>=uLEN) then
   begin
   i.p:=copy(u,lp,ap-lp+1);
   i.f:=copy(u,ap+1,p-ap+1);
   end;//end of if
//.inc
inc(p);
if (p<=uLEN) then goto path_end else goto skipend;

data_end:
if (u[p]='#') then
   begin
   i.d:=copy(u,lp,p-lp);
   lp:=p;
   goto mark_end;
   end
else if (p>=uLEN) then i.d:=copy(u,lp,p-lp+1);
//.inc
inc(p);
if (p<=uLEN) then goto data_end else goto skipend;

mark_end:
i.m:=copy(u,lp,uLEN);

skipend:
//.ext.end
for p:=length(i.f) downto 1 do if (i.f[p]='.') then
    begin
    i.e:=copy(i.f,p+1,length(i.f));
    break;
    end;//end of if
//.path.clean
swapchars(i.p,'\','/');
//.convert "//" to "/" for path "ui.p"
if not (pusExcludePathClean in s) then remdupc(i.p,'/');
if (i.p<>'') and (i.p[1]<>'/') then i.p:='/'+i.p;
//.optional host
if (i.h='') and (ou<>'') then
   begin
   os:=[pusExcludeMark,pusExcludeData,pusExcludeCleanURL];
   if (pusExcludeCollapse in s) then include(os,pusExcludeCollapse);
   if (pusExcludeQuotes in s) then include(os,pusExcludeQuotes);
   pub(ou,'',o,os,dp);
   if (o.h<>'') then i.h:=o.h;
   if (o.p<>'') then
      begin
      if (i.p<>'') and (o.p<>'') then o.p:=copy(o.p,1,length(o.p)-1);
      i.p:=o.p+i.p;
      end;//end of if
   i.pt:=o.pt;
   end;//end of if
//.force port
if (fp<>0) then i.pt:=fp;
//.collapse path
if (i.p<>'') and (not (pusExcludeCollapse in s)) then i.p:=urlcpath(i.p);
//.ip-port
if (pusIPPort in s) then
   begin
   //.host as ip
   i.ip:=_intip(i.h);
   //.force host to be a ip address (domain names will result in an error ip of 0.0.0.0)
   i.h:=_strip(i.ip);
   end;//end of if
//.clean url
if not (pusExcludeCleanURL in s) then
   begin
   i.cu:=i.h;
   if ((i.pt<>dp) or (fp<>0)) and (not (pusExcludePort in s)) then i.cu:=i.cu+':'+inttostr(i.pt);
   i.ca:=i.cu;//clean address (host or host:port = automatic)
   i.cu:=i.cu+i.p+i.f;
   if not (pusExcludeData in s) then i.cu:=i.cu+i.d;
   if not (pusExcludeMark in s) then i.cu:=i.cu+i.m;
   if (i.cu<>'') and (length(i.p)<=1) and (i.cu[length(i.cu)]='/') then setlength(i.cu,length(i.cu)-1);
   end;//end of if
except;end;
end;
//## shortbeep ##
procedure tgeneral.shortbeep(_repeats:integer);
begin
try;shortbeepb(_repeats,200,60);except;end;
end;
//## shortbeepb ##
procedure tgeneral.shortbeepb(_repeats,_delay,_strength:integer);
var
   r,p:integer;
begin
try
//range
_delay:=frcmin(_delay,5);
_strength:=frcrange(_strength,5,500);
//process
for r:=1 to _repeats do
begin
if (r>=2) then sleep(_delay);
for p:=1 to _strength do beep;
end;//end of r
except;end;
end;
//## keyON ##
function tgeneral.keyON(k:integer):boolean;
begin//Note: "VK_NUMLOCK" is detected correctly, though it cannot be set
try;result:=boolean(GetKeyState(k));except;end;
end;
//## keyESET ##
function tgeneral.keyESET(k:integer;_on:boolean):boolean;
begin//Note: "VK_NUMLOCK" does not work on m17.keyboard
try  //Warning: Should only be used for VK_CAPITAL and VK_SCROLL (as these are extended keyboard keys)
if (keyON(k)<>_on) then
   begin
   keybd_event(k,0,KEYEVENTF_EXTENDEDKEY or 0,0);
   keybd_event(k,0,KEYEVENTF_EXTENDEDKEY or KEYEVENTF_KEYUP,0);
   end;//end of if
except;end;
end;
//## shortblinkb ##
procedure tgeneral.shortblinkb(_key,_repeats,_delay:integer);
var
   r,p:integer;
begin
try
//range
_delay:=frcmin(_delay,5);
_repeats:=frcmin(_repeats,1);
//process
for r:=1 to _repeats do
begin
//.on
keyESET(_key,true);
//.off
keyESET(_key,false);
//.pause
sleep(_delay);
end;//end of r
except;end;
end;
//## shortblink ##
procedure tgeneral.shortblink(_key,_repeats:integer);
begin
try;shortblinkb(_key,_repeats,100);except;end;
end;
//## rword ##
function tgeneral.rword:word;
begin
try;result:=random(high(word));except;end;
end;
//## rwordSTR ##
function tgeneral.rwordSTR:string;
begin
try;result:=inttostr(random(high(word)));except;end;
end;
//## setBOL ##
function tgeneral.setBOL(new:boolean;var value:boolean):boolean;
begin
try
//defaults
result:=false;
//process
if (new<>value) then
   begin
   value:=new;
   result:=true;
   end;//end of if
except;end;
end;
//## setWRD ##
function tgeneral.setWRD(new:integer;var value:word):boolean;
var
   tmp:word;
begin
try
//defaults
result:=false;
//range
tmp:=word(new);
//process
if (tmp<>value) then
   begin
   value:=tmp;
   result:=true;
   end;//end of if
except;end;
end;
//## setINT ##
function tgeneral.setINT(new:integer;var value:integer):boolean;
begin
try
//defaults
result:=false;
//process
if (new<>value) then
   begin
   value:=new;
   result:=true;
   end;//end of if
except;end;
end;
//## setSTRING ##
function tgeneral.setSTRING(new:string;var value:string):boolean;
begin
try
//defaults
result:=false;
//process
if (new<>value) then
   begin
   value:=new;
   result:=true;
   end;//end of if
except;end;
end;
//## setWINCONTROL ##
function tgeneral.setWINCONTROL(new:twincontrol;var value:twincontrol):boolean;
begin
try
//defaults
result:=false;
//process
if (new<>value) then
   begin
   value:=new;
   result:=true;
   end;//end of if
except;end;
end;
//## lockbool ##
function tgeneral.lockbool(var x:boolean):boolean;
begin
try
result:=not x;
if result then x:=true;
except;end;
end;
//## lock ##
function tgeneral.lock(var x:integer):boolean;
begin
try;x:=x+1;result:=(x<>0);except;end;
end;
//## unlock ##
function tgeneral.unlock(var x:integer):boolean;
begin
try;x:=x-1;result:=(x<>0);except;end;
end;
//## locked ##
function tgeneral.locked(x:integer):boolean;
begin
try;result:=(x<>0);except;end;
end;
//## lockb ##
function tgeneral.lockb(var x:integer;var _lockedVAR:boolean;_onchange:tnotifyevent;sender:tobject):boolean;
begin
try
result:=lock(x);
if (result<>_lockedVar) then
   begin
   _lockedVar:=result;
   fireevent(_onchange,sender);
   end;//end of if
except;end;
end;
//## unlockb ##
function tgeneral.unlockb(var x:integer;var _lockedVAR:boolean;_onchange:tnotifyevent;sender:tobject):boolean;
begin
try
result:=unlock(x);
if (result<>_lockedVar) then
   begin
   _lockedVar:=result;
   fireevent(_onchange,sender);
   end;//end of if
except;end;
end;
//### ptc ##
function tgeneral.ptc(x:char):boolean;//plain text character
begin
try
case ord(x) of
45,48..57,65..90,97..122:result:=true;
else result:=false;
end;//end of case
except;end;
end;
//## plaintext ##
function tgeneral.plaintext(x:string;allowLATIN1:boolean):string;//25NOV2007
var
   i,p,len:integer;
   c:byte;
   ok:boolean;
begin
try
//defaults
result:=x;
len:=length(result);
i:=0;
x:='';
//scan
for p:=1 to len do
begin
//get
c:=byte(result[p]);
//decide
ok:=false;
case c of
9,10,13,32..126:ok:=true;
192..255:if allowLATIN1 then ok:=true;
end;//end of case
//set
if not ok then inc(i)
else if (i<>0) then result[p-i]:=result[p];
end;//end of loop
//shrink
if (i<>0) then setlength(result,len-i);
except;end;
end;
//### eptc ##
function tgeneral.eptc(x:char):boolean;//enhanced/plain text character
begin//Note: 32 and 160 are both spaces
try  //192..255 = enhanced latin-1 word characters
     //45 = dash "_" (multi-million), 64 = at "@" (contact@blaiz)
case ord(x) of
45,48..57,64..90,97..122,192..255:result:=true;
else result:=false;
end;//end of case
except;end;
end;
//## keywordsb ##
function tgeneral.keywordsb(x:string;limit:integer):string;//extract keywords
var
   count:integer;
begin
try;result:=keywords(x,limit,count);except;end;
end;
//## keywordclean ##
function tgeneral.keywordclean(x:string):string;//31-JAN-2007
var
   s,f,p,xlen:integer;
begin//sub-section of "keywords"
try
//defaults
result:='';
xlen:=length(x);
s:=0;
f:=0;
//scan up
for p:=1 to xlen do if (x[p]<>'-') then
   begin
   s:=p;
   break;
   end;//end of if
//scan down
if (s>=1) then for p:=xlen downto s do if (x[p]<>'-') then
   begin
   f:=p;
   break;
   end;//end of if
//set
if (s>=1) and (f>=s) then result:=copy(x,s,f-s+1);
except;end;
end;
//## keywords ##
function tgeneral.keywords(var x:string;limit:integer;var count:integer):string;//31-JAN-2007
var
   v:char;
   s,p,xlen,len:integer;
   e,ok:boolean;
   z:string;
begin
try
//defaults
result:='';
len:=0;
xlen:=length(x);
count:=0;
s:=0;
//process
for p:=1 to xlen do
begin
//.get
v:=x[p];
e:=eptc(v);
//.start
if e then
   begin
   if (s=0) then s:=p;
   end
else
   begin
   if (s<>0) then
      begin
      //.get
      z:=keywordclean(copy(x,s,p-s));
      s:=0;
      //.add
      if (z<>'') then
         begin
         pushb(len,result,z+',');
         //.inc
         inc(count);
         end;//end of if
      //.check
      if (limit>=1) and (count>=limit) then break;
      end;//end of if
   end;//end of if
end;//end of loop
//.finish
if (s<>0) and ((limit<=0) or (count<limit)) then
   begin
   //.get
   z:=keywordclean(copy(x,s,p-s+1));
   s:=0;
   //.add
   if (z<>'') then
      begin
      pushb(len,result,z+',');
      //.inc
      inc(count);
      end;//end of if
   end;//end of if
//.finalise
if (count>=1) then pushb(len,result,'');
except;end;
end;
//## iroll ##
procedure tgeneral.iroll(var x:integer;by:integer);//continuous incrementer with safe auto. reset
begin//if (x>capacity) reset to 0
try;x:=x+by;except;x:=0;end;
end;
//## irollb ##
procedure tgeneral.irollb(var x:integer;by,ex:integer);//continuous incrementer with safe auto. reset to user specified value
begin//if (x>capacity) reset to ex
try;x:=x+by;except;x:=ex;end;
end;
//## croll ##
procedure tgeneral.croll(var x:currency;by:currency);//continuous incrementer with safe auto. reset
begin//if (x>capacity) reset to 0
try;x:=x+by;except;x:=0;end;
end;
//## crollb ##
procedure tgeneral.crollb(var x:currency;by,ex:currency);//continuous incrementer with safe auto. reset
begin//if (x>capacity) reset to ex
try;x:=x+by;except;x:=ex;end;
end;
//## split ##
function tgeneral.split(var x,x1,x2:string;z:char):boolean;
var
   p:integer;
begin
try
//defaults
result:=false;
x1:='';
x2:='';
if (x='') then exit;
//process
//.set
for p:=1 to length(x) do if (x[p]=z) then
    begin
    x1:=copy(x,1,p-1);
    x2:=copy(x,p+1,length(x));
    result:=true;
    break;
    end;//end of loop
//.check
if not result then x1:=x;
except;end;
end;
//## findbrkval ##
function tgeneral.findbrkval(var _pos:integer;var _data:string;_type:char):string;//find bracket value
var
   a,b:char;
   s,p:integer;
begin
try
//defaults
result:='';
if (_pos<=0) then exit;
//prepare
a:=_type;
//.start
if (_type='(') then b:=')'
else if (_type='<') then b:='>'
else if (_type='{') then b:='}'
else if (_type='[') then b:=']'
//.invert-start
else if (_type=')') then b:='('
else if (_type='>') then b:='<'
else if (_type='}') then b:='{'
else if (_type=']') then b:='['
else
    begin
    a:='(';
    b:=')';
    end;//end of if
//process
s:=0;
for p:=_pos to length(_data) do
    if (_data[p]=a) then s:=p
    else if (s<>0) and (_data[p]=b) then
         begin
         result:=copy(_data,s+1,p-s-1);
         _pos:=p+1;
         break;
         end;//end of if
except;end;
end;
//## notDS09AZ ##
function tgeneral.notDS09AZ(var pos:integer;var x:string):boolean;//finds character outside of range
var
   p:integer;
begin
try
//defaults
result:=false;
//process
for p:=pos to length(x) do
    case ord(x[p]) of
    46,32,48..57,97..122,65..90:;//<dot>,<space>,0..9, a..z, A..Z
    else begin;result:=true;pos:=p;break;end
    end;//end of case
except;end;
end;
//## findchar ##
function tgeneral.findchar(var x:string;c:char):integer;//14SEP2007
var
   p:integer;
begin
try
//defaults
result:=0;//not found
//process
for p:=1 to length(x) do if (x[p]=c) then
   begin
   result:=p;
   break;
   end;//end of if
except;end;
end;
//## havechar ##
function tgeneral.havechar(var x:string;c:char):boolean;//02FEB2008
var
   p:integer;
begin
try
//defaults
result:=false;
//scan
for p:=1 to length(x) do if (x[p]=c) then
   begin
   result:=true;
   break;
   end;//end of if
except;end;
end;
//## havecharU ##
function tgeneral.havecharU(var x:string;c:char):boolean;//02FEB2008
var
   p:integer;
   uc:char;
begin
try
//defaults
result:=false;
//get
uc:=c;
if (c>='a') and (c<='z') then uc:=char(byte(c)-32)
else if (c>='A') and (c<='Z') then uc:=char(byte(c)+32);
//scan
for p:=1 to length(x) do if (x[p]=c) or (x[p]=uc) then
   begin
   result:=true;
   break;
   end;//end of if
except;end;
end;
//## findchardown ##
function tgeneral.findchardown(var x:string;c:char):integer;//15SEP2007
var
   p:integer;
begin
try
//defaults
result:=0;//not found
//process
for p:=length(x) downto 1 do if (x[p]=c) then
   begin
   result:=p;
   break;
   end;//end of if
except;end;
end;
//## copyuptob ##
function tgeneral.copyuptob(x:string;c:char):string;
begin
try;result:=copyupto(x,c);except;end;
end;
//## copyupto ##
function tgeneral.copyupto(var x:string;c:char):string;
var//Copyies all text if "c" not found, else copies upto but not including "c"
   p:integer;
begin
try
//defaults
result:=x;
//get
for p:=1 to length(x) do if (x[p]=c) then
   begin
   result:=copy(result,1,p-1);
   break;
   end;//end of if
except;end;
end;
//## copydowntob ##
function tgeneral.copydowntob(x:string;c:char):string;
begin
try;result:=copydownto(x,c);except;end;
end;
//## copydownto ##
function tgeneral.copydownto(var x:string;c:char):string;
var//Copyies all text if "c" not found, else copies downto but not including "c"
   p:integer;
begin
try
//defaults
result:=x;
//get
for p:=length(x) downto 1 do if (x[p]=c) then
   begin
   result:=copy(result,p+1,length(x));
   break;
   end;//end of if
except;end;
end;
//## findchars ##
function tgeneral.findchars(var _pos,_listpos:integer;var _data:string;_list:string):boolean;
const
     sizea=99;
var
   a:array [0..(sizea-1)] of byte;
   v:byte;
   i,p,LEN,lLEN:integer;
begin
try
//defaults
result:=false;
LEN:=length(_data);
lLEN:=frcmax(length(_list),sizea);
_listpos:=0;
//check
if (_pos>=len) or (_pos<0) or (len=0) or (lLEN=0) then exit;
for p:=1 to lLEN do a[p-1]:=ord(_list[p]);
//process
for p:=(_pos+1) to LEN do
begin
//.get
v:=ord(_data[p]);
i:=0;
repeat
if (v=a[i]) then
   begin
   result:=true;
   _pos:=p;
   _listpos:=i+1;
   exit;
   end;//end of if
inc(i);
until (i>=lLEN);
end;//end of loop
except;end;
end;
//## findtextb ##
function tgeneral.findtextb(var _pos:integer;_len:integer;var _data:string;_find:string):boolean;
var
   p:integer;
begin
try
p:=_pos;
result:=findtextL(p,_len,_data,_find);
if result then _pos:=p;
except;end;
end;
//## findtext ##
function tgeneral.findtext(var _pos:integer;var _data:string;_find:string):boolean;
begin
try;result:=findtextL(_pos,length(_data),_data,_find);except;end;
end;
//## findtextL ##
function tgeneral.findtextL(var _pos:integer;_len:integer;var _data:string;_find:string):boolean;
var//optimised for speed: 70,000 lines in ~270ms
   a,b,d,f:byte;
   p2,p,fLEN:integer;
begin
try
//defaults
result:=false;
fLEN:=length(_find);
//check
if (_len=0) or (fLEN=0) or (fLEN>_LEN) then exit;
//.d
d:=ord(_find[1]);
if (d>=97) and (d<=122) then d:=d-32;//uppercase
//process
for p:=_pos to (_LEN-fLEN+1) do
begin
//.get
f:=ord(_data[p]);
if (f>=97) and (f<=122) then f:=f-32;//uppercase
//.compare
if (f=d) then
   begin
   //fLEN=1
   if (fLEN=1) then
      begin
      result:=true;
      _pos:=p;
      exit;
      end;
   //fLEN=2..n
   for p2:=2 to fLEN do
   begin
   a:=ord(_find[p2]);if (a>=97) and (a<=122) then a:=a-32;//uppercase
   b:=ord(_data[p+p2-1]);if (b>=97) and (b<=122) then b:=b-32;//uppercase
   if (a<>b) then break
   else if (p2=fLEN) then
        begin
        result:=true;
        _pos:=p;
        exit;
        end;//end of if
   end;//end of loop
   end;//end of if
end;//end of loop
except;end;
end;
//## isunix ##
function tgeneral.isunix(var _data:string):boolean;
var
   c13,p:integer;
begin
try
//defaults
result:=false;
c13:=0;
//process
for p:=1 to length(_data) do
    if (_data[p]=#13) then inc(c13)
    else if (_data[p]=#10) then
         begin
         result:=(c13=0);
         break;
         end;//end of if
except;end;
end;
//## readbasehref ##
function tgeneral.readbasehref(var x,u:string):boolean;//find <base href="http://www.blaiz.net"> and return "http://www.blaiz.net"
label
   s2,s3,s4;
const
   scanlimit=2048;
var
   ui:tparseurl;
   xlen,maxp,minp,o,lp,p:integer;
   v,c:char;
   ok:boolean;
begin
try
//defaults
result:=false;
u:='';
xlen:=length(x);
minp:=1;
//s1 - scan for "<base"
maxp:=frcmax(minp+scanlimit,xlen-4);
for p:=minp to maxp do if (x[p]='<') and ((x[p+1]='b') or (x[p+1]='B')) and (comparetext(copy(x,p,6),'<base ')=0) then
   begin
   minp:=p+5;
   goto s2;
   end;//end of if
exit;
//s2 - scan for "href"
s2:
maxp:=frcmax(minp+scanlimit,xlen-4);
for p:=minp to maxp do
begin
v:=x[p];
if (v='>') then break
else if ((v='h') or (v='h')) and ((x[p+4]=#32) or (x[p+4]=#160) or (x[p+4]='=')) and (comparetext(copy(x,p,4),'href')=0) then
   begin
   minp:=p+4;
   goto s3;
   end;//end of if
end;//end of loop
exit;
//s3 - scan for "="
s3:
maxp:=frcmax(minp+scanlimit,xlen-4);
for p:=minp to maxp do
begin
v:=x[p];
if (v='>') then break
else if (v='=') then
   begin
   minp:=p+1;
   goto s4;
   end;//end of if
end;//end of loop
exit;
//s4 - scan for value
s4:
maxp:=frcmax(minp+scanlimit,xlen);
ok:=false;
lp:=0;
o:=0;//1;
for p:=minp to maxp do
begin
v:=x[p];
if (v='>') then break
else if ok then
   begin
   if (v=c) then
      begin
      o:=0;
      break;
      end;//end of if
   end
else if (v<>#32) or (v='"') or (v='''') then
   begin
   if (v='"') or (v='''') then
      begin
      c:=v;
      lp:=p+1;
      end
   else
      begin
      c:=#32;
      lp:=p;
      end;//end of if
   ok:=true;
   end;//end of if
end;//end of loop
if (lp>=1) then
   begin
   u:=copy(x,lp,p-lp-o);
   if (u<>'') then
      begin
      general.pu('http://'+u,'',ui,[pusExcludeMark]);
      if (ui.h<>'') and (ui.cu<>'') then
         begin
         u:=ui.ca+ui.p;//domain+port+path - no filename or data (must be excluded)
         result:=true;
         end;//end of if
      end;//end of if
   end;//end of if
except;end;
end;
//## readlink ##
function tgeneral.readlink(var _pos,_start,_length:integer;var _data:string):boolean;//16-MAR-2007
label//Note: now detects <a href=""> or <a href=''> and skips to next link
   redo;
var//Rapid: ~15,000 successfull links per second @ 200Mhz
   ib,iq,iqonce,ic,ic2:boolean;
   lv,v,qc:char;
   p,s,f,len:integer;
begin
try
//defaults
result:=false;
if (_pos<1) then exit;
len:=length(_data);
redo:
if (len=0) or (_pos>len) then exit;
_start:=_pos;
_length:=0;
ib:=false;
iq:=false;
iqonce:=true;
ic:=false;
ic2:=false;
s:=0;
f:=0;
v:=#0;
//process
repeat
//.get
lv:=v;
v:=_data[_pos];
//.down
if (not iq) and ((v='<') or (v='>')) then
   begin
   ib:=(v='<');
   if ib then
      begin
      s:=_pos+1;
      f:=0;
      end
   else if ic2 and (f=0) then f:=_pos-1;//finished
   iqonce:=true;
   ic:=false;
   ic2:=false;
   end
else if ib then
   begin
   if ic2 then
      begin
      //.quotes
      if iq then
         begin
         if (qc=v) then
            begin
            iq:=false;
            f:=_pos-1;
            end;//end of if
         end
      //.up
      else if ((v=#34) or (v=#39)) then
         begin
         if iqonce then
            begin
            iqonce:=false;
            qc:=v;
            iq:=true;
            s:=_pos+1;
            end;//end of if
         end
      else if (lv<>#32) and (v=#32) then f:=_pos-1;
      end
   else
      begin
      if ic then
         begin
         if (v='=') then
            begin
            s:=_pos+1;
            ic2:=true;
            end;//end of if
         end
      else if (lv=#32) then
         begin
         if (v='H') or (v='h') then (if (0=comparetext(copy(_data,_pos,4),'href')) then ic:=true)
         else if (v='S') or (v='s') then (if (0=comparetext(copy(_data,_pos,3),'src')) then ic:=true);
         end;//end of if
      end;//end of if
   end;
//.finished
if (f>=1) or (_pos>=len) then
   begin
   //.end point
   if (f=0) and ic2 then f:=_pos-1;//finished
   //.link
   if (s>=1) and (f>=s) then
      begin
      //.check - "nil quote set" ie <a href="">
      if (s=f) and ((_data[s]='"') or (_data[s]='''')) then goto redo;
      //.trim spaces
      if (_data[s]=#32) then for p:=s to f do if (_data[p]<>#32) then
          begin
          s:=p;
          break;
          end;//end of if
      if (_data[f]=#32) then for p:=f downto s do if (_data[p]<>#32) then
          begin
          f:=p;
          break;
          end;//end of if
      //.set
      _start:=s;
      _length:=f-s+1;
      result:=true;
      //.quit
      break;
      end;//end of if
   f:=0;
   end;//end of if
//.inc
inc(_pos);
until (_pos>len);
except;end;
end;
//## readmeta ##
function tgeneral.readmeta(var x:string;xp:integer;var name,content:string;var pos:integer):boolean;
begin
try;result:=readmetab(x,xp,length(x),name,content,pos);except;end;
end;
//## readmetab ##
function tgeneral.readmetab(var x:string;xp,xlen:integer;var name,content:string;var pos:integer):boolean;
const
   sNAME=0;
   sEQUAL=1;
   sVALUE=2;
var
   n,c:string;
   q,np,s,qp,maxp,p:integer;
   v:byte;
   nOK,cOK,cend:boolean;
begin
try
//defaults
result:=false;
name:='';
content:='';
xlen:=frcmax(length(x),xlen);
n:='';
c:='';
q:=0;
qp:=1;
nOK:=false;
cOK:=false;
cend:=false;
s:=sNAME;
np:=0;
//process
//.meta
if (0=comparetext('<meta ',copy(x,xp,6))) then inc(xp,6)
else if (0=comparetext('meta ',copy(x,xp,5))) then inc(xp,5);//end of if
//.maxp
for p:=xp to xlen do
begin
//.get
v:=byte(x[p]);
pos:=p;
//NAME
if (s=sNAME) then
   begin
   if (v=62) then break
   else if (v<>9) and (v<>32) and (v<>61) then
      begin
      if (v<>10) and (v<>13) then n:=n+x[p]
      end
   else if (n<>'') then
      begin
      if (v=61) then s:=sVALUE else s:=sEQUAL;
      end;//end of if
   end
else if (s=sEQUAL) then
   begin
   if (v=62) then break
   else if (v=61) then s:=sVALUE
   else if (v<>9) and (v<>32) and (v<>10) and (v<>13) then//.restart name=value
      begin
      cend:=false;
      np:=0;
      qp:=1;
      q:=0;
      n:='';
      c:='';
      s:=sNAME;
      end;//end of if
   end
else if (s=sVALUE) then
   begin
   if (q<>0) then
      begin
      if (v<>q) and (v<>9) and (v<>10) and (v<>13) then c:=c+x[p]
      else if (v=q) then cend:=true;
      end
   else if (c='') and ((v=34) or (v=39)) then
      begin
      q:=v;
      qp:=p+1;
      end
   else if (v=62) then cend:=true
   else if (v<>9) and (v<>32) then
      begin
      if (v<>10) and (v<>13) then c:=c+x[p];
      end
   else if (c<>'') and ((v=9) or (v=32)) then
      begin
      cend:=true;
      end;//end of if
   //.value
   if cend then
      begin
      if (0=comparetext(n,'name')) then
         begin
         name:=c;
         nOK:=true;
         end
      else if (0=comparetext(n,'content')) then
         begin
         content:=c;
         cOK:=true;
         end;//end of if
      //.quit
      if (v=62) or (nOK and cOK) then break;
      //.reset
      cend:=false;
      np:=0;
      qp:=1;
      q:=0;
      n:='';
      c:='';
      s:=sNAME;
      end;//end of if
   end;//end of if
end;//end of loop
//return result
result:=nOK and cOK;
inc(pos);
except;end;
end;
//## robotsmeta ##
procedure tgeneral.robotsmeta(content:string;var canindex,canfollow:boolean);
var
   len,p:integer;
   v:byte;
begin
try
//defaults
canindex:=true;
canfollow:=true;
//check
len:=length(content);
if (len=0) then exit;
//process
for p:=1 to len do
begin
//.get
v:=byte(content[p]);
//.decide
if (v=78) or (v=110) then//N or n
   begin
   //.set
   if (0=comparetext('noindex',copy(content,p,7))) then canindex:=false
   else if (0=comparetext('nofollow',copy(content,p,8))) then canfollow:=false
   else if (0=comparetext('none',copy(content,p,4))) then
      begin
      canindex:=false;
      canfollow:=false;
      end;//end of if
   //.quit
   if (not canindex) and (not canfollow) then break;
   end;//end of if
end;//end of loop
except;end;
end;
//## filterTDK ##
function tgeneral.filterTDK(x:string;xmaxsize:integer):string;//Updated to "nearest whole word" on 27-JAN-2007, removes "&nbsp;" on 18-MAR-2007
var
   rlen,len,i,p:integer;
   v:byte;
begin
try
//defaults
result:='';
//check
if (xmaxsize<1) then exit;
//process
//.replace ">|<" point brackets with round ")|("
len:=length(x);
i:=0;
for p:=1 to len do
begin
v:=ord(x[p]);
if (v=60) then x[p-i]:='('//<
else if (v=62) then x[p-i]:=')'//>
else if (v=160) then x[p-i]:=#32//convert "#160" to "#32" spaces
else if (v=13) then inc(i)//remove #13 (Windows line feed)
else if (v=10) or (v=9) then x[p-i]:=#32//<returncode> or <tab> => <space>
else if (i<>0) then x[p-i]:=x[p];
end;//end of loop
//.trim
rlen:=len-i;
if (rlen>=1) then
   begin
   //smaller - use all
   if (rlen<=xmaxsize) then result:=copy(x,1,rlen)
   //too big - trim down to nearest whole word
   else for p:=xmaxsize downto 1 do if (not eptc(x[p])) then
      begin
      result:=copy(x,1,p);
      break;
      end;//end of if
   //.remove html symbols "&nbsp;" etc, also converts #160 => #32
   remsymbols(result);
   //.remove multiple spaces
   remdupc(result,#32);
   //.remove lead space
   if (result<>'') and (result[1]=#32) then delete(result,1,1);
   end;//end of if
except;end;
end;
//## trimtoword ##
function tgeneral.trimtoword(x:string;maxlen:integer):string;
var
   p,xlen:integer;
   ok:boolean;
begin
try
//defaults
result:='';
xlen:=length(x);
//range
maxlen:=frcmin(maxlen,1);
//smaller - use all
if (xlen<=maxlen) and ((xlen<1) or eptc(x[xlen])) then result:=copy(x,1,xlen)
//too big - trim down to nearest whole word
else
   begin
   ok:=false;
   for p:=maxlen downto 1 do
      if eptc(x[p]) then
         begin
         if ok then
            begin
            result:=copy(x,1,p);
            break;
            end;//end of if
         end
      else ok:=true;
   end;//end of if
except;end;
end;
//## textgood ##
function tgeneral.textgood(x:string):boolean;//non-white text
var//text that is made up of more than white space (#32, #160)
   xlen,p:integer;
begin
try
//defaults
result:=false;
//setup
xlen:=length(x);
if (xlen=0) then exit;
//process
for p:=1 to xlen do if (x[p]<>#32) and (x[p]<>#160) then
   begin
   result:=true;
   break;
   end;//end of if
except;end;
end;
//## getTDK ##
procedure tgeneral.getTDK(var _data:string;agent:string;maxscan,tSIZE,dSIZE,kSIZE:integer;var t,d,k:string;var canindex,canfollow:boolean);//extract raw title/description/keywords
var
   tlarge,tmpT,tmpD,tmpK:string;
begin
try
//process
//.get
rawTDK(_data,agent,maxscan,tSIZE,dSIZE,kSIZE,tlarge,tmpT,tmpD,tmpK,canindex,canfollow);
//.title -> TDK
if textgood(tmpT) then t:=tmpT//use specified size title (whereas tLarge is for supliment of description/keywords)
else if textgood(tmpD) then t:=tmpD
else t:=tmpK;
//.description -> DTK
if textgood(tmpD) then d:=tmpD
else if textgood(tlarge) then d:=tlarge//larger title than "tmpT"
else d:=tmpK;
//.keywords -> KDT
if textgood(tmpK) then k:=tmpK
else if textgood(tmpD) then k:=tmpD
else k:=tlarge;//larger title than "tmpT"
except;end;
end;
//## rawTDK ##
procedure tgeneral.rawTDK(var _data:string;agent:string;maxscan,tSIZE,dSIZE,kSIZE:integer;var tlarge,t,d,k:string;var canindex,canfollow:boolean);//extract raw title/description/keywords - 18MAR2007
var
   n,c:string;
   s,len,_pos,p:integer;
   acanindex,acanfollow,aOK,dOK,kOK,rOK:boolean;
begin
try
//defaults
//.range
len:=length(_data);
if (maxscan>=1) then len:=frcmax(maxscan,len);
//.vars
dOK:=false;
kOK:=false;
rOK:=false;
aOK:=false;
canindex:=true;
canfollow:=true;
acanindex:=true;
acanfollow:=true;
t:='';
d:='';
k:='';
//.title - now handles title over return codes "<titleRCODE>xxxxxxxxxxxx</titleRCODE>" - 18MAR2007
_pos:=1;
if findtextL(_pos,len,_data,'<TITLE') then
   begin
   p:=_pos+6;
   if findtextL(p,len,_data,'>') then
      begin
      _pos:=p;
      inc(p);
      if findtextL(p,len,_data,'<') then t:=copy(_data,_pos+1,p-_pos-1);
      end;//end of if
   end;//end of if
//.description/keywords
_pos:=1;
repeat
if findtextL(_pos,len,_data,'<META') then
   begin
   if readmetab(_data,_pos,len,n,c,_pos) then
      begin
      //.set
      if (0=comparetext(n,'description')) then
         begin
         if not dOK then d:=c;
         dOK:=true;
         end
      else if (0=comparetext(n,'keywords')) then
         begin
         if not kOK then k:=c;
         kOK:=true;
         end
      else if (0=comparetext(n,'robots')) then
         begin
         if not rOK then robotsmeta(c,canindex,canfollow);
         rOK:=true;
         end
      else if (agent<>'') and (0=comparetext(n,agent)) then
         begin
         if not aOK then robotsmeta(c,acanindex,acanfollow);
         aOK:=true;
         end;//end of if
      //.quit
      if dOK and kOK and rOK and (aOK or (agent='')) then break;
      end;//end of if
   end
else break;
until (_pos>=len);
//.filter
s:=tSIZE;//find largest size and use it for "tlarge"
if (dSIZE>s) then s:=dSIZE;
if (kSIZE>s) then s:=kSIZE;
tlarge:=filterTDK(t,s);//larger title for above proc to use as description and keywords
t:=filterTDK(t,tSIZE);
d:=filterTDK(d,dSIZE);
k:=filterTDK(k,kSIZE);
//.agent
if aOK and (agent<>'') then
   begin
   canindex:=acanindex;
   canfollow:=acanfollow;
   end;//end of if
except;end;
end;
//## byteslines ##
function tgeneral.byteslines(var x:string;xbytes:integer):string;
var
   _pos,_start,_length,len,p:integer;
begin
try
//defaults
result:='';
len:=0;
_pos:=1;
//check
if (xbytes<=0) then exit;
//process
while TRUE do
begin
if readline(_pos,_start,_length,x) then
   begin
   if ((len+_length+length(rcode))<=xbytes) then pushb(len,result,copy(x,_start,_length)+rcode)
   else break;
   end
else break;
end;//end of loop
//.finalise
pushb(len,result,'');
except;end;
end;
//## firstline ##
function tgeneral.firstNBL(var _data:string):string;//first non-blank line
var
   tmp:string;
   p:integer;
begin
try
//defaults
result:='';
p:=1;
//process
while nextline(p,_data,tmp) do if (tmp<>'') then
   begin
   result:=tmp;
   break;
   end;//end of if
except;end;
end;
//## firstline ##
function tgeneral.firstline(var _data:string):string;
var
   ok:boolean;
   p:integer;
begin
try
//defaults
result:='';
ok:=false;
//process
for p:=1 to length(_data) do if (_data[p]=#10) then
   begin
   ok:=true;
   result:=copy(_data,1,p-1);
   break;
   end;//end of if
if not ok then result:=_data;
except;end;
end;
//## firstlineb ##
function tgeneral.firstlineb(_data:string):string;
begin
try;result:=firstline(_data);except;end;
end;
//## xxxlineb ##
function tgeneral.xxxlineb(count:integer;_data:string):string;
begin
try;result:=xxxline(count,_data);except;end;
end;
//## xxxline ##
function tgeneral.xxxline(count:integer;var _data:string):string;
var
   c,_pos,_start,_length:integer;
begin
try
//defaults
result:='';
_pos:=1;
c:=0;
//process
while readline(_pos,_start,_length,_data) do
begin
inc(c);
if (c>=count) then
   begin
   result:=copy(_data,_start,_length);
   break;
   end;//end of if
end;//end of loop
except;end;
end;
//## linecount ##
function tgeneral.linecount(var _data:string):integer;//18JAN2008
var
   p:integer;
   tmp:string;
begin
try
//defaults
result:=0;
//scan
p:=1;
while general.nextline(p,_data,tmp) do inc(result);
except;end;
end;
//## nextline ##
function tgeneral.nextline(var _pos:integer;var _data,_line:string):boolean;
var
   _start,_length:integer;
begin
try
//defaults
result:=false;
_line:='';
//process
if readline(_pos,_start,_length,_data) then
   begin
   _line:=copy(_data,_start,_length);
   result:=true;
   end;//end of if
except;end;
end;
//## readline ##
function tgeneral.readline(var _pos,_start,_length:integer;var _data:string):boolean;
var
   _winrc:boolean;
begin
try;result:=readlineb(_pos,_start,_length,_data,_winrc);except;end;
end;
//## readlineb ##
function tgeneral.readlineb(var _pos,_start,_length:integer;var _data:string;var _winrc:boolean):boolean;
var//Supports: Unix return codes "#10" and Windows/DOS return codes "#13+#10"
   lv,v:byte;
   p,LEN:integer;
begin
try
//defaults
result:=false;
_winrc:=false;
if (_pos<1) then exit;
LEN:=length(_data);
if (len=0) then exit;
_start:=_pos;
_length:=0;
lv:=0;
//process
//.loop
for p:=_pos to LEN do
begin
//.get
v:=ord(_data[p]);
//.set
if ((v=10) or (p=LEN)) then
   begin
   //.length
   _length:=p-_start;
   if (lv=13) then
      begin
      _length:=_length-1;
      _winrc:=true;
      end
   else if (p=LEN) and (v<>10) then _length:=_length+1;
   //.pos
   _pos:=p+1;
   //.successful
   result:=true;
   break;
   end;//end of if
//.lv
lv:=v;
end;//end of loop
except;end;
end;
//## readvalueb ##
function tgeneral.readvalueb(var _pos:integer;var _data,_value:string):boolean;
var
   _start,_length:integer;
begin
try
result:=readvalue(_pos,_start,_length,_data);
if result then _value:=copy(_data,_start,_length) else _value:='';
except;end;
end;
//## readvalue ##
function tgeneral.readvalue(var _pos,_start,_length:integer;var _data:string):boolean;
var//Note: First byte of entire data stream represents "sep" value, it's then assumed to sep all sub-data blocks
   sep,v:byte;
   p,LEN:integer;
begin
try
//defaults
result:=false;
if (_pos<1) then exit;
len:=length(_data);
if (len<=0) then exit;
_length:=0;
//.sep
sep:=byte(_data[_pos]);
//.inc - starts at _pos+1 (ie _pos=1 => sep=1, value=2..X)
inc(_pos);
_start:=_pos;
//process
//.loop
for p:=_pos to len do
begin
//.get
v:=ord(_data[p]);
//.set
if ((v=sep) or (p=LEN)) then
   begin
   //.length
   _length:=p-_start;
   if (p=LEN) and (v<>sep) then _length:=_length+1;
   //.pos
   _pos:=p;
   //.successful
   result:=true;
   break;
   end;//end of if
end;//end of loop
except;end;
end;
//## wait ##
procedure tgeneral.wait(ms:integer);
label
     redo;
var
   cms,z:currency;
begin
try
//check
if (ms<=0) then exit;
//prepare
cms:=ms;
z:=ms64;
//process
redo:
if ((ms64-z)<cms) then
   begin
   application.processmessages;
   sleep(1);
   goto redo;
   end;//end of if
except;end;
end;
//## nrw ##
function TGeneral.nrw(x,y,r:integer):boolean;//number within range
begin
try;result:=(x>=(y-r)) and (x<=(y+r));except;end;
end;
//## cnrw ##
function tgeneral.cnrw(x,y,r:currency):boolean;//number within range - currency - 07MAR2008
begin
try;result:=(x>=(y-r)) and (x<=(y+r));except;end;
end;
//## dc ##
function TGeneral.dc(x,y:integer):integer;//differential color
label
     redo;
var
   once:boolean;
   ox,a:tint4;
   by,z:integer;
begin
try
//prepare
once:=true;
ox.val:=colortorgb(x);
//y check
if (y=0) then
   begin
   result:=ox.val;
   exit;
   end;//end of if
//check for "black"
//.y
//yyyyyyyyyyyyyyyyyif (colbright(ox.val)<100) then y:=100;
//.by
by:=y;
if (by<0) then by:=-by;
by:=by div 2;
//a.val
a.val:=ox.val;
//process
redo:
//.r
z:=(a.r+y);if (z<0) then z:=0 else if (z>255) then z:=255;a.r:=z;
//.g
z:=(a.g+y);if (z<0) then z:=0 else if (z>255) then z:=255;a.g:=z;
//.b
z:=(a.b+y);if (z<0) then z:=0 else if (z>255) then z:=255;a.b:=z;
//check
if once and (nrw(colbright(a.val),colbright(ox.val),by) or (nrw(a.r,ox.r,by) and nrw(a.g,ox.g,by) and nrw(a.b,ox.b,by))) then
   begin
   a.val:=ox.val;
   y:=-y;
   once:=false;
   goto redo;
   end;//end of if
//return result
result:=a.val;
except;end;
end;
//## fm ##
function TGeneral.fm(x,y:tfont):boolean;//fonts match
begin
try
{yes}
result:=true;
if (x=nil) and (y=nil) then exit;
if (x.name=y.name) and (x.size=y.size) and (x.color=y.color) and (x.style=y.style) and (x.charSet=y.charSet) then exit;
{no}
result:=false;
except;end;
end;
//## afs ##
procedure TGeneral.afs(x:tfont;y:tfontstyle;z:boolean);//adjust font style
begin
try;if z then ifs(x,y) else efs(x,y);except;end;
end;
//## ifs ##
procedure TGeneral.ifs(x:tfont;y:tfontstyle);//include font style
begin
try;if (x<>nil) then x.style:=x.style+[y];except;end;
end;
//## efs ##
procedure TGeneral.efs(x:tfont;y:tfontstyle);//exclude font style
begin
try;if (x<>nil) then x.style:=x.style-[y];except;end;
end;
//## fromHEX ##
function TGeneral.fromHEX(x:string):integer;
var
   a:tint4;
   p:integer;
begin
try
//default
result:=0;
//prepare
if (copy(x,1,1)='#') then p:=2 else p:=1;
//process
//.remove leading '#'
x:=uppercase(copy(x,p,length(x))+'FFFFFF');
//.parse
a.t:=0;
a.r:=_fromHEX(x[1])*16+_fromHEX(x[2]);
a.g:=_fromHEX(x[3])*16+_fromHEX(x[4]);
a.b:=_fromHEX(x[5])*16+_fromHEX(x[6]);
//return result
result:=a.val;
except;end;
end;
//## _fromHEX ##
function TGeneral._fromHEX(x:string):Integer;
begin
try
x:=copy(x+'F',1,1);
if (x>='0') and (x<='9') then result:=strint(x[1])
else if (x>='A') and (x<='F') then result:=ord(X[1])-55
else result:=0;
//end of if
except;end;
end;
//## toHEX ##
function TGeneral.toHEX(x:integer;hash:boolean):string;//07-AUG-2004
begin
try;result:=toHEXex(x,hash,true);except;end;
end;
//## toHEXex ##
function TGeneral.toHEXex(x:integer;hash,_uppercase:boolean):string;//19-DEC-2006
var
   a:tint4;
   p,aa,bb:integer;
begin
try
//default
result:='000000';
//enforce range
a.val:=ColorToRGB(x);
//process
//.red-green-blue
for p:=0 to 2 do
begin
//zero based
aa:=a.bytes[p] div 16;
bb:=a.bytes[p]-(aa*16);
//1 based
result[p*2+1]:=_toHEX(aa);
result[p*2+2]:=_toHEX(bb);
end;//end of loop
//.hash
if hash then result:='#'+result;
//.case
if _uppercase then result:=uppercase(result) else result:=lowercase(result);
except;end;
end;
//## _toHEX ##
function TGeneral._toHEX(x:byte):char;
begin
try
case x of
0..9:result:=inttostr(x)[1];
10..16:result:=chr(55+x);
else
 result:='F';
end;//end of case
except;end;
end;
//## pause ##
function tgeneral.pause:boolean;
begin
try
//return result
result:=(ms64-iupdsys)>=100;
//process
if result then iupdsys:=ms64;
except;end;
end;
//## updsys ##
function tgeneral.updsys:boolean;
begin
try;result:=pause;if result then application.processmessages;except;end;
end;
//## AsWin95 ##
function TGeneral.AsWin95(x:string):string;//21-AUG-2004
var
   p,xLen:integer;
   z:string;
begin
try
//prepare
xLen:=length(x);
//check
if (xLen=0) then
   begin
   result:='';
   exit;
   end;//end of if
//process
if (x[1]='&') then p:=2 else p:=1;
result:=lowercase(x);
if (p<=xLen) then
   begin
   z:=uppercase(x[p]);
   result[p]:=z[1];
   end;//end of if
except;end;
end;
//## asname ##
function tgeneral.asname(x:string):string;//10JUN2007
var//Note: "/=47" and "\=92" support added 10JUN2007
   a:tstringlist;
   maxp,p:integer;
   ox,z:string;
begin
try
//defaults
result:='';
//init
a:=nil;
a:=tstringlist.create;
ox:=x;
for p:=1 to length(x) do
begin
case ord(x[p]) of
//("'_ -~)
34,39,10,9,95,32,45,126,47,92:x[p]:=#13;
end;//end of case
end;//end of loop
a.text:=x;
maxp:=a.count-1;
//get
z:='';
for p:=0 to maxp do z:=z+AsWin95(a.strings[p])+#32;
z:=copy(z,1,length(ox));
//set - replace spaces with orginal char's}
maxp:=length(z);
for p:=1 to maxp do if (z[p]=#32) then z[p]:=ox[p];
result:=z;
except;end;
try;freeobj(@a);except;end;
end;
//## strs ##
function tgeneral.strs(_use2:boolean;_str1,_str2:string):string;
begin
try;if _use2 then result:=_str2 else result:=_str1;except;end;
end;
//## posn ##
function TGeneral.posn(x:longint):longint;
begin//positive number
try
if (x<0) then x:=-x;
result:=x;
except;end;
end;
//## oddn ##
function tgeneral.oddn(x:longint):longint;
begin//oodd number
try
if (((x div 2)*2)=x) then
   begin
   if (x=maxint) then dec(x) else inc(x);
   end;//end of if
result:=x;
except;end;
end;
//## evenn ##
function tgeneral.evenn(x:longint):longint;
begin//oodd number
try
if (((x div 2)*2)<>x) then
   begin
   if (x=maxint) then dec(x) else inc(x);
   end;//end of if
result:=x;
except;end;
end;
//## isodd ##
function tgeneral.isodd(x:integer):boolean;
begin
try;result:=(x<>((x div 2)*2));except;end;
end;
//## iseven ##
function tgeneral.iseven(x:integer):boolean;
begin
try;result:=(x=((x div 2)*2));except;end;
end;
//## fromnullb ##
function tgeneral.fromnullb(x:string):string;{removes trailing null's - i.e. null terminated string -> string}
begin
try;fromnull(x);result:=x;except;end;
end;
//## fromnull ##
procedure tgeneral.fromnull(var x:string);{removes trailing null's - i.e. null terminated string -> string}
var
   p:integer;
begin
try
{process}
for p:=1 to length(x) do if (x[p]=#0) then
    begin
    x:=copy(x,1,p-1);
    break;
    end;//end of if
except;end;
end;
//## nullstr ##
function tgeneral.nullstr(x:integer;y:char):string;
var//speed: 8-9Mb/sec, tested at 9Mb=1,000ms @ 200Mhz
   p:integer;
begin
try;setlength(result,x);for p:=length(result) downto 1 do result[p]:=y;except;end;
end;
//## randomstr ##
function tgeneral.randomstr(x:integer):string;
var
   p:integer;
begin
try
//get
result:=nullstr(x,#0);
//set
for p:=1 to length(result) do result[p]:=char(random(256));
except;end;
end;
//## fapne ##
procedure TGeneral.fapne(x:string;var p,n,e:string);//filename as path/name/extension
begin
try;p:=extractfilepath(x);fane(extractfilename(x),n,e);except;end;
end;
//## fane ##
procedure TGeneral.fane(x:string;var n,e:string);//filename as name/extension
var
   maxp,p:integer;
begin
try
{defaults}
n:=x;
e:='';
{process}
maxp:=length(x);
for p:=maxp downto 1 do if (x[p]='.') then
    begin
    n:=copy(x,1,p-1);
    e:=copy(x,p+1,maxp);
    break;
    end;//end of if
except;end;
end;
//## ref24DU ##
function tgeneral.ref24DU(const x:string):integer;//updated 10-JUN-2006
var//Dual encoding for collision free stability
   //Encode 24 "full binary characters" forward and backward
   //Case in-sensitive
   //172,000 keywords => 2 collisions (1 in 86,000, 11.6/million)
   w,v,d,c,p,olen,xlen:integer;
   a,b:tint4;
begin
try
//default
result:=0;
//setup
xlen:=length(x);
olen:=xlen;
if (xlen=0) then exit
else if (xlen>24) then xlen:=24;
//process
a.val:=0;
b.val:=0;

//1
w:=0;
for p:=1 to xlen do
begin
//2-stage - prevent math error
v:=byte(x[p]);
if (v>=97) and (v<=122) then dec(v,32);
//inc
w:=w+p4INT32[p]*v;
end;//end of loop
a.val:=w+olen;

//2
w:=0;
c:=0;
for p:=1 to xLen do
begin
c:=round(c+1.5);
//2-stage - prevent math error
d:=round(c*c*c*0.7)+3;
v:=byte(x[p]);
if (v>=97) and (v<=122) then dec(v,32);
d:=d*v;
//inc
w:=w+d;
end;//end of loop
b.val:=w;

//.merge
a.bytes[0]:=byte(a.bytes[0]+b.bytes[3]);
a.bytes[1]:=byte(a.bytes[1]+b.bytes[2]);
a.bytes[2]:=byte(a.bytes[2]-b.bytes[1]);
a.bytes[3]:=byte(a.bytes[3]+b.bytes[0]);

//return result
result:=a.val;
if (result=0) then result:=1;
except;end;
end;
//## ref32 ##
function tgeneral.ref32(const x:string):integer;{1..32}
var//Fast: 192% faster
   p,xlen:integer;
begin
try
//default
result:=0;
//setup
xlen:=length(x);
if (xlen=0) then exit
else if (xlen>high(p4INT32)) then xlen:=high(p4INT32);
//process
for p:=1 to xlen do result:=result+p4INT32[p]*byte(x[p]);
except;end;
end;
//## ref32U ##
function tgeneral.ref32U(const x:string):integer;{1..32}
var//Fast: 180% faster
   v:byte;
   p,xlen:integer;
begin
try
//default
result:=0;
//setup
xlen:=length(x);
if (xlen=0) then exit
else if (xlen>high(p4INT32)) then xlen:=high(p4INT32);
//process
for p:=1 to xlen do
begin
//2-stage - prevent math error
v:=byte(x[p]);
if (v>=97) and (v<=122) then dec(v,32);
//inc
result:=result+p4INT32[p]*v;
end;//end of loop
except;end;
end;
//## ref256 ##
function tgeneral.ref256(const x:string):currency;
var//Fast: 300% faster
   p,xlen:integer;
begin
try
//default
result:=0;
//setup
xlen:=length(x);
if (xlen=0) then exit
else if (xlen>high(p4CUR256)) then xlen:=high(p4CUR256);
//process
for p:=1 to xlen do result:=result+p4CUR256[p]*byte(x[p]);
except;end;
end;
//## ref256U ##
function tgeneral.ref256U(const x:string):currency;
var//Fast: 300% faster
   d:currency;
   v:byte;
   p,xlen:integer;
begin
try
//default
result:=0;
//setup
xlen:=length(x);
if (xlen=0) then exit
else if (xlen>high(p4CUR256)) then xlen:=high(p4CUR256);
//process
for p:=1 to xlen do
begin
//lowercase
v:=byte(x[p]);
if (v>=97) and (v<=122) then dec(v,32);
//add
d:=p4CUR256[p];
d:=d*v;
result:=result+p4CUR256[p]*v;
end;//end of loop
except;end;
end;
//## ref256UD ##
procedure tgeneral.ref256UD(const x:string;var ua,ub:integer);
var
   a:tcur8;
begin
try
a.val:=ref256U(x);
ua:=a.ints[0];
ub:=a.ints[1];
except;end;
end;
//## incInt ##
Procedure TGeneral.incInt(var x:integer);
begin
try;incxInt(x,1);except;end;
end;
//## incCur ##
Procedure TGeneral.incCur(var x:currency);
begin
try;incxCur(x,1);except;end;
end;
//## incxInt ##
Procedure TGeneral.incxInt(var x:integer;by:integer);
begin
try;x:=x+by;except;end;
end;
//## incxCur ##
Procedure TGeneral.incxCur(var x:currency;by:currency);
begin
try;x:=x+by;except;end;
end;
//## StrsMatch ##
Function TGeneral.StrsMatch(Mask,Name:String):Boolean;
Label
     SkipOne, SkipEnd;
Var
   A:TStringList;
   MaxP,Np,NMax,N,LenN,LenX,P:Integer;
   X:String;
   Roam,Ok:Boolean;
begin
try
//defaults - no match
result:=false;
a:=nil;
{Setup}
Name:=UpperCase(Name)+' ';
Mask:=UpperCase(Mask)+' ';
{Mask}
A:=TStringList.Create;
SwapStrs(Mask,'*',RCode+'*'+RCode);
SwapStrs(Mask,'?',RCode+'?'+RCode);
A.Text:=Mask;
{Remove Blank Lines}
For P:=(A.Count-1) downTo 0 Do If (A.Strings[P]='') then A.Delete(P);
LenN:=Length(Name);
Np:=1;
MaxP:=A.Count-1;
Roam:=False;
For P:=0 to MaxP Do
begin
X:=A.Strings[P];
LenX:=Length(X);
If (X='*') then
   begin
   If (P=MaxP) then break;
   Roam:=True;
   Goto SkipOne;
   end;//end of if
If (X='?') then
   begin
   Np:=Np+1;
   Goto SkipOne;
   end;//end of if
 If (Np>LenN) then Goto SkipEnd;
 Ok:=False;
 If Roam then NMax:=LenN else NMax:=Np;
 For N:=Np to NMax Do
 begin
 If (Copy(Name,N,LenX)=X) then
    begin
    Np:=N+LenX;
    Ok:=True;
    break;
    end;//end of if
 end;//end of loop
 If (P=MaxP) and (Np<=LenN) then Goto SkipEnd;
 If Not Ok then Goto SkipEnd;
 If Ok then Roam:=False;
SkipOne:
end;//end of loop
{Successful}
Result:=True;
SkipEnd:
except;end;
try;freeobj(@a);except;end;
end;
//## Thousands ##
Function TGeneral.Thousands(X:Integer):String;{fixed "minus problem" on 4-FEB-2004}
Var
   I,MaxP,P:Integer;
   z2,Z,Y:String;
begin
try
{Error}
Result:='0';
z2:='';
if (x<0) then
   begin
   x:=-x;
   z2:='-';
   end;//end of if
Y:=inttostr(X);
Z:='';
MaxP:=Length(Y);
I:=0;
For P:=MaxP DownTo 1 Do
begin
I:=I+1;
If (I>=3) and (P<>1) then
   begin
   Z:=','+Copy(Y,P,3)+Z;
   I:=0;
   end;//end of if
end;//end of loop
If (I<>0) then Z:=Copy(Y,1,I)+Z;
{Return Result}
Result:=z2+Z;
except;end;
end;
//## CurComma ##
function TGeneral.CurComma(x:currency):string;{same as "Thousands" but for "double"}
begin
try;result:=curstrex(x,',');except;end;
end;
//## curstrex ##
function tgeneral.curstrex(x:currency;sep:string):string;//07SEP2007
Var
   I,MaxP,P:Integer;
   z2,Z,Y:String;
begin
try
//defaults
result:='0';
z2:='';
if (x<0) then
   begin
   x:=-x;
   z2:='-';
   end;//end of if
y:=floattostrex2(x);
z:='';
maxp:=length(y);
i:=0;
for p:=maxp downto 1 do
begin
i:=i+1;
if (i>=3) and (p<>1) then
   begin
   z:=sep+copy(y,p,3)+z;
   i:=0;
   end;//end of if
end;//end of loop
if (i<>0) then z:=copy(y,1,i)+z;
{Return Result}
result:=z2+z;
except;end;
end;
//## StrDec ##
function TGeneral.StrDec(a:string;y:byte;z:boolean):string;
var
   b:string;
   aLen,p:integer;
begin
try
{enforce range}
//y
if (y<0) then y:=0
else if (y>10) then y:=10;
{prepare}
aLen:=length(a);
b:='';
{process}
//get
for p:=1 to aLen do if (a[p]='.') then
    begin
    b:=copy(a,p+1,aLen);
    a:=copy(a,1,p-1);
    break;
    end;//end of if
//z - thousands
if z then a:=CurComma(strtofloatex(a));
{return result}
if (y<=0) then result:=a else result:=a+'.'+copy(b+'0000000000',1,y);
except;end;
end;
//## ipercentage ##
function tgeneral.ipercentage(a,b:integer):extended;
begin
try
if (a<0) then a:=0;
if (b<1) then b:=1;
result:=(a/b)*100;
if (result<0) then result:=0 else if (result>100) then result:=100;
except;end;
end;
//## cpercentage ##
function tgeneral.cpercentage(a,b:currency):extended;
begin
try
if (a<0) then a:=0;
if (b<1) then b:=1;
result:=(a/b)*100;
if (result<0) then result:=0 else if (result>100) then result:=100;
except;end;
end;
//## percentage ##
function tgeneral.percentage(x:extended;_symbol:boolean):string;
begin
try;result:=percentageb(x,2,_symbol);except;end;
end;
//## percentageb ##
function tgeneral.percentageb(x:extended;points:byte;_symbol:boolean):string;
begin
try
//enforce range
if (x<0) then x:=0 else if (x>100) then x:=100;
//keep in safe range (to much data overloads)
x:=round(x*100)/100;
//process
result:=strdec(floattostrex2(x),points,false);
if _symbol then result:=result+'%';
except;end;
end;
//## CurDec ##
function TGeneral.CurDec(x:currency;y:byte;z:boolean):string;
begin
try;result:=StrDec(floattostrex2(x),y,z);except;end;
end;
//## insint ##
function tgeneral.insint(x:integer;y:boolean):integer;//insert integer
begin
try;if y then result:=x else result:=0;except;end;
end;
//## insstr ##
function tgeneral.insstr(x:string;y:boolean):string;//insert string
begin
try;if y then result:=x else result:='';except;end;
end;
//## ifstr ##
function tgeneral.ifstr(x,y:string):string;//insert string
begin
try;result:=ifstrex(x,'',y);except;end;
end;
//## ifstrex ##
function tgeneral.ifstrex(x,pre,post:string):string;//insert string
begin
try;if (x<>'') then result:=pre+x+post else result:='';except;end;
end;
//## aorb ##
function tgeneral.aorb(a,b:integer;_useb:boolean):integer;
begin
try;if _useb then result:=b else result:=a;except;end;
end;
//## caorb ##
function tgeneral.caorb(a,b:currency;_useb:boolean):currency;
begin
try;if _useb then result:=b else result:=a;except;end;
end;
//## eaorb ##
function tgeneral.eaorb(a,b:extended;_useb:boolean):extended;
begin
try;if _useb then result:=b else result:=a;except;end;
end;
//## ifdiv ##
function tgeneral.ifdiv(x,divby:integer;_usediv:boolean):integer;
begin
try
result:=x;
if _usediv then result:=result div divby;
except;end;
end;
//## aorbstr ##
function tgeneral.aorbstr(a,b:string;_useb:boolean):string;
begin
try;if _useb then result:=b else result:=a;except;end;
end;
//## SortByRef ##
function TGeneral.SortByRef(var x:array of string;var xRef:array of integer;xCount:integer;y:TGeneralSortSet):integer;
label
     skipend,redo;
var
   ztmpRef,tmpv,minp,maxp,minV,maxV,cp,p:integer;
   a,ztmp:string;
begin
try
{error}
result:=0;
{prepare}
maxp:=high(x);
if (xCount>=1) then maxp:=frcmax(xCount-1,maxp);
if (glssRef in y) or (glssRefUC in y) then
   begin
   for p:=0 to maxp do
   begin
   case (glssRefUC in y) of
   true:a:=uppercase(x[p]);
   false:a:=x[p];
   end;//end of case
   xRef[p]:=Ref32(a);
   end;//end of loop
   end;//end of if
{process}
//value range
minp:=0;
minV:=high(integer);
maxV:=0;
for p:=0 to maxp do
begin
if (xRef[p]<minV) then minV:=xRef[p];
if (xRef[p]>maxV) then maxV:=xRef[p];
end;//end of loop
//search for next highest value
Redo:
cp:=minp;
tmpv:=maxV;
for p:=minp to maxp do if (xRef[p]>=minV) and (xRef[p]<tmpv) then
    begin
    tmpv:=xRef[p];
    cp:=p;
    end;//end of if
minV:=xRef[cp];
//set
ztmpRef:=xRef[minp];
ztmp:=x[minp];
x[minp]:=x[cp];x[cp]:=ztmp;
xRef[minp]:=xRef[cp];xRef[cp]:=ztmpRef;
//set.check
if (glssDup in y) or (result=0) or ((result>0) and (minV>xRef[result-1])) then
   begin
   if (glssNull in y) or (minV<>0) then
      begin
      x[result]:=x[minp];
      xRef[result]:=xRef[minp];
      incInt(result);
      end;//end of if
   end;//end of if
minp:=minp+1;
{get next highest value}
if (minp<=maxp) then goto redo;
SkipEnd:
except;end;
end;
//## ParseStr ##
function TGeneral.ParseStr(var x:string;xSep:char;var z:array of string;zMaxCount:integer):integer;
var
   zMax,xLen,dp,lp,p:integer;
begin
try
{defaults}
result:=0;
{prepare}
zMax:=high(z)+1;
if (zMaxCount>0) and (zMaxCount<=zMax) then zMax:=zMaxCount;
xLen:=length(x);
dp:=0;
lp:=1;
{process}
for p:=1 to xLen do if (x[p]=xSep) or (p=xLen) then
    begin
    if (p=xLen) and (x[p]<>xSep) then dp:=1;
    z[result]:=copy(x,lp,p-lp+dp);
    result:=result+1;
    {enforce limit - internal/user}
    if (result>=zMax) then break;
    {lp}
    lp:=p+1;
    end;//end of if
except;end;
end;
//## uptob ##
function tgeneral.uptob(x:string;sep:char):string;
begin
try;result:=upto(x,sep);except;end;
end;
//## upto ##
function tgeneral.upto(var x:string;sep:char):string;
var
   p:integer;
begin
try
//defaults
result:='';
//process
//.set
for p:=1 to length(x) do if (x[p]=sep) then
   begin
   result:=copy(x,1,p-1);
   exit;
   end;//end of if
//.full
result:=x;
except;end;
end;
//## swapcharsb ##
function tgeneral.swapcharsb(x:string;a,b:char):string;
begin
try;result:=x;swapchars(result,a,b);except;end;
end;
//## SwapChars ##
procedure TGeneral.SwapChars(var x:string;a,b:char);
var
   p:integer;
begin
try;for p:=1 to length(x) do if (x[p]=a) then x[p]:=b;except;end;
end;
//## swapstrsb ##
function tgeneral.swapstrsb(x,a,b:string):string;
begin
try
swapstrs(x,a,b);
result:=x;
except;end;
end;
//## remcharb ##
function tgeneral.remcharb(x:string;c:char):string;
begin
try
result:=x;
remchar(result,c);
except;end;
end;
//## remchar ##
function tgeneral.remchar(var x:string;c:char):boolean;
var
   i,maxp,p:integer;
begin
try
//defaults
result:=false;
maxp:=length(x);
i:=0;
//process
for p:=1 to maxp do
begin
if (x[p]=c) then inc(i)
else if (i<>0) then x[p-i]:=x[p];
end;//end of loop
//shrink
if (i<>0) then setlength(x,maxp-i);
except;end;
end;
//## SwapStrs ##
function TGeneral.SwapStrs(Var X:String;A,B:String):boolean;
label
     ReDo;
var
   lenB,lenA,MaxP,P:Integer;
begin
try{Extremely Fast Praser/StrSwaper - 5KBx6 times = 1-7ms => 46 times faster than SwapStrs => 325ms}
//no
result:=false;
//prepare
MaxP:=Length(X);
lenA:=Length(A);
lenB:=Length(B);
P:=0;
//process
ReDo:
P:=P+1;
If (P>MaxP) then exit;
If (X[P]=A[1]) then If (Copy(X,P,lenA)=A) then
   begin
   X:=Copy(X,1,P-1)+B+Copy(X,P+LenA,MaxP);
   P:=P+LenB-1;
   MaxP:=MaxP-LenA+LenB;
   //yes
   result:=true;
   end;//End of LOOP
Goto ReDo;
except;end;
end;
//## swapstrsUb ##
function tgeneral.swapstrsUb(var x:string;a,b,pr,pt:string;_word,_html:boolean):boolean;
begin
try;result:=swapstrsU(x,a,b,pr,pt,_word,_html,0);except;end;
end;
//## swapstrsU ##
function tgeneral.swapstrsU(var x:string;a,b,pr,pt:string;_word,_html:boolean;_count:integer):boolean;
label
     skipone;
var
   rt:boolean;
   al,au,aLEN,bLEN,xLEN,rLEN,tLEN,v,p:integer;
   hON:boolean;
begin
try{Extremely Fast Praser/StrSwaper - 5KBx6 times = 1-7ms => 46 times faster than SwapStrs => 325ms}
//no
result:=false;
//prepare
xLEN:=Length(x);
aLEN:=Length(a);
bLEN:=Length(b);
rLEN:=Length(pr);
tLEN:=Length(pt);
rt:=(rLEN>=1) or (tLEN>=1);
hON:=false;
//check
if (xLEN=0) or (aLEN=0) then exit;
p:=1;
//.au + al
au:=ord(a[1]);
if (au>=97) and (au<=122) then dec(au,32);
al:=au;
if (al>=65) and (al<90) then inc(al,32);
//process
repeat
//.get
v:=ord(x[p]);
//.html command - ignore contents
if _html then
   begin
   if (v=60) then hON:=true
   else if hON and (v=62) then hON:=false;
   end;//end of if
//.set
if (not hON) and ((v=au) or (v=al)) and (0=comparetext(copy(x,p,aLEN),a)) then
   begin
   if rt then
      begin
      //.check
      if _word then
         begin
         if (p>=2) and eptc(x[p-1]) then goto skipone;
         if ((p+aLEN)<xLEN) and eptc(x[p+aLEN]) then goto skipone;
         end;//end of if
      x:=copy(x,1,p-1)+pr+copy(x,p,aLEN)+b+pt+copy(x,p+aLEN,xLEN);
      p:=p+rLEN+aLEN+bLEN+tLEN-1;
      xLEN:=xLEN+rLEN+bLEN+tLEN;
      end
   else
      begin
      x:=copy(x,1,p-1)+b+copy(x,p+aLEN,xLEN);
      p:=p+bLEN-1;
      xLEN:=xLEN-aLEN+bLEN;
      end;//end of if
   //yes
   result:=true;
   end;//end of if
skipone:
//.inc
inc(p);
until (p>xLEN) or ((_count>=1) and (p<_count));
except;end;
end;
//## MveControl ##
Procedure tgeneral.MveControl(X,Y,W,H:Integer;Z:TWinControl);
Const
     SafeW=32;
begin
try
If (Z=nil) then exit;
X:=FrcRange(X,SafeW-W,Screen.Width-SafeW);
Y:=FrcRange(Y,SafeW-H,Screen.Height-SafeW);
Z.SetBounds(X,Y,W,H);
except;end;
end;
//## PosControl ##
procedure TGeneral.PosControl(x,y:integer;z:twincontrol);
begin
try
//check
if (Z=nil) then exit;
//enforce range
if (x<0) then x:=0 else if ((x+z.width)>screen.width) then x:=screen.width-z.width;
if (y<0) then y:=0 else if ((y+z.height)>screen.height) then y:=screen.height-z.height;
//set
z.setbounds(x,y,z.width,z.height);
except;end;
end;
//## NB ##
Function TGeneral.NB(X:String):Boolean;
begin
try;Result:=(X='1');except;end;
end;
//## bn ##
function tgeneral.bn(x:boolean):char;
begin
try;if x then result:='1' else result:='0';except;end;
end;
//## StdEncrypt ##
Function TGeneral.StdEncrypt(X:String;EKey:String;Mode1:Integer):String;{date: 22-FEB-2004}
Var
   Lt,El,E,p2,p:integer;
begin
try
{default: fail safe key}
if (EKey='') then EKey:='198dlkjq34';
Lt:=Length(X);
El:=Length(EKey);
E:=0;
case Mode1 of
0:begin
//Encrypt the String:
For P:=1 to Lt do
begin
E:=E+1;
If (E>El) then E:=1;
p2:=Ord(EKey[E])+Ord(X[p]);
if (p2>255) then p2:=p2-256;
X[p]:=chr(p2);
end;//end of loop
end;//end of begin
1:begin
//Decrypt the String:
for p:=1 to Lt do
begin
E:=E+1;
If (E>El) then E:=1;
p2:=Ord(X[p])-Ord(EKey[E]);
if (p2<0) then p2:=p2+256;
X[p]:=chr(p2);
end;//end of loop
end;//end of begin
2:begin
//Encrypt PlainText to PlainText String (13-255):
For P:=1 to Lt do
begin
E:=E+1;
If (E>El) then E:=1;
p2:=Ord(EKey[E])+Ord(X[p]);
if (p2>255) then p2:=p2-242;
X[p]:=chr(p2);
end;//end of loop
end;//end of begin
3:begin
//Decrypt the String:
for p:=1 to Lt do
begin
E:=E+1;
If (E>El) then E:=1;
p2:=Ord(X[p])-Ord(EKey[E]);
if (p2<14) then p2:=p2+242;
X[p]:=chr(p2);
end;//end of loop
end;//end of begin
end;
Result:=X;
except;end;
end;
//## filesize ##
function tgeneral.filesize(x:string):integer;//25SEP2007
var
   a:tfilestream;
begin
try
//defaults
result:=-1;
//check
if (x='') or (not fileexists(x)) then exit;
//get
a:=nil;
a:=tfilestream.create(x,fmOpenRead+fmShareDenyNone);
result:=a.size;
except;end;
try;freeObj(@a);except;end;
end;
//## ColShade ##
Function TGeneral.ColShade(X,P:Integer):Integer;
var
   a:tint4;
begin
try
a.val:=x;
Result:=RGB(a.r*P Div 100,a.b*P Div 100,a.g*P Div 100);
except;end;
end;
//## ColSplice ##
Function TGeneral.ColSplice(X,C1,C2:Integer):Integer;
var
   a,b:tint4;
   P1,P2:Integer;
begin
try
{Error}
Result:=0;
{P1 & P2}
P1:=(X*100) Div 100;
P2:=100-P1;
{Color}
a.val:=c1;
b.val:=c2;
a.R:=(a.R*P1+b.R*P2) Div 100;
a.G:=(a.G*P1+b.G*P2) Div 100;
a.B:=(a.B*P1+b.B*P2) Div 100;
{Return Result}
Result:=a.val;
except;end;
end;
//## ColBright ##
Function TGeneral.ColBright(X:Integer):Integer;
var
   a:tint4;
begin
try
{Default}
result:=0;
a.val:=x;
If (a.R>Result) then Result:=a.R;
If (a.G>Result) then Result:=a.G;
If (a.B>Result) then Result:=a.B;
except;end;
end;
//## ColDark ##
Function TGeneral.ColDark(X:Integer):Integer;
var
   a:tint4;
begin
try
{Default}
Result:=255;
a.val:=x;
If (a.R<Result) then Result:=a.R;
If (a.G<Result) then Result:=a.G;
If (a.B<Result) then Result:=a.B;
except;end;
end;
//## Files ##
Function TGeneral.Files(sPath:String;AsFullFileNames:Boolean):String;
begin
try;result:=filesex(spath,asfullfilenames,false);except;end;
end;
//## filesex ##
function tgeneral.filesex(spath:string;asfullfilenames:boolean;_sort:boolean):string;//23SEP2007
Var
 I:Integer;
 SearchRec:TSearchRec;
 A:TStringList;
 rPath:String;
begin
try
//defaults
result:='';
//get
a:=nil;
If AsFullFileNames then rPath:=ExtractFilePath(sPath);
A:=TStringList.Create;
I := FindFirst(sPath, 0, SearchRec);
while I = 0 do
begin
Case AsFullFileNames of
True:A.Add(rPath+SearchRec.Name);//As Full Path & FileNames
False:A.Add(SearchRec.Name);//As Just FileNames
end;//End of CASE
I:=FindNext(SearchRec);
end;
//sort
if _sort then a.sort;
//set
result:=a.text;
//free memory
FindClose(SearchRec);
except;end;
try;freeobj(@a);except;end;
end;
//## filesb ##
function tgeneral.filesb(mask:string;full:boolean;_name:tdynamicstring;_size,_time:tdynamicinteger):boolean;
var//files only
 p,i:integer;
 SearchRec:TSearchRec;
 tmp,rPath:String;
begin
try
//defaults
result:=false;
if (_name=nil) then exit;
//process
if full then rPath:=ExtractFilePath(mask);
i:=findfirst(mask,
faReadOnly or faHidden or faSysFile or faArchive,
searchrec);
while I = 0 do
begin
//.name
if full then tmp:=rpath+searchrec.name else tmp:=searchrec.name;
p:=_name.count;
_name.value[p]:=tmp;
//.time
if (_time<>nil) then _time.value[p]:=searchrec.time;
//.size
if (_size<>nil) then _size.value[p]:=searchrec.size;
//.inc
i:=findnext(SearchRec);
end;
//successful
result:=true;
{Free Memory}
FindClose(SearchRec);
except;end;
end;
//## filesc ##
function tgeneral.filesc(pathmask:string;_name,_fullname:tdynamicstring;_size,_time,_attr:tdynamicinteger;_date:tdynamicdatetime):boolean;//09-OCT-2006
var
   p,i:integer;
   searchrec:tsearchrec;
   tmp,mask,path:string;
   systime:tsystemtime;
begin
try
//defaults
result:=false;
if (_name=nil) then exit;
path:='';
mask:='';
//process
//.get path/mask
for p:=length(pathmask) downto 1 do if (pathmask[p]='\') or (pathmask[p]='/') then
   begin
   path:=copy(pathmask,1,p);
   mask:=copy(pathmask,p+1,length(pathmask));
   if not textgood(mask) then mask:=cmAllFiles;
   break;
   end;//end of if
//.check
if (path='') or (mask='') then exit;
//.scan
i:=findfirst(path+cmAllFiles,faReadOnly or faHidden or faSysFile or faDirectory or faArchive or faAnyFile,searchrec);
while i=0 do
begin
if ((searchrec.attr and faDirectory)>0) or inf(searchrec.name,mask) then
   begin
   //.name
   p:=_name.count;
   _name.value[p]:=searchrec.name;
   //.fullname
   if (_fullname<>nil) then _fullname.value[p]:=path+searchrec.name;
   //.size
   if (_size<>nil) then _size.value[p]:=searchrec.size;
   //.time
   if (_time<>nil) then _time.value[p]:=searchrec.time;
   //.attr
   if (_attr<>nil) then _attr.value[p]:=searchrec.attr;
   //.date
   if (_date<>nil) then _date.value[p]:=dates.filedatetime(searchrec.finddata.ftLastWriteTime);
   end;//end of if
//.inc
i:=findnext(searchrec);
end;
//successful
result:=true;
//close
findclose(searchrec);
except;end;
end;
//## vibratecontrol ##
procedure tgeneral.vibratecontrol(x:twincontrol);
var
   p:integer;
begin
try
for p:=1 to 4 do
begin
x.top:=x.top+5;
sleep(50);
x.top:=x.top-5;
sleep(50);
end;//end of loop
except;end;
end;
//## center ##
procedure tgeneral.center(x:twincontrol;w,h:integer;_fullscreen:boolean);//work area
var
   a:trect;
begin
try
if _fullscreen then a:=rect(0,0,screen.width,screen.height) else a:=workarea;
centerb(x,w,h,a);
except;end;
end;
//## centerb ##
procedure tgeneral.centerb(x:twincontrol;w,h:integer;a:trect);//work area
var
   aw,ah,dx,dy:integer;
begin
try
//check
if (x=nil) then exit;
//process
//.get
aw:=frcmin(a.right-a.left,200);
ah:=frcmin(a.bottom-a.top,200);
//.calc
dx:=a.left +((aw-w)  div 2);
dy:=a.top  +((ah-h) div 2);
//.set
if (dx<>x.left) or (dy<>x.top) or (w<>x.width) or (h<>x.height) then x.setbounds(dx,dy,w,h);
except;end;
end;
//## centerbyapp ##
procedure tgeneral.centerbyapp(x:twincontrol;w,h:integer;_fullscreen:boolean);
var
   a:trect;
   aw,ah,dx,dy:integer;
begin
try
//check
if (x=nil) then exit;
if _fullscreen then a:=rect(0,0,screen.width,screen.height) else a:=workarea;
//process
//.desired new location
if (screen.activeform<>nil) then
   begin
   dx:=(screen.activeform.left+(screen.activeform.width div 2))-(w div 2);
   dy:=(screen.activeform.top+(screen.activeform.height div 2))-(h div 2);
   end
else
   begin
   aw:=frcmin(a.right-a.left,1);
   ah:=frcmin(a.bottom-a.top,1);
   dx:=a.left +((aw-w)  div 2);
   dy:=a.top  +((ah-h) div 2);
   end;//end of if
//.range
dx:=frcrange(dx,a.left,a.right-w);
dy:=frcrange(dy,a.top,a.bottom-h);
//.set
if (dx<>x.left) or (dy<>x.top) or (w<>x.width) or (h<>x.height) then x.setbounds(dx,dy,w,h);
except;end;
end;
//## StartFailure ##
Procedure TGeneral.StartFailure;
begin
try;showerror60(ntranslate(gecOutOfMemory));siHalt;except;end;
end;
//## iferror ##
procedure tgeneral.iferror(x:string);
begin
try;if (x<>'') and (x<>gecOK) then showerror60(translate(x));except;end;
end;
//## raiseerror ##
procedure TGeneral.raiseerror(x:string);
begin
//raise error
//yyyyyyyyyyyyyyyyyif (x<>'') then raise egeneralerror.create(x);
end;

//########################### tdates ###########################################
//## create ##
constructor tdates.create;
//Note: Any routines that uses any translated var in "init" must call "init" before using
//that var, as they must be inited (not automatic, since "tdates" is used by low functions
//that must work without triggering the system translation system to start! 14OCT2007
begin
inherited;
//vars
//.idiv
idiv[0]:=1;//ms
idiv[1]:=1000;//sec
idiv[2]:=idiv[1]*60;//min
idiv[3]:=idiv[2]*60;//hour
idiv[4]:=idiv[3]*24;//day
idiv[5]:=idiv[4]*32;//month
idiv[6]:=idiv[5]*13;//year
//.inilZERO
with inilZERO do
begin
year:=1900;
month:=1;
day:=1;
hour:=0;
minute:=0;
second:=0;
msec:=0;
end;//end of with
end;
//## destroy ##
destructor tdates.destroy;
begin
try
//self
inherited;
except;end;
end;
//## init ##
procedure tdates.init;//don't translate strings until we need them, makes booting smoother for dual translation systems
var
   p:integer;
begin
try
//check
if iinit then exit else iinit:=true;
//months
for p:=low(_months) to high(_months) do
begin
imonths[p]:=ntranslate(_months[p]);
imonths_abrv[p]:=ntranslate(_months_abrv[p]);
end;//end of loop
//days
for p:=low(_days) to high(_days) do
begin
idays[p]:=ntranslate(_days[p]);
idays_abrv[p]:=ntranslate(_days_abrv[p]);
end;//end of loop
//get
iGMT:=uppercase(translate('GMT'));
iAM:=uppercase(translate('AM'));
iPM:=uppercase(translate('PM'));
iBC:=uppercase(translate('BC'));
except;end;
end;
//## wsd ##
function tdates.wsd(d,m,y:word;sep:char):string;//write string date
begin
try;result:=general.digpad(d,2)+sep+monthABRV[m,false]+sep+general.digpad(y,4);except;end;
end;
//## wsdb ##
function tdates.wsdb(x:tdatetime;sep:char):string;//write string date
begin
try;result:=date(x,sep,false,true);except;end;
end;
//## rsd ##
procedure tdates.rsd(var d,m,y:word;sep:char;x:string);//read string date
var
   z,v,c,p:integer;
   tmp:string;
begin
try
//defaults
d:=1;
m:=1;
y:=1900;
//process
//.filter
if (sep<>#10) then general.swapchars(x,sep,#10);
//.get
c:=0;
p:=1;
while general.nextline(p,x,tmp) do if general.textgood(tmp) then
   begin
   inc(c);
   v:=strint(tmp);
   case c of
   1:d:=frcrange(v,1,31);
   2:begin
     if not findmonth(tmp,z) then z:=v;//switch between "short month", "long month" and "numerical month" automatically
     m:=frcrange(z,1,12);
     end;//end of begin
   3:y:=frcmin(v,0);
   else break;
   end;//end of case
   end;//end of if
except;end;
end;
//## uptime ##
function tdates.uptime(x:currency;t:boolean;sep:string):string;
begin
try;result:=uptimeb(x,t,true,sep);except;end;
end;
//## uptimeb ##
function tdates.uptimeb(x:currency;t,showms:boolean;sep:string):string;//Updated: 07SEP2007
const
   oneday  =86400000;
   onehour =3600000;
   onemin  =60000;
   onesec  =1000;
var
   onemonth,mth,dy,h,m,s,ms:currency;
   ok:boolean;
begin
try
//defaults
result:='';
ok:=false;
mth:=0;
dy:=0;
h:=0;
m:=0;
s:=0;
ms:=0;
//range
if (x<0) then x:=0;
//.onemonth
onemonth:=oneday;
onemonth:=onemonth*28;
//process
//.get
if (x>=0) then
   begin
   //.month
   mth:=cround(x/onemonth);
   x:=x-(mth*onemonth);
   //.day
   dy:=cround(x/oneday);
   x:=x-(dy*oneday);
   //.hour
   h:=cround(x/onehour);
   x:=x-(h*onehour);
   //.minute
   m:=cround(x/onemin);
   x:=x-(m*onemin);
   //.second
   s:=cround(x/onesec);
   x:=x-(s*onesec);
   //.ms
   ms:=x;
   end;//end of if
//.set
if (mth>=1) or ok then
   begin
   result:=result+general.insstr(sep,length(result)>=1)+
   general.sdigpad(floattostrex2(mth),2)+general.aorbstr('mth',tslcMTH,t);
   ok:=true;
   end;//end of if
if (dy>=1) or ok then
   begin
   result:=result+general.insstr(sep,length(result)>=1)+
   general.sdigpad(floattostrex2(dy),2)+general.aorbstr('dy',tslcDY,t);
   ok:=true;
   end;//end of if
if (h>=1) or ok then
   begin
   result:=result+general.insstr(sep,length(result)>=1)+
   general.sdigpad(floattostrex2(h),2)+general.aorbstr('h',tslcH,t);
   ok:=true;
   end;//end of if
if (m>=1) or ok then
   begin
   result:=result+general.insstr(sep,length(result)>=1)+
   general.sdigpad(floattostrex2(m),2)+general.aorbstr('m',tslcM,t);
   ok:=true;
   end;//end of if
if (s>=1) or ok or (not showms) then
   begin
   result:=result+general.insstr(sep,length(result)>=1)+
   general.sdigpad(floattostrex2(s),2)+general.aorbstr('s',tslcS,t);
   ok:=true;
   end;//end of if
if showms and ((ms>=0) or ok) then
   begin
   result:=result+general.insstr(sep,length(result)>=1)+
   general.sdigpad(floattostrex2(ms),3)+general.aorbstr('ms',tslcMS,t);
   ok:=true;
   end;//end of if
except;end;
end;
//## filedatetime ##
function tdates.filedatetime(x:tfiletime):tdatetime;
var
   a:integer;
   c:tfiletime;
begin
try
//defaults
result:=now;
//process
filetimetolocalfiletime(x,c);
if filetimetodosdatetime(c,longrec(a).hi,longrec(a).lo) then result:=filedatetodatetime(a)
else result:=now;
except;end;
end;
//## fileage ##
function tdates.fileage(x:thandle):tdatetime;
var
   a:tbyhandlefileinformation;
begin
try;if (x=0) or (not getfileinformationbyhandle(x,a)) then result:=now else result:=filedatetime(a.ftLastWriteTime);except;end;
end;
//## getday ##
function tdates.getday(x:byte;t:boolean):string;
begin
try
init;
x:=frcrange(x,1,7);
if t then result:=idays[x] else result:=_days[x];
except;end;
end;
//## getdayABRV ##
function tdates.getdayABRV(x:byte;t:boolean):string;
begin
try
init;
x:=frcrange(x,1,7);
if t then result:=idays_abrv[x] else result:=_days_abrv[x];
except;end;
end;
//## getmonth ##
function tdates.getmonth(x:byte;t:boolean):string;
begin
try
init;
x:=frcrange(x,1,12);
if t then result:=imonths[x] else result:=_months[x];
except;end;
end;
//## getmonthABRV ##
function tdates.getmonthABRV(x:byte;t:boolean):string;
begin
try
init;
x:=frcrange(x,1,12);
if t then result:=imonths_abrv[x] else result:=_months_abrv[x];
except;end;
end;
//## year ##
function tdates.year:word;
var
   m,d:word;
begin
try;decodedate(now,result,m,d);except;end;
end;
//## yearstr ##
function tdates.yearstr:string;
begin
try;result:=general.digpad(year,4);except;end;
end;
//## shortdate ##
function tdates.shortdate(x:tdatetime;t:boolean):string;
begin
try;result:=shortdateex(x,t,false);except;end;
end;
//## shortdateex ##
function tdates.shortdateex(x:tdatetime;t,ordered:boolean):string;
begin
try;result:=uppercase(dateex(x,'-',t,true,ordered));except;end;
end;
//## date ##
function tdates.date(x:tdatetime;sep:string;t,abrv:boolean):string;
begin
try;result:=dateex(x,sep,t,abrv,false);except;end;
end;
//## dateex ##
function tdates.dateex(x:tdatetime;sep:string;t,abrv,ordered:boolean):string;
var
   y,m,d:word;
begin
try
//prepare
decodedate(x,y,m,d);
if (sep='') then sep:=#32;
//process
case abrv of
false:case ordered of
      true:result:=general.digpad(y,4)+sep+month[m,t]+sep+general.digpad(d,2);//year-month-day
      false:result:=general.digpad(d,2)+sep+month[m,t]+sep+general.digpad(y,4);//day-month-year
      end;//end of case
true:case ordered of
     true:result:=general.digpad(y,4)+sep+monthABRV[m,t]+sep+general.digpad(d,2);//year-month-day
     false:result:=general.digpad(d,2)+sep+monthABRV[m,t]+sep+general.digpad(y,4);//day-month-year
     end;//end of case
end;//end of case
except;end;
end;
//## logstyle ##
function tdates.logstyle:string;//01FEB2008
begin
try;result:=logstyleex(true);except;end;
end;
//## logstyleex ##
function tdates.logstyleex(full:boolean):string;//01FEB2008
var
   y,m,d:word;
begin
try
//defaults
result:='';
//init
decodedate(now,y,m,d);
//get
result:=
 general.insstr('-[',full)+
 'y'+general.digpad(y,4)+'-'+
 'm'+general.digpad(m,2)+'-'+
 'd'+general.digpad(d,2)+
 general.insstr(']',full);
except;end;
end;
//## shorttime ##
function tdates.shorttime(x:tdatetime;t:boolean):string;
begin
try;result:=shorttimeb(x,t,false);except;end;
end;
//## shorttimeb ##
function tdates.shorttimeb(x:tdatetime;t,showsec:boolean):string;
begin
try;result:=uppercase(time(x,':',' ',t,showsec));except;end;
end;
//## time ##
function tdates.time(x:tdatetime;sep,sep2:string;t,showsec:boolean):string;//02-AUG-2006
var//Note: Not translated - used for "stable" filename, therefore
   //      we must be able to refer to previous files even is language
   //      changes.
   h,m,s,ms:word;
   ap:string;
begin
try
//prepare
init;
decodetime(x,h,m,s,ms);
ap:='';
if (sep='') then sep:=':';
if (sep2='') then sep2:=#32;
if (h>=0) and (h<=11) then
   begin
   ap:=general.aorbstr('AM',iam,t);
   if (h=0) then h:=12;
   end
else
   begin
   ap:=general.aorbstr('PM',ipm,t);
   dec(h,12);
   if (h=0) then h:=12;
   end;//end of if
//process
result:=general.digpad(h,2)+sep+general.digpad(m,2)+general.insstr(sep+general.digpad(s,2),showsec)+sep2+ap;
except;end;
end;
//## shortdatetime ##
function tdates.shortdatetime(x:tdatetime;t:boolean):string;
begin
try;result:=shortdatetimeb(x,t,false);except;end;
end;
//## shortdatetimeb ##
function tdates.shortdatetimeb(x:tdatetime;t,showsec:boolean):string;
begin
try;result:=shortdate(x,t)+', '+shorttimeb(x,t,showsec);except;end;
end;
//## strYDHMS ##
function tdates.strYDHMS(xsec:integer):string;
var
   y,d,h,m,s:integer;
begin
try
//defaults
result:='';
//process
//.get
toYDHMS(xsec,y,d,h,m,s);
//.set
if (y>=1) then result:=result+general.digpad(y,2)+'y ';
if (y>=1) or (d>=1) then result:=result+general.digpad(d,3)+'d ';
if (y>=1) or (d>=1) or (h>=1) then result:=result+general.digpad(h,2)+'h ';
if (y>=1) or (d>=1) or (h>=1) or (m>=1) then result:=result+general.digpad(m,2)+'m ';
result:=result+general.digpad(s,2)+'s';
except;end;
end;
//## toYDHMS ##
procedure tdates.toYDHMS(xsec:integer;var y,d,h,m,s:integer);
begin
try
//defaults
y:=0;
d:=0;
h:=0;
m:=0;
s:=0;
//process
if (xsec>=1) then
   begin
   //.y
   y:=xsec div 31557600;//oneyear = 86400x365.25 = 31,557,600 seconds
   xsec:=frcrange(xsec-y*31557600,0,31557599);
   //.d
   if (xsec>=1) then
      begin
      d:=xsec div 86400;
      xsec:=frcrange(xsec-d*86400,0,86399);
      //.h
      if (xsec>=1) then
         begin
         h:=frcrange(xsec div 3600,0,23);
         xsec:=frcrange(xsec-h*3600,0,3599);
         //.m
         if (xsec>=1) then
            begin
            m:=frcrange(xsec div 60,0,59);
            xsec:=frcrange(xsec-m*60,0,59);
            //.s
            if (xsec>=1) then s:=frcrange(xsec,0,59);
            end;//end of if
         end;//end of if
      end;//end of if
   end;//end of if
except;end;
end;
//## strYDHMSb ##
function tdates.strYDHMSb(xmin,xsec:integer):string;
var//Note: xsec<0 - seconds are not displayed
   y,d,h,m:integer;
begin
try
//defaults
result:='';
//process
//.get
toYDHM(xmin,y,d,h,m);
//.set
if (y>=1) then result:=result+general.digpad(y,2)+'y ';
if (y>=1) or (d>=1) then result:=result+general.digpad(d,3)+'d ';
if (y>=1) or (d>=1) or (h>=1) then result:=result+general.digpad(h,2)+'h ';
if ((y>=1) or (d>=1) or (h>=1) or (m>=1)) and (xsec>=0) then result:=result+general.digpad(m,2)+'m ';
if (xsec>=0) then result:=result+general.digpad(frcrange(xsec,0,59),2)+'s';
except;end;
end;
//## toYDHM ##
procedure tdates.toYDHM(xmin:integer;var y,d,h,m:integer);
const
   oneyr=525960;//minutes - 365.25*1440
begin
try
//defaults
y:=0;
d:=0;
h:=0;
m:=0;
//process
if (xmin>=1) then
   begin
   //.y
   y:=xmin div oneyr;
   xmin:=frcmin(xmin-y*oneyr,0);
   //.d
   if (xmin>=1) then
      begin
      d:=xmin div 1440;
      xmin:=frcrange(xmin-d*1440,0,1491308);
      //.h
      if (xmin>=1) then
         begin
         h:=frcrange(xmin div 60,0,23);
         xmin:=frcrange(xmin-h*60,0,1439);
         //.m
         if (xmin>=1) then m:=frcrange(xmin,0,59);
         end;//end of if
      end;//end of if
   end;//end of if
except;end;
end;
//## yearLABEL ##
function tdates.yearLABEL(x:integer;bc,ad:string):string;
begin
try;result:=general.aorbstr(bc,ad,x>=0);except;end;
end;
//## restrictZERO ##
procedure tdates.restrictZERO(var x:tdateZERO);
begin
try
with x do
begin
year:=frcrange(year,-25000,25000);
month:=frcrange(month,0,12);
day:=frcrange(day,0,31);
hour:=frcrange(hour,0,23);
minute:=frcrange(minute,0,59);
second:=frcrange(second,0,59);
msec:=frcrange(msec,0,999);
end;//end of with
except;end;
end;
//## toMSb ##
function tdates.toMSb(x:tdateZERO):tdateMS;
begin
try;toMS(x,result);except;end;
end;
//## toMS ##
procedure tdates.toMS(var x:tdateZERO;var y:tdateMS);
var
   neg:boolean;
begin
try
//defaults
y:=0;
//process
//.neg
neg:=x.year<0;
if neg then x.year:=general.posn(x.year);
//.restrict
restrictZERO(x);
//.set
y:=y+x.msec;
y:=y+x.second*idiv[1];
y:=y+x.minute*idiv[2];
y:=y+x.hour*idiv[3];
y:=y+x.day*idiv[4];//allow zero
y:=y+x.month*idiv[5];//allow zero
y:=y+x.year*idiv[6];
//.finalise
if neg then y:=-y;
except;end;
end;
//## fromMSb ##
function tdates.fromMSb(x:tdateMS):tdateZERO;
begin
try;fromMS(x,result);except;end;
end;
//## fromMS ##
procedure tdates.fromMS(x:tdateMS;var y:tdateZERO);
var
   neg:boolean;
begin
try
//process
//.neg
neg:=x<0;
if neg then x:=-x;
//.set
with y do
begin
year:=frcrange(trunc(x/idiv[6]),0,25000);x:=x-(year*idiv[6]);
month:=frcrange(trunc(x/idiv[5]),0,12);x:=x-(month*idiv[5]);
day:=frcrange(trunc(x/idiv[4]),0,31);x:=x-(day*idiv[4]);
hour:=frcrange(trunc(x/idiv[3]),0,23);x:=x-(hour*idiv[3]);
minute:=frcrange(trunc(x/idiv[2]),0,59);x:=x-(minute*idiv[2]);
second:=frcrange(trunc(x/idiv[1]),0,59);x:=x-(second*idiv[1]);
msec:=frcrange(trunc(x),0,999);
//.finalise
if neg then year:=-year;
end;//end of with
except;end;
end;
//## toDT ##
function tdates.toDT(x:tdateMS):tdatetime;//ms to datetime
var
   tmp:tdateZERO;
   yy,mm,dd,h,m,s,ms:word;
begin
try
//defaults
result:=0;
//process
//.get
fromMS(x,tmp);
//.enforce range
with tmp do
begin
year:=frcrange(year,1900,9999);
month:=frcrange(month,1,12);
day:=frcrange(day,1,31);
end;//end of with
//return result
result:=encodedate(tmp.year,tmp.month,tmp.day)+encodetime(tmp.hour,tmp.minute,tmp.second,tmp.msec);
except;end;
end;
//## fromDT ##
function tdates.fromDT(x:tdatetime):tdateMS;//datetime to ms
var
   tmp:tdateZERO;
   yy,mm,dd,h,m,s,ms:word;
begin
try
//process
//.get
decodedate(x,yy,mm,dd);
decodetime(x,h,m,s,ms);
//.set
with tmp do
begin
year:=yy;
month:=mm;
day:=dd;
hour:=h;
minute:=m;
second:=s;
msec:=ms;
end;//end of with
//return result
toMS(tmp,result);
except;end;
end;
//## dtzero ##
function tdates.dtzero(x:tdatetime):tdateZERO;//datetime -> dateZERO
begin
try;result:=fromMSb(fromDT(x));except;end;
end;
//## zerodt ##
function tdates.zerodt(x:tdateZERO):tdatetime;//dateZERO -> datetime
begin
try;result:=toDT(toMSb(x));except;end;
end;
//## toFILEDATE ##
function tdates.toFILEDATE(x:tdateZERO):string;
begin
try;result:=toFILEDATEb(x,'_','_','-','-','-');except;end;
end;
//## toFILEDATEb ##
function tdates.toFILEDATEb(x:tdateZERO;sepA,sepB,sep1,sep2,sep3:string):string;
begin
try
//process
//.restric
restrictZERO(x);
//.set
with x do
begin
day:=frcmin(day,1);
month:=frcmin(month,1);
result:=sepA+general.digpad(day,2)+sep1+_months_abrv[month]+sep1+general.digpad(general.posn(year),4)+yearLABEL(year,'BC','')+sepB+general.digpad(hour,2)+sep2+general.digpad(minute,2)+sep2+general.digpad(second,2)+sep3+general.digpad(msec,3);
end;//end of with
except;end;
end;
//## fromFILEDATE ##
function tdates.fromFILEDATE(x:string):tdateZERO;
var
   v,o,lp,c,xLEN,p2,p:integer;
   tmp:string;
begin
try
//defaults
result:=inilZERO;
xLEN:=length(x);
c:=0;
//process
//.scan
with result do
begin
p:=xLEN;
repeat
if (x[p]='.') then lp:=p-1
else if (x[p]='-') or (x[p]='_') or (p=1) then
   begin
   //.end
   if (p=1) and ((x[p]<>'-') and (x[p]<>'_')) then o:=1 else o:=0;
   //.get
   tmp:=copy(x,p+1-o,lp-p+o);
   v:=strint(tmp);
   case c of
   0:msec:=v;
   1:second:=v;
   2:minute:=v;
   3:hour:=v;
   4:begin
     year:=v;
     if (0=comparetext('BC',copy(tmp,length(tmp)-1,2))) then year:=-general.posn(year);
     end;//end of begin
   5:begin
     for p2:=1 to 12 do if (0=comparetext(_months_abrv[p2],tmp)) then
        begin
        month:=p2;
        break;
        end;//end of if
     end;//end of begin
   6:begin
     day:=v;
     break;
     end;//end of begin
   end;//end of case
   //.inc
   inc(c);
   lp:=p-1;
   end;//end of if
//.dec
dec(p);
until (p<=0);
end;//end of with
except;end;
try;restrictZERO(result);except;end;
end;
//## asGMT ##
function tdates.asGMT(x:tdatetime):tdatetime;//convert date to GMT date
var
   a:tsystemtime;
begin
try;getsystemtime(@a);result:=x-(now-systemtimetodatetime(a));except;end;
end;
//## gmtOFFSET ##
procedure tdates.gmtOFFSET(var h,m,factor:integer);
var//Confirmed using 02-JUL-2005 (all GMT offsets are correct - no summer daylight timings)
   a,b:integer;
   sys:tsystemtime;
begin
try
//defaults
h:=0;
m:=0;
factor:=1;
//process
//.get
getsystemtime(@sys);
a:=general.dim(now);
b:=general.dim(SystemTimeToDateTime(sys));
//.calc
a:=a-b;
if (a<0) then
   begin
   a:=-a;
   factor:=-1;
   end
else if (a=0) then factor:=0;
h:=a div 60;
dec(a,h*60);
m:=a;
except;end;
end;
//## gmt ##
function tdates.gmt(x:tdatetime):string;//gtm for webservers
begin
try;result:=gmtb(x,false);except;end;
end;
//## gmtb ##
function tdates.gmtb(x:tdatetime;t:boolean):string;//gtm for webservers
var
   y,m,d,hr,min,sec,msec:word;
begin
try
//defaults
init;
result:='';
//process
//.get
decodedate(x,y,m,d);
decodetime(x,hr,min,sec,msec);
//.set
result:=
  dayABRV[dayofweek(x),t]+', '+general.digpad(d,2)+#32+monthABRV[m,t]+#32+general.digpad(y,4)+#32+
  general.digpad(hr,2)+':'+general.digpad(min,2)+':'+general.digpad(sec,2)+#32+general.aorbstr('GMT',igmt,t);
except;end;
end;
//## gmtnow ##
function tdates.gmtnow:string;
begin
try;result:=gmtnowb(false);except;end;
end;
//## gmtnowb ##
function tdates.gmtnowb(t:boolean):string;
begin
try;result:=gmtb(asgmt(now),t);except;end;
end;
//## stamp ##
function tdates.stamp(x:tdateZERO;s:tdatestamp):string;
var
   tmp:integer;
   AMPM:string;
begin
try
//defaults
init;
result:='';
//process
//.date
if (dspDate in s) then
   begin
   result:=result+
    general.digpad(x.day,2)+'-'+
    general.aorbstr(month[x.month,dspTranslate in s],monthABRV[x.month,dspTranslate in s],(dspShort in s))+
    '-'+general.digpad(general.posn(x.year),4);
    general.insstr(dates.yearLABEL(x.year,general.aorbstr('BC',ibc,dspTranslate in s),''),dspBC in s);
   end;//end of if
//.time
if (dspTime in s) then
   begin
   if (result<>'') then result:=result+' / ';
   if (dspAMPM in s) then
      begin
      tmp:=x.hour;
      if (tmp>=0) and (tmp<12) then (if (dspTranslate in s) then ampm:=uppercase(translate('AM')) else ampm:='AM')
      else if (dspTranslate in s) then ampm:=uppercase(translate('PM')) else ampm:='PM';
      if (tmp>12) then dec(tmp,12);
      if (tmp=0) then tmp:=12;
      result:=result+general.digpad(tmp,2)+':'+general.digpad(x.minute,2)+'.'+general.digpad(x.second,2);
      end
   else result:=result+general.digpad(x.hour,2)+':'+general.digpad(x.minute,2)+'.'+general.digpad(x.second,2);
   //.ms
   if not (dspExcludeMS in s) then result:=result+'-'+general.digpad(x.msec,3);
   //.ampm
   if (dspAMPM in s) then result:=result+#32+ampm;
   end;//end of if
except;end;
end;
//## findmonth ##
function tdates.findmonth(x:string;var i:integer):boolean;
var
   p:integer;
begin
try
//defaults
result:=false;
i:=0;
//process
//.short
for p:=1 to 12 do if (0=comparetext(_months_abrv[p],x)) then
   begin
   i:=p;
   result:=true;
   break;
   end;//end of if
//.long
if not result then for p:=1 to 12 do if (0=comparetext(_months[p],x)) then
   begin
   i:=p;
   result:=true;
   break;
   end;//end of if
except;end;
end;
//## toYMD ##
function tdates.toDMY(shortdate:string;sep:char;var d,m,y:integer):boolean;
var
   c,p,len:integer;
   tmp:string;
begin//expects date in format "DAY-MONTH(eng)-YEAR" e.g. "21-AUG-2005"
try
//defaults
result:=false;
len:=length(shortdate);
y:=2000;
m:=1;
d:=1;
c:=0;
p:=1;
//process
//.split
general.swapchars(shortdate,sep,#10);
//.get
while general.nextline(p,shortdate,tmp) do
begin
//..inc
inc(c);
if (c=1) then d:=frcrange(strint(tmp),1,31)
else if (c=2) then
   begin
   if not findmonth(tmp,m) then m:=1;
   end
else if (c=3) then
   begin
   y:=frcmin(strint(tmp),0);
   //successful
   result:=true;
   break;
   end;//end of if
end;//end of loop
except;end;
end;

//## tresdata ##################################################################
//## create ##
constructor tresdata.create(_ptr:pstring);
begin
//self
inherited create(nil);
//check
iptr:=_ptr;
if (iptr=nil) then showerror60(ntranslate(gecUnexpectedError));
end;
//## setvalue ##
procedure tresdata.setvalue(x:string);
begin
try;if (iptr<>nil) then iptr^:=x;except;end;
end;
//## getvalue ##
function tresdata.getvalue:string;
begin
try;if (iptr<>nil) then result:=iptr^ else result:='';except;end;
end;

//## html ######################################################################
//## create ##
constructor thtml.create;
begin
//self
inherited;
//vars
rows:=0;
cols:=0;
size:=0;
width:=0;
end;
//## destroy ##
destructor thtml.destroy;
begin
try
//self
inherited;
except;end;
end;
//## favicon ##
function thtml.favicon(ext:string):string;
var
   a:tstreammem;
   tmp,e,z,ico:string;
begin
try
//defaults
result:='';
//init
if (not ifaviconDONE) then
   begin
   ifaviconDONE:=true;
   //ico
   try
   a:=nil;
   a:=tstreammem.create(@ico);
   application.icon.savetostream(a);
   except;end;
   try;freeobj(@a);except;end;
   tmp:=ico;
   if ccs.convertdata(tmp,'ico','',e) then ifaviconICO:=tmp;
   //gif - still
   tmp:=ico;
   if ccs.convertdata(tmp,'gif','',e) then ifaviconGIF:=tmp;
   //gif - animated
   z:=programanimatedicon;
   if (z='') or (not ccs.convertdata(z,'gif','',e)) then z:=ifaviconGIF;
   ifaviconAGIF:=z;
   //jpg
   tmp:=ico;
   if ccs.convertdata(tmp,'jpg','',e) then ifaviconJPG:=tmp;
   end;//end of if
//get
ext:=lowercase(ext);
ext:=general.udv(readfileext(ext,false),ext);//handles even pure "ext" such as "ext=GIF" without any filename or period "."
if (ext='ico') then result:=ifaviconICO
else if (ext='gif') then result:=general.aorbstr(ifaviconGIF,ifaviconAGIF,vs.b[vsAnimateIcon])
else if (ext='jpg') then result:=ifaviconJPG
else result:='';
except;end;
end;
//## faviconBUFFERS ##
procedure thtml.faviconBUFFERS(ext:string;var header,content:string);
begin
try
//defaults
ext:=lowercase(ext);
ext:=general.udv(readfileext(ext,false),ext);//handles even pure "ext" such as "ext=GIF" without any filename or period "."
//get
general.whREPLY(header,content,favicon(ext),ext);
except;end;
end;
//## setrows ##
procedure thtml.setrows(x:integer);
begin
try
if (x<=0) then x:=6;
irows:=x;
except;end;
end;
//## setcols ##
procedure thtml.setcols(x:integer);
begin
try
if (x<=0) then x:=40;
icols:=x;
except;end;
end;
//## setsize ##
procedure thtml.setsize(x:integer);
begin
try
if (x<=0) then x:=45;
isize:=x;
except;end;
end;
//## setwidth ##
procedure thtml.setwidth(x:integer);
begin//Note: supports minus values (percentages)
try
if (x=0) then x:=400;//default value
iwidth:=x;
except;end;
end;
//## formbegin ##
function thtml.formbegin(f,_method:string):string;//18FEB2008
var
   _multipart:boolean;
begin
try
//range
if (f='') then f:='/';
_method:=lowercase(_method);
_multipart:=(_method='multipart');//18FEB2008
if _multipart or ((_method<>'get') and (_method<>'post')) then _method:='post';
//set
result:='<form method='+_method+general.insstr(' enctype="multipart/form-data"',_multipart)+' action="'+f+'">'+rcode;
except;end;
end;
//## formend ##
function thtml.formend:string;
begin
try;result:='</form>'+rcode;except;end;
end;
//## areabegin ##
function thtml.areabegin(_width:integer;_nowidth:boolean;_title:boolean):string;
begin
try;result:='<table'+aswidth(_width,not _nowidth)+' bgcolor='+bgcolor(_title)+' cellpadding=0 cellspacing=0 border=0><td>'+rcode;except;end;
end;
//## areaend ##
function thtml.areaend:string;
begin
try;result:='</td></table>'+rcode;except;end;
end;
//## aswidth ##
function thtml.aswidth(_width:integer;_enable:boolean):string;
begin
try
//defaults
result:='';
//check
if not _enable then exit;
if (_width=0) then
   begin
   _width:=iwidth;
   if (_width=0) then exit;
   end;//end of if
//get
if (_width>=0) then result:=inttostr(_width) else result:=inttostr(-_width)+'%';
//set
if (result<>'') then result:=' width='+result;
except;end;
end;
//## rowbegin ##
function thtml.rowbegin(_width:integer;_nowidth:boolean;_title:boolean):string;//19FEB2008
begin
try;result:='<table'+aswidth(_width,not _nowidth)+' bgcolor='+bgcolor(_title)+' cellpadding=0 cellspacing=0 border=0>'+rcode;except;end;
end;
//## rowBG ##
function thtml.rowBG(_labels:array of string;var _bgcolor:boolean;_title:boolean):string;
begin
try
//get
result:=row(_labels,_bgcolor,_title);
//inc
_bgcolor:=not _bgcolor;
except;end;
end;
//## row ##
function thtml.row(_labels:array of string;_bgcolor,_title:boolean):string;//19FEB2008
var//Note: Allows raw data input e.g. "[raw]data...."
   p:integer;
   z,c:string;
begin
try
//defaults
c:='';
if _bgcolor then c:=' bgcolor='+general.aorbstr(viNormal.hbackshade,viTitle.hbackshade,_title);
//init
result:='<tr'+c+'>';
//get
for p:=low(_labels) to high(_labels) do
begin
z:=_labels[p];
if (copy(z,1,5)='[raw]') then delete(z,1,5) else z:=net_encode_for_html_b(z);
result:=result+'<td><font color='+fontcolor(_title)+'>'+z+'</font></td>';
end;//end of loop
result:=result+'</tr>'+rcode;
except;end;
end;
//## rowend ##
function thtml.rowend:string;
begin
try;result:='</table>'+rcode;except;end;
end;
//## fontcolor ##
function thtml.fontcolor(_title:boolean):string;
begin
try;result:=general.aorbstr(viNormal.hfont,viTitle.hfont,_title);except;end;
end;
//## bgcolor ##
function thtml.bgcolor(_title:boolean):string;
begin
try;result:=general.aorbstr(viNormal.hbackground,viTitle.hbackground,_title);except;end;
end;
//## cappage ##
function thtml.cappage(_label,_deslabel,_links:string;_title:boolean):string;
begin
try;result:=cappageex(false,_label,_deslabel,_links,_title);except;end;
end;
//## cappageex ##
function thtml.cappageex(_favicon:boolean;_label,_deslabel,_links:string;_title:boolean):string;
begin
try
//range
if (_label<>'') then net_encode_for_html(_label);
if (_deslabel<>'') then net_encode_for_html(_deslabel);
//get
result:=
'<table cellpadding=5 cellspacing=0 border=0 width=100% bgcolor='+bgcolor(_title)+'>'+rcode+
general.insstr('<td width=32><img src="/favicon.gif" width=32 height=32 border=0></td>'+rcode,_favicon)+
'<td><font size="+2" color='+fontcolor(_title)+'>'+_label+general.insstr('<font size=1><br>'+_deslabel+'</font>',_deslabel<>'')+'</font></td>'+rcode+
'<td align=right>'+rcode+
_links+
'</td>'+rcode+
'</tr>'+rcode+
'</table>'+rcode;
except;end;
end;
//## cap ##
function thtml.cap(_label:string;_title:boolean):string;
begin
try;result:=capex(_label,'',_title);except;end;
end;
//## capex ##
function thtml.capex(_label,_comment:string;_title:boolean):string;//22FEB2008
begin
try
result:=
'<font size="+2" color='+fontcolor(_title)+'>'+net_encode_for_html_b(_label)+'</font>'+
general.insstr(' &nbsp; <font color='+fontcolor(_title)+'>'+net_encode_for_html_b(_comment)+'</font>',(_comment<>''))+
'<br>'+rcode;
except;end;
end;
//## comment ##
function thtml.comment(_label:string;_title:boolean):string;
begin
try;result:='<font color='+fontcolor(_title)+'>'+net_encode_for_html_b(_label)+'</font><br>'+rcode;except;end;
end;
//## line ##
function thtml.line(_title:boolean):string;
begin
try;result:=lineex(1,_title);except;end;
end;
//## lineex ##
function thtml.lineex(_size:integer;_title:boolean):string;
begin
try;result:='<hr size='+inttostr(frcmin(_size,1))+' color='+general.aorbstr(viNormal.hbackground,viTitle.hbackground,_title)+'>'+rcode;except;end;
end;
//## href ##
function thtml.href(_label,_url,_currentpage:string;_title:boolean):string;
begin
try;result:=hrefex(_label,_url,_currentpage,_title,true);except;end;
end;
//## hrefex ##
function thtml.hrefex(_label,_url,_currentpage:string;_title:boolean;_encode:boolean):string;
var
   ok:boolean;
begin
try
//get
ok:=(comparetext(_url,_currentpage)=0);
if _encode then net_encode_str_slash(_url,true);
//set
result:='<a href="'+_url+'"><font color='+fontcolor(_title)+'>'+general.insstr('<b>',ok)+net_encode_for_html_b(_label)+general.insstr('</b>',ok)+'</font></a> &nbsp;';
except;end;
end;
//## localfile ##
function thtml.localfile(_label,_varname:string;_size:integer;_title:boolean):string;
begin
try
//defaults
result:='';
//range
if (_label<>'') then _label:=net_encode_for_html_b(_label);
if (_size<=0) then _size:=isize;
//GET
//label
if (_label<>'') then result:=result+cap(_label,_title);
//text
result:=result+
'<input type=file name="'+_varname+'" size='+inttostr(_size)+'><br>'+rcode;
except;end;
end;
//## text ##
function thtml.text(_label,_line,_varname:string;_size:integer;_title:boolean):string;
begin
try
//defaults
result:='';
//range
if (_label<>'') then _label:=net_encode_for_html_b(_label);
if (_line<>'') then _line:=net_encode_for_html_b(general.firstlineb(_line));
if (_size<=0) then _size:=isize;
//GET
//label
if (_label<>'') then result:=result+cap(_label,_title);
//text
result:=result+
'<input type=text name="'+_varname+'" size='+inttostr(_size)+' value="'+_line+'"><br>'+rcode;
except;end;
end;
//## textarea ##
function thtml.textarea(_label,_text,_varname:string;_rows,_cols:integer;_wrap:boolean;_title:boolean):string;
begin
try
//defaults
result:='';
//range
if (_label<>'') then _label:=net_encode_for_html_b(_label);
if (_text<>'') then _text:=net_encode_for_html_b(_text);
if (_rows<=0) then _rows:=irows;
if (_cols<=0) then _cols:=icols;
//GET
//label
if (_label<>'') then result:=result+cap(_label,_title);
//text
result:=result+
'<textarea name="'+_varname+'" rows='+inttostr(_rows)+' cols='+inttostr(_cols)+' wrap='+general.aorbstr('off','on',_wrap)+'>'+_text+'</textarea><br>'+rcode;
except;end;
end;
//## tick ##
function thtml.tick(_label:string;_value:boolean;_varname:string;_title:boolean):string;
begin
try
//defaults
result:='';
//range
if (_label<>'') then _label:=net_encode_for_html_b(_label);
//GET
result:='<input type=checkbox name="'+_varname+'" value=1'+general.insstr(' CHECKED',_value)+'>'+general.insstr(#32+_label,_label<>'')+'<br>'+rcode;
except;end;
end;
//## button ##
function thtml.button(_label,_varname:string):string;
begin
try
//defaults
result:='';
//range
if (_label<>'') then _label:=net_encode_for_html_b(_label);
//GET
result:='<input type=submit name="'+_varname+'" value="'+_label+'"> &nbsp;';
except;end;
end;
//## buttonsave ##
function thtml.buttonsave:string;
begin
try;result:=button(ntranslate('save'),'save');except;end;
end;
//## buttonview ##
function thtml.buttonview:string;
begin
try;result:=button(ntranslate('view'),'view');except;end;
end;
//## buttonclear ##
function thtml.buttonclear:string;
begin
try;result:=button(ntranslate('clear'),'clear');except;end;
end;
//## eol ##
function thtml.eol:string;//end of line
begin
try;result:='<br>'+rcode;except;end;
end;
//## hsp ##
function thtml.hsp:string;//horizontal space
begin
try;result:=' &nbsp; &nbsp;';except;end;
end;

//## tmisc #####################################################################
//## misc_dialoghook ##
function tmisc_dialoghook(Wnd: HWnd; Msg: UINT; WParam: WPARAM; LParam: LPARAM): UINT; stdcall;
begin
result:=0;
end;
//## create ##
constructor tmisc.create;
begin
inherited;
//vars
iimageextlist:=nil;
//controls
iimg:=tbitmap.create;
iimg.pixelformat:=pf4bit;
//vars
icursorfi:=4;//all cursors
//defaults
cursorpath:='';
end;
//## destroy ##
destructor tmisc.destroy;
begin
try
//delete
delmidi;
//controls
freeobj(@iimg);
freeobj(@iimageextlist);
//self
inherited;
except;end;
end;
//## shortfile ##
function tmisc.shortfile(_longfilename:string):string;//translate long filenames to short filename, using MS api, for "MCI playback of filenames with 125+c" - 23FEB2008
var//Note: works only for existing filenames - short names accessed from disk system
  z:string;
  zlen:integer;
begin
try
//defaults
result:=_longfilename;
//get
setlength(z,max_path);
zlen:=getshortpathname(pchar(_longfilename),pchar(z),max_path-1);
if (zlen>=1) then
   begin
   setlength(z,zlen);
   result:=z;
   end;//end of if
except;end;
end;
//## rndsplashbc ##
function tmisc.rndsplashbc:integer;
begin//All colors must work with "white" text
try
case random(5) of
0:result:=rgb(0,110,255);//blue
1:result:=rgb(255,39,1);//red
2:result:=rgb(0,213,1);//green
3:result:=rgb(231,12,154);//purple
4:result:=rgb(253,154,55);//orange
end;//end of case
except;end;
end;
//## enforceEOL ##
function tmisc.enforceEOL(x:string):string;//12FEB2008
begin
try;result:=enforceEOLex(x,true);except;end;
end;
//## enforceEOLex ##
function tmisc.enforceEOLex(x:string;includeempty:boolean):string;//12FEB2008
var
   p:integer;
begin
try
//get
result:=x;
//set
p:=length(result);
if (p=0) then
   begin
   if not includeempty then exit;
   result:=rcode;
   end
else if (result[p]<>#10) and (result[p]<>#13) then result:=result+rcode;
except;end;
end;
//## calcservice ##
function tmisc.calcservice(s:string;var d:string):boolean;
label
   skipend;
var
   c,slen,p:integer;
begin
try
//defaults
result:=false;
d:='';
slen:=length(s);
if (slen=0) then goto skipend;
//decide
//.web
d:='http:';
if (comparetext(copy(s,1,length(d)),d)=0) then goto skipend;
//.email
d:='mailto:';
if (comparetext(copy(s,1,length(d)),d)=0) then goto skipend;
for p:=1 to slen do if (s[p]='@') then goto skipend;
//.phone/VoIP
d:='callto:';
if (comparetext(copy(s,1,length(d)),d)=0) then goto skipend;
c:=0;
for p:=1 to slen do if (s[p]='+') or ((s[p]>='0') and (s[p]<='9')) then inc(c);
if (c=slen) then goto skipend;
//not found
d:='';
skipend:
//successful
result:=(d<>'');
except;end;
end;
//## showservice ##
function tmisc.showservice(s:string):boolean;//runs service: mailto:, http:, callto: etc
var
   d,n,v:string;
begin
try
//defaults
result:=false;
//get
v:=s;
if calcservice(s,n) then
   begin
   //adjust
   if (n='http:') then n:=''//retain service
   else if (n='mailto:') then findemail(s,v)//strip any service
   else if (n='callto:') then
      begin
      if (copy(v,1,1)='+') then findvoip(s,v) else findphone(s,v);//strip any service
      end;//end of if
   //run
   d:=n+v;
   run(d,'');
   end;//end of if
except;end;
end;
//## findemail ##
function tmisc.findemail(var s,d:string):boolean;
var
   v2,v,i,p,slen:integer;
begin
try
//defaults
result:=false;
d:='';
slen:=length(s);
//get
for p:=1 to slen do if (s[p]='@') then
   begin
   //downto start
   v:=1;
   for i:=p downto 1 do
      begin
      //handles
      //a)SPACE: "john jim@abc.com" => jim@abc.com
      //b)MAILTO: "mailto:jim@abc.com"=>jim@abc.com
      if (s[i]=#32) or (s[i]=':') then break;
      v:=i;
      end;//end of loop
   //to end
   v2:=slen;
   for i:=p to slen do
      begin
      if (s[i]=#32) then break;
      v2:=i;
      end;//end of loop
   //get
   d:=copy(s,v,v2-v+1);
   //quit
   break;
   end;//end of if
//successful
result:=(d<>'');
except;end;
end;
//## findweb ##
function tmisc.findweb(var s,d:string):boolean;
var
   v2,v,i,p,slen:integer;
begin
try
//defaults
result:=false;
d:='';
slen:=length(s);
//http
for p:=1 to slen do if ((s[p]='h') or (s[p]='H')) and (comparetext(copy(s,p,7),'http://')=0) then
   begin
   //to end
   v2:=slen;
   for i:=p to slen do
      begin
      if (s[i]=#32) then break;
      v2:=i;
      end;//end of loop
   //get
   d:=copy(s,p,v2-p+1);
   //quit
   break;
   end;//end of if
//successful
result:=(d<>'');
except;end;
end;
//## findphone ##
function tmisc.findphone(var s,d:string):boolean;
var
   zlast,z:string;
   ps,v2,v,i,p,zlastlen,zlen,slen:integer;
   c:char;
begin
try
//defaults
result:=false;
d:='';
z:='';
zlast:='';
slen:=length(s);
zlen:=0;
zlastlen:=0;
//http
for p:=1 to slen do
begin
//get
c:=s[p];
//decide
if (c>='0') and (c<='9') then
   begin
   z:=z+c;
   inc(zlen);
   end
else if (c=#32) or (c='-') or (c='+') or (c='#') or (c='.') then
   begin
   //skip over known phone characters while maintaining current number progress
   end
else if (zlen>=1) then//store longest phone number
   begin
   if (zlen>zlastlen) then
      begin
      zlastlen:=zlen;
      zlast:=z;
      end;//end of if
   zlen:=0;
   z:='';
   end;//end of if
end;//end of loop
//finalise
if (zlen>=1) then//store longest phone number
   begin
   if (zlen>zlastlen) then
      begin
      zlastlen:=zlen;
      zlast:=z;
      end;//end of if
   end;//end of if
//set
d:=zlast;
result:=(d<>'');
except;end;
end;
//## findVoIP ##
function tmisc.findVoIP(var s,d:string):boolean;
var
   tmp:string;
begin
try
//get - "skype" requires phone numbers to be preceeded with a "+", e.g. "+000"
if findphone(s,tmp) then d:='+'+tmp else d:='';
//successful
result:=(d<>'');
except;end;
end;
//## initprogramdata ##
procedure tmisc.initprogramdata(var programdata:string);//10JAN2008
var//Handles a) plain base64 encoded data as well as b) internal resource stream based items by name
   e:string;
begin
try
if (comparetext(copy(programdata,1,5),'res: ')=0) then fromres(copy(programdata,6,length(programdata)),programdata,e)
else programdata:=io.fromb64b(programdata);
except;end;
end;
//## snippetenhance ##
function tmisc.snippetenhance(x:string;var r:string;var rlimit:integer;rlimitonly:boolean):boolean;//03MAR2008
label
   skipend,redo;
var
   pos,ylen,len,lp,p:integer;
   tmp,y,z:string;
begin
try
//defaults
result:=false;
r:=x;
rlimit:=1;
//comment
if (copy(x,1,2)='//') then exit;
//#10 return codes only
general.remchar(r,#13);
//init
len:=length(r);
lp:=0;//off
if (len=0) then exit;
//rlimit - format is "1234=snippet..." - supports range of 1...9999
for p:=1 to frcmax(len,5) do if (r[p]='=') then
   begin
   rlimit:=frcmin(strint(copy(r,1,p-1)),1);
   r:=copy(r,p+1,len);
   len:=length(r);
   end;//end of if
if rlimitonly then goto skipend;
//get
p:=1;
redo:
if (lp=0) and (r[p]='[') then lp:=p
else if (lp<>0) and (r[p]=']') then
   begin
   //init
   y:='';
   z:=copy(r,lp+1,p-lp-1);
   general.swapchars(z,',',#10);
   general.remchar(z,#32);
   //get
   pos:=1;
   while general.nextline(pos,z,tmp) do y:=y+char(frcrange(strint(tmp),0,255));
   //set
   ylen:=length(y);
   r:=copy(r,1,lp-1)+y+copy(r,p+1,len);
   p:=lp-1+ylen;
   len:=length(r);
   lp:=0;
   end;//end of if
//inc
inc(p);
if (p<=len) then goto redo;
skipend:
//successful
result:=(r<>'');
except;end;
end;
//## snippetfound ##
function tmisc.snippetfound(snippets,data:string;var _snippetfound:string):boolean;//03MAR2008
begin
try;result:=snippetfoundex(snippets,data,_snippetfound,false);except;end;
end;
//## snippetfoundex ##
function tmisc.snippetfoundex(snippets,data:string;var _snippetfound:string;_enhancedsnippets:boolean):boolean;//03MAR2008
label//Enhanced Snippet format "XYZ=snippet text"
   skipone,redo,skipend;
var
   a:tstringlist;
   count,zlimit,zlen,len,p2,p,psize:integer;
   oz,z:string;
   z1:char;
begin
try
//defaults
result:=false;
a:=nil;
snippets:=lowercase(snippets);
data:=lowercase(data);
_snippetfound:='';
len:=length(data);
//check
if (len=0) then exit;
//init
a:=tstringlist.create;
a.text:=snippets;
//SCAN
for p:=0 to (a.count-1) do
begin
z:=a.strings[p];
//.comment
if (copy(z,1,2)='//') then goto skipone;
oz:=z;
zlimit:=1;
zlen:=0;
count:=0;
p2:=1;
//get
if general.textgood(z) and _enhancedsnippets then snippetenhance(oz,z,zlimit,false);//03MAR2008
zlen:=length(z);
psize:=len-zlen+1;//03MAR2008
if (zlen=0) or (psize<=0) then goto skipone;
//scan
z1:=z[1];
redo:
if (z1=data[p2]) and (z=copy(data,p2,zlen)) then
   begin
   //inc
   inc(count);
   //decide
   if (count>=zlimit) then
      begin
      _snippetfound:=oz;
      result:=true;
      goto skipend;
      end;//end of if
   //inc
   if (zlen>=2) then inc(p2,zlen-1);
   end;//end of if
//inc
inc(p2);
if (p2<=psize) then goto redo;
//next
skipone:
end;//end of loop
skipend:
except;end;
try;freeobj(@a);except;end;
end;
//## realtimehelpUpgrade ##
procedure tmisc.realtimehelpUpgrade(pasFiles:array of string;rthText:string;saveoutput:boolean);//upgrade application's realtime help
label
   redo,next,skipend;
const
   a1='[ORG]>';
   a2='[NEW]>';
   alen=6;
var
   a:tstringlist;
   findex,cc,i,slen,zlen,p,startp,endp:integer;
   s,f,e,tmp,z6,z,_eng,_oth:string;
   result,binary,ok:boolean;
   org:tdynamicnamelist;
   new:tdynamicstring;
   used:tdynamicboolean;
begin
try
//defaults
result:=false;
a:=nil;
org:=nil;
new:=nil;
used:=nil;
s:='';
slen:=0;
e:=gecUnexpectedError;
db.text:='Realtime Help Upgrade starting...';
//check
if (rthText='') then
   begin
   e:=gecEmpty;
   goto skipend;
   end;//end of if
//init
a:=tstringlist.create;
a.text:=rthText;
org:=tdynamicnamelist.create;
new:=tdynamicstring.create;
used:=tdynamicboolean.create;
//GET
_eng:='';
_oth:='';
p:=0;
if (p>=a.count) then goto skipend;
cc:=0;
//scan
repeat
z:=a.strings[p];
zlen:=length(z);
z6:=copy(z,1,alen);
ok:=false;
if (zlen>=alen) then
   begin
   //.eng
   if (comparetext(z6,a1)=0) then
      begin
      ok:=true;
      //prev
      if (_eng<>'') then
         begin
         i:=org.add(_eng);
         if (i>=0) then
            begin
            new.value[i]:='';
            used.value[i]:=false;
            end;//end of if
         end;//end of if
      //set
      _eng:=copy(z,alen+1,zlen);
      _oth:='';
      end
   //.oth
   else if (comparetext(z6,a2)=0) then
      begin
      ok:=true;
      //set
      _oth:=copy(z,alen+1,zlen);
      if (_eng<>'') then
         begin
         i:=org.add(_eng);
         if (i>=0) then
            begin
            new.value[i]:=_oth;
            used.value[i]:=false;
            end;//end of if
         end;//end of if
      //clear
      _eng:='';
      _oth:='';
      end;//end of if
   end;//end of if
//inc
inc(p);
until (p>=a.count);//end of loop
//SET
findex:=low(pasFiles)-1;
next:
inc(findex);
if (findex>=low(pasFiles)) and (findex<=high(pasFiles)) then f:=pasFiles[findex]
else
   begin
   result:=true;
   goto skipend;
   end;//end of if
if (f='') then goto next;
db.text:='Loading file: '+f;
application.processmessages;
general.shortbeep(2);
if not io.fromfile(f,z,e) then goto skipend;
zlen:=length(z);
if (zlen<13) then goto next;
p:=1;
startp:=0;
endp:=1;
//REPLACE
redo:
//stats
inc(cc);
if (cc>=10000) then
   begin
   db.text:='Scanning: '+general.thousands(p)+' of '+general.thousands(zlen);
   cc:=0;
   end;//end of if
//scan
if (startp=0) and (z[p]='(') and (comparetext(copy(z,p-12,14),'rthtranslate(''')=0) then
   begin
   startp:=p+2;//within string area
   endp:=startp;
   end
else if (startp<>0) and (z[p]=')') and (copy(z,p-1,2)=''')') then
   begin
   endp:=p-2;//within string area
   //find
   i:=org.findfast(0,copy(z,startp,endp-startp+1));
   if (i>=0) then
      begin
      used.value[i]:=true;
      //replace
      if (new.value[i]<>'') then
         begin
         db.text:='Found: '+copy(z,startp,endp-startp+1)+rcode+'Replace with: '+new.value[i];
         z:=copy(z,1,startp-1)+new.value[i]+copy(z,endp+1,zlen);
         zlen:=length(z);
         end;//end of if
      //inc
      p:=startp;
      end;//end of if
   //reset
   startp:=0;
   endp:=1;
   end;//end of if
//loop
if (p<zlen) then
   begin
   inc(p);
   goto redo;
   end
else
   begin
   //save
   if saveoutput then
      begin
      db.text:='Saving file: '+f;
      if not io.tofile(f,z,e) then goto skipend;
      application.processmessages;
      general.shortbeep(3);
      end;//end of if
   //next
   goto next;
   end;//end of if
//successful
result:=true;
skipend:
//stats
db.text:='Building stats...';
s:='';
slen:=0;
for p:=0 to (used.count-1) do if (not used.items[p]) and (new.value[p]<>'') then
   begin
   pushb(slen,s,
    a1+org.value[p]+rcode+
    a2+new.value[p]+rcode+
    rcode
    );
   end;//end of if
pushb(zlen,z,'');
db.text:='Finished';
except;end;
try
freeobj(@a);
freeobj(@org);
freeobj(@new);
freeobj(@used);
//error
if not result then showbasic('Error: '+translate(e));
if (s<>'') then
   begin
   clipboard.astext:=s;
   showbasic('Usage stats have been copied to clipboard');
   end;//end of if
showbasic('Done');
except;end;
end;
//## isfolder ##
function tmisc.isfolder(x:string):boolean;
begin
try;result:=(x<>'') and (x[length(x)]='\') or (x[length(x)]='/');except;end;
end;
//## supportcount ##
function tmisc.supportcount:integer;
begin
try;result:=10;except;end;
end;
//## supportinfo ##
function tmisc.supportinfo(x:integer;var _label,_foldername,_realtimehelp:string):boolean;//return information about support folders
begin
try
//defaults
_label:='';
_foldername:='';
_realtimehelp:='';
//get
case x of
0:begin
   _label:=ntranslate('animations');
   _foldername:=bvfAnimations;
   _realtimehelp:=rthtranslate('Support Folder (library). Storage/sharing animations');
   end;//end of begin
1:begin
   _label:=ntranslate('pictures');
   _foldername:=bvfPictures;
   _realtimehelp:=rthtranslate('Support Folder (library). Storage/sharing still images/pictures');
   end;//end of begin
2:begin
   _label:=ntranslate('cursors');
   _foldername:=bvfCursors;
   _realtimehelp:=rthtranslate('Support Folder (library). Storage/sharing icons and cursors');
   end;//end of begin
3:begin
   _label:=ntranslate('music');
   _foldername:=bvfMusic;
   _realtimehelp:=rthtranslate('Support Folder (library). Storage/sharing music (midi, wave, mp3)');
   end;//end of begin
4:begin
   _label:=ntranslate('documents');
   _foldername:=bvfDocuments;
   _realtimehelp:=rthtranslate('Support Folder (library). Storage/sharing text documents');
   end;//end of begin
5:begin
   _label:=ntranslate('frames');
   _foldername:=bvfFrames;
   _realtimehelp:=rthtranslate('Support Folder (library). Storage/sharing frame files');
   end;//end of begin
6:begin
   _label:=ntranslate('shades');
   _foldername:=bvfShades;
   _realtimehelp:=rthtranslate('Support Folder (library). Storage/sharing shade files');
   end;//end of begin
7:begin
   _label:=ntranslate('schemes');
   _foldername:=bvfSchemes;
   _realtimehelp:=rthtranslate('Support Folder (library). Storage/sharing Scheme files (predefined/user created)');
   end;//end of begin
8:begin
   _label:=translate('TextBrushes');
   _foldername:=bvfTextBrushs;
   _realtimehelp:=rthtranslate('Support Folder (library). Storage/sharing TextBrushs');
   end;//end of begin
9:begin
   _label:=ntranslate('miscellaneous');
   _foldername:=bvfMiscellaneous;
   _realtimehelp:=rthtranslate('Support Folder (library). Storage/sharing miscellaneous/general files');
   end;//end of begin
end;//end of case
//successful
result:=(_foldername<>'');
except;end;
end;
//## cansyncfolder ##
function tmisc.cansyncfolder(a,b:string):boolean;
begin
try
//defaults
result:=false;
//range
a:=asfolder(extractfilepath(a));
b:=asfolder(extractfilepath(b));
//check
if (a='') or (b='') or (a='/') or (b='/') then exit;
//get
if not directoryexists(a) then exit;
if not directoryexists(b) then exit;
//successful
result:=true;
except;end;
end;
//## syncfolder ##
function tmisc.syncfolder(a,b:string;var e:string):boolean;
var
   count,ecount:integer;
begin
try;result:=syncfolderex(a,b,count,ecount,e) and (ecount<=0);except;end;
end;
//## syncfolderex ##
function tmisc.syncfolderex(a,b:string;var count,ecount:integer;var e:string):boolean;
var
   al,bl:tstringlist;
   z1,z2:string;
begin
try
//defaults
result:=false;
e:=gecTaskFailed;
al:=nil;
bl:=nil;
count:=0;
ecount:=0;
//range
a:=asfolder(extractfilepath(a));
b:=asfolder(extractfilepath(b));
//check
if not cansyncfolder(a,b) then
   begin
   //no error for folders that don't exist
   result:=true;
   exit;
   end;//end of if
//init
al:=tstringlist.create;
bl:=tstringlist.create;
//get
al.text:=general.files(a+'*.*',false);
bl.text:=general.files(b+'*.*',false);
al.sort;
bl.sort;
//set
repeat
//.a -> b
if (al.count>=1) then
   begin
   z1:=a+al.strings[0];
   z2:=b+al.strings[0];
   if not fileexists(z2) then
      begin
      if general.copytoex(z1,z2,e) then inc(count) else inc(ecount);
      end;//end of if
   al.delete(0);
   end;//end of if
//.b -> a
if (bl.count>=1) then
   begin
   z1:=b+bl.strings[0];
   z2:=a+bl.strings[0];
   if not fileexists(z2) then
      begin
      if general.copytoex(z1,z2,e) then inc(count) else inc(ecount);
      end;//end of if
   bl.delete(0);
   end;//end of if
//error tolerance - stop trying after "50" fails
if (ecount>=50) then break;
until (al.count=0) and (bl.count=0);//end of loop
//successful
result:=(ecount=0);
except;end;
try
freeobj(@al);
freeobj(@bl);
except;end;
end;
//## retainformatext ##
function tmisc.retainformatext(_filename,_retainfilename:string;_retain:boolean):string;
var
   ext:string;
begin
try
//defaults
result:=_filename;
//get
if _retain then
   begin
   ext:=readfileext(_retainfilename,false);
   if (ext<>'') then
      begin
      //init
      ext:='.'+ext;
      //set
      result:=extractfilepath(_filename)+general.remlastext(extractfilename(_filename))+ext;
      end;//end of if
   end;//end of if
except;end;
end;
//## subfile ##
function tmisc.subfile(x:string;xlimit:integer):string;//automatically returns a new filename based on "x" if x's size exceeds "xlimit" bytes
var
   p:integer;
   ox,oext,tmp,f:string;
begin
try
//defaults
result:=x;
//init
xlimit:=frcmin(xlimit,0);
tmp:=extractfilename(x);
ox:=extractfilepath(x)+general.remlastext(tmp);
oext:=readfileext(tmp,false);
//DECIDE
for p:=0 to 100 do
begin
//get
if (p=0) then f:=x else f:=ox+'['+general.digpad(p,3)+'].'+oext;//c:\windows\temp\abc-x.html -> c:\windows\temp\abc-x[001..100].html
//set
if (general.filesize(f)<xlimit) then
   begin
   result:=f;
   break;
   end;//end of if
end;//end of loop
except;end;
end;
//## mapfile ##
function tmisc.mapfile(x:string):string;
begin
try;mapfileex(x,result);except;end;
end;
//## mapfileex ##
function tmisc.mapfileex(x:string;var z:string):boolean;//attempts to locate path/file (if "x" can't be found) 23SEP2007
label
   skipend;
var
   tmp,path,name:string;
   cd:char;
   _new:boolean;
begin
try
//defaults
result:=false;
z:=x;
path:='';
name:='';
_new:=false;
//check - does not have a "path" ie "c:" or "e:\....."
if (length(x)<2) or (x[2]<>':') then goto skipend;
//get
path:=asfolder(extractfilepath(x));
name:=extractfilename(x);
tmp:=general.udv(copy(getcurrentdir,1,1),'c');
cd:=tmp[1];
//FOLDER
if not directoryexists(path) then
   begin
   //same drive so ignore
   if (path[1]=cd) then goto skipend;
   //try new drive
   path[1]:=cd;
   if not directoryexists(path) then goto skipend;
   _new:=true;
   end;//end of if
//FILE
if (name<>'') then
   begin
   if not fileexists(path+name) then goto skipend
   //set new filename
   else z:=path+name;
   end;//end of if
//inc
if _new then general.croll(systemfileremaps,1);
//successful
result:=true;
skipend:
except;end;
end;
//## signalbar ##
function tmisc.signalbar(pert:extended):string;
const
   bar='1234567890';//10
var
   p,y:integer;
begin
try
//defaults
result:='|'+bar;//no signal
//get
if (pert<0) then pert:=0
else if (pert>100) then pert:=100;
y:=frcmax(frcrange(round(pert/10),0,10),length(bar));
//set
for p:=1 to length(bar) do if (p<=y) then result[p+1]:='+' else result[p+1]:=#32;
except;end;
end;
//## ucc ##
function tmisc.ucc(u:string):byte;//convert url to contry code index
var
   ui:tparseurl;
   p:integer;
   _domainext:string;
begin
try
//defaults
result:=0;//all
//get
general.pu('http://'+u,'',ui,[pusExcludeMark]);
u:=ui.h;
_domainext:='';
for p:=length(u) downto 1 do if (u[p]='.') then
   begin
   _domainext:=copy(u,p+1,length(u));
   break;
   end;//end of if
//set
result:=ecc(_domainext);
except;end;
end;
//## ecc ##
function tmisc.ecc(_domainext:string):byte;//convert domainext to contry code index
var
   p:integer;
begin
try
//defaults
result:=0;//all
//scan
if (_domainext<>'') then for p:=0 to high(countrycodes) do if (comparetext(countrycodes[p],_domainext)=0) then
   begin
   result:=p;
   break;
   end;//end of if
except;end;
end;
//## pushend ##
function tmisc.pushend(var xlen:integer;var x:string):boolean;
begin
try;result:=pushb(xlen,x,'');except;end;
end;
//## pushbol ##
function tmisc.pushbol(var xlen:integer;var x:string;y:boolean):boolean;
var
   a:char;
begin
try
//get
if y then a:=#1 else a:=#0;
//set
result:=pushb(xlen,x,a);
except;end;
end;
//## pushbyt ##
function tmisc.pushbyt(var xlen:integer;var x:string;y:byte):boolean;
begin
try;result:=pushb(xlen,x,char(y));except;end;
end;
//## pushint ##
function tmisc.pushint(var xlen:integer;var x:string;y:integer):boolean;
var
   a:tint4;
begin
try
//get
a.val:=y;
//set
result:=pushb(xlen,x,a.chars[0]+a.chars[1]+a.chars[2]+a.chars[3]);
except;end;
end;
//## pushcur ##
function tmisc.pushcur(var xlen:integer;var x:string;y:currency):boolean;
var
   a:tcur8;
begin
try
//get
a.val:=y;
//set
result:=pushb(xlen,x,a.chars[0]+a.chars[1]+a.chars[2]+a.chars[3]+a.chars[4]+a.chars[5]+a.chars[6]+a.chars[7]);
except;end;
end;
//## pushstr ##
function tmisc.pushstr(var xlen:integer;var x:string;y:string):boolean;
var
   ylen:integer;
begin
try
//get
ylen:=length(y);
//set
result:=pushint(xlen,x,ylen) and ((ylen=0) or pushb(xlen,x,y));
except;end;
end;
//## pullbol ##
function tmisc.pullbol(var pos:integer;xlen:integer;var x:string;var y:boolean):boolean;
begin
try
//defaults
result:=false;
//set
if (pos>=1) and (pos<=xlen) then
   begin
   y:=(x[pos]<>#0);
   inc(pos,1);
   result:=true;
   end;//end of if
except;end;
end;
//## pullbyt ##
function tmisc.pullbyt(var pos:integer;xlen:integer;var x:string;var y:byte):boolean;
begin
try
//defaults
result:=false;
//set
if (pos>=1) and (pos<=xlen) then
   begin
   y:=byte(x[pos]);
   inc(pos,1);
   result:=true;
   end;//end of if
except;end;
end;
//## pullint ##
function tmisc.pullint(var pos:integer;xlen:integer;var x:string;var y:integer):boolean;
var
   a:tint4;
begin
try
//defaults
result:=false;
//set
if (pos>=1) and (pos<=(xlen-3)) then
   begin
   a.chars[0]:=x[pos+0];
   a.chars[1]:=x[pos+1];
   a.chars[2]:=x[pos+2];
   a.chars[3]:=x[pos+3];
   y:=a.val;
   inc(pos,4);
   result:=true;
   end;//end of if
except;end;
end;
//## pullcur ##
function tmisc.pullcur(var pos:integer;xlen:integer;var x:string;var y:currency):boolean;
var
   a:tcur8;
begin
try
//defaults
result:=false;
//set
if (pos>=1) and (pos<=(xlen-7)) then
   begin
   a.chars[0]:=x[pos+0];
   a.chars[1]:=x[pos+1];
   a.chars[2]:=x[pos+2];
   a.chars[3]:=x[pos+3];
   a.chars[4]:=x[pos+4];
   a.chars[5]:=x[pos+5];
   a.chars[6]:=x[pos+6];
   a.chars[7]:=x[pos+7];
   y:=a.val;
   inc(pos,8);
   result:=true;
   end;//end of if
except;end;
end;
//## pullstr ##
function tmisc.pullstr(var pos:integer;xlen:integer;var x:string;var y:string):boolean;
var
   ylen:integer;
begin
try
//defaults
result:=false;
//set
if pullint(pos,xlen,x,ylen) then
   begin
   if (ylen=0) then
      begin
      y:='';
      result:=true;
      end
   else if ((pos+ylen-1)<=xlen) then
      begin
      y:=copy(x,pos,ylen);
      inc(pos,ylen);
      result:=true;
      end;//end of if
   end;//end of if
except;end;
end;
//## isnumber ##
function tmisc.isnumber(x:string):boolean;
var
   p:integer;
begin
try
//defaults
result:=true;
//scan
for p:=1 to length(x) do
case byte(x[p]) of
45,46,48..57:;
else
   begin
   result:=false;
   break;
   end;//end of begin
end;//end of case
except;end;
end;
//## isint ##
function tmisc.isint(x:string):boolean;
begin
try;result:=(inttostr(strint(x))=x);except;end;
end;
//## iscur ##
function tmisc.iscur(x:string):boolean;
begin
try;result:=(floattostrex2(strtofloatex(x))=x);except;end;
end;
//## ints ##
function tmisc.ints(x:array of integer):integer;//add all numbers together
var
   p:integer;
begin
try
//defaults
result:=0;
//get
for p:=low(x) to high(x) do general.iroll(result,x[p]);
except;end;
end;
//## curs ##
function tmisc.curs(x:array of currency):currency;//add all numbers together
var
   p:integer;
begin
try
//defaults
result:=0;
//get
for p:=low(x) to high(x) do general.croll(result,x[p]);
except;end;
end;
//## initcrc32 ##
procedure tmisc.initcrc32;
const//Note: 0xedb88320L="-306674912"
   seed=$edb88320;
var
   c,k,n:integer;
begin
try
//check
if iinitcrc32 then exit;
//process
//.get
for n:=0 to 255 do
begin
c:=n;
for k:=0 to 7 do if boolean(c and 1) then c:=seed xor (c shr 1) else c:=c shr 1;
icrc32[n]:=c;
end;//end of loop
except;end;
try;iinitcrc32:=true;except;end;
end;
//## crc32inc ##
procedure tmisc.crc32inc(var _crc32:integer;x:char);//31-DEC-2006
var
   c:integer;
begin
try
c:=_crc32 xor $ffffffff;
c:=icrc32[(c xor byte(x)) and $ff] xor (c shr 8);
_crc32:=c xor $ffffffff;
except;end;
end;
//## crc32 ##
procedure tmisc.crc32(var _crc32:integer;var x:string;s,f:integer);//31-DEC-2006, updated 27-MAR-2007
var//Industry standard CRC-32 (PASSED, Sunday 31-DEC-2006)
   c,p,xlen:integer;
begin
try
//init
if not iinitcrc32 then initcrc32;
//defaults
_crc32:=0;//27-MAR-2007
xlen:=length(x);
//check
if (xlen=0) then exit;
//range
s:=frcrange(s,1,xlen);
f:=frcrange(f,s,xlen);
//process
//.get
for p:=s to f do crc32inc(_crc32,x[p]);
except;end;
end;
//## crc32b ##
function tmisc.crc32b(x:string):integer;
begin
try;crc32(result,x,1,length(x));except;end;
end;
//## timeup ##
function tmisc.timeup(var _timeindex:currency;_delay:currency):boolean;
var
   tmp:currency;
begin
try
//defaults
result:=false;
//range
if (_delay<0) then _delay:=0;
//get
tmp:=ms64;
if (tmp>=_timeindex) then
   begin
   //set
   _timeindex:=tmp+_delay;
   result:=true;
   end;//end of if
except;end;
end;
//## striphtml ##
function tmisc.striphtml(x:string):string;
var
   c,p,len:integer;
begin
try
//defaults
result:=x;
len:=0;
c:=0;
//scan
for p:=1 to length(x) do
begin
//.start
if (x[p]='<') then inc(c);
//.set
if (c=0) then
   begin
   inc(len);
   result[len]:=x[p];
   end;//end of if
//.finish
if (x[p]='>') then dec(c);
end;//end of loop
//trim
delete(result,len+1,length(x));
except;end;
end;
//## bu ##
function tmisc.bu(x:string):string;//breakable url
var//Important Note: "http://abc.com /xxx /yyy.asp" won't wrap in IE5,
   //                must be "http://abc.com/ xxx/ yyy.asp"
   len,s,p:integer;
begin
try
//defaults
result:=x+x;
len:=0;
s:=1;
//start - skip "//" or "\\"
for p:=1 to frcmax(length(x),8) do if (copy(x,p,2)='//') or (copy(x,p,2)='\\') then
   begin
   s:=p+2;
   break;
   end;//end of if
//get
len:=s-1;
for p:=s to length(x) do
begin
//.inc
inc(len);
//.set
result[len]:=x[p];
if (x[p]='/') or (x[p]='?') then
   begin
   inc(len);
   result[len]:=#32;
   end;//end of if
end;//end of if
//trim
delete(result,len+1,length(result));
except;end;
end;
//## at ##
function tmisc.at(x:string):taddresstype;//address type (unknown,local,email,internet)
var
   xlen,p:integer;
begin
try
//defaults
result:=atUnknown;
xlen:=length(x);
//process
if (copy(x,1,1)='*') then exit
else if (xlen>=2) then
   begin
   //.local
   if (x[2]=':') or ((x[1]='/') and (x[2]='/')) then result:=atLocal
   else
      begin
      //.email
      for p:=1 to xlen do if (x[p]='@') then
         begin
         result:=atEmail;
         break;
         end;//end of if
      //.internet
      if (result=atUnknown) then result:=atUrl;
      end;//end of if
   end;//end of if
except;end;
end;
//## navtype ##
function tmisc.navtype(_image:string):string;
var
   _action,_class:string;
begin
try;navfin(_image,result,_action,_class);except;end;
end;
//## navaction ##
function tmisc.navaction(_image:string):string;
var
   _type,_class:string;
begin
try;navfin(_image,_type,result,_class);except;end;
end;
//## navfin ##
procedure tmisc.navfin(_image:string;var _type,_action,_class:string);//tnav: from image name
var
   len,c,p,p1,p2:integer;
begin
try
//defaults
_type:=ntInternal;
_action:=naHome;
_class:='';
len:=length(_image);
p1:=0;
p2:=len;
//process
//.get
c:=0;
for p:=1 to len do if (_image[p]=nsSep) then
   begin
   if (c=0) then p1:=p
   else if (c=1) then
      begin
      p2:=p;
      break;
      end;//end of if
   inc(c);
   end;//end of if
//.set
_type:=copy(_image,1,p1);//*- or f- or p-
_action:=copy(_image,1,p2);//*-home or f-url or p-folder
_class:=copy(_image,p2+1,len);//gif, exe, jpg or <nil>
except;end;
end;
//## navbaa ##
function tmisc.navbaa(_image,_name,_host,_path,_file:string;_navs:tdynamicstring):string;//tnav: build action address
var
   ilen,p:integer;
   _type,_action,_class:string;
begin
try
//defaults
result:=naHome;
//process
//.get
navfin(_image,_type,_action,_class);
//.decide
if (_type=ntInternal) then result:=_action
else if (_type=ntFull) then result:=_name
else if (_type=ntPartial) then
   begin
   if (_action=naHost) then result:=_host
   else if (_action=naNav) then result:=_host+_name
   else if (_action=naUp) then
      begin
      if (_navs<>nil) then
         begin
         if (_navs.count>=2) then result:=_host+_navs.value[_navs.count-2]
         else if (_navs.count=1) then result:=_host
         else result:=naHome;
         end
      else result:=naHome;
      end
   else if (_action=naFolder) then result:=_host+_path+_name+'/'
   else if (_action=naFile) then result:=_host+_path+_name;
   end;//end of if
except;end;
end;
//## extracttext ##
function tmisc.extracttext(s:tstringlist;var output:string;findtext:string;var olinecount:integer):boolean;
var
   i,p,len:integer;
   tmp:string;
begin
try
//defaults
result:=false;
olinecount:=0;
output:='';
len:=0;
//check
if (findtext='') or (s=nil) or (s.count=0) then exit;
//process
//.scan
for p:=0 to (s.count-1) do
begin
tmp:=s.strings[p];
i:=1;
if (tmp<>'') and general.findtext(i,tmp,findtext) then
   begin
   pushb(len,output,tmp+rcode);
   inc(olinecount);
   end;//end of if
end;//end of loop
//successful
result:=(olinecount>=1);
except;end;
try
//.finalise
pushb(len,output,'');
except;end;
end;
//## writeUNIX32 ##
function tmisc.writeUNIX32(x:integer):string;//write unix 32bit number
var//Format [256^2][256^1][256^0][256^3] = [2][1][0][3]
   a:tint4;
begin
try;a.val:=x;result:=a.chars[3]+a.chars[2]+a.chars[1]+a.chars[0];except;end;
end;
//## readUNIX32 ##
function tmisc.readUNIX32(x:string):integer;//read unix 32bit number
var
   a:tint4;
begin
try
//defaults
result:=0;
//get
if (length(x)>=4) then
   begin
   a.chars[0]:=x[4];
   a.chars[1]:=x[3];
   a.chars[2]:=x[2];
   a.chars[3]:=x[1];
   result:=a.val;
   end;//end of if
except;end;
end;
//## writeUNIX16 ##
function tmisc.writeUNIX16(x:word):string;//write unix 16bit number
var
   a:twrd2;
begin
try
a.val:=x;result:=a.chars[1]+a.chars[0];except;end;
end;
//## readUNIX16 ##
function tmisc.readUNIX16(x:string):word;//read unix 16bit number
var
   a:twrd2;
begin
try
//defaults
result:=0;
//get
if (length(x)>=2) then
   begin
   a.chars[0]:=x[2];
   a.chars[1]:=x[1];
   result:=a.val;
   end;//end of if
except;end;
end;
//## dnsRCODENAME ##
function tmisc.dnsRCODENAME(x:byte):string;
begin
try
case x of
rcodeOK:result:='OK';
rcodeFormatError:result:='Format Error';
rcodeServerFailure:result:='Server Failure';
rcodeNameError:result:='Name Error';
rcodeNotSupported:result:='Not Supported';
rcodeRefused:result:='Refused';
else
   result:='-';
end;//end of case
except;end;
end;
//## dnsQTYPENAME ##
function tmisc.dnsQTYPENAME(x:byte):string;
begin
try
case x of
1:result:='A';
2:result:='NS';
3:result:='MD';
4:result:='MF';
5:result:='CNAME';
6:result:='SOA';
7:result:='MB';
8:result:='MG';
9:result:='MR';
10:result:='NULL';
11:result:='WKS';
12:result:='PTR';
13:result:='HINFO';
14:result:='MINFO';
15:result:='MX';
16:result:='TXT';
17:result:='RP';
18:result:='AFSDB';
19:result:='X25';
20:result:='ISDN';
21:result:='RT';
22:result:='NSAP';
23:result:='NSAP_PTR';
24:result:='SIG';
25:result:='KEY';
26:result:='PX';
27:result:='GPOS';
28:result:='AAAA';
29:result:='LOC';
30:result:='NXT';
31:result:='EID';
32:result:='NIMLOC';
33:result:='SRV';
34:result:='ATMA';
35:result:='NAPTR';
36:result:='KX';
37:result:='CERT';
38:result:='A6';
39:result:='DNAME';
40:result:='SINK';
41:result:='OPT';
43:result:='DS';
249:result:='TKEY';
250:result:='TSIG';
251:result:='IXFR';
252:result:='AXFR';
253:result:='MAILB';
254:result:='MAILA';
255:result:='ANY';
else
   result:='-';
end;//end of case
except;end;
end;
//## dnsinit ##
procedure tmisc.dnsinit(var x:tdns);
begin
try
with x do
begin
//header
id:=0;
qr:=false;
opcode:=0;
aa:=false;
tc:=false;
rd:=false;
ra:=false;
z:=0;
rcode:=0;
qdcount:=0;
ancount:=0;
nscount:=0;
arcount:=0;
//question
qdata:='';
qtype:=0;
qclass:=0;
//internal
andata:='';
nsdata:='';
ardata:='';
maxlen:=512;//UDP
end;//end of case
except;end;
end;
//## dnsshow ##
procedure tmisc.dnsshow(var x:tdns;comment:string);
const
   eol=rcode;
var
   tmp:string;
begin
try
//get
with x do
begin
tmp:=
general.insstr(comment+eol,comment<>'')+
'============================'+eol+
'-- HEADER --'+eol+
'ID: '+inttostr(id)+eol+
'QR: '+bn(qr)+eol+
'OPCODE: '+inttostr(opcode)+eol+
'AA: '+bn(aa)+eol+
'TC: '+bn(tc)+eol+
'RD: '+bn(rd)+eol+
'RA: '+bn(ra)+eol+
'Z: '+inttostr(z)+eol+
'RCODE: '+inttostr(rcode)+eol+
'QDCOUNT: '+inttostr(qdcount)+eol+
'ANCOUNT: '+inttostr(ancount)+eol+
'NSCOUNT: '+inttostr(nscount)+eol+
'ARCOUNT: '+inttostr(arcount)+eol+
'-- QUESTION --'+eol+
'QDATA: '+qdata+'<<'+eol+
'QTYPE: '+inttostr(qtype)+eol+
'QCLASS: '+inttostr(qclass)+eol+
'-- ANSWER --'+eol+

'============================'+eol;
end;//end of case
//set
showbasic(tmp);
except;end;
end;
//## dnsshowb ##
procedure tmisc.dnsshowb(var x,y:tdns;xl,yl:string);
const
   eol=rcode;
   sep=' | ';
var
   tmp:string;
begin
try
//get
tmp:=
xl+' | '+yl+eol+
'========= X -> Y ==================='+eol+
'-- HEADER --'+eol+
'ID: '+inttostr(x.id)                +sep+inttostr(y.id)+eol+
'QR: '+bn(x.qr)                      +sep+bn(y.qr)+eol+
'OPCODE: '+inttostr(x.opcode)        +sep+inttostr(y.opcode)+eol+
'AA: '+bn(x.aa)                      +sep+bn(y.aa)+eol+
'TC: '+bn(x.tc)                      +sep+bn(y.tc)+eol+
'RD: '+bn(x.rd)                      +sep+bn(y.rd)+eol+
'RA: '+bn(x.ra)                      +sep+bn(y.ra)+eol+
'Z: '+inttostr(x.z)                  +sep+inttostr(y.z)+eol+
'RCODE: '+inttostr(x.rcode)          +sep+inttostr(y.rcode)+eol+
'QDCOUNT: '+inttostr(x.qdcount)      +sep+inttostr(y.qdcount)+eol+
'ANCOUNT: '+inttostr(x.ancount)      +sep+inttostr(y.ancount)+eol+
'NSCOUNT: '+inttostr(x.nscount)      +sep+inttostr(y.nscount)+eol+
'ARCOUNT: '+inttostr(x.arcount)      +sep+inttostr(y.arcount)+eol+
'-- QUESTION --'+eol+
'QDATA: '+x.qdata                    +sep+y.qdata+'<<'+eol+
'QTYPE: '+inttostr(x.qtype)          +sep+inttostr(y.qtype)+eol+
'QCLASS: '+inttostr(x.qclass)        +sep+inttostr(y.qclass)+eol+
'-- ANSWER --'+eol+
'============================'+eol;
//set
showbasic(tmp);
except;end;
end;
//## dnsreadQ ##
function tmisc.dnsreadQ(var x:tdns;var y:string;ylen:integer;var p:integer):boolean;
label//Note: stores first question, ignores all other questsions
   rescan,redo;
var
   qdcount,len:integer;
   ignore,usedot:boolean;
begin
try
//defaults
result:=false;
ignore:=false;
x.qdata:='';
x.qtype:=0;
x.qclass:=0;
qdcount:=0;
//check
rescan:
usedot:=false;
if (x.qdcount=0) or (p<1) or (p>ylen) then exit;
//process
//.get
redo:
len:=byte(y[p]);
inc(p);
if (len>=1) then
   begin
   //.data (domain)
   if (not ignore) then x.qdata:=x.qdata+general.insstr('.',usedot)+copy(y,p,len);
   usedot:=true;
   inc(p,len);
   if (p<=ylen) then goto redo;
   end
else
   begin
   //.type
   if (not ignore) and (p<ylen) then x.qtype:=readunix16(copy(y,p,2));
   inc(p,2);
   //.class
   if (not ignore) and (p<ylen) then x.qclass:=readunix16(copy(y,p,2));
   inc(p,2);
   //successful
   result:=((p-1)<=ylen);
   end;//end of if
//.read to end of question section
inc(qdcount);
if result and (qdcount<x.qdcount) then
   begin
   ignore:=true;
   goto rescan;
   end;//end of if
except;end;
end;
//## dnsread ##
function tmisc.dnsread(var y:tdns;x:string):boolean;
label
   skipend;
var
   a:twrd2;
   b:tbit8;
   i,len:word;
   nc,count,p,xlen:integer;
   ok:boolean;
begin
try
//defaults
result:=false;
//init
xlen:=length(x);
dnsinit(y);
//process
if (xlen>=12) then
   begin
   //HEADER
   //.block1 (1-2)
   y.id:=readunix16(copy(x,1,2));
   //.block2a (3*-4)
   b.val:=byte(x[3]);
   y.qr:=(7 in b.bits);
   y.opcode:=
      byte(6 in b.bits)+
    2*byte(5 in b.bits)+
    4*byte(4 in b.bits)+
    8*byte(3 in b.bits);
   y.aa:=(2 in b.bits);
   y.tc:=(1 in b.bits);
   y.rd:=(0 in b.bits);
   //.blockb (3-4*)
   b.val:=byte(x[4]);
   y.ra:=(7 in b.bits);
   y.z:=
      byte(6 in b.bits)+
    2*byte(5 in b.bits)+
    4*byte(4 in b.bits);
   y.rcode:=
      byte(3 in b.bits)+
    2*byte(2 in b.bits)+
    4*byte(1 in b.bits)+
    8*byte(0 in b.bits);
   //.counters
   y.qdcount:=readunix16(copy(x,5,2));
   y.ancount:=readunix16(copy(x,7,2));
   y.nscount:=readunix16(copy(x,9,2));
   y.arcount:=readunix16(copy(x,11,2));
   //QUESTION
   p:=13;
   if not dnsreadQ(y,x,xlen,p) then goto skipend;
   //successful
   result:=true;
   end;//end of if
skipend:
except;end;
end;
//## dnswritedomain ##
function tmisc.dnswritedomain(x:string):string;
begin
try;result:=dnswritedomainb(x,true);except;end;
end;
//## dnswritedomainb ##
function tmisc.dnswritedomainb(x:string;eod:boolean):string;
var//EOD: end of domain
   xlen,len,lp,o,p:integer;
begin//[len1][data1]...[lenN][dataN][#0 - terminator]
try
//defaults
result:='';
xlen:=length(x);
lp:=1;
//zero-len
if (xlen=0) and eod then
   begin
   result:=#0;
   exit;
   end;//end of if
//process
for p:=1 to xlen do if (x[p]='.') or (p=xlen) then
   begin
   //.get
   if (x[p]='.') then o:=0 else o:=1;
   len:=frcmax(p-lp+o,63);
   //.set
   if (len>=1) then result:=result+char(len)+copy(x,lp,len);
   //..terminator
   if (p=xlen) and eod then result:=result+#0;
   //.inc
   lp:=p+1;
   end;//end of if
except;end;
end;
//## dnswritestr ##
function tmisc.dnswritestr(x:string):string;
var
   len:integer;
begin//[len][data] upto 256 bytes (including 1 byte length)
try
//get
len:=frcmax(length(x),255);
//set
result:=char(len)+copy(x,1,len);
except;end;
end;
//## dnswriteRR ##
function tmisc.dnswriteRR(dn:string;_type,_class:word;_ttl,rdata:string):string;//write resource record
var
   len,c,t:twrd2;
   ttl:tint4;
begin//dn=domain name
try
//defaults
result:='';
t.val:=_type;
c.val:=_class;
len.val:=frcrange(length(rdata),0,maxword);
//process
result:=
 dnswritedomain(dn)+//domain
 t.chars[1]+t.chars[0]+//type
 c.chars[1]+c.chars[0]+//class
 _ttl+//ttl
 len.chars[1]+len.chars[0]+//len of RDATA
 copy(rdata,1,len.val);
except;end;
end;
//## dnswrite ##
function tmisc.dnswrite(var y:tdns;var x:string):boolean;
label
   redo;
var
   a,a2:twrd2;
   c,b:tbit8;
   p:integer;
   tcOK,once:boolean;
begin
try
//defaults
result:=false;
once:=true;
tcOK:=false;
//init
redo:
//process
//HEADER (12 bytes)
x:=writeunix16(y.id)+#0#0;
//.block2a (3*-4)
b.val:=0;
if y.qr then include(b.bits,7);
c.val:=y.opcode;
if (0 in c.bits) then include(b.bits,6);
if (1 in c.bits) then include(b.bits,5);
if (2 in c.bits) then include(b.bits,4);
if (3 in c.bits) then include(b.bits,3);
if y.aa then include(b.bits,2);
if (y.tc or tcOK) then include(b.bits,1);
if y.rd then include(b.bits,0);
x[3]:=b.c;
//.blockb (3-4*)
b.val:=0;
if y.ra then include(b.bits,7);
c.val:=y.rcode;
if (0 in c.bits) then include(b.bits,3);
if (1 in c.bits) then include(b.bits,2);
if (2 in c.bits) then include(b.bits,1);
if (3 in c.bits) then include(b.bits,0);
x[4]:=b.c;
//.counters
x:=x+
writeunix16(y.qdcount)+
writeunix16(y.ancount)+
writeunix16(y.nscount)+
writeunix16(y.arcount);
//QUESTION
if (y.qdcount>=1) then
   begin
   a.val:=y.qtype;
   a2.val:=y.qclass;
   x:=x+
    dnswritedomain(y.qdata)+//qdata (single domain)
    a.chars[1] + a.chars[0]+//qtype
    a2.chars[1]+a2.chars[0];//qclass
   end;//end of if
//RR's
if (y.ancount>=1) then x:=x+y.andata;
if (y.nscount>=1) then x:=x+y.nsdata;
if (y.arcount>=1) then x:=x+y.ardata;
//.trim
if (length(x)>y.maxlen) then
   begin
   if once then//repeat message construction, but this time "TC=TRUE", message has been trimed.
      begin
      once:=false;
      tcOK:=true;
      goto redo;
      end
   else setlength(x,y.maxlen);
   end;//end of if
//successful
result:=true;
except;end;
end;
//## dt ##
function tmisc.dt(x:string):string;//decode text - shows error and halts with NULL result
begin
result:=ecap(x,false);
end;
//## respack ##
function tmisc.respack(name,sfile,dfile:string;var e:string):boolean;
label
   skipend;
var
   tmp:string;
begin
try
//defaults
result:=false;
e:=gecOutOfMemory;
//process
//.get
if not io.fromfile(sfile,tmp,e) then goto skipend;
//.convert
if not tores(name,tmp,tmp,e) then goto skipend;
//.set
if not io.tofile(dfile,tmp,e) then goto skipend;
//successful
result:=true;
skipend:
except;end;
end;
//## tores ##
function tmisc.tores(name,value:string;var output,e:string):boolean;
var
   a:tstreammem;
   b:tresdata;
begin
try
//defaults
result:=false;
e:=gecOutOfMemory;
output:='';
a:=nil;
b:=nil;
//setup
b:=tresdata.create(@value);
//process
//.get
a:=tstreammem.create(@output);
a.writecomponentres(name,b);
//successful
result:=true;
except;end;
try;freeobj(@a);freeobj(@b);except;end;
end;
//## fromres ##
function tmisc.fromres(name:string;var value,e:string):boolean;
var
   a:tcustommemorystream;
   b:tresdata;
begin
try
//defaults
result:=false;
e:=gecOutOfMemory;
a:=nil;
b:=nil;
value:='';
//process
//.init
b:=tresdata.create(@value);
//.get
e:=gecNotFound;
a:=tresourcestream.create(hinstance,name,rt_rcdata);
a.readcomponent(b);
//successful
result:=true;
except;end;
try;freeobj(@a);freeobj(@b);except;end;
end;
//## resunpack ##
function tmisc.resunpack(name,filename:string;var e:string):boolean;
label
   skipend;
var
   tmp:string;
begin
try
//defaults
result:=false;
e:=gecOutOfMemory;
//process
//.get
if not fromres(name,tmp,e) then
   begin
   e:=gecNotFound;
   goto skipend;
   end;//end of if
//.set
if not io.tofile(filename,tmp,e) then goto skipend;
//successful
result:=true;
skipend:
except;end;
end;
//## resread ##
function tmisc.resread(name,mask:string;_nv:tnamevalue;var e:string):boolean;
label
   skipend;
var
   a:tnamevalue;
   tmp:string;
begin
try
//defaults
result:=false;
e:=gecNotFound;
a:=nil;
//check
if (_nv=nil) or (name='') then
   begin
   e:=gecUnexpectedError;
   exit;
   end;//end of if
//find
if not misc.fromres(name,tmp,e) then goto skipend;
//get
a:=tnamevalue.create;
if not io.fromEAT(a,tmp,e) then goto skipend;
//mask - also "unpacks" compressed EAT records
_nv.copyfrom(a,mask);
//successful
result:=true;
skipend:
except;end;
try;freeobj(@a);except;end;
end;
//## rd ##
function tmisc.rd(var x:string;k:string):boolean;//rotate data
var//k defines how far to move before performing a single right byte swap.
   //Note: k is not allowed to contain #0, since this WILL corrupt date
   kitems:array[1..100] of byte;
   k2,k3,k4,c,kcount,xlen,pk,p:integer;
   tmp:char;
begin
try
//defaults
result:=false;
xlen:=length(x);
//range
if (length(k)<=0) then k:=k+#1#7#3;//move 1, 7 and 3
//process
//.fill
kcount:=frcrange(length(k),1,high(kitems));
for p:=1 to kcount do kitems[p]:=frcmin(byte(k[p]),1);
k2:=frcrange(kcount div 2,1,kcount);//middle
k3:=frcrange(kcount-2,1,kcount);//from end by 2
k4:=frcrange(k2-3,1,kcount);//left of middle by 3
//.get
pk:=1;
p:=0;
c:=1;
repeat
//.inc + move
inc(p,1+kitems[pk]);
//.swap
if (p<xlen) then
   begin
   tmp:=x[p];
   x[p]:=x[p+1];
   x[p+1]:=tmp;
   end;//end of if
//.inc k
inc(pk);
if (pk>kcount) then
   begin
   inc(c);
   case c of
   0,1:pk:=1;
   2:pk:=k2;
   3:pk:=k3;
   4:begin
     pk:=k4;
     c:=0;
     end;//end of begin
   else pk:=1;
   end;//end of case
   end;//end of if
until (p>=xlen);
//successful
result:=true;
except;end;
end;
//## ro ##
function tmisc.ro(var x,e:string):boolean;//reverse order
var
   tmp:string;
   xlen,p:integer;
begin
try
//defaults
result:=false;
e:=gecOutOfMemory;
//fill
xlen:=length(x);
tmp:=x;
//check
if (xlen<=0) then
   begin
   result:=true;
   exit;
   end;//end of if
//process
//.set
for p:=1 to xlen do x[p]:=tmp[xlen-p+1];
//successful
result:=true;
except;end;
end;
//## ll ##
function tmisc.ll(var x:string;linesep:string;linelength:integer;var e:string):boolean;//line length
var
   len,p:integer;
   tmp,z:string;
begin
try
//defaults
result:=false;
e:=gecOutOfMemory;
if (linesep='') then linesep:=rcode;
//range
linelength:=frcmin(linelength,1);
//process
//.get - remove return codes
tmp:='';
len:=0;
p:=1;
while general.nextline(p,x,z) do pushb(len,tmp,z);
pushb(len,tmp,'');
//.set
x:='';
len:=0;
while true do
if (length(tmp)>=1) then
   begin
   pushb(len,x,copy(tmp,1,linelength)+linesep);
   delete(tmp,1,linelength);
   end
else break;
//.finish
if (tmp<>'') then pushb(len,x,tmp);
//.finalise
pushb(len,x,'');
//successful
result:=true;
except;end;
end;
//## iplist ##
function tmisc.iplist(x,sep:string):string;
var
   i,p,len:integer;
   v:string;
begin
try
//defaults
result:='';
if (sep='') then sep:='; ';
//process
//.get
general.swapchars(x,';',#10);
general.swapchars(x,',',#10);
general.swapstrs(x,#13,'');
general.swapstrs(x,#32,'');
//.filter
len:=0;
p:=1;
while general.nextline(p,x,v) do if (v<>'') then
   begin
   //.get
   for i:=1 to length(v) do if (v[i]='=') then
      begin
      v:=copy(v,1,i-1);
      break;
      end;//end of if
   //.set
   if general.textgood(v) then pushb(len,result,v+sep);
   end;//end of if
//..finalise
pushb(len,result,'');
except;end;
end;
//## readIP ##
function tmisc.readIP(var header:string;sourceip:integer):integer;
var
   z:string;
begin
try
//defaults
result:=sourceip;
//GET
//Note: Use supplied "proxy-ip" address instead of "_ip". Valid if "IP2<>0.0.0.0"
//      and ["IP1=127.X.X.X" or "IP1=10.X.X.X"](local proxy only)
if misc.ipprivate(sourceip) and misc.headerfind(header,'proxy-sourceip: ',z) then
   begin
   sourceip:=_intip(z);
   if (sourceip<>0) then result:=sourceip;
   end;//end of if
except;end;
end;
//## headeraddb ##
procedure tmisc.headeraddb(var h:string;n,v,rc:string);
begin
try;headeraddex(h,n,v,rc,false);except;end;
end;
//## headeraddex ##
procedure tmisc.headeraddex(var h:string;n,v,rc:string;_delete:boolean);
var
   tmp:string;
   nlen,len,_pos,_start,_length:integer;
   found:boolean;
begin
try
//defaults
nlen:=length(n);
len:=0;
tmp:='';
found:=false;
//process
//.range
//..return code
if (rc<>#10) and (rc<>rcode) then rc:=rcode;
//..name - single line
_pos:=1;
general.nextline(_pos,n,tmp);n:=tmp;
//..value - single line
_pos:=1;
general.nextline(_pos,v,tmp);v:=tmp;
//.set
_pos:=1;
while general.readline(_pos,_start,_length,h) do if (_length>=1) then
   begin
   if (not found) and (_length>=nlen) and (0=comparetext(n,copy(h,_start,nlen))) then
      begin
      if (not _delete) then pushb(len,tmp,n+v+rc);
      found:=true;
      end
   else pushb(len,tmp,copy(h,_start,_length)+rc);
   end;//end of if
//.add - not found
if (not _delete) and (not found) then pushb(len,tmp,n+v+rc);
//.finish
pushb(len,tmp,rc);
//.finalise
pushb(len,tmp,'');
//.return result
h:=tmp;
except;end;
end;
//## headeradd ##
procedure tmisc.headeradd(var h:string;n,v:string);
begin
try;headeraddb(h,n,v,rcode);except;end;
end;
//## headerdel ##
procedure tmisc.headerdel(var h:string;n:string);
begin
try;headeraddex(h,n,'',rcode,true);except;end;
end;
//## headerfind ##
function tmisc.headerfind(var h:string;n:string;var v:string):boolean;
var
   nlen,len,_pos,_start,_length:integer;
   tmp:string;
begin
try
//defaults
result:=false;
v:='';
nlen:=length(n);
//check
if (nlen<=0) then exit;
//process
//.scan
_pos:=1;
while general.readline(_pos,_start,_length,h) do if (_length>=1) then
   begin
   if (_length>=nlen) and (0=comparetext(n,copy(h,_start,nlen))) then
      begin
      //.get
      tmp:=copy(h,_start+nlen,_length-nlen);
      //.set
      if general.textgood(tmp) then
         begin
         v:=tmp;
         result:=true;
         end;//end of if
      end;//end of if
   end;//end of if
except;end;
end;
//## dobName ##
function tmisc.dobName(var name:string):boolean;
begin
try
if (length(name)>255) then name:=copy(name,1,255);
result:=(length(name)>=1);
except;end;
end;
//## dobBoolean ##
procedure tmisc.dobBoolean(var len:integer;var data:string;name:string;value:boolean);
var
   a:char;
begin//#8=false, #9=true
try
if dobName(name) then
   begin
   if value then a:=#9 else a:=#8;
   pushb(len,data,char(length(name))+name+a);
   end;//end of if
except;end;
end;
//## dobInteger ##
procedure tmisc.dobInteger(var len:integer;var data:string;name:string;value:integer);
var//Note: Delphi's native component writer fails to write negative integer values!
   //      Custom version below, successfully writes negative numbers.
   w:twrd2;
   i:tint4;
begin//#2=byte, #3=word, #4=type integer
try
if dobName(name) then
   begin
   //int8
   if (value>=-128) and (value<=127) then pushb(len,data,char(length(name))+name+char(vaInt8)+char(value))
   //int16
   else if (value>=-32768) and (value<=32767) then
      begin
      w.si:=value;
      pushb(len,data,char(length(name))+name+char(vaInt16)+w.chars[0]+w.chars[1]);
      end
   //int32
   else
      begin
      i.val:=value;
      pushb(len,data,char(length(name))+name+char(vaInt32)+i.chars[0]+i.chars[1]+i.chars[2]+i.chars[3]);
      end;//end of if
   end;//end of if
except;end;
end;
//## dobString ##
procedure tmisc.dobString(var len:integer;var data:string;name,value:string);
var
   tmp:tint4;
begin//#6=type short string OR #12=type long string
try
if dobName(name) then
   begin
   tmp.val:=length(value);
   //.short string
   if (tmp.val<=255) then pushb(len,data,char(length(name))+name+char(vaString)+char(tmp.val)+value)
   //.long string
   else pushb(len,data,char(length(name))+name+char(vaLString)+tmp.chars[0]+tmp.chars[1]+tmp.chars[2]+tmp.chars[3]+value);
   end;//end of if
except;end;
end;
//## dobHead ##
function tmisc.dobHead(var len:integer;var data:string;name:string;init:boolean):boolean;
begin//#0
try
//defaults
result:=false;
//init
if init then
   begin
   len:=0;
   data:='';
   end;
//process
if dobName(name) then
   begin
   pushb(len,data,'TPF0'+char(length(name))+name+#0);
   result:=true;
   end;//end of if
except;end;
end;
//## dobEnd ##
procedure tmisc.dobEnd(var len:integer;var data:string);
begin//#0
try
//set
pushb(len,data,char(vaNull)+char(vaNull));
//finalise
pushb(len,data,'');
except;end;
end;
//## dobRead ##
function tmisc.dobRead(var pos:integer;var data,name,vs:string;var vi:integer;var useVI:boolean):boolean;//delphi object read
const
   //states
   sname=0;
   svalue=1;
var
   w:twrd2;
   i:tint4;
   s,v:byte;
   vlen,tmp,nok,len:integer;
   vtmp:string;
begin
try
//defaults
result:=false;
len:=length(data);
name:='';
vs:='';
vi:=0;
useVI:=true;//number by default
s:=sname;
//check
if (pos<=0) then pos:=1;
if (pos>len) then exit;
//process
//.header/object
if (pos=1) then
   begin
   if (copy(data,pos,4)='TPF0') then
      begin
      inc(pos,4);
      name:='TPF0';
      if (pos<=len) then
         begin
         //.get
         tmp:=byte(data[pos]);
         vs:=copy(data,pos+1,tmp);
         useVI:=false;
         //.inc
         inc(pos,1+tmp);
         //.null or other initial value - Note: some "san" files ahve rubbish
         if (pos<=len) then
            begin
            tmp:=byte(data[pos]);
            inc(pos,1+tmp);
            end;//end ofif
         end;//end of if
      result:=true;
      end;//end of if
   exit;
   end;//end of if
//.values
repeat
//.get
v:=byte(data[pos]);
//.name
if (s=sname) and (v>=1) then
   begin
   name:=copy(data,pos+1,v);
   inc(pos,v);
   s:=svalue;
   end
//.value
else if (s=svalue) then
   begin
   inc(pos);
   //.decide
   case tvaluetype(v) of
   vaInt8:begin//2=byte=1byte
      if (pos<=len) then vi:=shortint(data[pos]);
      inc(pos);
      result:=true;
      end;//end of begin
   vaInt16:begin//3=word=2bytes
      if ((pos+1)<=len) then
         begin
         w.chars[0]:=data[pos];
         w.chars[1]:=data[pos+1];
         vi:=w.si;
         end;//end of if
      inc(pos,2);
      result:=true;
      end;//end of begin
   vaInt32:begin//4=integer=4bytes
      if ((pos+3)<=len) then
         begin
         i.chars[0]:=data[pos];
         i.chars[1]:=data[pos+1];
         i.chars[2]:=data[pos+2];
         i.chars[3]:=data[pos+3];
         vi:=i.val;
         end;//end of if
      inc(pos,4);
      result:=true;
      end;//end of begin
   vaString:begin//6=short string=Xbytes
      if (pos<=len) then
         begin
         vlen:=byte(data[pos]);
         if (vlen>=1) then
            begin
            vs:=copy(data,pos+1,vlen);
            inc(pos,vlen);
            end;//end of if
         end;//end of if
      inc(pos);
      useVI:=false;
      result:=true;
      end;//end of begin
   vaFalse:begin//8=FALSE(boolean)=0byte
      vi:=0;
      result:=true;
      end;//end of begin
   vaTrue:begin//9=TRUE(boolean)=0byte
      vi:=1;
      result:=true;
      end;//end of begin
   vaLString:begin//12=long string=Xbytes
      if ((pos+3)<=len) then
         begin
         i.chars[0]:=data[pos];
         i.chars[1]:=data[pos+1];
         i.chars[2]:=data[pos+2];
         i.chars[3]:=data[pos+3];
         vlen:=i.val;
         if (vlen>=1) then
            begin
            vs:=copy(data,pos+4,vlen);
            inc(pos,vlen);
            end;//end of if
         end;//end of if
      inc(pos,4);
      useVI:=false;
      result:=true;
      end;//end of begin
   vaNull,vaNil:;//nil
   else break;
   end;//end of case
   //.quit
   if result then break;
   end;//end of if
//.inc
inc(pos);
until (pos>len);
except;end;
end;
//## reverseINT ##
procedure tmisc.reverseINT(x:tdynamicinteger;minp,maxp:integer);
var
   tmp:tdynamicinteger;
   c,p:integer;
begin
try
//defaults
tmp:=nil;
//check
if (x=nil) or (x.count<=1) then exit;
//range
minp:=frcrange(minp,0,x.count-1);
maxp:=frcrange(maxp,minp,x.count-1);
if (minp=maxp) then exit;
//setup
tmp:=tdynamicinteger.create;
//process
//.set
c:=maxp-minp+1;
tmp.setparams(c,c,0);
for p:=minp to maxp do tmp.items[p-minp]:=x.items[p];
for p:=minp to maxp do x.items[maxp-(p-minp)]:=tmp.items[p-minp];
except;end;
try;freeobj(@tmp);except;end;
end;
//## b ##
function tmisc.b(x:currency;sym:boolean):string;
begin
try;result:=general.CurComma(x)+general.insstr(#32+tsB,sym);except;end;
end;
//## kb ##
function tmisc.kb(x:currency;sym:boolean):string;
begin
try;result:=kbb(x,3,sym);except;end;
end;
//## kbb ##
function tmisc.kbb(x:currency;p:byte;sym:boolean):string;
begin
try;result:=general.curdec(x/1000,p,true)+general.insstr(#32+tsKB,sym);except;end;
end;
//## mb ##
function tmisc.mb(x:currency;sym:boolean):string;
begin
try;result:=general.curdec(x/1000000,3,true)+general.insstr(#32+tsMB,sym);except;end;
end;
//## gb ##
function tmisc.gb(x:currency;sym:boolean):string;
begin
try;result:=general.curdec(x/1000000000,3,true)+general.insstr(#32+tsGB,sym);except;end;
end;
//## numbers ##
function tmisc.numbers(_from,_to:integer;sep:char):string;
var
   len,p:integer;
begin
try
//defaults
result:='';
len:=0;
if (_to<_from) then swapint(_from,_to);
//process
//.get
for p:=_from to _to do pushb(len,result,inttostr(p)+sep);
//.finalise
pushb(len,result,'');
except;end;
end;
//## stripHTTP ##
function tmisc.stripHTTP(x:string):string;
begin
try;if (comparetext(copy(x,1,7),'http://')=0) then result:=copy(result,8,length(x)) else result:=x;except;end;
end;
//## stringfixedlength ##
function tmisc.stringfixedlength(len:integer;_input:string;_null:char):string;//24JAN2008
var
   ilen,p:integer;
begin
try
//defaults
result:='';
if (len<=0) then exit;
ilen:=length(_input);
//get
setlength(result,len);
//set
for p:=1 to len do if (p<=ilen) then result[p]:=_input[p] else result[p]:=_null;
except;end;
end;
//## yes ##
function tmisc.yes(x:boolean):string;
begin
try;result:=general.aorbstr('No','Yes',x);except;end;
end;
//## yest ##
function tmisc.yest(x:boolean):string;
begin
try;result:=general.aorbstr(tsNo,tsYes,x);except;end;
end;
//## passed ##
function tmisc.passed(x:boolean):string;
begin
try;result:=general.aorbstr('Failed','Passed',x);except;end;
end;
//## testmidi ##
procedure tmisc.testmidi;
label
   skipend;
var
   e,d,f:string;
begin
try
//defaults
e:=gecOutOfMemory;
//process
//.filename
f:=bvfportable(bvfTemp)+'Test-Midi.mid';
//.data
d:=io.fromb64b('TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwtxsAD/LwBNVHJrAAAALgD/IQEAAMAOALAHfwCwCj8AkE9keE8AAFZkeFYAAFNkeFMAAE9kg2BPAAD/LwA=');
//.write
if not io.tofile(f,d,e) then goto skipend;
//.run
run(f,'');
//successful
e:='';
skipend:
except;end;
try;if (e<>'') then ShowError60(translate(e));except;end;
end;
//## delmidi ##
procedure tmisc.delmidi;
begin
try;remfile(bvfportable(bvfTemp)+'Test-Midi.mid');except;end;
end;
//## linkise ##
function tmisc.linkise(x:string):string;
begin
try;result:=linkiseb(x,'');except;end;
end;
//## linkiseb ##
function tmisc.linkiseb(x:string;_class:string):string;
label
   skipone;
const//Updated: 02-SEP-2006
   http='http://';
   https='https://';
   ftp='ftp://';
   httpLEN=length(http);
   httpsLEN=length(https);
   ftpLEN=length(ftp);
var
   okcount,o,sp,p,xlen:integer;
   tmp2,tmp:string;
begin
try
//defaults
result:=x;
xlen:=length(x);
p:=1;
sp:=0;
okcount:=0;
//check
if (xlen=0) then exit;
if (_class<>'') and (_class[1]<>#32) then _class:=#32+_class;
//process
repeat
//.ignore
if (x[p]='<') then inc(okcount)
else if (x[p]='>') then dec(okcount);
if (okcount<>0) then
   begin
   sp:=0;
   goto skipone;
   end;//end of if
//.scan
if (sp=0) and
(
(0=comparetext(copy(x,p,httpLEN),http)) or
(0=comparetext(copy(x,p,httpsLEN),https)) or
(0=comparetext(copy(x,p,ftpLEN),ftp))
) then sp:=p
else if (sp>=1) and ((p=xlen) or (x[p]=#32) or (x[p]=#10) or (x[p]=#13)) then
   begin
   if (p=xlen) and ((x[p]<>#32) and (x[p]<>#10) and (x[p]<>#13)) then o:=1 else o:=0;
   tmp:=copy(x,sp,p-sp+o);
   tmp2:='<a'+_class+' href="'+tmp+'">'+tmp+'</a>';
   x:=copy(x,1,sp-1)+tmp2+copy(x,p+o,xlen);
   xlen:=length(x);
   inc(p,length(tmp2)-length(tmp));
   sp:=0;
   end;//end of if
skipone:
//.inc
inc(p);
until (p>xlen);
//return result
result:=x;
except;end;
end;
//## helpise ##
function tmisc.helpise(x:string;html:boolean):string;
var
   tmp:string;
begin
try
//defaults
result:='';
//vars
general.swapstrsUb(x,'<programname>',programnameHARD,'','',false,false);
general.swapstrsUb(x,'<programstartbutton>','Start > Programs > Blaiz Enterprises > '+programcategoryHARD,'','',false,false);
general.swapstrsUb(x,'<programclassification>',programclassification,'','',false,false);
//.other
general.swapstrsUb(x,'<programdownload>','http://www.blaizenterprises.com/'+uppercase(webname)+'.ZIP','','',false,false);
general.swapstrsUb(x,'<programinformationpage>','http://www.blaizenterprises.com/'+uppercase(webname)+'.HTM','','',false,false);
general.swapstrsUb(x,'<programlink>','http://www.blaizenterprises.com/'+lowercase(webname)+'.html','','',false,false);
general.swapstrsUb(x,'<programeula>',programEULA,'','',false,false);
case html of
false:general.swapstrsUb(x,'<programnetworkcodes>',tsNetwork+#32+tsCodes+rcode+general.networkcodes(' = ',rcode),'','',false,false);
true:begin
   //.get
   tmp:=tsNetwork+#32+tsCodes+rcode+'[html]'+ht.tableb(tsNetwork+#32+tsCodes,'',general.networkcodes(#0,#0),#0,false,false,false,true,2,2,-100,5)+'[/html]';
   //.clean
   general.swapstrs(tmp,'<programnetworkcodes>','');
   //.set
   general.swapstrsUb(x,'<programnetworkcodes>',tmp,'','',false,false);
   end;//end of begin
end;//end of case
//html
if html then x:=htmlise(x);
//return result
result:=x;
except;end;
end;
//## htmlcaption ##
function tmisc.htmlcaption(x:string;large:boolean):string;
begin
try
result:=
'<table cellpadding='+general.aorbstr('2','5',large)+' cellspacing=0 border=0 width=100% bgcolor='+viTitle.hbackground+'>'+
'<td>'+
'<font'+general.insstr(' size="+2"',large)+' color='+viTitle.hfont+'><strong>'+net_encode_for_html_b(x)+'</strong></font>'+
'</td>'+
'</table>'+
rcode;
except;end;
end;
//## htmlallow ##
procedure tmisc.htmlallow(var x:string;start,stop:string);
var
   okcount:integer;
begin
try;okcount:=0;htmlallow(x,start,stop);except;end;
end;
//## htmlallowb ##
procedure tmisc.htmlallowb(var x:string;var okcount:integer;start,stop:string);
var//Note: okcount should be set to "0" when starting out
   dr:string;
   lendr,d,startlen,stoplen,lenx,p:integer;
begin
try
//range
if (start='') then start:='[html]';
if (stop='') then stop:='[/html]';
//defaults
startlen:=length(start);
stoplen:=length(stop);
lenx:=length(x);
//check
if (lenx<=0) or (startlen<=0) or (stoplen<=0) then exit;
if (startlen=stoplen) and (comparetext(start,stop)=0) then exit;
//setup
p:=1;
d:=0;
//process
repeat
//.start/stop/modify
if (x[p]=start[1]) and (comparetext(copy(x,p,startlen),start)=0) then
   begin
   inc(okcount);
   d:=startlen;
   end
else if (x[p]=stop[1]) and (comparetext(copy(x,p,stoplen),stop)=0) then
   begin
   dec(okcount);
   d:=stoplen;
   end
else if (okcount<=0) then
   begin
   if (x[p]='<') then
      begin
      d:=1;
      dr:='&lt;';
      end
   else if (x[p]='>') then
      begin
      d:=1;
      dr:='&gt;';
      end;//end of if
   end;//end of if
//.adjust
if (d>=1) then
   begin
   //.fill
   lendr:=length(dr);
   x:=copy(x,1,p-1)+dr+copy(x,p+d,lenx);
   //.dec
   dec(p);
   //.size
   lenx:=lenx-d+lendr;
   //.reset
   d:=0;
   if (lendr<>0) then dr:='';
   end;//end of if
//.inc
inc(p);
until (p>=lenx);
except;end;
end;
//## filtertext ##
function tmisc.filtertext(x:string):string;
begin
try;result:=filtertextb(x,true);except;end;
end;
//## filtertextb ##
function tmisc.filtertextb(x:string;removebrackets:boolean):string;
begin
try
result:=x;
if removebrackets then
   begin
   general.swapchars(result,'<','(');
   general.swapchars(result,'>',')');
   end;//end of if
general.swapchars(result,'"',#39);
except;end;
end;
//## nospaces ##
function tmisc.nospaces(x:string;_lowercase:boolean):string;//filtered content (no html code allowed)
begin//Note: prevent the use of any quotes (single or double), as these cause link failure
try  //      in the "a...n" section of relative links within OB1new
     //      for example: <a href="index.html#aaaa....nnn">abc</a>
//get
x:=filtertext(x);
general.swapchars(x,#32,'-');
general.swapchars(x,'''','`');
//filter
if _lowercase then x:=lowercase(x);
//set
result:=x;
except;end;
end;
//## htmlise ##
function tmisc.htmlise(x:string):string;
begin
try;result:=htmliseb(x,ntranslate('topics'),'',true,false);except;end;
end;
//## htmliseb ##
function tmisc.htmliseb(x,_topicslabel,_generatorname:string;_topicsnumber,_nocopyright:boolean):string;//08NOV2007
const//Proc v1.00.045
     //Note: Supports html code embedding using start/stop tags "[html]...[/html]" - 28-AUG-2006
   minblank=2;//2 blank lines before starting a new topic
var
   okcount,len,headLEN,topicLEN,bc,i,p:integer;
   topiclink,_des,_key,title,head,topic,tmp:string;
   spacingOK,topicsOK,headOK:boolean;
begin
try
//defaults
result:='';
title:='Untitled';
_des:='';
_key:='';
p:=1;
bc:=minblank;
headOK:=false;
head:='';
topic:='';
len:=0;
headLEN:=0;
topicLEN:=0;
okcount:=0;
//.range
topicsOK:=general.textgood(_topicslabel);
if not general.textgood(_generatorname) then _generatorname:='htmlise v1.00.045 - Blaiz Enterprises';
//process
//.title
while general.nextline(p,x,tmp) do if (tmp<>'') then
   begin
   title:=tmp;
   general.swapchars(title,'<','(');
   general.swapchars(title,'>',')');
   break;
   end;//end of if
//.topics
while general.nextline(p,x,tmp) do
begin
//.clean - remove any html code and replace with html safe code
htmlallowb(tmp,okcount,'[html]','[/html]');
//.bc
//.bc
if (tmp='') then inc(bc)
else
   begin
   //.ehance * to "<li>", must be at start of line
   if (tmp[1]='*') then
      begin
      delete(tmp,1,1);//remove *
      insert('<li>',tmp,1);//insert "<li>"
      end;//end of if
   bc:=0;
   end;//end of if
//.reset
if headOK and (bc>=minblank) then
   begin
   //.finish topic
   pushb(topicLEN,topic,general.insstr('</p>',spacingOK)+rcode+rcode);
   //.clear
   headOK:=false;
   end;//end of if
//.start topic
if (not headOK) and (bc=0) then
   begin
   //.vars
   spacingOK:=not general.swapstrs(tmp,'[nospacing]','');
   //.head
   headOK:=true;
   topiclink:=nospaces(tmp,true);
   pushb(headLEN,head,'<li><a href="#'+topiclink+'">'+tmp+'</a><br>'+rcode);
   //.topic - header
   pushb(topicLEN,topic,
   '<a name="'+topiclink+'"><h2>'+net_encode_for_html_b(tmp)+'</h2></a>'+rcode+
   general.insstr('<p>',spacingOK)+rcode);
   end
//.fill topic
else if headOK and (bc<minblank) then
   begin
   case (okcount<=0) of
   true:pushb(topicLEN,topic,linkise(tmp)+'<br>'+rcode);
   false:pushb(topicLEN,topic,tmp);
   end;//end of case
   end;//end of if
end;//end of loop
//.finish topic
if headOK then pushb(topicLEN,topic,general.insstr('</p>',spacingOK)+rcode+rcode);
//.finalise
pushb(headLEN,head,'');
pushb(topicLEN,topic,'');
//.meta-tags
//..description
_des:=title;
general.swapchars(_des,'"','''');
if not general.textgood(_des) then _des:='';
//..keywords
_key:=general.keywordsb(title,maxint);
if not general.textgood(_key) then _key:='';
//.build page
pushb(len,result,
'<html>'+rcode+
'<head>'+rcode+
' <title>'+title+'</title>'+rcode+
' <meta http-equiv="content-type" content="text/html; charset=iso-8859-1">'+rcode+
general.insstr(' <meta name="description" content="'+_des+'">'+rcode,_des<>'')+
general.insstr(' <meta name="keywords" content="'+_key+'">'+rcode,_key<>'')+
' <meta name="generator" content="'+_generatorname+'">'+rcode+
#32+viNormal.hstyle+rcode+
'</head>'+rcode+
viNormal.hbody+rcode);
//..main header
pushb(len,result,htmlcaption(title,true)+'<br>'+rcode+rcode);
//..topics
if topicsOK then
   begin
   pushb(len,result,
   '<table border=0 width=100%>'+rcode+
   '<td align=left valign=top width=35%>'+rcode+rcode+
   '<h2>'+net_encode_for_html_b(_topicslabel)+'</h2>'+rcode+
   head+
   rcode+'</td>'+rcode);
   end;//end of if
//..content
pushb(len,result,
'<td align=left valign=top width='+general.aorbstr('100%','65%',topicsOK)+'>'+rcode+rcode+
topic+
'</td>'+rcode+
'</table>'+rcode+rcode);
//..finish
pushb(len,result,general.aorbstr(viHtmlEnd,'</body>'+rcode+'</html>'+rcode,_nocopyright));
//.finalise
pushb(len,result,'');
except;end;
end;
//## toblock ##
function tmisc.toblock(x:string;perline:integer):string;
label
   redo;
var
   len,p:integer;
   tmp,buffer:string;
begin
try
//defaults
result:='';
p:=1;
tmp:='';
buffer:='';
//check
perline:=frcmin(perline,2);
//process
while general.nextline(p,x,tmp) do
begin
//.push
buffer:=buffer+tmp;
//.pull
redo:
if (length(buffer)>=perline) then
   begin
   pushb(len,result,''''+copy(buffer,1,perline)+'''+'+rcode);
   delete(buffer,1,perline);
   goto redo;
   end;//end of if
end;//end of loop
//.finish
if (length(buffer)>=1) then pushb(len,result,''''+buffer+'''+'+rcode);
//.finalise
pushb(len,result,'');
//.terminator
for p:=length(result) downto (length(result)-10) do if (result[p]='+') then
   begin
   result[p]:=';';
   break;
   end;//end of if
except;end;
end;
//## tofileIAD ##
function tmisc.tofileIAD(x:string;url,des:string;image:tbitmap;var e:string):boolean;
label
   skipend;
var
   data:string;
begin
try
//defaults
result:=false;
e:=gecOutOfMemory;
//process
//.set
if not toIAD(url,des,image,data,e) then goto skipend;
//.write
if not io.tofile(x,data,e) then goto skipend;
//successful
result:=true;
skipend:
except;end;
end;
//## toIAD ##
function tmisc.toIAD(url,des:string;image:tbitmap;var data,e:string):boolean;
label
   skipend;
var
   a:tnv;
   m:tstreamstr;
   p:integer;
   istr:string;
begin
try
//defaults
result:=false;
a:=nil;
m:=nil;
e:=gecOutOfMemory;
data:='';
istr:='';
//setup
a:=newnv;
a.data:=@data;
if not a.initwrite('IAD',e) then goto skipend;
//process
//.image -> string
m:=tstreamstr.create(@istr);
if (image<>nil) then image.savetostream(m);
freeObj(@m);
//.string -> compress
if not io.toC(istr,e) then goto skipend;
//.write
if not a.writeb('url',url,e) then goto skipend;
if not a.writeb('des',des,e) then goto skipend;
if not a.writeb('image',istr,e) then goto skipend;
//.finalise
if not a.writeb('','',e) then goto skipend;
//.encode - base64
data:=io.tob64b(data,70);
//successful
result:=(data<>'');
skipend:
except;end;
try
freeobj(@a);
freeobj(@m);
except;end;
end;
//## fromfileIAD ##
function tmisc.fromfileIAD(x:string;var url,des,image:string;var e:string):boolean;
label
   skipend;
var
   data:string;
begin
try
//defaults
result:=false;
e:=gecOutOfMemory;
url:='';
des:='';
image:='';
//process
//.read
if not io.fromfile(x,data,e) then goto skipend;
//.get
if not fromIAD(data,url,des,image,e) then goto skipend;
//successful
result:=true;
skipend:
except;end;
end;
//## fromIAD ##
function tmisc.fromIAD(var data,url,des,image:string;var e:string):boolean;
label
   skipend;
var
   a:tnv;
   p:integer;
   n,v:string;
begin
try
//defaults
result:=false;
//check
e:=gecUnexpectedError;
//setup
a:=nil;
e:=gecOutOfMemory;
url:='';
des:='';
image:='';
//process
//.decode - base64
data:=io.fromb64b(data);
e:=gecUnknownFormat;
if (data='') then goto skipend;
//.init
a:=newnv;
a.data:=@data;
if not a.initread('IAD',e) then goto skipend;
//.loop
while a.canread do
begin
//.get
if not a.read(n,v,e) then goto skipend;
//.set [style1+index4]=[value as string]
if (n<>'') then
   begin
   if (0=comparetext(n,'url')) then url:=misc.enforceservice(v)
   else if (0=comparetext(n,'des')) then des:=v
   else if (0=comparetext(n,'image')) then
      begin
      //.decompress
      if not io.fromC(v,e) then goto skipend;
      //.string -> bitmap
      image:=v;
      end;//end of if
   end;//end of if
end;//end of with
//successful
result:=true;
skipend:
except;end;
try;freeObj(@a);except;end;
end;
//## isredirect ##
function tmisc.isredirect(x:integer):boolean;
begin
try
//defaults
result:=false;
//get
case x of
300..303,307:result:=true;
end;//end of case
except;end;
end;
//## ip127 ##
function tmisc.ip127(x:integer):boolean;//ip is "127.x.x.x"
var
   a:tint4;
begin
try;a.val:=x;result:=(a.bytes[0]=127);except;end;
end;
//## iphighest ##
function tmisc.iphighest(newip:integer;var ip:integer):boolean;//03FEB2008
begin//return highest IP address "[lowest] zero=>machine=>local=>public [highest]"
try
//defaults
result:=false;
//check
if (newip=0) then exit;
//set
if (ip=0) or ip127(ip) or ippublic(newip) then
   begin
   ip:=newip;
   result:=true;
   end;//end of if
except;end;
end;
//## ipmachine ##
function tmisc.ipmachine(x:integer):boolean;//ip is "local machine" 25JAN2008
var
   a:tint4;
begin
try
//defaults
result:=false;
a.val:=x;
//check
result:=(x<>0) and ((x=machine_ip) or (a.bytes[0]=127));
except;end;
end;
//## ippublic ##
function tmisc.ippublic(x:integer):boolean;//ip is "public (internet) network"
begin
try;result:=not ipprivate(x);except;end;
end;
//## ipprivate ##
function tmisc.ipprivate(x:integer):boolean;//ip is "private network"
var
   _class:char;
begin
try;result:=ipprivateex(x,_class);except;end;
end;
//## ipprivateex ##
function tmisc.ipprivateex(x:integer;var _class:char):boolean;//ip is "private network"
var//*=rfc1918
   a:tint4;
begin
try
//defaults
result:=false;
_class:='i';//i=internet
//get
a.val:=x;
//DECIDE
//*class A => 10.0.0.0 - 10.255.255.255 [10.x.x.x]
if (a.bytes[0]=10) then
   begin
   _class:='a';
   result:=true;
   exit;
   end;//end of if
//*class B => 172.16.0.0 - 172.31.255.255
if (a.bytes[0]=172) and (a.bytes[1]>=16) and (a.bytes[1]<=31) then
   begin
   _class:='b';
   result:=true;
   exit;
   end;//end of if
//*class C => 192.168.0.0 - 192.168.255.255
if (a.bytes[0]=192) and (a.bytes[1]=168) then
   begin
   _class:='c';
   result:=true;
   exit;
   end;//end of if
//loopback => 127.0.0.1
if (a.bytes[0]=127) then
   begin
   _class:='l';//loopback
   result:=true;
   exit;
   end;//end of if
except;end;
end;
//## remdup ##
procedure tmisc.remdup(x:tstringlist);//remove duplicates
var
   a:tdynamicnamelist;
   p:integer;
begin
try
//defaults
a:=nil;
//check
if (x=nil) or (x.count<=1) then exit;
//process
//.set
a:=tdynamicnamelist.create;
for p:=0 to (x.count-1) do a.add(x.strings[p]);
//.get
x.text:=a.text;
except;end;
try;freeObj(@a);except;end;
end;
//## remdupb ##
function tmisc.remdupb(x:string):string;//remove duplicates
var
   a:tstringlist;
begin
try
//defaults
a:=nil;
a:=tstringlist.create;
//get
a.text:=x;
//filter
remdup(a);
//set
result:=a.text;
except;end;
end;
//## jpf ##
function tmisc.jpf(_path,_file:string):string;//join path and file
begin
try;result:=jpfb(_path,_file,'\');except;end;
end;
//## jpfb ##
function tmisc.jpfb(_path,_file:string;sep:char):string;//join path and file
begin
try
//process
//.check
if (sep=#0) then sep:='\';
//.clean
if (sep='\') then
   begin
   general.swapchars(_path,'/',sep);
   general.swapchars(_file,'/',sep);
   end
else if (sep='/') then
   begin
   general.swapchars(_path,'\',sep);
   general.swapchars(_file,'\',sep);
   end;//end of if
//.get
if (_path<>'') then
   begin
   if (copy(_path,length(_path),1)<>sep) then _path:=_path+sep;
   end;//end of if
if (_file<>'') and (_file[1]=sep) then _file:=copy(_file,2,length(_file));
//.set
result:=_path+_file;
except;end;
end;
//## urlasfile ##
function tmisc.urlasfile(localpath,url:string;style:turlfilestyle):string;
var//Note: url path automatically collasped with "general.pu"
   i:tparseurl;
begin
try
//defaults
result:='';
//process
//.set
case style of
ufsUrlPathFile:begin
   //.decode url
   general.pu('http://'+url,'',i,[pusExcludeData,pusExcludeMark]);
   //.root path
   if (i.h<>'') then result:=result+general.safefilename(i.h,false);
   if (i.pt<>80) then result:=result+pcSymSafe+general.safefilename(inttostr(i.pt),false);
   //.sub path
   if (i.p<>'') then result:=result+general.safefilename(i.p,true);
   //.filename
   result:=result+general.safefilename(i.f,true);
   end;//end of begin
ufsUrlFile:begin//NO PATH - just url\filename
   //.decode url
   general.pu('http://'+url,'',i,[pusExcludeData,pusExcludeMark]);
   //.root path
   if (i.h<>'') then result:=result+general.safefilename(i.h,false);
   if (i.pt<>80) then result:=result+pcSymSafe+general.safefilename(inttostr(i.pt),false);
   //.filename
   result:=result+'\'+general.safefilename(i.f,true);
   end;//end of begin
ufsPathFile:begin
   //.decode url
   general.pu('http://'+url,'',i,[pusExcludeData,pusExcludeMark]);
   //.path
   if (i.p<>'') then result:=result+general.safefilename(i.p,true);
   //.filename
   result:=result+general.safefilename(i.f,true);
   if (result<>'') and (result[1]='\') then result:=copy(result,2,length(result));
   end;//end of begin
ufsFile:begin
   //.decode url
   general.pu('http://'+url,'',i,[pusExcludeData,pusExcludeMark]);
   //.get
   result:=general.swapcharsb(i.f,#32,pcSymSafe);
   end;//end of begin
ufsSumPathFile:result:=general.ufnb(url,false);
else//ufsSumUrlPathFile
   result:=general.ufnb(url,true);
end;//end of case
//catch "empty" results (http://www.blaiz.net -> "nil")
if (result='') or (extractfilename(result)='') then result:=result+'index.html';
//localpath
if (localpath<>'') then
   begin
   if (result<>'') and (result[1]='\') then result:=copy(result,2,length(result));
   result:=asfolder(localpath)+result;
   end;
except;end;
end;
//## insertampb ##
function tmisc.insertampb(usedchars:string;x:string):string;
begin
try;result:=insertamp(usedchars,x);except;end;
end;
//## insertamp ##
function tmisc.insertamp(var usedchars:string;x:string):string;
var//Note: assumes "usedchars" is always uppercase
   ulen,xlen,p2,p:integer;
   f:byte;
   z:char;
   ok:boolean;
begin//Automatically inserts "&" in x skipping characters defined in "usedchars"
try
//defaults
result:=x;
ulen:=length(usedchars);
xlen:=length(x);
//process
for p:=1 to xlen do
begin
//.get
f:=ord(x[p]);
if (f>=97) and (f<=122) then f:=f-32;//uppercase
//.compare (A..Z or 0..9)
if ((f>=65) and (f<=90)) or ((f>=48) and (f<=57)) then
   begin
   //.search
   z:=char(f);
   ok:=true;
   for p2:=1 to ulen do if (z=usedchars[p2]) then
      begin
      ok:=false;
      break;
      end;//end of if
   //.set
   if ok then
      begin
      usedchars:=usedchars+z;
      insert('&',result,p);
      break;
      end;//end of if
   end;//end of if
end;//end of loop
except;end;
end;
//## hasurlsb ##
function tmisc.hasurlsb(x:string):boolean;
begin
try;result:=hasurls(x);except;end;
end;
//## hasurls ##
function tmisc.hasurls(var x:string):boolean;
var
   p:integer;
begin
try
//defaults
result:=false;
//process
for p:=1 to length(x) do if ((x[p]='h') or (x[p]='H')) and (0=comparetext(copy(x,p,7),'http://')) then
    begin
    result:=true;
    break;
    end;//end of if
except;end;
end;
//## extracturls ##
function tmisc.extracturls(x:string;onurl:tstringevent):string;
var
   tmp,quote:char;
   xlen,p,s,len:integer;
   within:boolean;
   z:string;
begin
try
//defaults
result:='';
len:=0;
xlen:=length(x);
s:=0;
within:=false;
quote:=#0;//none
//process
for p:=1 to xlen do
begin
if (not within) and (0=comparetext(copy(x,p,7),'http://')) then
   begin
   within:=true;
   s:=p;
   //.quote
   quote:=#0;
   if (p>=2) then (if (x[p-1]='"') or (x[p-1]='''') then quote:=x[p-1]);
   end
else if within and
   (
   (p=xlen) or
   ((quote=#0) and ((x[p]=#32) or (x[p]=#10) or (x[p]='>'))) or
   ((quote<>#0) and (quote=x[p]))
   )
   then
   begin
   //.get
   z:='';
   if (quote=#0) then
      begin
      if (x[p]=#32) or (x[p]=#10) or (x[p]='>') then z:=copy(x,s,p-s)
      else if (p=xlen) then z:=copy(x,s,p-s+1);
      end
   else
      begin
      if (quote=x[p]) then z:=copy(x,s,p-s)
      else if (p=xlen) then z:=copy(x,s,p-s+1);
      end;//end of if
   //.filter
   general.swapstrs(z,#9,'');
   general.swapstrs(z,#10,'');
   general.swapstrs(z,#13,'');
   //.set
   if assigned(onurl) then onurl(self,z)
   else pushb(len,result,z+rcode);
   //.reset
   s:=0;
   within:=false;
   end;//end of if
end;//end of loop
//.finalise
if not assigned(onurl) then pushb(len,result,'');
except;end;
end;
//## findclass ##
function tmisc.findclass(x:twincontrol;y:tclass):tobject;
var
   p:integer;
begin
try
//defaults
result:=nil;
//check
if (x=nil) then exit;
//process
//.controls
for p:=0 to (x.controlcount-1) do if (x.controls[p] is y) then
   begin
   result:=x.controls[p];
   exit;
   end;//end of if
//.components
for p:=0 to (x.componentcount-1) do if (x.components[p] is y) then
   begin
   result:=x.components[p];
   exit;
   end;//end of if
except;end;
end;
//## savecolors ##
function tmisc.savecolors(x:string;var y:array of integer;var e:string):boolean;
var
   len,p:integer;
   tmp:string;
begin
try
//defaults
result:=false;
e:=gecOutOfMemory;
//process
//.get
len:=0;
tmp:='';
for p:=low(y) to high(y) do pushb(len,tmp,general.tohex(y[p],true)+rcode);
pushb(len,tmp,'');
//.set
result:=io.tofile(x,tmp,e);
except;end;
end;
//## loadcolors ##
function tmisc.loadcolors(x:string;var y:array of integer;var e:string):boolean;
var
   i,_pos,_start,_length:integer;
   tmp:string;
begin
try
//defaults
result:=false;
e:=gecOutOfMemory;
for i:=low(y) to high(y) do y[i]:=clwhite;
//process
//.get
if io.fromfile(x,tmp,e) then
   begin
   //.set
   _pos:=1;
   i:=low(y);
   while general.readline(_pos,_start,_length,tmp) do
   begin
   y[i]:=general.fromhex(copy(tmp,_start,_length));
   inc(i);
   if (i>high(y)) then break;
   end;//end of loop
   //successful
   result:=true;
   end;//end of if
except;end;
end;
//## showcolor ##
function tmisc.showcolor(var _color:integer):boolean;
const
  MaxCustomColors = 16;
  CC_RGBINIT = $00000001;
  CC_FULLOPEN = $00000002;
  CC_ENABLEHOOK = $00000010;
  CC_ANYCOLOR = $00000100;
type
  tcolors=array[0..MaxCustomColors - 1] of Longint;
var
  a:tchoosecolor;
  b:tcolors;
  p:integer;
  e:string;
begin
try
//defaults
result:=false;
//prepare
loadcolors(bvfportable(bvfSettings)+'ColorWindow-CustomColors.txt',b,e);
fillchar(a, SizeOf(tchoosecolor),0);
with a do
begin
//.core
hInstance:=SysInit.HInstance;
hWndOwner:=application.mainform.handle;
lStructSize:=sizeof(tchoosecolor);
lpfnHook:=tmisc_dialoghook;
flags:=CC_FULLOPEN or CC_RGBINIT or CC_ENABLEHOOK;
//.other
lpCustColors:=@b;
lCustData:=0;
rgbResult:=ColorToRGB(_color);
end;//end of with
//process
if choosecolor(a) then
   begin
   result:=true;
   _color:=colortorgb(a.rgbResult);
   end;//end of if
savecolors(bvfportable(bvfSettings)+'ColorWindow-CustomColors.txt',b,e);
except;end;
end;
//## foldercallback ##
function foldercallback(Wnd: HWND; uMsg: UINT; lParam, lpData: LPARAM):integer;
var
   tmp:string;
begin
try
case umsg of
BFFM_INITIALIZED:begin//.set initial path
   tmp:=asfolder(string(pchar(lpdata)));
   if directoryexists(tmp) then sendmessage(wnd,BFFM_SETSELECTION,1,longint(pchar(lpdata)));
   end;//end of begin
end;//end of case
except;end;
end;
//## folderdlg ##
function tmisc.folderdlg(title:string;var path:string):boolean;
const
   BIF_NEWDIALOGSTYLE     =$0040;{version 5.0 or higher of shell32.dll, win98/2=v4.72}
var
   lpItemID:PItemIDList;
   browseinfo:tbrowseinfo;
   displayname,temppath:array[0..MAX_PATH] of char;
   _path,tmp:string;
   len:integer;
begin
try
//defaults
result:=false;
//check - causes problems if used before app has fully loaded
if (application.mainform=nil) or (screen.activeform=nil) then exit;
//setup
if (title='') then title:=translate('Select Folder');
//process
//.get
fillchar(browseinfo,sizeof(tbrowseinfo),0);
fillchar(displayname,sizeof(displayname),0);
//.remove last slash (API accepts a) "c:\<dir>\<dir>", b) "c:\")
_path:=path;
len:=length(_path);
if (len>=2) and (_path[len]='\') and (_path[len-1]<>':') then _path:=copy(_path,1,len-1);
//.set
with browseinfo do
begin
hwndOwner:=screen.activeform.handle;//places dlg near active window
lpszTitle:=pchar(title);
pszDisplayName:=@displayname;
ulFlags:=BIF_NEWDIALOGSTYLE or BIF_RETURNONLYFSDIRS;//folders only
lpfn:=foldercallback;
lParam:=longint(pchar(_path));
end;
//.prompt
lpItemID:=SHBrowseForFolder(BrowseInfo);
if (lpItemId<>nil) then
   begin
   SHGetPathFromIDList(lpItemID,@temppath);
   tmp:=string(temppath);
   GlobalFreePtr(lpItemID);
   //return result
   if (tmp<>'') then
      begin
      path:=asfolder(tmp);
      result:=true;
      end;//end of if
   end;//end of if
except;end;
end;
//## opendlg ##
function tmisc.opendlg(defext,filters,idir:string;var filterindex:integer;var filename:string):boolean;
begin
try;result:=opendlgex(application.mainform.handle,defext,filters,idir,ntranslate('open'),filterindex,filename,true,false,true);except;end;
end;
//## opendlgb ##
function tmisc.opendlgb(defext,filters,idir:string;filterindex:integer;var filename:string):boolean;
begin
try;result:=opendlg(defext,filters,idir,filterindex,filename);except;end;
end;
//## savedlg ##
function tmisc.savedlg(defext,filters,idir:string;filterindex:integer;var filename:string;allowuserext:boolean):boolean;
begin
try;result:=savedlgb(defext,filters,idir,filterindex,filename,true,allowuserext);except;end;
end;
//## savedlgb ##
function tmisc.savedlgb(defext,filters,idir:string;var filterindex:integer;var filename:string;promptreplace,allowuserext:boolean):boolean;
begin
try;result:=opendlgex(application.mainform.handle,defext,filters,idir,ntranslate('save as'),filterindex,filename,false,promptreplace,allowuserext);except;end;
end;
//## opendlgex ##
function tmisc.opendlgex(handle:thandle;defext,filters,idir,title:string;var filterindex:integer;var filename:string;isopen,promptreplace,allowuserext:boolean):boolean;
label
   redo;
const//date: 26-JUL-2005
   OFN_READONLY = $00000001;
   OFN_OVERWRITEPROMPT = $00000002;
   OFN_HIDEREADONLY = $00000004;
   OFN_NOCHANGEDIR = $00000008;
   OFN_SHOWHELP = $00000010;
   OFN_ENABLEHOOK = $00000020;
   OFN_ENABLETEMPLATE = $00000040;
   OFN_ENABLETEMPLATEHANDLE = $00000080;
   OFN_NOVALIDATE = $00000100;
   OFN_ALLOWMULTISELECT = $00000200;
   OFN_EXTENSIONDIFFERENT = $00000400;
   OFN_PATHMUSTEXIST = $00000800;
   OFN_FILEMUSTEXIST = $00001000;
   OFN_CREATEPROMPT = $00002000;
   OFN_SHAREAWARE = $00004000;
   OFN_NOREADONLYRETURN = $00008000;
   OFN_NOTESTFILECREATE = $00010000;
   OFN_NONETWORKBUTTON = $00020000;
   OFN_NOLONGNAMES = $00040000;
   OFN_EXPLORER = $00080000;
   OFN_NODEREFERENCELINKS = $00100000;
   OFN_LONGNAMES = $00200000;
var
   a:topenfilename;
   szFile:array[0..MAX_PATH] of Char;
   _filename,_ext:string;
   _filterindex:integer;
begin
try
//defaults
result:=false;
_filename:='';
_filterindex:=1;
//dir
if (idir='') then idir:=extractfilepath(filename) else idir:=extractfilepath(idir);
//prepare
fillchar(a,sizeof(topenfilename),0);
with a do
begin
//.core
hInstance:=SysInit.HInstance;
hWndOwner:=handle;
lStructSize:=sizeof(topenfilename);
case isopen of
true:flags:=OFN_HIDEREADONLY or OFN_LONGNAMES or OFN_PATHMUSTEXIST or OFN_FILEMUSTEXIST;
false:flags:=OFN_HIDEREADONLY or OFN_LONGNAMES or OFN_PATHMUSTEXIST;
end;//end of if
//.other
lpstrFile:=szFile;
nMaxFile:=sizeof(szFile);
if (title<>'') then lpstrTitle:=PChar(Title);
if (idir<>'') then lpstrInitialDir:=PChar(iDir);
if not isopen then strpcopy(lpstrFile,general.remlastext(extractfilename(filename))) else strpcopy(lpstrFile,'');
lpstrFilter:=PChar(general.swapcharsb(Filters,'|',#0)+#0#0);
nFilterIndex:=word(filterindex);
if (DefExt<>'') then lpstrDefExt:=PChar(DefExt);
end;//end of with
//process
redo:
//.reset - if user cancels a "overwrite prompt", window is displayed again and below items must be assigned as structure is corrupted
a.lpstrFilter:=PChar(general.swapcharsb(Filters,'|',#0)+#0#0);
//get
case isopen of
true:if GetOpenFileName(a) then
        begin
        result:=true;
        _filename:=strpas(szFile);
        _filterindex:=a.nfilterindex;
        _ext:=getfilterextex(filters,general.insstr(_filename,allowuserext),_filterindex-1);//allow user specified extension via "_filename.user-extension"
        end;//end of if
false:if GetSaveFileName(a) then
        begin
        result:=true;
        _filename:=strpas(szFile);
        _filterindex:=a.nfilterindex;
        _ext:=getfilterextex(filters,general.insstr(_filename,allowuserext),_filterindex-1);//allow user specified extension via "_filename.user-extension"
        end;//end of if
end;//end of case
//finalise
if result then
   begin
   //enforce ext
   if (_ext<>'') then _filename:=general.remlastext(_filename)+'.'+_ext;
   //replace prompt
   if (not isopen) and promptreplace and fileexists(_filename) and (not showreplacefile(_filename,true)) then
      begin
      result:=false;
      goto redo;
      end;//end of if
   //set
   filename:=_filename;
   filterindex:=_filterindex;
   end;//end of if
except;end;
end;
//## setcursorpath ##
procedure tmisc.setcursorpath(x:string);
begin
try
if (x='') then x:=extfolder('.cur');
icursorpath:=asfolder(x);
except;end;
end;
//## getfilterext ##
function tmisc.getfilterext(x:string;i:integer):string;
begin
try;result:=getfilterextex(x,'',i);except;end;
end;
//## getfilterextex ##
function tmisc.getfilterextex(x,userext:string;i:integer):string;
var//Range of i = 0..N, where 0=first ext and N=last ext
   fi,si,p,c:integer;
   ignore:boolean;
begin
try
//defaults
result:='';
//init
i:=frcmin(i,0);
c:=-1;
si:=-1;
fi:=0;
ignore:=false;
//user
if (userext<>'') then
   begin
   userext:=readfileext(userext,true);
   if (userext<>'') then
      begin
      result:=userext;
      exit;
      end;//end of if
   end;//end of if
//scan
for p:=1 to length(x) do
begin
fi:=p+1;
if (x[p]='|') then
   begin
   if (not ignore) or (c=i) then
      begin
      inc(c);
      if (c=i) then si:=p+3//skip over "*." part from "*.colors"
      else if (c>i) then
         begin
         fi:=p-1;
         break;
         end;//end of loop
      end;//end of if
   ignore:=not ignore;
   end;//end of if
end;//end of loop
//.set
if (si>=0) then
   begin
   result:=uppercase(copy(x,si,fi-si+1));
   //check
   for p:=1 to length(result) do if (result[p]='*') or (result[p]=';') or (result[p]='|') then
      begin
      result:='';
      break;
      end;//end of if
   end;//end of if
except;end;
end;
//## getfilterinfo ##
function tmisc.getfilterinfo(_filename,_filters:string;var ext:string;var filterindex:integer):boolean;
var
   scanextlen,sp,c,p,extLEN:integer;
   ok:boolean;
   _ext,scanext:string;
begin
try
//defaults
result:=false;
filterindex:=1;
ext:='';
//init
_filters:=_filters+'|';
_ext:=readfileext(_filename,true);
scanext:='.'+_ext+'|';
scanextlen:=length(scanext);
ok:=true;
sp:=1;
c:=0;
//scan
for p:=1 to length(_filters) do if (_filters[p]='|') then
   begin
   if ok then
      begin
      inc(c);//"|*.bmp;*.jpg|" => ".bmp" = NO MATCH, "|*.bmp|" => ".bmp"  = MATCH
      if (0=comparetext(copy(_filters,p+2,scanextlen),scanext)) then
         begin
         //set
         filterindex:=c;
         ext:=_ext;
         //successful
         result:=true;
         break
         end;//end of if
      end;//end of if
   ok:=not ok;
   end;//end of if
except;end;
end;
//## openurl ##
function tmisc.openurl(var _address,_mask,_data,e:string;prompt:boolean):boolean;
begin
try;result:=navdlg.open(_address,_mask,_data,e,prompt);except;end;
end;
//## opentext ##
function tmisc.opentext(var filename,data,e:string;filters:string;prompt:boolean):boolean;
var
   filterindex:integer;
begin
try
filterindex:=1;
result:=opentextb(filename,data,e,filters,filterindex,prompt);
except;end;
end;
//## opentextb ##
function tmisc.opentextb(var filename,data,e:string;filters:string;var filterindex:integer;prompt:boolean):boolean;
var
   _filename:string;
begin
try
//defaults
result:=false;
data:='';
e:=gecOK;
_filename:=filename;
//process
//.prompt
if prompt then
   begin
   //.filters
   if (filters='') then
      begin
      filters:=
      ntranslate('text documents')+' (*.txt)|*.txt|'+
      ntranslate('all files')+' (*.*)|*.*';
      end;//end of if
   //.prompt (filename -> data)
   if not opendlg(getfilterextex(filters,'.txt',filterindex-1),filters,extractfilepath(_filename),filterindex,_filename) then
      begin
      e:=gecTaskCancelled;
      exit;
      end;//end of if
   //.set
   filename:=_filename;
   end;//end of if
//.load
result:=io.fromfile(filename,data,e);
except;end;
end;
//## savetext ##
function tmisc.savetext(var filename,data,e:string;filters:string;prompt:boolean):boolean;
var
   filterindex:integer;
begin
try
filterindex:=1;
result:=savetextb(filename,data,e,filters,filterindex,prompt);
except;end;
end;
//## savetextb ##
function tmisc.savetextb(var filename,data,e:string;filters:string;var filterindex:integer;prompt:boolean):boolean;
label
   redo,skipend;
var
   _filename,ext:string;
begin
try
//defaults
result:=false;
e:=gecOK;
_filename:=filename;
//process
//.prompt
if prompt then
   begin
   //.filters
   if (filters='') then
      begin
      filters:=
      ntranslate('text documents')+' (*.txt)|*.txt|'+
      ntranslate('all files')+' (*.*)|*.*';
      end;//end of if
   //.prompt (filename -> data)
redo:
   if not savedlgb(getfilterextex(filters,'.txt',filterindex-1),filters,extractfilepath(_filename),filterindex,_filename,false,true) then
      begin
      e:=gecTaskCancelled;
      goto skipend;
      end;//end of if
   //.replace prompt
   if not showreplacefile(_filename,true) then goto redo;
   //.set
   filename:=_filename;
   end;//end of if
//.load
result:=io.tofile(filename,data,e);
skipend:
except;end;
end;
//## cursordlg ##
function tmisc.cursordlg(var filename:string):boolean;
var
   f:string;
begin
try
f:=
 translate('Icon')+' (*.ico)|*.ico|'+
 translate('Cursor')+' (*.cur)|*.cur|'+
 translate('Animated')+#32+translate('Cursor')+' (*.ani)|*.ani|'+
 translate('All')+#32+translate('Cursors')+'|*.ico;*.cur;*.ani';
//.prompt (filename -> data)
result:=opendlg('',f,icursorpath,icursorfi,filename);
//.path
if result then cursorpath:=extractfilepath(filename);
except;end;
end;
//## imageextcount ##
function tmisc.imageextcount:integer;
begin
try
//defaults
result:=0;
//fill
if (iimageextlist=nil) then getimageext(0);
//get
if (iimageextlist<>nil) then result:=iimageextlist.count;
except;end;
end;
//## getimageext ##
function tmisc.getimageext(x:integer):string;
begin
try
//defaults
result:='';
//get
if (iimageextlist=nil) then
   begin
   iimageextlist:=tstringlist.create;
   iimageextlist.text:=imageexts;
   end;//end of if
//set
if (iimageextlist<>nil) and (x>=0) and (x<iimageextlist.count) then result:=iimageextlist.strings[x];
except;end;
end;
//## imageexts ##
function tmisc.imageexts:string;
var
   a:tstringlist;
   p:integer;
begin
try
//defaults
result:='';
a:=nil;
a:=tstringlist.create;
//get
a.text:=general.swapcharsb('bmp;wmf;emf;jpg;jpgt;jif;gif;ico;ppm;pgm;pbm;xbm;tep;atep;omi;san;ean;htm;html',';',#13);
//filter
for p:=(a.count-1) downto 0 do if not ccs.supportformat(a.strings[p]) then a.delete(p);
//return result
result:=a.text;
except;end;
try;freeobj(@a);except;end;
end;
//## imagelabel ##
function tmisc.imagelabel(extorfilename:string;var z:string):boolean;
label
   skipend;
var
   p:integer;
   ext:string;
begin
try
//defaults
result:=false;
z:='';
ext:=readfileext('.'+extorfilename,true);
//get
if ccs.supportformat(ext) then
   begin
   //decide
   if (ext='BMP') then z:=ntranslate('bitmap')
   else if (ext='WMF') then z:=ntranslate('windows metafile')
   else if (ext='EMF') then z:=ntranslate('windows enhanced metafile')
   else if (ext='JPG') then z:=ntranslate('optimised jpeg')
   else if (ext='JPGT') then z:=ntranslate('optimised transparent jpeg')
   else if (ext='JIF') then z:=ntranslate('jpeg')
   else if (ext='GIF') then z:=ntranslate('graphics interchange format')
   else if (ext='ICO') then z:=ntranslate('icon')
   else if (ext='PPM') then z:=ntranslate('portable pixelmap')
   else if (ext='PGM') then z:=ntranslate('portable graymap')
   else if (ext='PBM') then z:=ntranslate('portable bitmap')
   else if (ext='XBM') then z:=ntranslate('x bitmap')
   else if (ext='TEP') then z:=ntranslate('text picture')
   else if (ext='ATEP') then z:=ntranslate('animated text picture')
   else if (ext='OMI') then z:=ntranslate('optimised multiformat image')
   else if (ext='SAN') then z:=ntranslate('simple animation')
   else if (ext='EAN') then z:=ntranslate('enhanced animation')
   else if (ext='HTM') then z:=ntranslate('email signature')
   else if (ext='HTML') then z:=ntranslate('email signature')
   else goto skipend;
   //successful
   result:=true;
   end;//end of if
skipend:
except;end;
end;
//## imagelabelb ##
function tmisc.imagelabelb(extorfilename:string):string;
begin
try;imagelabel(extorfilename,result);except;end;
end;
//## imagelabelext ##
function tmisc.imagelabelext(extorfilename,sep1,sep2:string):string;
var//FORMAT = LABEL (*.EXT) <sep1> *.EXT <sep2>
   ext:string;
begin
try
//range
ext:=lowercase(readfileext('.'+extorfilename,false));
//get
result:=imagelabelb(ext)+' (*.'+ext+')'+sep1+general.insstr('*.'+ext+sep2,sep2<>'');
except;end;
end;
//## imageextdes ##
function tmisc.imageextdes(extorfilename,sep:string):string;
var//FORMAT = EXT <sep> LABEL
   ext:string;
begin
try
//range
ext:=lowercase(readfileext('.'+extorfilename,false));
sep:=general.udv(sep,' - ');
//get
result:=general.asname(ext)+sep+imagelabelb(ext);
except;end;
end;
//## imageextdesmany ##
function tmisc.imageextdesmany(manyextorfilenames:string;manysep:char;outsep,outeol:string):string;
var//accepts multiple filenames/extensions (separated by "manysep"
   ext:string;
   p:integer;
begin
try
//defaults
result:='';
//range
general.swapchars(manyextorfilenames,manysep,#13);
outsep:=general.udv(outsep,' - ');
//get
p:=1;
while general.nextline(p,manyextorfilenames,ext) do if (ext<>'') then
   begin
   //get
   ext:=lowercase(readfileext('.'+ext,false));
   //add
   result:=result+general.asname(ext)+outsep+imagelabelb(ext)+outeol;
   end;//end of if
except;end;
end;
//## imagefilters ##
function tmisc.imagefilters(all:boolean;sep1,sep2:string):string;
var
   tmp:integer;
begin
try;result:=imagefiltersex(all,sep1,sep2,'',tmp);except;end;
end;
//## imagefiltersex ##
function tmisc.imagefiltersex(all:boolean;sep1,sep2,eol:string;var count:integer):string;
var
   a:tstringlist;
   maxp,p:integer;
   z:string;
begin
try
//defaults
result:='';
a:=nil;
a:=tstringlist.create;
//get
a.text:=imageexts;
maxp:=a.count-1;
count:=a.count+general.insint(2,all);
//set
for p:=0 to maxp do result:=result+imagelabelext(a.strings[p],sep1,sep2)+eol;
//.all
if all then
   begin
   //get
   z:='';
   for p:=0 to maxp do z:=z+'*.'+a.strings[p]+general.insstr(';',p<maxp);
   //set
   result:=result+
    ntranslate('all pictures')+sep1+general.insstr(z+sep2,sep2<>'')+eol+
    ntranslate('all files')+' (*.*)'+sep1+general.insstr('*.*',sep2<>'')+eol;
   end;//end of if
except;end;
try;freeobj(@a);except;end;
end;
//## openimagedlg ##
function tmisc.openimagedlg(a:tbitmap;idir:string;var filename:string):boolean;
label
   skipend;
var
   i,c,p:integer;
   dext,e,f:string;
begin
try
//defaults
result:=false;
e:=gecUnexpectedError;
//check
if (a=nil) then goto skipend;
//init
f:=imagefilters(true,'|','|');
//get
getfilterinfo(filename,f,dext,i);
if opendlgex(application.mainform.handle,dext,f,idir,ntranslate('open image'),i,filename,true,false,true) then
   begin
   //.set
   if not ccs.fromfile(a,filename,e) then goto skipend;
   end
else
   begin
   e:='';
   goto skipend;//cancelled
   end;//end of if
//successful
e:='';
result:=true;
skipend:
except;end;
try;general.iferror(e);except;end;
end;
//## saveimagedlg ##
function tmisc.saveimagedlg(a:tbitmap;idir:string;var filename:string):boolean;
var
   _saved:boolean;
begin
try;result:=saveimagedlgex(a,idir,filename,_saved);except;end;
end;
//## saveimagedlgex ##
function tmisc.saveimagedlgex(a:tbitmap;idir:string;var filename:string;var _saved:boolean):boolean;
label
   skipend;
var
   i,c,p:integer;
   dext,e,f:string;
begin
try
//defaults
result:=false;
e:=gecUnexpectedError;
_saved:=false;
//check
if (a=nil) then goto skipend;
//init
f:=imagefilters(false,'|','|');
//get
getfilterinfo(filename,f,dext,i);
if opendlgex(application.mainform.handle,dext,f,idir,ntranslate('save image'),i,filename,false,true,false) then
   begin
   //set
   if not ccs.tofile(a,filename,e) then goto skipend;
   _saved:=true;
   end
else
   begin
   e:='';
   goto skipend;//cancelled
   end;//end of if
//successful
e:='';
skipend:
except;end;
try
result:=(e='');
general.iferror(e);
except;end;
end;
//## pastefromimagedlg ##
function tmisc.pastefromimagedlg(var sfilename,dfilename:string):boolean;
label//Copies an image file from an external location into current path "dfilename", converting it's format to "dfilename" format
     //Internal Error Handling
     //Result: TRUE=image transfered successfully, FALSE=cancelled or failed
   redo,skipend;
var
   a:tbitmapenhanced;
   ok:boolean;
   f,e:string;
begin
try
//defaults
result:=false;
e:=gecTaskFailed;
ok:=true;
a:=nil;
a:=tbitmapenhanced.create;
//get
if openimagedlg(a,extractfilepath(sfilename),sfilename) then
   begin
   //retain "dfilename" extension
   f:=retainformatext(extractfilepath(dfilename)+extractfilename(sfilename),dfilename,true);
   //prompt for new name of same "type"
redo:
   if fileexists(f) and (not newfilename60(f,f)) then goto skipend;
   if fileexists(f) then goto redo;
   //copy
   dfilename:=f;
   ok:=general.copyto(sfilename,dfilename);
   if ok then result:=true;
   end;//end of if
skipend:
except;end;
try
freeobj(@a);
if not ok then showerror60(ntranslate(e));
except;end;
end;
//## gat ##
function TMisc.gat(x:string):byte;//get address type
var
   a:tstringlist;
   y:string;
   c,p:integer;
begin
try
//defaults
result:=gatNil;
//check
if (x='') then exit;
//prepare
a:=nil;
//process
//.local file
if (copy(x,2,2)=':\') then result:=gatLocalFile
//.network file
else if (copy(x,1,2)='\\') then result:=gatNetworkFile
//.web or ip address
else
    begin
    //assume web address
    result:=gatWebAddress;
    //parse
    y:=x;
    for p:=1 to length(x) do if (x[p]='/') then
        begin
        y:=copy(x,1,p-1);
        break;
        end;//end of if
    general.swapstrs(y,'.',rcode);
    a:=tstringlist.create;
    a.text:=y;
    //get
    if (a.count>=4) then
       begin
       c:=0;
       for p:=0 to 3 do if (a.strings[p]=inttostr(strint(a.strings[p]))) then c:=c+1 else break;
       if (c>=4) then result:=gatIPAddress;
       end;//end of if
    end;//end of if
except;end;
try;freeobj(@a);except;end;
end;
//## EnforceService ##
Function TMisc.EnforceService(X:String):String;
begin
try
{Process}
Case IsWebService(X) of
True:Result:='http://'+StripService(X,False);
False:Result:='mailto:'+StripService(X,False);
end;//end of case
except;end;
end;
//## IsWebService ##
Function TMisc.IsWebService(X:String):Boolean;
Var
   cP,P,MaxP:Integer;
begin
try
{Default}
Result:=True;
{Prepare}
X:=StripService(X,False);
MaxP:=Length(X);
//Web
For P:=1 to MaxP Do If (X[P]='/') or (X[P]='\') then exit;
//Email
cP:=0;
For P:=1 to MaxP Do If (X[P]='@') then cP:=cP+1;
If (cP=1) then
   begin
   Result:=False;
   exit;
   end;//end of if
except;end;
end;
{//yyyyyyyyyyyyyy
//## fc ##
procedure TMisc.fc(x:trichedit);//font check
begin
try
//DefAttributes
If (x.DefAttributes.Name<>x.Font.Name) then x.DefAttributes.Name:=x.Font.Name;
If (x.DefAttributes.CharSet<>x.Font.CharSet) then x.DefAttributes.CharSet:=x.Font.CharSet;
If (x.DefAttributes.Size<>x.Font.Size) then x.DefAttributes.Size:=x.Font.Size;
If (x.DefAttributes.Color<>x.Font.Color) then x.DefAttributes.Color:=x.Font.Color;
If (x.DefAttributes.Style<>x.Font.Style) then x.DefAttributes.Style:=x.Font.Style;
except;end;
end;
{}
//## alignmentcalc ##
function tmisc.alignmentcalc(a:talignment;left,textwidth,right:integer):integer;
begin
try
//defaults
result:=left;
//process
if (a=taCenter) then result:=left+(((right-left)-textwidth) div 2)
else if (a=taRightJustify) then result:=right-textwidth;
except;end;
end;
//## fontheight ##
function tmisc.fontheight(x:tfont):integer;
begin
try
//defaults
result:=0;
//process
//.get
if (x=nil) then exit;
//.set
iimg.canvas.font.assign(x);
result:=iimg.canvas.textheight('#');
except;end;
end;
//## fontwidth ##
function tmisc.fontwidth(x:tfont;y:string):integer;
begin
try
//defaults
result:=0;
//process
//.get
if (x=nil) then exit;
//.set
iimg.canvas.font.assign(x);
result:=iimg.canvas.textwidth(y);
except;end;
end;
{//yyyyyyyyyyyyyyy//xxx
//## MaxLen ##
function TMisc.MaxLen(x:trichedit;y:integer):boolean;
var
   a:tstringstream;
begin
try
//error
result:=false;
//check
if (x=nil) then exit;
//prepare
a:=nil;
//process
//enforce range
if (y<=0) then y:=409600*3;//1.2288Mb
//get
a:=tstringstream.create(general.nullstr(y,'A'));
a.position:=0;
//set
x.lines.clear;
x.lines.loadfromstream(a);
//successful
result:=true;
except;end;
try
if (x<>nil) then x.lines.clear;
a.free;
except;end;
end;
{}

//## tsuptrans #################################################################
//## create ##
constructor tsuptrans.create;
var
   tmp:string;
   p:integer;
begin
//self
inherited;
//vars
fillchar(iactive,sizeof(iactive),0);
ipactive:=@iactive;
fillchar(ihit,sizeof(ihit),0);
iphit:=@ihit;
ilimit:=2500;//max number of allowed translation - prevents accidential translation sprial overflow (if a translation of translation situation occurs over a long time)
//controls
ieng:=tdynamicnamelist.create;
ioth:=tdynamicstring.create;
istyle:=tdynamicbyte.create;
//SYSTEM ERRORS
for p:=0 to (general.syserrCount-1) do if general.syserr(p,tmp) then addonce(tmp,'',stError);
//NETWORK ERRORS
for p:=0 to (general.neterrCount-1) do if general.neterr(p,tmp) then addonce(tmp,'',stError);
//defaults
itimer:=mt.new(_ontimer,2000,true);
end;
//## createsys ##
constructor tsuptrans.createsys(sysVar:prootobject);
var
   e:string;
begin
//self
inherited createsys(sysVar);
//.system related
if (sysstate=ssOK) then
   begin
   if (comparetext(programnameHARD,'select language')<>0) then fill(vs.s[vsSuptrans],true);
   end;//end of if
end;
//## destroy ##
destructor tsuptrans.destroy;
begin
try
//timer
mt.del(itimer);
//controls
freeobj(@ieng);
freeobj(@ioth);
freeobj(@istyle);
//self
inherited;
except;end;
end;
//## stats ##
function tsuptrans.stats(showall:boolean;colsep,linesep:string):string;
const
   ma='-- ';
   mb=' --';
   sep='/';
begin
try
//range
colsep:=general.udv(colsep,#9);
linesep:=general.udv(linesep,rcode);
//get
result:=
ma+tsInformation+mb+linesep+
tsLanguage+colsep+general.udv(ilanguage,'English')+linesep+
linesep+
ma+tsLookup+mb+linesep+
tsSuccessful+colsep+general.curcomma(ihit.good)+linesep+
tsNotFound+colsep+general.curcomma(ihit.fail)+linesep+
tsTotal+colsep+general.curcomma(ihit.total)+linesep+
linesep+
ma+tsCoverage+mb+linesep+
tsGUI+colsep+general.thousands(iactive.Umain)+sep+general.thousands(iactive.main)+linesep+
tsRealtimeHelp+colsep+general.thousands(iactive.Uhelp)+sep+general.thousands(iactive.help)+linesep+
tsError+colsep+general.thousands(iactive.Uerror)+sep+general.thousands(iactive.error)+linesep+
tsUnused+colsep+general.thousands(iactive.Uunused)+sep+general.thousands(iactive.unused)+linesep+
tsTotal+colsep+general.thousands(iactive.Utotal)+sep+general.thousands(iactive.total)+linesep;
except;end;
end;
//## _ontimer ##
procedure tsuptrans._ontimer(sender:tobject);
begin
try
//syncinfo
if imustupdateinfo then
   begin
   imustupdateinfo:=false;
   syncinfo;
   end;//end of if
except;end;
end;
//## syncinfo ##
procedure tsuptrans.syncinfo;
var
   a:ttransinfo;
   p:integer;
   s:byte;
begin
try
//init
fillchar(a,sizeof(a),0);
//info
for p:=(ieng.count-1) downto 0 do if (ieng.items[p]^<>'') then
   begin
   //get
   s:=istyle.items[p];
   //decide
   case s of
   stNa:general.iroll(a.unused,1);
   stError:general.iroll(a.error,1);
   stMain:general.iroll(a.main,1);
   stHelp:general.iroll(a.help,1);
   end;//end of case
   general.iroll(a.total,1);
   //used counts
   if (ioth.items[p]^<>'') then
      begin
      case s of
      stNa:general.iroll(a.Uunused,1);
      stError:general.iroll(a.Uerror,1);
      stMain:general.iroll(a.Umain,1);
      stHelp:general.iroll(a.Uhelp,1);
      end;//end of case
      general.iroll(a.Utotal,1);
      end;//end of if
   end;//end of if
//set
iactive:=a;
ifull:=(a.utotal>=ilimit);
except;end;
end;
//## flush ##
procedure tsuptrans.flush;
var
   p:integer;
begin
try
//scan
for p:=0 to (ieng.count-1) do
   begin
   ioth.items[p]^:='';
   if (istyle.items[p]=stNa) then ieng.items[p]^:='';
   end;//end of if
//update
imustupdateinfo:=true;
except;end;
end;
//## fill ##
procedure tsuptrans.fill(x:string;init:boolean);
label
   skipend;
const
   a1='[ORG]>';
   a2='[NEW]>';
   alen=6;
var
   a:tstringlist;
   zlen,p:integer;
   tmp,format,z6,z,_language,_details,_tep,_eng,_oth:string;
   binary,ok:boolean;
begin
try
//defaults
a:=nil;
a:=tstringlist.create;
_language:='';
_details:='';
_tep:='';
//flush
general.iroll(iid,1);
if (fmultilingual<>nil) then fmultilingual.clearlast;//remove last cache entry
flush;
//init
a.text:=x;
//GET
_eng:='';
_oth:='';
p:=0;
if (p>=a.count) then goto skipend;
//scan
repeat
z:=a.strings[p];
zlen:=length(z);
z6:=copy(z,1,alen);
ok:=false;
if (zlen>=alen) then
   begin
   //.eng
   if (comparetext(z6,a1)=0) then
      begin
      ok:=true;
      //prev
      if (_eng<>'') then
         begin
         if init then addonce(_eng,'',stNa) else sync(_eng,'');
         end;//end of if
      //set
      _eng:=copy(z,alen+1,zlen);
      _oth:='';
      end
   //.oth
   else if (comparetext(z6,a2)=0) then
      begin
      ok:=true;
      //set
      _oth:=copy(z,alen+1,zlen);
      if (_eng<>'') then
         begin
         if init then addonce(_eng,_oth,stNa) else sync(_eng,_oth);
         end;//end of if
      //clear
      _eng:='';
      _oth:='';
      end;//end of if
   end;//end of if
//other
if (not ok) and (zlen>=1) and (z[1]='[') then
   begin
   _eng:='';
   _oth:='';
   if (comparetext(copy(z,1,11),'[language]>')=0) then _language:=copy(z,12,zlen)
   else if (comparetext(copy(z,1,18),'[acknowledgement]>')=0) then _details:=copy(z,19,zlen)
   else if (comparetext(copy(z,1,6),'[tep]>')=0) then
      begin
      tmp:=copy(z,7,zlen);
      if ccs.findformat(tmp,format,binary) and ((format='TEP') or (format='ANM')) then _tep:=tmp;
      end;//end of if
   end;//end of if
//inc
inc(p);
until (p>=a.count);//end of loop
skipend:
except;end;
try
freeobj(@a);
//update
ilanguage:=general.udv(_language,ntranslate('english'));
idetails:=_details;
itep:=_tep;
imustupdateinfo:=true;
except;end;
end;
//## gettext ##
function tsuptrans.gettext:string;
const
   a1='[ORG]>';
   a2='[NEW]>';
var
   len,p:integer;
   once:boolean;
   sep:string;
begin
try
//defaults
result:='';
len:=0;
//init
sep:=general.nullstr(80,'#');
//GET
//information
pushb(len,result,general.replacec(' Information ',sep,3)+rcode+rcode);
pushb(len,result,'[Language]>'+ilanguage+rcode);
pushb(len,result,'[Acknowledgement]>'+idetails+rcode);
pushb(len,result,'[TEP]>'+itep+rcode);
pushb(len,result,rcode);
//main
once:=true;
for p:=0 to (ieng.count-1) do if (istyle.items[p]=stMain) and (ieng.items[p]^<>'') then
   begin
   if once then pushb(len,result,general.replacec(' GUI Translation ',sep,3)+rcode+rcode);
   pushb(len,result,a1+ieng.items[p]^+rcode+a2+ioth.items[p]^+rcode+rcode);
   once:=false;
   end;//end of if
//help
once:=true;
for p:=0 to (ieng.count-1) do if (istyle.items[p]=stHelp) and (ieng.items[p]^<>'') then
   begin
   if once then pushb(len,result,general.replacec(' Realtime Help Translation ',sep,3)+rcode+rcode);
   pushb(len,result,a1+ieng.items[p]^+rcode+a2+ioth.items[p]^+rcode+rcode);
   once:=false;
   end;//end of if
//error
once:=true;
for p:=0 to (ieng.count-1) do if (istyle.items[p]=stError) and (ieng.items[p]^<>'') then
   begin
   if once then pushb(len,result,general.replacec(' Error Translation ',sep,3)+rcode+rcode);
   pushb(len,result,a1+ieng.items[p]^+rcode+a2+ioth.items[p]^+rcode+rcode);
   once:=false;
   end;//end of if
//unused
once:=true;
for p:=0 to (ieng.count-1) do if (istyle.items[p]=stNa) and (ieng.items[p]^<>'') then
   begin
   if once then pushb(len,result,general.replacec(' Currently Unused Translation ',sep,3)+rcode+rcode);
   pushb(len,result,a1+ieng.items[p]^+rcode+a2+ioth.items[p]^+rcode+rcode);
   once:=false;
   end;//end of if
//finalise
pushb(len,result,'');
except;end;
end;
//## settext ##
procedure tsuptrans.settext(x:string);
begin
try;fill(x,false);except;end;
end;
//## getvalid ##
function tsuptrans.getvalid(x:integer):boolean;
begin
try;result:=(x>=0) and (x<ieng.count);except;end;
end;
//## geteng ##
function tsuptrans.geteng(x:integer):string;
begin
try;if valid[x] then result:=ieng.value[x] else result:='';except;end;
end;
//## getoth ##
function tsuptrans.getoth(x:integer):string;
begin
try;if valid[x] then result:=ioth.items[x]^ else result:='';except;end;
end;
//## findeng ##
function tsuptrans.findeng(x:string;var i:integer):boolean;
begin
try
//defaults
result:=false;
i:=-1;
//get
if (ieng.count>=1) then
   begin
   i:=ieng.findfast(0,x);
   if (ioth.items[i]^='') then i:=-1;
   end;//end of if
//set
result:=(i>=0);
//hit
general.croll(ihit.total,1);
if result then general.croll(ihit.good,1) else general.croll(ihit.fail,1);
except;end;
end;
//## syncsizes ##
procedure tsuptrans.syncsizes;
var
   c:integer;
begin
try
//get
c:=ieng.count;
//set
if (c>ioth.count) then ioth.value[c-1]:='';
if (c>istyle.count) then istyle.value[c-1]:=0;
except;end;
end;
//## addonce ##
procedure tsuptrans.addonce(_eng,_oth:string;_style:byte);
var
   p:integer;
   _new:boolean;
begin
try
//defaults
_new:=false;
//check
if (_eng='') then exit;
//get
if ifull then p:=ieng.findfast(0,_eng) else p:=ieng.addex(_eng,false,_new);
//set
if (p>=0) then
   begin
   //set
   if _new then
      begin
      syncsizes;
      ioth.items[p]^:=_oth;
      end;//end of if
   //sync - shift "style" to higher range
   if _new or ((_style<>stNa) and (istyle.value[p]=stNa)) then
      begin
      istyle.items[p]:=_style;
      //update
      imustupdateinfo:=true;
      end;//end of if
   end;//end of if
except;end;
end;
//## sync ##
procedure tsuptrans.sync(_eng,_oth:string);
var
   _new:boolean;
   p:integer;
begin
try
if (_eng<>'') then
   begin
   //add - some translation "unused" must be added (to prevent them being left out)
   if ifull then p:=ieng.findfast(0,_eng) else p:=ieng.addex(_eng,false,_new);
   if (p>=0) then
      begin
      if _new then syncsizes;
      ioth.items[p]^:=_oth;
      end;//end of if
   end;//end of if
except;end;
end;

//########################### tscript ##########################################
//-- Note for variables: $=system, @/=user, all others=temp
//## issystem ##
function tscript.issystem(name:string):boolean;
begin
try;result:=(name<>'') and (name[1]='$');except;end;
end;
//## isuser ##
function tscript.isuser(name:string):boolean;
begin
try;result:=(name<>'') and ((name[1]='@') or (name[1]='/'));except;end;
end;
//## istemp ##
function tscript.istemp(name:string):boolean;
begin
try;result:=(name<>'') and (name[1]<>'$') and (name[1]<>'@') and (name[1]<>'/');except;end;
end;
//## getmv ##
function tscript.getmv(core,temp:tdynamicvars;name:string):string;//get multi-value
begin//assumes (core<>nil) and (temp<>nil)
try;if istemp(name) then result:=temp.value[name] else result:=core.value[name];except;end;
end;
//## setmv ##
procedure tscript.setmv(core,temp:tdynamicvars;name,value:string);//set multi-value
begin//assumes (core<>nil) and (temp<>nil)
try;if istemp(name) then temp.value[name]:=value else core.value[name]:=value;except;end;
end;
//## getmc ##
function tscript.getmc(core,temp:tdynamicvars;name:string):currency;
begin
try;if istemp(name) then result:=temp.c[name] else result:=core.c[name];except;end;
end;
//## setmc ##
procedure tscript.setmc(core,temp:tdynamicvars;name:string;value:currency);
begin
try;if istemp(name) then temp.c[name]:=value else core.c[name]:=value;except;end;
end;
//## getmi ##
function tscript.getmi(core,temp:tdynamicvars;name:string):integer;
begin
try;if istemp(name) then result:=temp.i[name] else result:=core.i[name];except;end;
end;
//## setmi ##
procedure tscript.setmi(core,temp:tdynamicvars;name:string;value:integer);
begin
try;if istemp(name) then temp.i[name]:=value else core.i[name]:=value;except;end;
end;
//## getmb ##
function tscript.getmb(core,temp:tdynamicvars;name:string):boolean;
begin
try;if istemp(name) then result:=temp.b[name] else result:=core.b[name];except;end;
end;
//## setmb ##
procedure tscript.setmb(core,temp:tdynamicvars;name:string;value:boolean);
begin
try;if istemp(name) then temp.b[name]:=value else core.b[name]:=value;except;end;
end;
//## setup ##
function tscript.setup(var core,temp:tdynamicvars):boolean;
begin
try
result:=(core<>nil);
if (temp=nil) then temp:=core;
except;end;
end;
//## exec ##
procedure tscript.exec(core,temp:tdynamicvars;defpath,content:string);
label//vars: $=system(readonly), @=temp(read/write), all others are user(read/write)
   skipone,skipend;
var
   p,_blen,_pos,_start,_length:integer;
   e,_blockname,_block,cmd,tmp,tmp1,tmp2:string;
begin
try
//check
if not setup(core,temp) then exit;
if (content='') then exit;
//.defpath
if (defpath='') then defpath:='C:\';
defpath:=asfolder(defpath);
//prepare
_pos:=1;
_blen:=0;
_blockname:='';
_block:='';
//process
//.set
while general.readline(_pos,_start,_length,content) do
begin
//.get
tmp:=copy(content,_start,_length);
cmd:=uppercase(copy(tmp,1,8));
//.decide
if (cmd<>'') and (cmd[1]='/') then
   begin
   if (copy(cmd,1,2)='//') then goto skipone
   //.VARIABLES
   else if (copy(cmd,1,4)='/END') and (_blockname<>'') then
        begin
        //.finalise
        pushb(_blen,_block,'');
        //.set
        tmp1:=copy(_blockname,1,1);
        _blockname:=copy(_blockname,2,length(_blockname));
        //..ban any variables starting with "$"
        if not issystem(_blockname) then
           begin
           if (tmp1='V') then mv[core,temp,_blockname]:=_block
           else if (tmp1='6') then mv[core,temp,_blockname]:=io.fromb64b(_block);
           end;//end of if
        //.reset
        _blen:=0;
        _blockname:='';
        _block:='';
        end
   else if (_blockname<>'') then
        begin
        pushb(_blen,_block,tmp+rcode);
        goto skipone;//within block
        end
   else if (copy(cmd,1,8)='/VARLOAD') then
        begin
        //.prepare
        tmp:=copy(tmp,10,length(tmp));
        general.split(tmp,tmp1,tmp2,'=');
        tmp:='';
        //.get
        if not issystem(tmp1) then
           begin
           if (copy(tmp2,2,1)<>':') and (copy(tmp2,1,2)<>'\\') then tmp2:=defpath+tmp2;//insert "default" local path "C:\defpath\"
           io.fromFILEc(tmp2,tmp,e,10);
           //.set
           mv[core,temp,tmp1]:=tmp;
           end;//end of if
        end
   else if (copy(cmd,1,7)='/VARB64') then _blockname:='6'+copy(tmp,9,length(tmp))
   else if (copy(cmd,1,5)='/VARB') then _blockname:='V'+copy(tmp,7,length(tmp))
   else if (copy(cmd,1,4)='/VAR') then
        begin
        //.get
        tmp:=copy(tmp,6,length(tmp));
        //.set
        general.split(tmp,tmp1,tmp2,'=');
        if not issystem(tmp1) then mv[core,temp,tmp1]:=tmp2;
        end
   else if (copy(cmd,1,7)='/EQUATE') then
        begin
        tmp1:=copy(tmp,9,length(tmp));
        if not issystem(tmp1) then equate(core,temp,tmp1);
        end
   //.ACTIONS
   else if (copy(cmd,1,5)='/STOP') then break
   end
else if (_blockname<>'') then pushb(_blen,_block,tmp+rcode);//end of if
skipone:
end;//end of loop
skipend:
except;end;
end;
//## equate ##
procedure tscript.equate(core,temp:tdynamicvars;name:string);
var
   p:integer;
begin
try
//check
if not setup(core,temp) then exit;
//process
p:=core.find(name);
if (p<>-1) then equatevalue(core,temp,core.valueiptr[p]^);
except;end;
end;
//## equatevalue ##
procedure tscript.equatevalue(core,temp:tdynamicvars;var value:string);
var//vars: $=system (readonly), @=temp(read/write), all others are user(read/write)
   tmpc:currency;
   count,dc,cc,s,vLEN,p2,p,xLEN,_pos:integer;
   tmp,cmd,vname,v:string;
   a:char;
begin
try
//check
if not setup(core,temp) then exit;
//prepare
xLEN:=length(value);
cmd:='';
vname:='';
count:=0;
//process
//.loop
_pos:=1;
while TRUE do
begin
//.search
if general.findtext(_pos,value,'<EQUATE') then
   begin//1
   inc(count);
   p:=_pos+7;
   //.end
   if general.findtext(p,value,'>') then
      begin//2
      //.cmd
      tmp:=copy(value,_pos+7,p-_pos-7);
      p2:=1;
      cmd:=uppercase(general.findbrkval(p2,tmp,'('));
      //.vname
      for p2:=(p-1) downto (_pos+7) do if (value[p2]=#32) or (value[p2]=')') then
          begin
          vname:=copy(value,p2+1,p-p2-1);
          break;
          end;//end of if
      //.commands
      if (cmd=',') or (cmd='THOUSANDS') then v:=general.curcomma(mc[core,temp,vname])//comma-separated
      else if (cmd='NEXT') or (cmd='PULL') then v:=next(core,temp,vname)
      else if (copy(cmd,1,5)='SHIFT') then//shift32
           begin
           cc:=strint(copy(cmd,6,1));
           dc:=strint(copy(cmd,7,1));
           tmpc:=mc[core,temp,vname];
           if (cc>=1) then tmpc:=(tmpc/power(10,cc));
           v:=general.curdec(tmpc,dc,true);
           end
      else if (cmd='UPPER') then v:=uppercase(mv[core,temp,vname])//uppercase
      else if (cmd='LOWER') then v:=lowercase(mv[core,temp,vname])//lowercase
      else if (cmd='HTMLSWAP') then
           begin
           v:=mv[core,temp,vname];
           general.swapchars(v,'(','<');
           general.swapchars(v,')','>');
           end
      else if (cmd='SEC') then v:=general.strdec(floattostrex2(mi[core,temp,vname]/1000),2,false)//milli-seconds as seconds "x.yz"
      else if (cmd='HTML') then v:=net_encode_for_html_b(mv[core,temp,vname])//encode for html
      else if (cmd='EURL') then v:=net_encode_str_b(mv[core,temp,vname])//encode url
      else if (cmd='DURL') then v:=net_decode_str_b(mv[core,temp,vname])//decode url
      else if (cmd='BOOLEAN') then v:=general.aorbstr('FALSE','TRUE',mb[core,temp,vname])
      else if (cmd='CHECKED') then v:=general.aorbstr('',#32+'CHECKED',mb[core,temp,vname])
      else if (cmd='YES') then v:=general.aorbstr('no','yes',mb[core,temp,vname])
      else if (cmd='RANDOM') then
           begin
           //.get
           v:=mv[core,temp,vname];
           vLEN:=length(v);
           if (vLEN>=1) then
              begin
              //.prepare
              a:=v[1];
              cc:=0;
              s:=2;
              //.count /v1/v2/v3/ (4 boundaries, 3 values)
              for p2:=1 to vLEN do if (v[p2]=a) then inc(cc);
              //.get
              dc:=frcrange(1+random(cc-1),1,cc);//1..count
              cc:=0;
              for p2:=2 to vLEN do if (v[p2]=a) then
                  begin
                  inc(cc);
                  if (cc<dc) then s:=p2+1
                  else
                      begin
                      v:=copy(v,s,p2-s);
                      break;
                      end;//end of if
                  end;//end of if
              end;//end of if
           end
      else if (copy(cmd,1,1)='X') then
           begin
           try;v:=general.curcomma(mc[core,temp,vname]*strint(copy(cmd,2,length(cmd))));except;end;
           end
      else v:=mv[core,temp,vname];//end of if
      //.set
      value:=copy(value,1,_pos-1)+v+copy(value,p+1,xLEN);
      xLEN:=length(value);
      end
      else break;//2
   end
   else break;//1
//.check (upto 10K tags)
if (count>=10000) then break;
end;//end of while
except;end;
end;
//## next ##
function tscript.next(core,temp:tdynamicvars;name:string):string;
var
   pn:string;
   d:pstring;
   c,i,_pos,_start,_length,op,p:integer;
   z:tdynamicvars;
begin
try
//defaults
result:='';
//check
if (name='') then exit;
if not setup(core,temp) then exit;
if istemp(name) then z:=temp else z:=core;
//prepare
pn:='next___'+name;
_pos:=1;
//process
//.find
i:=z.find(name);
if (i=-1) then exit else d:=z.valueiptr[i];
//.inc
p:=z.i[pn];
op:=p;
//.scan
c:=0;
while general.readline(_pos,_start,_length,d^) do
begin
//..get
if (c=0) or (c>=p) then
   begin
   result:=copy(d^,_start,_length);
   if (c>=p) then
      begin
      inc(p);
      break;
      end;//end of if
   end;//end of if
//..next
inc(c);
end;//end of while
//.set
if (op=p) then p:=1;
z.i[pn]:=p;
except;end;
end;

//########################### thtmltemplate ####################################
//## create ##
constructor thtmltemplate.create;
begin
inherited;
end;
//## destroy ##
destructor thtmltemplate.destroy;
begin
try
//self
inherited;
except;end;
end;
//## table ##
function thtmltemplate.table(cap,caplinks,data:string;sep:char;encode:boolean;cols,border,width:integer):string;
begin
try;result:=tableb(cap,caplinks,data,sep,encode,false,true,true,cols,border,width,0);except;end;
end;
//## tableb ##
function thtmltemplate.tableb(cap,caplinks,data:string;sep:char;encode,rawcode,topline,strong:boolean;cols,border,width,cellpad:integer):string;
begin
try;result:=tablec(cap,caplinks,data,sep,encode,rawcode,topline,strong,cols,border,width,cellpad,viNormal.hborder,viNormal.hbackground,viTitle.hbackground,viTitle.hfont,'',viNormal.hbackshade);except;end;
end;
//## tablec ##
function thtmltemplate.tablec(cap,caplinks,data:string;sep:char;encode,rawcode,topline,strong:boolean;cols,border,width,cellpad:integer;cborder,cbackground,cbacktitle,cfonttitle,crow1,crow2:string):string;
var
   lp,len,c,p:integer;
   dLEN:integer;
   bgc,a,b,tmp:string;
   cc:boolean;
begin
try
//defaults
result:='';
//range
dLEN:=length(data);
border:=frcmin(border,1);
cols:=frcmin(cols,1);
len:=0;
cc:=false;
if (width<-100) then width:=-100
else if (width=0) then width:=-100;//100%
cellpad:=frcmin(cellpad,0);
if encode then net_encode_for_html(cap);
if (cborder='') then cborder:='black';
if (cbackground='') then cbackground:='white';
if (cbacktitle='') then cbacktitle:='white';
if (cfonttitle='') then cfonttitle:='black';
//process
//.borders
pushb(len,result,
'<table bgcolor='+cborder+' width='+general.aorbstr(inttostr(width),inttostr(-width)+'%',width<=0)+' cellpadding='+inttostr(border)+' cellspacing=0 border=0>'+rcode+
'<td>'+rcode+
'<table bgcolor='+cbackground+' width=100% cellpadding=0 cellspacing=0 border=0>'+rcode+
'<td>'+rcode+
//.caption
 general.insstr(
 '<table bgcolor='+cbackground+' width=100% cellpadding=1 cellspacing=0 border=0>'+rcode+
 '<tr bgcolor='+cbacktitle+'><td><font'+general.insstr(' size="+1"',strong)+general.insstr(' color='+cfonttitle,cfonttitle<>'')+'><strong>'+cap+'</strong></font></td>'+
 general.insstr('<td align=right>',caplinks<>'')+caplinks+general.insstr('</td>',caplinks<>'')+
 '</tr>'+rcode+
 '</table>'+rcode,(cap<>'') or (caplinks<>''))+
 //.top line
 general.insstr(
  '<table bgcolor='+cborder+' width=100% cellspacing=0 border=0>'+rcode+
  '<tr><td height='+inttostr(border)+' bgcolor='+cborder+'></td></tr>'+rcode+
  '</table>'+rcode
 ,topline)+
 //.content
 '<table bgcolor='+cbackground+' width=100% cellpadding='+inttostr(cellpad)+' cellspacing=0 border=0>'+rcode);
 //.set
 c:=1;
 lp:=1;
 for p:=1 to dLEN do
 begin
 //.get
 if (data[p]=sep) or (p=dLEN) then
    begin
    //.tmp
    tmp:=copy(data,lp,p-lp+integer(data[p]<>sep));
    lp:=p+1;
    //.column
    if (c=1) then
       begin
       if cc then bgc:=crow2 else bgc:=crow1;
       pushb(len,result,'<tr'+general.insstr(' bgcolor='+bgc,bgc<>'')+'>');
       end;//end of if
    //.rawcode
    a:='<td>';
    b:='</td>';
    if rawcode then
       begin
       if (comparetext(copy(tmp,1,3),'<td')=0) then a:='';
       if (comparetext(copy(tmp,length(tmp)-3,4),'/td>')=0) then b:='';
       end;//end of if
    //.encode
    if encode then net_encode_for_html(tmp);
    //.add
    pushb(len,result,a+tmp+b);
    //.inc
    inc(c);
    if (c>cols) or (p=dLEN) then
       begin
       c:=1;
       cc:=not cc;
       pushb(len,result,'</tr>'+rcode);
       end;//end of if
    end;//end of if
 end;//end of loop
 //.finalise
 pushb(len,result,
 '</table>'+rcode+
//.borders
'</td></table>'+rcode+
'</td></table>'+rcode);
pushb(len,result,'');
except;end;
end;
//## window ##
function thtmltemplate.window(cap,caplinks,data:string;encode,topline,bottompad:boolean;border,width:integer):string;
begin
try;result:=windowb(cap,caplinks,data,encode,true,bottompad,border,width,0);except;end;
end;
//## windowb ##
function thtmltemplate.windowb(cap,caplinks,data:string;encode,topline,bottompad:boolean;border,width,cellpad:integer):string;
var//Automatically inserts "<td>..</td>" for "data" if not present
   lp,len,c,p:integer;
   a,b:string;
begin
try
//defaults
result:='';
len:=0;
//range
border:=frcmin(border,1);
if (width<-100) then width:=-100
else if (width=0) then width:=-100;//100%
cellpad:=frcmin(cellpad,0);
//process
//.borders
pushb(len,result,
'<table bgcolor='+viNormal.hborder+' width='+general.aorbstr(inttostr(width),inttostr(-width)+'%',width<=0)+' cellpadding='+inttostr(border)+' cellspacing=0 border=0>'+rcode+
'<td>'+rcode+
'<table bgcolor='+viNormal.hbackshade+' width=100% cellpadding=0 cellspacing=0 border=0>'+rcode+
'<td>'+rcode+
//.caption
 '<table bgcolor='+viNormal.hbackground+' width=100% cellpadding=1 cellspacing=0 border=0>'+rcode+
 '<tr bgcolor='+viTitle.hbackground+'><td><font size="+1" color='+viTitle.hfont+'><strong>'+net_encode_for_html_b(cap)+'</strong></font></td>'+
 general.insstr('<td align=right>',caplinks<>'')+caplinks+general.insstr('</td>',caplinks<>'')+
 '</tr>'+rcode+
 general.insstr('<tr><td height='+inttostr(border)+' bgcolor='+viNormal.hborder+'></td></tr>'+rcode,topline)+
 '</table>'+rcode+
//.content
 general.insstr('<table width=100% cellpadding='+inttostr(cellpad)+' cellspacing=0 border=0><td>&nbsp;</td></table>'+rcode,bottompad)+
 '<table width=100% cellpadding='+inttostr(cellpad)+' cellspacing=0 border=0>'+rcode);
 a:='<td>';
 b:='</td>';
 if (comparetext(copy(data,1,3),'<td')=0) or (comparetext(copy(data,1,3),'<tr')=0) then a:='';
 if (comparetext(copy(data,length(data)-3,4),'/td>')=0) or (comparetext(copy(data,length(data)-3,4),'/tr>')=0) then b:='';
 if encode then net_encode_for_html(data);
 pushb(len,result,a+data+b+rcode+'</table>'+rcode+
  general.insstr('<table width=100% cellpadding='+inttostr(cellpad)+' cellspacing=0 border=0><td>&nbsp;</td></table>'+rcode,bottompad)
 );
//.finalise
pushb(len,result,
'</td></table>'+rcode+
'</td></table>'+rcode);
pushb(len,result,'');
except;end;
end;
//## safeline ##
function thtmltemplate.safeline(x:string):string;
begin
try;result:=general.swapcharsb(x,'"','''');except;end;
end;
//## safecolor ##
function thtmltemplate.safecolor(x:string):string;
begin
try
if (copy(x,1,1)='#') then result:=general.tohex(general.fromhex(x),true)
else
   begin
   general.swapchars(x,#32,'_');
   x:=safeline(x);
   end;//end of if
except;end;
end;
//## safealign ##
function thtmltemplate.safealign(x:string):string;
begin
try
if (0=comparetext(x,'right')) then result:='right'
else if (0=comparetext(x,'center')) then result:='center'
else result:='left';
except;end;
end;
//## safevalign ##
function thtmltemplate.safevalign(x:string):string;
begin
try
if (0=comparetext(x,'top')) then result:='top'
else if (0=comparetext(x,'center')) then result:='center'
else result:='bottom';
except;end;
end;
//## goodcolor ##
function thtmltemplate.goodcolor(color:string):string;
begin
try
color:=safecolor(color);
if (color='') then color:='#000000';
result:=color;
except;end;
end;
//## findname ##
function thtmltemplate.findname(x:string):integer;
var
   p:integer;
begin
try
//defaults
result:=0;//nil
//process
for p:=0 to high(htmlnames) do if (0=comparetext(htmlnames[p],x)) then
   begin
   result:=p;
   break;
   end;//end of if
except;end;
end;
//## fromeSTYLE ##
procedure thtmltemplate.fromSTYLE(x:string;var y:thtmlvalues);
var//Accepts "x" in format: "color=#FF0000;text=#00000..." and/or "{bgcolor=#FFFFFF};{title=The cat's name=fred;};"
   //Banned characters for text value are "{}" (brackets are reserved for boundaries, all other values possible.
   xLEN,i,fp,lp,p,p2:integer;
   bOK:boolean;
   n,v:string;
begin
try
//defaults
xLEN:=length(x);
bOK:=false;
lp:=1;
fp:=0;
for p:=low(y) to high(y) do y[p]:='';
//process
for p:=1 to xLEN do
begin
//.brackets
if (not bOK) and (x[p]='{') then
   begin
   lp:=p+1;
   bOK:=true;
   end
else if bOK and (x[p]='}') then
   begin
   fp:=p-1;
   bOK:=false;
   end
else if (not bOK) and (x[p]=';') then
   begin
   if (fp=0) then fp:=p-1;
   //.get
   for p2:=lp to fp do if (x[p2]='=') then
      begin
      n:=copy(x,lp,p2-lp);
      v:=copy(x,p2+1,fp-p2);
      //.lookup - "name$=variable_name"
      if (n<>'') and (n[1]='$') then
         begin
         n:=copy(n,2,length(n));
         v:=y[findname(v)];
         end;//end of if
      //.set
      i:=findname(n);
      y[i]:=v;
      break;
      end;//end of loop
   //.reset
   lp:=p+1;
   fp:=0;
   end;//end of if
end;//end of loop
//.enforce ranges
for p:=low(y) to high(y) do
begin
case htmlmodes[p] of
1:y[p]:=safecolor(y[p]);
2:y[p]:=safeline(y[p]);
3:y[p]:=net_encode_for_html_b(y[p]);
4:y[p]:=goodcolor(y[p]);
5:y[p]:=safealign(y[p]);
6:y[p]:=safevalign(y[p]);
end;//end of case
end;//end of loop
except;end;
end;
//## toSTYLE ##
function thtmltemplate.toSTYLE(var x:thtmlvalues):string;
var
   tmp:string;
   p,len:integer;
begin
try
//defaults
result:='';
len:=0;
//process
for p:=low(x) to high(x) do if (x[p]<>'') then
   begin
   tmp:=x[p];
   general.swapchars(tmp,'{','(');
   general.swapchars(tmp,'}',')');
   pushb(len,result,'{'+htmlnames[p]+'='+x[p]+'};');
   end;//end of if
pushb(len,result,'');
except;end;
end;
//## line ##
function thtmltemplate.line(color,width:string):string;
begin
try
if (width='') then width:='100%';
result:='<table width='+width+' cellpadding=0 cellspacing=0 border=0 bgcolor='+goodcolor(color)+'><td><table width=100% cellpadding=1 cellspacing=0 border=0><td></td></table></td></table>';
except;end;
end;
//## lineb ##
function thtmltemplate.lineb(color:string):string;
begin
try;result:=line(color,'100%');except;end;
end;
//## progressbar ##
function thtmltemplate.progressbar(p,width,height:integer;fcolor,bcolor:string;border:boolean):string;
var
   w:string;
begin
try
//range
p:=frcrange(p,0,100);
if (width<0) then w:=inttostr(frcrange(-width,0,100))+'%'
else w:=inttostr(frcmin(width,20));
height:=frcmin(height,1);
if (fcolor='') and (bcolor='') then
   begin
   bcolor:='#000000';
   fcolor:='#FFFFFF';
   end;//end of if
//set
result:=
'<table width='+w+' cellpadding=0 cellspacing=0 border='+bn(border)+general.insstr(' bgcolor='+bcolor,bcolor<>'')+'><td>'+
'<table width='+inttostr(p)+'% cellpadding=0 cellspacing=0 border=0 height='+inttostr(height)+general.insstr(' bgcolor='+fcolor,fcolor<>'')+'><td>'+
'<table width=100% cellpadding=0 cellspacing=0 border=0><td></td></table>'+
'</td></table>'+
'</td></table>';
except;end;
end;
//## toolbar ##
function thtmltemplate.toolbar(color,name,subname,links:string):string;
var//links: label,target(optional),url
   n,u,t,tmp:string;
   c,lp,p,tmpLEN,len:integer;
begin
try
//defaults
len:=length(links);
tmpLEN:=0;
tmp:='';
c:=0;
lp:=1;
//process
//.links
for p:=1 to len do
begin
if ((links[p]=',') or (links[p]=';')) then
   begin
   case c of
   0:n:=copy(links,lp,p-lp);
   1:t:=copy(links,lp,p-lp);
   2:u:=copy(links,lp,p-lp);
   end;//end of case
   lp:=p+1;
   //.set
   if (c=2) or (links[p]=';') then
      begin
      c:=-1;
      if (u<>'') then
         begin
         if (t<>'') then t:='target='+safeline(t)+#32;
         pushb(tmpLEN,tmp,'<a '+t+'href="'+safeline(u)+'">'+net_encode_for_html_b(n)+'</a> &nbsp;'+rcode);
         end;//end of if
      end;//end of if
   //.inc
   inc(c);
   //.reset
   if (links[p]=';') then c:=0;
   end;
end;//end of loop
pushb(tmpLEN,tmp,'');
//.set
result:=
 '<table width=100% cellpadding=0 cellspacing=0 border=0><td><font size=+2 color='+goodcolor(color)+'>'+net_encode_for_html_b(name)+'&nbsp; <font size=-2>'+net_encode_for_html_b(subname)+'</font></font></td>'+
 '<td align=right valign=bottom>'+rcode+tmp+'</td></table>'+rcode+lineb(color)+rcode+'<br>'+rcode;
except;end;
end;
//## frame ##
function thtmltemplate.frame(width:integer;dark,light,content:string):string;
begin
try;result:='<table width='+inttostr(width)+' cellpadding=1 cellspacing=0 border=0 bgcolor='+goodcolor(dark)+'><td><table width=100% cellpadding=1 cellspacing=0 border=0 bgcolor='+goodcolor(light)+'><td>'+rcode+content+rcode+'</td></table></td></table>';except;end;
end;
//## createcaption ##
function thtmltemplate.createcaption(var v:thtmlvalues;caption:string):string;
var
   l,d:string;
begin
try
//defaults
result:='';
if (caption='') then exit;
//process
//.get
d:=v[htndark];
l:=v[htnlight];
//.set
result:='<table width=100% cellpadding=3 cellspacing=0 border=0 bgcolor='+d+'><td align='+v[htncaptionAlign]+'><font color='+l+'><b>'+net_encode_for_html_b(caption)+'</b></font></td></table>';
except;end;
end;
//## createbgcolor ##
function thtmltemplate.createbgcolor(index:integer;colorlist:tstringlist):string;
begin
try;if (colorlist<>nil) and (index>=0) and (colorlist.count>=1) and (index<colorlist.count) and (colorlist.strings[index]<>'') and (0<>comparetext('nil',colorlist.strings[index])) then result:=' bgcolor='+safecolor(colorlist.strings[index]) else result:='';except;end;
end;
//## createtable ##
function thtmltemplate.createtable(var v:thtmlvalues;c:string):string;
var
   widths,aligns,valigns,cs:tstringlist;
   o,lp,p,ai,rLEN,cLEN,colCOUNT,rcINDEX:integer;
   width,align,valign,bgcolor:string;
   tmp:char;
begin
try
//defaults
widths:=nil;
aligns:=nil;
valigns:=nil;
cs:=nil;
widths:=tstringlist.create;
aligns:=tstringlist.create;
valigns:=tstringlist.create;
cs:=tstringlist.create;
result:='';
lp:=1;
rLEN:=0;
cLEN:=length(c);
colCOUNT:=0;
rcINDEX:=0;
widths.text:=general.swapcharsb(v[htntableWidths],',',#10);
aligns.text:=general.swapcharsb(v[htntableAligns],',',#10);
valigns.text:=general.swapcharsb(v[htntableVAligns],',',#10);
for p:=0 to (aligns.count-1) do aligns.strings[p]:=safealign(aligns.strings[p]);
for p:=0 to (valigns.count-1) do valigns.strings[p]:=safevalign(valigns.strings[p]);
cs.text:=general.swapcharsb(v[htntableRowColors],',',#10);
bgcolor:=createbgcolor(rcINDEX,cs);
//process
pushb(rlen,result,'<table width=100% cellpadding='+inttostr(frcmin(strint(v[htntableSpacing]),0))+' cellspacing=0 border='+inttostr(frcmin(strint(v[htntableBorder]),0))+'>'+rcode+'<tr'+bgcolor+'>');
for p:=1 to cLEN do
begin
//.new column
if (c[p]=#0) or (c[p]=#1) or (p=cLEN) then
   begin
   //..widths
   if (colCOUNT<widths.count) then width:=' width='+widths.strings[colCOUNT] else width:='';
   //..align
   if (colCOUNT<aligns.count) then align:=' align='+aligns.strings[colCOUNT] else align:='';
   //..valign
   if (colCOUNT<valigns.count) then valign:=' valign='+valigns.strings[colCOUNT] else valign:='';
   //..inc
   inc(colCOUNT);
   //..content
   if (p=cLEN) and ((c[p]<>#0) and (c[p]<>#1)) then o:=1 else o:=0;
   pushb(rlen,result,'<td'+width+align+valign+'>'+copy(c,lp,p-lp+o)+'</td>');
   lp:=p+1;
   if (c[p]=#1) then
      begin
      inc(rcINDEX);
      if (rcINDEX>=cs.count) then rcINDEX:=0;
      bgcolor:=createbgcolor(rcINDEX,cs);
      colCOUNT:=0;
      pushb(rlen,result,'</tr>'+rcode+'<tr'+bgcolor+'>');
      end;//end of if
   end;//end of if
end;
pushb(rlen,result,'</tr>'+rcode+'</table>');
//.finalise
pushb(rlen,result,'');
except;end;
try;freeObj(@widths);freeObj(@aligns);freeObj(@valigns);freeObj(@cs);except;end;
end;
//## createwindow ##
function thtmltemplate.createwindow(var v:thtmlvalues;caption,content:string):string;
var
   cs:integer;
   tmp,a,l,d,s:string;
begin
try
//defaults
result:='';
//process
//.get
d:=v[htndark];
l:=v[htnlight];
a:=v[htncontentAlign];
s:=v[htnwindowStyle];
cs:=strint(v[htncontentSpacing]);
//.align
if (0=comparetext(a,'right')) then tmp:='align=right'
else if (0=comparetext(a,'center')) then tmp:='align=center'
else tmp:='align=left';
//.table
if (v[htntableAligns]<>'') then content:=createtable(v,content);
//.msg (blank line top and bottom)
if (0=comparetext(s,'msg')) then content:='<br>'+content+'<br>&nbsp;';
//.content spacing
if (cs>=1) then content:='<table width=100% cellpadding='+inttostr(cs)+' cellspacing=0 border=0><td>'+rcode+content+rcode+'</td></table>'+rcode;
//.caption
content:=createcaption(v,caption)+rcode+content;
//.style
//..dlg
if (0=comparetext(s,'msg')) or (0=comparetext(s,'dlg')) then result:='<table width=400 cellpadding=1 cellspacing=0 border=0 bgcolor='+d+'><td><table width=100% cellpadding=1 cellspacing=0 border=0 bgcolor='+l+'><td ' +tmp+'>'+rcode+content+rcode+'</td></table></td></table>'+rcode
//..noborder
else if (0=comparetext(s,'noborder')) then result:='<table width=560 cellpadding=1 cellspacing=0 border=0 bgcolor='+l+'><td ' +tmp+'>'+rcode+content+rcode+'</td></table>'+rcode
//..plain
else result:='<table width=560 cellpadding=1 cellspacing=0 border=0 bgcolor='+d+'><td><table width=100% cellpadding=1 cellspacing=0 border=0 bgcolor='+l+'><td ' +tmp+'>'+rcode+content+rcode+'</td></table></td></table>'+rcode;
except;end;
end;
//## page ##
function thtmltemplate.page(values,content:string):string;
var
   v:thtmlvalues;
   len:integer;
   z:string;
begin
try
//defaults
result:='';
len:=0;
//process
//.get
fromSTYLE(values,v);
//.set
pushb(len,result,'<html>'+rcode+'<head>'+rcode);
if (v[htntitle]<>'') then pushb(len,result,'<title>'+v[htntitle]+'</title>'+rcode);
pushb(len,result,'<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">'+rcode);
pushb(len,result,'<link rel="shortcut icon" href="favicon.ico">'+rcode);
if (v[htnkeywords]<>'') then pushb(len,result,'<meta name="keywords" content="'+v[htnkeywords]+'">'+rcode);
if (v[htndescription]<>'') then pushb(len,result,'<meta name="description" content="'+v[htndescription]+'">'+rcode);
pushb(len,result,'</head>'+rcode);
//..<body>
z:='';
if (v[htnbgcolor]<>'') then z:=z+' bgcolor='+v[htnbgcolor];
if (v[htntext]<>'') then z:=z+' text='+v[htntext];
if (v[htnlink]<>'') then z:=z+' link='+v[htnlink];
if (v[htnalink]<>'') then z:=z+' alink='+v[htnalink];
if (v[htnvlink]<>'') then z:=z+' vlink='+v[htnvlink];
if (v[htnmarginTop]<>'') then z:=z+' topmargin='+v[htnmarginTop];
if (v[htnmarginLeft]<>'') then z:=z+' leftmargin='+v[htnmarginLeft];
pushb(len,result,'<body'+z+'>'+rcode);
//.<style> - note: must be create in exact order of "active/visited/link/hover" otherwise IE5 will not implement style
z:='<style type="text/css"><!--';
if (v[htnalink]<>'') then z:=z+'a:active {color: '+v[htnalink]+'; text-decoration: none}';
if (v[htnvlink]<>'') then z:=z+'a:visited {color: '+v[htnvlink]+'; text-decoration: none}';
if (v[htnlink]<>'') then z:=z+'a:link {color: '+v[htnlink]+'; text-decoration: none}';
if (v[htnalink]<>'') then z:=z+'a:hover {color: '+v[htnalink]+'; text-decoration: underline}';
z:=z+'--></style>';
pushb(len,result,z+rcode);
//.toolbar
pushb(len,result,toolbar(v[htndark],v[htntoolbarName],v[htntoolbarSubname],v[htntoolbarLinks]));
//.data
pushb(len,result,'<center>'+rcode);
pushb(len,result,content);
//.footer
if (v[htnfooter]<>'') then pushb(len,result,'<br>'+rcode+'<p align='+v[htnfooterAlign]+'><font size=-1 color='+v[htnfootercolor]+'>'+v[htnfooter]+'</font></p>'+rcode+'<br>&nbsp'+rcode);
//.</body>
pushb(len,result,rcode+'</center>'+rcode+'</body>'+rcode+'</html>');
//.finalise
pushb(len,result,'');
except;end;
end;
//## pagewindow ##
function thtmltemplate.pagewindow(values,caption,content:string):string;
var
   v:thtmlvalues;
begin
try;fromSTYLE(values,v);result:=page(values,createwindow(v,caption,content));except;end;
end;

//################# ECap #######################################################
//## ECapK ##
Function ECapK:String;
Const
     map='asdfklj4imzxhmewro982489alkt9[1239-12,as[023aeoi43q[9';
Var
   MaxP,P:Integer;
   X:String;
begin{Generate Random Key}
try
{Prepare}
MaxP:=10+Random(41);{10-50}
X:=Copy(map,1,MaxP);
{Process}
For P:=1 to MaxP Do X[P]:=map[1+random(50)];
{Return Result}
Result:=X;
except;end;
end;
//## ECap ##
Function ECap(X:String;E:Boolean):String;
begin
try;result:=ECapBin(x,e,false);except;end;
end;
//## ECapBin ##
Function ECapBin(X:String;E,bin:Boolean):String;
Var
   kLen:Integer;
   Z,K:String;
   ee,dd:byte;
begin{Encrypt/Decrypt Caption - Valid input range 14-255}
try
{Default}
Result:='';
{Ignore}
If (X='') then exit;
{ascii/binary}
case bin of
true:begin
     ee:=glseEncrypt;
     dd:=glseDecrypt;
     end;//end of begin
false:begin
     ee:=glseTextEncrypt;
     dd:=glseTextDecrypt;
     end;//end of begin
end;//end of case
{Process}
Case E of
True:begin{Encrypt}
    {Gen. Key}
    K:=ECapK;
    kLen:=Length(K);
    {Encrypt}
    Z:=General.StdEncrypt(X,K,ee);
    {Header - kLlength(1),Key(10-50),eData(0..X)}
    Z:=Chr(14+kLen)+General.StdEncrypt(K,glseEDK,dd)+Z;
    {Filter}
    if not bin then General.SwapStrs(Z,#39,#39+#39);
    {Return Result}
    Result:=Z;
    end;//end of begin
False:begin{Decrypt}
     {Filter}
     if not bin then General.SwapStrs(X,#39+#39,#39);
     {kLength}
     kLen:=Ord(X[1])-14;
     {Prepare}
     K:=Copy(X,2,kLen);
     Z:=Copy(X,kLen+2,Length(X));
     {Decrypt}
     K:=General.StdEncrypt(K,glseEDK,ee);
     Z:=General.StdEncrypt(Z,K,dd);
     {Return Result}
     Result:=Z;
     end;//end of begin
end;//end of case
except;end;
end;

//################## Main - Ligthweight System #################################
function PeekMessage; external user32 name 'PeekMessageA';
function SendMessage; external user32 name 'SendMessageA';
function TranslateMessage; external user32 name 'TranslateMessage';
function DispatchMessage; external user32 name 'DispatchMessageA';
function WaitMessage; external user32 name 'WaitMessage';
function CreateWindowEx; external user32 name 'CreateWindowExA';
function GetSystemMetrics; external user32 name 'GetSystemMetrics';
function ShowWindow; external user32 name 'ShowWindow';
function RegisterClassEx; external user32 name 'RegisterClassExA';
function RegisterClass; external user32 name 'RegisterClassA';
function GetClassInfo; external user32 name 'GetClassInfoA';
function GetClassInfoEx; external user32 name 'GetClassInfoExA';
function SetWindowLong; external user32 name 'SetWindowLongA';
function DefWindowProc; external user32 name 'DefWindowProcA';
function LoadIcon; external user32 name 'LoadIconA';
function LoadCursor; external user32 name 'LoadCursorA';
function LoadCursorFromFile; external user32 name 'LoadCursorFromFileA';
function SetSystemCursor; external user32 name 'SetSystemCursor';
function GetStockObject; external gdi32 name 'GetStockObject';
function LoadResource; external kernel32 name 'LoadResource';
function SetWindowPos; external user32 name 'SetWindowPos';
function ReplyMessage; external user32 name 'ReplyMessage';
procedure PostQuitMessage; external user32 name 'PostQuitMessage';
function GetWindowPlacement; external user32 name 'GetWindowPlacement';
function SetWindowPlacement; external user32 name 'SetWindowPlacement';
function GetClientRect; external user32 name 'GetClientRect';
function GetWindowRect; external user32 name 'GetWindowRect';
function AdjustWindowRect; external user32 name 'AdjustWindowRect';
function GetDC; external user32 name 'GetDC';
function GetWindowDC; external user32 name 'GetWindowDC';
function ReleaseDC; external user32 name 'ReleaseDC';
function StretchBlt; external gdi32 name 'StretchBlt';
function TextOut; external gdi32 name 'TextOutA';
function ExtTextOut; external gdi32 name 'ExtTextOutA';
function Rectangle; external gdi32 name 'Rectangle';
function DestroyWindow; external user32 name 'DestroyWindow';
function GetCapture; external user32 name 'GetCapture';
function SetCapture; external user32 name 'SetCapture';
function ReleaseCapture; external user32 name 'ReleaseCapture';
function BeginPaint; external user32 name 'BeginPaint';
function EndPaint; external user32 name 'EndPaint';
function CreatePopupMenu; external user32 name 'CreatePopupMenu';
function AppendMenu; external user32 name 'AppendMenuA';
function GetSubMenu; external user32 name 'GetSubMenu';
function GetMenuItemID; external user32 name 'GetMenuItemID';
function GetMenuItemCount; external user32 name 'GetMenuItemCount';
function CheckMenuItem; external user32 name 'CheckMenuItem';
function EnableMenuItem; external user32 name 'EnableMenuItem';
function InsertMenuItem; external user32 name 'InsertMenuItemA';
function DestroyMenu; external user32 name 'DestroyMenu';
function TrackPopupMenu; external user32 name 'TrackPopupMenu';
function GetSystemMenu; external user32 name 'GetSystemMenu';
function GetCursorPos; external user32 name 'GetCursorPos';
function SetCursorPos; external user32 name 'SetCursorPos';
function SetFileAttributes; external kernel32 name 'SetFileAttributesA';
function DeleteFile; external kernel32 name 'DeleteFileA';
function SetCursor; external user32 name 'SetCursor';
function GetTempPath; external kernel32 name 'GetTempPathA';
function CreateDirectory; external kernel32 name 'CreateDirectoryA';
function ShellExecute; external shell32 name 'ShellExecuteA';
function GetTickCount; external kernel32 name 'GetTickCount';
function UpdateWindow; external user32 name 'UpdateWindow';
procedure Sleep; external kernel32 name 'Sleep';

//## ReadSTDHeader ##
Function ReadSTDHeader(Var X,Hdr,Body:String):Boolean;
Var
   MaxP,P:Integer;
begin
try
{Error}
Result:=False;
{Search}
For P:=1 to MaxP Do If (X[P]=#0) then
    begin
    Hdr:=Copy(X,1,P-1);
    Body:=Copy(X,P+1,MaxP);
    {Successful}
    Result:=True;
    break;
    end;//end of if
except;end;
end;
//## Draw3DFrame ##
Procedure Draw3DFrame(X:TFrameInfo;Img:TBitmap;_onlyline:boolean);//31-AUg-2004
Label
     SkipOne;
Var{X-multi lined inputs: Width%,Color1,Color2
    Width%: "d"(default=100%), "r"(remaining percentage), "0..100"(real percentage)
    Color1: "d"(use col), "-X..0..+X"(real color), "sXX"(shade of col)
    Color2: "d"(use col), "-X..0..+X"(real color), "sXX"(shade of col)
}
   dXpos,Zadj,Zpos,Zlen,C,MaxP,P,P1,MaxP2,P2,dX,dY,dW,dH:Integer;
   pWrem,pW,dC1,dC2:Integer;
   A:Array[0..2] of String;
   B:TStringList;
   z:string;
begin
try
{Ignore}
If (X.Width<=0) or (Img=nil) or (X.Style='') then exit;
{Prepare}
B:=nil;
B:=TStringList.Create;
z:=x.style;general.swapchars(z,'|',#13);//31-AUG-2004
B.Text:=z;
MaxP:=B.Count-1;
pWrem:=100;
pW:=0;
If (X.Color<0) then X.Color:=0;
dC1:=X.Color;
dC2:=X.Color;
dXpos:=0;
{## Process ##}
For P:=0 to MaxP Do
begin
{Defaults}
For P2:=0 to High(A) Do A[P2]:='';
{Parse Input}
Z:=B.Strings[P];
If (Z='') or (Copy(Z,1,2)='//') then Goto SkipOne;
Zlen:=Length(Z);
Zpos:=1;
Zadj:=0;
C:=0;
For P2:=1 to Zlen Do
begin
If (Z[P2]=',') or (P2=Zlen) then
   begin
   If (P2=Zlen) then Zadj:=1;
   A[C]:=Copy(Z,Zpos,P2-Zpos+Zadj);
   If (A[C]='') then A[C]:='d';{default}
   Zpos:=P2+1;
   If (C>High(A)) then break;
   C:=C+1;
   end;//end of if
end;//end of loop
{Read}
//Width%
If (A[0]='d') then pW:=100
else If A[0]='r' then pW:=pWrem
else pW:=FrcRange(StrToInt(A[0]),0,100);
//Color1
If (A[1]='d') then dC1:=X.Color
else If Copy(A[1],1,1)='s' then dC1:=ColSplice(StrToInt(Copy(A[1],2,Length(A[1]))),X.Color,clBlack)
else dC1:=StrToInt(A[1]);
//Color2
If (A[2]='d') then dC2:=X.Color
else If Copy(A[2],1,1)='s' then dC2:=ColSplice(StrToInt(Copy(A[2],2,Length(A[2]))),X.Color,clBlack)
else dC2:=StrToInt(A[2]);
{Draw}
MaxP2:=FrcRange((pW*X.Width) Div 100,0,x.width);
For P2:=0 to MaxP2 Do
begin
If (MaxP2=0) then P1:=0 else P1:=(P2*100) Div MaxP2;
dX:=dXpos+P2;dY:=dX;dW:=Img.Width-dX;dH:=Img.Height-dX;
{Enforce maxWidth}
If (dX>=X.Width) then break;
case _onlyline of
false:begin
     Img.Canvas.Brush.Color:=ColSplice(P1,dC2,dC1);
     Img.Canvas.FrameRect(Rect(dX,dY,dW,dH));
     end;//end of begin
true:begin
     Img.Canvas.Pen.Color:=ColSplice(P1,dC2,dC1);
     Img.Canvas.MoveTo(0,dy);
     Img.Canvas.LineTo(img.width,dy);
     end;//end of begin
end;//end of case
end;//end of loop
dXpos:=dX+1;
pWrem:=FrcMin(pWrem-pW,0);
If (pWrem<=0) then break;
SkipOne:
end;//end of loop
except;end;
try;freeobj(@b);except;end;
end;
//## StdEncrypt ##
Function StdEncrypt(X:String;EKey:String;Mode1:Integer):String;
Var
   Lt,El,E,p2,p:integer;
begin
try
Lt:=Length(X);
El:=Length(EKey);
E:=0;
case Mode1 of
0:begin
//Encrypt the String:
For P:=1 to Lt do
begin
E:=E+1;
If (E>El) then E:=1;
p2:=Ord(EKey[E])+Ord(X[p]);
if (p2>255) then p2:=p2-256;
X[p]:=chr(p2);
end;//end of loop
end;//end of begin
1:begin
//Decrypt the String:
for p:=1 to Lt do
begin
E:=E+1;
If (E>El) then E:=1;
p2:=Ord(X[p])-Ord(EKey[E]);
if (p2<0) then p2:=p2+256;
X[p]:=chr(p2);
end;//end of loop
end;//end of begin
2:begin
//Encrypt PlainText to PlainText String (13-255):
For P:=1 to Lt do
begin
E:=E+1;
If (E>El) then E:=1;
p2:=Ord(EKey[E])+Ord(X[p]);
if (p2>255) then p2:=p2-242;
X[p]:=chr(p2);
end;//end of loop
end;//end of begin
3:begin
//Decrypt the String:
for p:=1 to Lt do
begin
E:=E+1;
If (E>El) then E:=1;
p2:=Ord(X[p])-Ord(EKey[E]);
if (p2<14) then p2:=p2+242;
X[p]:=chr(p2);
end;//end of loop
end;//end of begin
end;
Result:=X;
except;end;
end;
//## ColBright ##
Function ColBright(X:Integer):Integer;
Var
   A:TInt4;
begin
try
Result:=0;
{Process}
A.val:=X;
If (A.R>Result) then Result:=A.R;
If (A.G>Result) then Result:=A.G;
If (A.B>Result) then Result:=A.B;
except;end;
end;
//## InvColor ##
Function InvColor(X:Integer;GreyCorrection:Boolean):Integer;
Var
   Cinv:TInt4;
   Ok:Boolean;
begin
try
{Prepare}
Cinv.val:=X;
Ok:=False;
{Process}
Case GreyCorrection of
False:Ok:=True;
True:Case ColBright(Cinv.val) of
     100..156:Cinv.val:=clWhite
     else
      Ok:=True;
     end;//end of case
end;//end of case
{Invert}
If Ok then
   begin
   Cinv.R:=(255-Cinv.R);
   Cinv.G:=(255-Cinv.G);
   Cinv.B:=(255-Cinv.B);
   end;//end of if
{Return Result}
Result:=Cinv.val;
except;end;
end;
//## StripService ##
Function StripService(X:String;Full:Boolean):String;
Label
     ReDo;
Var
   Y:String;
   MaxP,P:Integer;
begin
try
{Default}
Result:=X;
{Process}
ReDo:
Y:=LowerCase(Copy(X,1,7));
If (Y='mailto:') or (Y='http://') then
   begin
   X:=Copy(X,8,Length(X));
   If (X<>'') then Goto ReDo;
   end;//end of if
{Full}
If Full then
   begin
   MaxP:=Length(X);
   For P:=1 to MaxP Do If (X[P]='?') then
       begin
       X:=Copy(X,1,P-1);
       break;
       end;//end of if
   end;//end of if
{Return Result}
Result:=X;
except;end;
end;
//## asGZfile ##
function asGZfile(filename:string;var data,e:string):boolean;
var//filename must finish with ".gz" extension, ie. "index.html.gz"
   b:tint4;
   c,z:string;
begin
try
//defaults
result:=false;
e:=gecOutOfMemory;
//process
//.header
z:=#31#139#8#8;
//.space
z:=z+#0#0#0#0#0#0;
//.filename
z:=z+general.remlastext(extractfilename(filename))+#0;
//.compressed data
c:=data;
if io.compress(c,e) then
   begin
   //.c
   c:=copy(c,3,length(c));
   z:=z+c;
   //.4byte length
   b.val:=length(data);
   z:=z+b.chars[0]+b.chars[1]+b.chars[2]+b.chars[3];
   //.write
   if io.tofile(filename,z,e) then result:=true;
   end;//end of if
except;end;
end;
//## zipstr ##
function zipstr(var x,e:string;raw:boolean):boolean;
label
     skipend;
var
   z:string;
begin
try
//error
result:=false;
e:=gecOutOfMemory;
//process
//.compress
if not io.compress(x,e) then goto skipend;
//.header+data
if not raw then
   begin
   z:=x;
   x:='';
   if not io.wsv32(x,z) then goto skipend;
   end;//end of if
//successful
result:=true;
skipend:
except;end;
end;
//## unzipstr ##
function unzipstr(var x,e:String;raw:boolean):boolean;//03-OCT-2004
label
     skipend;
var
   p:integer;
begin
try
//error
result:=false;
e:=gecOutOfMemory;
//process
//.raw
if not raw then
   begin
   p:=1;
   e:=gecUnknownFormat;
   if not io.rsv32(p,x,x) then goto skipend;
   end;//end of if
//.decompress
result:=io.decompress(x,e);
skipend:
except;end;
end;
//## fireevent ##
procedure fireevent(x:tnotifyevent;y:tobject);
begin
try;if assigned(x) then x(y);except;end;
end;
//## fireeventsafe ##
procedure fireeventsafe(x:tnotifyevent;y:tobject);
begin
try;if (sysstate=ssOK) then fireevent(x,y);except;end;
end;
//## swapInt ##
procedure swapInt(var x,y:LongInt);
var
   z:integer;
begin
try
z:=x;
x:=y;
y:=z;
except;end;
end;
//## swapCur ##
procedure swapCur(var x,y:currency);
var
   z:currency;
begin
try
z:=x;
x:=y;
y:=z;
except;end;
end;
//## swapExt ##
procedure swapExt(var x,y:extended);//06JUN2007
var
   z:extended;
begin
try
z:=x;
x:=y;
y:=z;
except;end;
end;
//## swapStr ##
procedure swapStr(var x,y:string);
var
   z:string;
begin
try
z:=x;
x:=y;
y:=z;
except;end;
end;
//## freeObj ##
procedure freeObj(x:pobject);
begin
try
//check
if (x=nil) or (x^=nil) then exit;
//hide
if (x^ is twincontrol) then
   with (x^ as twincontrol) do
   begin
   visible:=false;
   parent:=nil;
   end;//end of with
//process
if (x^ is trootobject) then (x^ as trootobject).free
else x^.free;
x^:=nil;
except;end;
end;
//## NewForm ##
function NewForm(p:twincontrol):tform;
begin
try
{default}
result:=nil;
{process}
result:=tform.create(p);
with result do
begin
parent:=p;
bordericons:=[];
borderstyle:=bsNone;
vertscrollbar.visible:=false;
horzscrollbar.visible:=false;
caption:='';
hint:='';
showHint:=false;
end;//end of with
except;end;
end;
//## decText ##
function decText(x:boolean;y,n:string):string;{Decision Text}
begin
try;if x then result:=y else result:=n;except;end;
end;
//## Run ##
Function Run(X,Y:String):Boolean;
Var{runs [Email mailto:abc@xyz.com ''] [Web http://www.xyz.com/?abc ''] [Doc c:\1.bmp ''] [Prog/Doc c:\MSPaint.EXE "c:\3.bmp"]}
   H:THandle;
begin
try
{Error}
Result:=False;
H:=ShellExecute(0,nil,PChar(X),PChar(Y),PChar(ExtractFilePath(X)),1);
{Successful}
Result:=True;
except;end;
end;
//## StrLen ##
Function StrLen(Str: PChar): Cardinal; assembler;
asm
MOV     EDX,EDI
MOV     EDI,EAX
MOV     ECX,0FFFFFFFFH
XOR     AL,AL
REPNE   SCASB
MOV     EAX,0FFFFFFFEH
SUB     EAX,ECX
MOV     EDI,EDX
end;
//## UpperCase ##
Function UpperCase(X:String):String;
Var
  A:Char;
  MaxP,P:Integer;
begin
try
MaxP:=Length(X);
For P:=1 to MaxP Do
begin
A:=X[P];
if (A>='a') and (A<='z') then X[P]:=Chr(Ord(A)-32);
end;//end of loop
{Return Result}
Result:=X;
except;end;
end;
//## LowerCase ##
Function LowerCase(X:String):String;
Var
  A:Char;
  MaxP,P:Integer;
begin
try
MaxP:=Length(X);
For P:=1 to MaxP Do
begin
A:=X[P];
if (A>='A') and (A<='Z') then X[P]:=Chr(Ord(A)+32);
end;//end of loop
{Return Result}
Result:=X;
except;end;
end;
//## ExtractFilePath ##
Function ExtractFilePath(X:String):String;
Var
   MaxP,P:Integer;
begin
try
{Default}
Result:='';
{Prepare}
MaxP:=Length(X);
For P:=MaxP downTo 1 Do If (X[P]='\') or (X[P]=':') then
    begin
    Result:=Copy(X,1,P);
    break;
    end;//end of if
except;end;
end;
//## ColSplice ##
Function ColSplice(X,C1,C2:Integer):Integer;
Var
   A1,A2:TInt4;
   P1,P2:Integer;
begin
try
{Error}
Result:=0;
If (X>100) then
   begin
   Result:=ColSplice(FrcRange(X-100,0,100),clWhite,C1);
   exit;
   end;//end of if
{P1 & P2}
P1:=(X*100) Div 100;
P2:=FrcRange(100-P1,0,100);
{Color}
A1.val:=C1;
A2.val:=C2;
A1.R:=FrcRange((A1.R*P1+A2.R*P2) Div 100,0,255);
A1.G:=FrcRange((A1.G*P1+A2.G*P2) Div 100,0,255);
A1.B:=FrcRange((A1.B*P1+A2.B*P2) Div 100,0,255);
A1.T:=0;
{Return Result}
Result:=A1.val;
except;end;
end;
//## frcmin ##
function frcmin(x,min:integer):integer;//14-SEP-2004
begin
try;if (x<min) then x:=min;result:=x;except;end;
end;
//## FrcCurMin ##
Function FrcCurMin(X,Min:currency):currency;
begin
try
Result:=X;
If (X<Min) then X:=Min;
Result:=X;
except;end;
end;
//## smallest ##
function smallest(a,b:integer):integer;
begin
try
result:=a;
if (result>b) then result:=b;
except;end;
end;
//## largest ##
function largest(a,b:integer):integer;
begin
try
result:=a;
if (result<b) then result:=b;
except;end;
end;
//## csmallestex ##
function csmallestex(a:array of currency):currency;//22JAN2008
var
   p:integer;
begin
try
//defaults
result:=maxcur;
//scan
for p:=low(a) to high(a) do if (a[p]<result) then result:=a[p];
except;end;
end;
//## clargestex ##
function clargestex(a:array of currency):currency;//22JAN2008
var
   p:integer;
begin
try
//defaults
result:=mincur;
//scan
for p:=low(a) to high(a) do if (a[p]>result) then result:=a[p];
except;end;
end;
//## frcmax ##
function frcmax(x,max:integer):integer;//14-SEP-2004
begin
try;if (x>max) then x:=max;result:=x;except;end;
end;
//## FrcCurMax ##
Function FrcCurMax(X,Max:currency):currency;
begin
try
Result:=X;
If (X>Max) then X:=Max;
Result:=X;
except;end;
end;
//## frcrange ##
function frcrange(x,min,max:integer):integer;//13-SEP-2004
begin
try
//filter
if (x<min) then x:=min
else if (x>max) then x:=max;
//return result
result:=x;
except;end;
end;
//## frcrangeex ##
function frcrangeex(x,min,max,defvalue:integer):integer;//14-JAN-2007
begin
try
//defvalue
if (x=0) then x:=defvalue;
//set
result:=frcrange(x,min,max);
except;end;
end;
//## frccurrange ##
function frccurrange(x,min,max:currency):currency;//date: 02-APR-2004
begin
try
result:=x;
if (x<min) then x:=min;
if (x>max) then x:=max;
result:=x;
except;end;
end;
//## frcextrange ##
function frcextrange(x,min,max:extended):extended;//06JUN2007
begin
try
result:=x;
if (x<min) then x:=min;
if (x>max) then x:=max;
result:=x;
except;end;
end;
//## FileSize ##
Function FileSize(X:String):Integer;
Var
   A:TFileStream;
   AOpen:Boolean;
begin
try
{Error}
Result:=-1;
A:=nil;
A:=TFileStream.Create(X,fmOpenRead+fmShareDenyNone);
{Return Result}
Result:=A.Size;
except;end;
try;A.Free;except;end;
end;
//## FileAge ##
Function FileAge(const FileName:string):Integer;
Var
  Handle: THandle;
  FindData: TWin32FindData;
  LocalFileTime: TFileTime;
begin
try
  Handle := FindFirstFile(PChar(FileName), FindData);
  if Handle <> INVALID_HANDLE_VALUE then
  begin
    Windows.FindClose(Handle);
    if (FindData.dwFileAttributes and FILE_ATTRIBUTE_DIRECTORY) = 0 then
    begin
      FileTimeToLocalFileTime(FindData.ftLastWriteTime, LocalFileTime);
      if FileTimeToDosDateTime(LocalFileTime, LongRec(Result).Hi,
        LongRec(Result).Lo) then Exit;
    end;
  end;
  Result := -1;
except;end;
end;
//## FileExists ##
Function FileExists(const FileName:string):Boolean;
begin
try;Result:=FileAge(FileName)<>-1;except;end;
end;
//## xpush ##
Function xpush(var d,dtmp:string;x:string;b:integer):boolean;{date: 16-FEB-2004}
begin{x=inbound, d=outbound, dtmp=tmp buffer for speed}
try
{error}
result:=false;
{append}
dtmp:=dtmp+x;
{check}
if (length(dtmp)>=b) or (x='') then
   begin
   d:=d+dtmp;
   dtmp:='';
   end;//end of if
{successful}
result:=true;
except;end;
end;
//## xpushPTR ##
function xpushPTR(d,dtmp,x:pstring;b:integer):boolean;{date: 12-JUL-2004}
begin{x=inbound, d=outbound, dtmp=tmp buffer for speed}
try
{error}
result:=false;
//check
if (d=nil) or (dtmp=nil) then exit;
{append}
if (x<>nil) then dtmp^:=dtmp^+x^;
{check}
if (x=nil) or (length(dtmp^)>=b) or (x^='') then
   begin
   d^:=d^+dtmp^;
   dtmp^:='';
   end;//end of if
{successful}
result:=true;
except;end;
end;
//## xypush ##
Function xypush(var d,stmp,ltmp:string;x:string;s,l:integer):boolean;{date: 16-FEB-2004}
begin
try
{error}
result:=false;
{finalise}
if (x='') then
   begin
   d:=d+ltmp+stmp;
   result:=true;
   exit;
   end;//end of if
{append}
xpush(ltmp,stmp,x,s);
{check}
if (length(ltmp)>=l) then
   begin
   d:=d+ltmp;
   ltmp:='';
   end;//end of if
{successful}
result:=true;
except;end;
end;
//## To16Bit ##
Function To16Bit(X:String;si:boolean):Integer;
Var
   A:TWrd2;
begin
try
Result:=0;
If (Length(X)<2) then exit;
a.chars[0]:=x[1];
a.chars[1]:=x[2];
case si of
false:result:=a.val;
true:result:=a.si;
end;//end of case
except;end;
end;
//## From16Bit ##
Function From16Bit(X:Integer;si:boolean):String;
Var
   A:TWrd2;
begin
try
case si of
false:a.val:=x;
true:a.si:=x;
end;//end of case
result:=a.chars[0]+a.chars[1];
except;end;
end;
//## to32bit ##
function to32bit(x:string):integer;//29AUG2007
var
   a:tint4;
   p:integer;
begin
try
//defaults
result:=0;
if (length(x)<4) then exit;
//get
a.chars[0]:=x[1];
a.chars[1]:=x[2];
a.chars[2]:=x[3];
a.chars[3]:=x[4];
//set
result:=a.val;
except;end;
end;
//## from32bit ##
function from32bit(x:integer):string;//29AUG2007
Var
   a:tint4;
   p:integer;
begin
try
//defaults
a.val:=x;
result:='####';
//set
result[1]:=a.chars[0];
result[2]:=a.chars[1];
result[3]:=a.chars[2];
result[4]:=a.chars[3];
except;end;
end;
//## To64Bit ##
function To64Bit(x:string):currency;//updated: 02-APRIL-2004
Var
   a:TCur8;
   p:integer;
begin
try
{default}
result:=0;
{check}
If (length(x)<8) then exit;
{process}
for p:=1 to 8 do A.chars[p-1]:=x[p];
{return result}
result:=a.val;
except;end;
end;
//## From64Bit ##
function From64Bit(x:currency):string;//updated: 02-APRIL-2004
Var
   a:TCur8;
   p:integer;
begin
try
{prepare}
a.val:=X;
result:='########';
{process}
for p:=1 to 8 do result[p]:=a.chars[p-1];
except;end;
end;
//## SetCaptureHwnd ##
Procedure SetCaptureHwnd(X:Hwnd);
begin
try
ReleaseCapture;
FCaptureHwnd:=0;
If (X<>0) then
   begin
   SetCapture(X);
   FCaptureHwnd:=X;
   end;//end of if
except;end;
end;
//## ScreenWidth ##
Function ScreenWidth:Integer;
begin
try;Result:=GetSystemMetrics(SM_CXSCREEN);except;end;
end;
//## ScreenHeight ##
Function ScreenHeight:Integer;
begin
try;Result:=GetSystemMetrics(SM_CYSCREEN);except;end;
end;
//## Rect ##
Function Rect(X,Y,W,H:Integer):TRect;
begin
try
Result.Left:=X;
Result.Top:=Y;
Result.Right:=W;
Result.Bottom:=H;
except;end;
end;
//## StrScan ##
function StrScan(Str: PChar; Chr: Char): PChar; assembler;
asm
        PUSH    EDI
        PUSH    EAX
        MOV     EDI,Str
        MOV     ECX,0FFFFFFFFH
        XOR     AL,AL
        REPNE   SCASB
        NOT     ECX
        POP     EDI
        MOV     AL,Chr
        REPNE   SCASB
        MOV     EAX,0
        JNE     @@1
        MOV     EAX,EDI
        DEC     EAX
@@1:    POP     EDI
end;
//## ByteTypeTest ##
function ByteTypeTest(P: PChar; Index: Integer): TMbcsByteType;
begin
  Result := mbSingleByte;
  if (Index = 0) then
  begin
    if P[Index] in LeadBytes then Result := mbLeadByte;
  end
  else
  begin
    if (P[Index-1] in LeadBytes) and (ByteTypeTest(P, Index-1) = mbLeadByte) then
      Result := mbTrailByte
    else if P[Index] in LeadBytes then
      Result := mbLeadByte;
  end;
end;
//## ByteType ##
function ByteType(const S: string; Index: Integer): TMbcsByteType;
begin
  Result := mbSingleByte;
//  if SysLocale.FarEast then
//yyyyyyyyyyyyyyyyy    Result := ByteTypeTest(PChar(S), Index-1);
end;
//## LastDelimiter ##
function LastDelimiter(const Delimiters, S: string): Integer;
Var
  P:PChar;
begin
try
Result:=Length(S);
P:=PChar(Delimiters);
while (Result>0) do
begin
if (S[Result]<>#0) and (StrScan(P,S[Result])<>nil) then
   if (ByteType(S,Result)=mbTrailByte) then Dec(Result) else exit;
Dec(Result);
end;//end of loop
except;end;
end;
//## ExtractFileName ##
function ExtractFileName(const FileName: string): string;
var
  I: Integer;
begin
try
I:=LastDelimiter('\:',FileName);
Result:=Copy(FileName,I+1,MaxInt);
except;end;
end;
//## ReadFileExt ##
Function ReadFileExt(x:string;fu:boolean):string;{Date: 24-DEC-2004, Superceeds "ExtractFileExt"}
var//supports: "c:\windows\abc.RTF" and alseo "http://www.blaiz.net/abc/docs/index.RTF?abc=com"
   a,b:string;
begin
try
if scandownto(x,'.','/','\',a,result) then
   begin
   if scandownto(result,'?',#0,#0,a,b) then result:=a;
   if fu then result:=uppercase(result);
   end else result:='';
except;end;
end;
//## scandownto ##
function scandownto(x:string;y,stopA,stopB:char;var a,b:string):boolean;
var
   maxp,p:integer;
   _stopA,_stopB:boolean;
begin
try
//defaults
result:=false;
a:='';
b:='';
_stopA:=(stopA<>#0);
_stopB:=(stopB<>#0);
//prepare
maxp:=length(x);
//process
for p:=maxp downto 1 do
    if (_stopA and (x[p]=stopA)) then break
    else if (_stopB and (x[p]=stopB)) then break
    else if (x[p]=y) then
         begin
         a:=copy(x,1,p-1);
         b:=copy(x,p+1,maxp);
         result:=true;
         break;
         end;//end of if
except;end;
end;
//## CreateWindow ##
function CreateWindow(lpClassName:PChar;lpWindowName:PChar;dwStyle:DWORD;X,Y,nWidth,nHeight:Integer;hWndParent:HWND;hMenu:HMENU;hInstance:HINST;lpParam:Pointer):HWND;
begin
try;Result:=CreateWindowEx(0,lpClassName,lpWindowName,dwStyle,X,Y,nWidth,nHeight,hWndParent,hMenu,hInstance,lpParam);except;end;
end;
//## BN ##
Function BN(X:Boolean):String;
begin
try
Case X of
True:Result:='1';
False:Result:='0';
end;//end of case
except;end;
end;
//## bv ##
function bv(x:boolean):byte;//boolean to value
begin
try
case x of
true:result:=1;
false:result:=0;
end;//end of case
except;end;
end;
//## vb ##
function vb(x:byte):boolean;//value to boolean
begin
try;result:=(x=1);except;end;
end;
//## NB ##
Function NB(X:String):Boolean;
begin
try;Result:=(X='1');except;end;
end;
//## SysHMENU ##
Function SysHMENU(Handle:Hwnd):HMENU;
begin
try;Result:=GetSystemMenu(Handle,False);except;end;
end;
//## PopMenu ##
Procedure PopMenu(Handle:HWND;X:HMENU;dX,dY:Integer);
Const
     Flags:Array[TPopupAlignment] of Word=(TPM_LEFTALIGN,TPM_RIGHTALIGN,TPM_CENTERALIGN);
Var
   FAlignment:TPopupAlignment;
begin
try
{UpdateMenu}
//yyyyyyyyyyyyyyyyyUpdateMenu;
{Popup}
//yyyyyyyyyyyyyyyyySysHMenu
FAlignment:=paLeft;
TrackPopupMenu(X,Flags[FAlignment] or TPM_RIGHTBUTTON,dX,dY,0,Handle,nil);
{Close .. OS Bug fix..............//yyyyyyyyyyyyyyyyy}

except;end;
end;

//####################### TMsgList #############################################
//## AddWindowProc ##
Function AddWindowProc(X:HWND;Y:TWindowProc):Integer;
begin
try;Result:=MsgList.Add(X,Y);except;end;
end;
//## DelWindowProc ##
Procedure DelWindowProc(X:HWND);
begin
try;MsgList.Del(X);except;end;
end;
//## WindowProc ##
Function WindowProc(hWnd:HWND;Msg:UINT;wParam:WPARAM;lParam:LPARAM):LRESULT;stdcall
begin
try;Result:=MsgList.WindowProc(hwnd,msg,wParam,lParam);except;end;
end;
//## create ##
constructor TMsgList.create;
begin
inherited;
{ipItems}
ipItems:=@iItems;
{Clear}
Clear;
end;
//## destroy ##
destructor TMsgList.destroy;
begin
try
//self
inherited;
except;end;
end;
//## WindowProc ##
Function TMsgList.WindowProc(hWnd:HWND;Msg:UINT;wParam:WPARAM;lParam:LPARAM):LRESULT;stdcall
Var
   P:Integer;
begin
try
P:=Find(hWnd);
{Process}
Case (P=-1) or (@iItems.Items[P].Proc=nil) of
True:Result:=DefWindowProc(hwnd,msg,wParam,lParam);{Default}
False:Result:=iItems.Items[P].Proc(hwnd,msg,wParam,lParam);{Custom}
end;//end of case
except;end;
end;
//## Clear ##
Procedure TMsgList.Clear;
Var
   P,MaxP:Integer;
begin
try
MaxP:=Items.Count-1;
{Reset}
For P:=0 to MaxP Do iItems.Items[P].Proc:=nil;
{Clear}
iItems.Count:=0;
except;end;
end;
//## Find ##
Function TMsgList.Find(X:Hwnd):Integer;
Var
   P,MaxP:Integer;
begin
try
{Not Found}
Result:=-1;
MaxP:=iItems.Count-1;
{Search}
For P:=0 to MaxP Do If (iItems.Items[P].Handle=X) then
    begin
    Result:=P;
    break;
    end;//end of if
except;end;
end;
//## Add ##
Procedure TMsgList.Del(X:Hwnd);
Label
     SkipEnd;
Var
   iP,MaxP,P:Integer;
begin
try
{Check}
iP:=Find(X);
If (iP=-1) then Goto SkipEnd;
{Shift}
MaxP:=iItems.Count-2;
For P:=iP to MaxP Do iItems.Items[P]:=iItems.Items[P+1];
{Shrink}
iItems.Count:=iItems.Count-1;
SkipEnd:
except;end;
end;
//## Add ##
Function TMsgList.Add(X:Hwnd;Y:TWindowProc):Integer;
Label
     SkipEnd;
Var
   NewOk:Boolean;
   P:Integer;
begin
try
{Error}
Result:=-1;
{Check}
NewOk:=False;
P:=Find(X);
{New}
If (P=-1) then
   begin
   NewOk:=True;
   P:=iItems.Count;
   If (P>mglMaxItem) then Goto SkipEnd;
   end;//end of if
{Add/Edit}
iItems.Items[P].Handle:=X;
iItems.Items[P].Proc:=Y;
If NewOk then iItems.Count:=P+1;
SkipEnd:
{Return Result}
Result:=P;
except;end;
end;

//################ TLiteForm #######################################################
//## Create ##
Constructor TLiteForm.Create(dwStyle,dwExStyle:DWORD;pHandle:HWND);
Var
   P:Integer;
   A:TWndClassEx;
   hA:Atom;
   B:TWindowProc;
   C:TRect;
begin
{iHandle}
iHandle:=0;
{Defaults}
With iMouseInfo Do
begin
 Down:=False;
 Button:=mbLeft;
 Shift:=[];
 X:=0;
 Y:=0;
 lX:=0;
 lY:=0;
end;//end of with
{Default Styles}
If (dwStyle=-1) then dwStyle:=WS_POPUP or WS_SYSMENU or WS_GROUP;
If (dwExStyle=-1) then dwExStyle:=0;
{Other}
ipMouseInfo:=@iMouseInfo;
iTag:=0;
iVisible:=False;
{Prepare}
A.cbSize:=SizeOf(TWndClassEx);
A.style:=0;
A.lpfnWndProc:=@WindowProc;{Standard}
A.cbClsExtra:=0;
A.cbWndExtra:=0;
A.hInstance:=hInstance;
A.hIcon:=LoadIcon(HInstance,'mainicon');
A.hCursor:=hcrArrow;
A.hbrBackground:=GetStockObject(GRAY_BRUSH);;
A.lpszMenuName:=nil;
A.lpszClassName:='TLiteForm';
A.hIconSm:=LoadIcon(HInstance,'mainicon');
{iCursor}
iCursor:=A.hCursor;
{Regisitor TWndClassEx}
hA:=RegisterClassEx(A);
{Borderless Frame with Taskbar Icon/Menu/Minimizable/Restorable}
iHandle:=CreateWindowEx(dwExStyle,'TLiteForm','Form1',dwStyle,0,0,100,100,pHandle,0,hInstance,nil);
{WindowProc - Add to Global TMsgList}
AddWindowProc(Handle,WndProc);
{Size}
SetBounds(ScreenWidth Div 4,ScreenHeight Div 4,ScreenWidth Div 2,ScreenHeight Div 2);
end;
//## destroy ##
destructor TLiteForm.destroy;
var
   h:HWND;
begin
try
{prepare}
h:=iHandle;
iHandle:=0;
{process}
if (h<>0) then DestroyWindow(h);
//self
inherited;
except;end;
end;
//## _SetCursor ##
Procedure TLiteForm._SetCursor(X:HCursor);
begin
try
iCursor:=X;
SetCursor(X);
except;end;
end;
//## SetMouseCapture ##
Procedure TLiteForm.SetMouseCapture(X:Boolean);
begin
try
if (MouseCapture<>X) then
   begin
   Case X of
   True:SetCaptureHwnd(iHandle);
   False:SetCaptureHwnd(0);
   end;//end of case
   end;//end of if
except;end;
end;
//## GetMouseCapture ##
Function TLiteForm.GetMouseCapture:Boolean;
begin
try;Result:=(FCaptureHwnd=iHandle);except;end;
end;
//## SetBounds ##
Procedure TLiteForm.SetBounds(X,Y,W,H:Integer);
begin
try;SetWindowPos(Handle,0,X,Y,W,H,0);except;end;
end;
//## GetBounds ##
Function TLiteForm.GetBounds:TRect;
begin
try;GetWindowRect(Handle,Result);except;end;
end;
//## _GetClientRect ##
Function TLiteForm._GetClientRect:TRect;
begin
try;GetClientRect(Handle,Result);except;end;
end;
//## _SetClientRect ##
Procedure TLiteForm._SetClientRect(X:TRect);
Var
   A:TRect;
begin
try
If (X.Right<>ClientWidth) or (X.Bottom<>ClientHeight)then
   begin
   A:=GetBounds;
   A.Right:=X.Right+(Width-ClientWidth);
   A.Bottom:=X.Bottom+(Height-ClientHeight);
   SetBounds(A.Left,A.Top,A.Right,A.Bottom);
   end;//end of if
except;end;
end;
//## GetClientWidth ##
Function TLiteForm.GetClientWidth:Integer;
begin
try;Result:=ClientRect.Right;except;end;
end;
//## SetClientWidth ##
Procedure TLiteForm.SetClientWidth(X:Integer);
Var
   A:TRect;
begin
try
If (X<>ClientWidth) then
   begin
   A:=GetBounds;
   A.Right:=X+(Width-ClientWidth);
   A.Bottom:=Height;
   SetBounds(A.Left,A.Top,A.Right,A.Bottom);
   end;//end of if
except;end;
end;
//## GetClientHeight ##
Function TLiteForm.GetClientHeight:Integer;
begin
try;Result:=ClientRect.Bottom;except;end;
end;
//## SetClientHeight ##
Procedure TLiteForm.SetClientHeight(X:Integer);
Var
   A:TRect;
begin
try
If (X<>ClientHeight) then
   begin
   A:=GetBounds;
   A.Right:=Width;
   A.Bottom:=X+(Height-ClientHeight);
   SetBounds(A.Left,A.Top,A.Right,A.Bottom);
   end;//end of if
except;end;
end;
//## GetLeft ##
Function TLiteForm.GetLeft:Integer;
begin
try;Result:=GetBounds.Left;except;end;
end;
//## SetLeft ##
Procedure TLiteForm.SetLeft(X:Integer);
Var
   A:TRect;
begin
try
If (X<>Left) then
   begin
   A:=GetBounds;
   A.Left:=X;
   SetBounds(A.Left,A.Top,A.Right,A.Bottom);
   end;//end of if
except;end;
end;
//## GetTop ##
Function TLiteForm.GetTop:Integer;
begin
try;Result:=GetBounds.Top;except;end;
end;
//## SetTop ##
Procedure TLiteForm.SetTop(X:Integer);
Var
   A:TRect;
begin
try
If (X<>Top) then
   begin
   A:=GetBounds;
   A.Top:=X;
   SetBounds(A.Left,A.Top,A.Right,A.Bottom);
   end;//end of if
except;end;
end;
//## GetWidth ##
Function TLiteForm.GetWidth:Integer;
begin
try;Result:=GetBounds.Right-GetBounds.Left;except;end;
end;
//## SetWidth ##
Procedure TLiteForm.SetWidth(X:Integer);
Var
   A:TRect;
begin
try
If (X<>Width) then
   begin
   A:=GetBounds;
   A.Right:=X;
   A.Bottom:=Height;
   SetBounds(A.Left,A.Top,A.Right,A.Bottom);
   end;//end of if
except;end;
end;
//## GetHeight ##
Function TLiteForm.GetHeight:Integer;
begin
try;Result:=GetBounds.Bottom-GetBounds.Top;except;end;
end;
//## SetHeight ##
Procedure TLiteForm.SetHeight(X:Integer);
Var
   A:TRect;
begin
try
If (X<>Height) then
   begin
   A:=GetBounds;
   A.Right:=Width;
   A.Bottom:=X;
   SetBounds(A.Left,A.Top,A.Right,A.Bottom);
   end;//end of if
except;end;
end;
//## DoMouse ##
Procedure TLiteForm.DoMouse(X:Integer);
begin
try
Case X of
lfmDown:If Assigned(FOnMouseDown) then FOnMouseDown(Self,iMouseInfo.Button,iMouseInfo.Shift,iMouseInfo.X,iMouseInfo.Y);
lfmMove:If Assigned(FOnMouseMove) then FOnMouseMove(Self,iMouseInfo.Shift,iMouseInfo.X,iMouseInfo.Y);
lfmUp:If Assigned(FOnMouseUp) then FOnMouseUp(Self,iMouseInfo.Button,iMouseInfo.Shift,iMouseInfo.X,iMouseInfo.Y);
end;//end of case
except;end;
end;
//## WndProc ##
Function TLiteForm.WndProc(hWnd:HWND;Msg:UINT;wParam:WPARAM;lParam:LPARAM):LRESULT;
Var
   A:TCloseAction;
   B:Boolean;
   C:TMsgConv;
   PS:TPaintStruct;
   tmpDC:HDC;
begin
try
{Default Reply}
Result:=0;
If Assigned(FOnWndProc) then
   begin
   Result:=FOnWndProc(hWnd,Msg,wParam,lParam);
   //socket message - exit
   if (msg=cm_socketmessage) then exit;//15JAN2008
   //other
   if (result<>0) then exit;
   end;//end of if
{Process}
Case Msg of
WM_SETCURSOR:begin
    SetCursor(iCursor);
    exit;
    end;//end of begin
WM_COMMAND:begin
    Perform(WM_SYSCOMMAND,wParam,lParam);
    exit;
    end;//end of begin
WM_SYSCOMMAND:;
//Mouse
WM_LBUTTONDOWN,WM_MBUTTONDOWN,WM_RBUTTONDOWN:begin
     If iMouseInfo.Down then exit;
     iMouseInfo.Down:=True;
     MouseCapture:=True;
     msgXY(lParam,iMouseInfo.X,iMouseInfo.Y);
     Case Msg of
     WM_LBUTTONDOWN:iMouseInfo.Button:=mbLeft;
     WM_MBUTTONDOWN:iMouseInfo.Button:=mbMiddle;
     WM_RBUTTONDOWN:iMouseInfo.Button:=mbRight;
     end;//end of case
     DoMouse(lfmDown);
     iMouseInfo.lX:=iMouseInfo.X;
     iMouseInfo.lY:=iMouseInfo.Y;
     end;//end of begin
WM_MOUSEMOVE:begin
     msgXY(lParam,iMouseInfo.X,iMouseInfo.Y);
     DoMouse(lfmMove);
     end;//end of if
WM_LBUTTONUP,WM_MBUTTONUP,WM_RBUTTONUP:begin
     If Not iMouseInfo.Down then exit;
     msgXY(lParam,iMouseInfo.X,iMouseInfo.Y);
     DoMouse(lfmUp);
     iMouseInfo.lX:=iMouseInfo.X;
     iMouseInfo.lY:=iMouseInfo.Y;
     MouseCapture:=False;
     iMouseInfo.Down:=False;
     end;//end of begin
//Size
WM_SIZING:;
WM_SIZE:If Assigned(FOnResize) then FOnResize(Self);
//Paint
WM_PAINT:begin
     {Prepare}
     tmpDC:=BeginPaint(Handle,PS);
     {Process}
     iPaintDC:=tmpDC;
     If Assigned(FOnPaint) then FOnPaint(Self);
     {Finish}
     EndPaint(Handle,PS);
     If (iPaintDC=tmpDC) then iPaintDC:=0;
     end;//end of begin
//Close/Destroy
WM_QUERYENDSESSION:begin
   B:=True;
   If Assigned(FOnCloseQuery) then FOnCloseQuery(Self,B);
   Result:=Integer(B);
   exit;
   end;//end of if
WM_EndSession:begin
   If Assigned(FOnEndSession) then FOnEndSession(Self);
   If Assigned(FOnHalt) then FOnHalt(Self);
   exit;
   end;//end of begin
WM_CLOSE:begin
   If Assigned(FOnClose) then FOnClose(Self);
   If Assigned(FOnHalt) then FOnHalt(Self);
   exit;
   end;//end of begin
WM_DESTROY:;
end;//end of case
{Windows Handler}
Result:=DefWindowProc(hWnd,Msg,wParam,lParam);
except;end;
end;
//## msgXY ##
Procedure TLiteForm.msgXY(X:Longint;Var rX,rY:Integer);
Var
   A:TMsgConv;
begin
try
A.lParam:=X;
rX:=A.lParamLo;
rY:=A.lParamHi;
except;end;
end;
//## Show ##
Procedure TLiteForm.Show;
begin
try;Visible:=True;except;end;
end;
//## Hide ##
Procedure TLiteForm.Hide;
begin
try;Visible:=False;except;end;
end;
//## SetVisible ##
Procedure TLiteForm.SetVisible(X:Boolean);
begin
try
{Check}
If (X=Visible) then exit;
{Set}
Case X of
True:ShowWindow(Handle,SW_SHOWNORMAL);
False:ShowWindow(Handle,SW_HIDE);
end;//end of case
iVisible:=X;
except;end;
end;
//## Perform ##
Function TLiteForm.Perform(Msg:UINT;wParam:WPARAM;lParam:LPARAM):LRESULT;
begin
try;Result:=WndProc(iHandle,Msg,wParam,lParam);except;end;
end;
//## SetCaption ##
Procedure TLiteForm.SetCaption(X:String);
Var
   A:PChar;
begin
try
{Check}
If (X=Caption) then exit;
{Set}
Perform(WM_SETTEXT,0,LongInt(PChar(X)));
except;end;
end;
//## GetCaption ##
Function TLiteForm.GetCaption:String;
Var
  A:PChar;
  Len:Integer;
begin
try
Len:=Perform(WM_GETTEXTLENGTH,0,0);
SetString(Result,PChar(nil),Len);
if (Len<>0) then Perform(WM_GETTEXT,Len+1,LongInt(Result));
except;end;
end;
//## PaintTo ##
Procedure TLiteForm.PaintTo(dRect:TRect;sDC:HDC;sRect:TRect;Rop:DWORD);
Var
   tmpDC:HDC;
   NewDC:Boolean;
begin
try
{Prepare}
tmpDC:=iPaintDC;
NewDC:=False;
If (tmpDC=0) then
   begin
   tmpDC:=GetDC(Handle);
   NewDC:=True;
   end;//end of if
{Process}
StretchBlt(tmpDC,dRect.Left,dRect.Top,dRect.Right,dRect.Bottom,sDC,sRect.Left,sRect.Top,sRect.Right,sRect.Bottom,Rop);
except;end;
try;If NewDC then ReleaseDC(Handle,tmpDC);except;end;
end;

//################## TApp ######################################################
//## create ##
constructor TApp.create;
begin
inherited;
//.vars
iTerminated:=False;
iRunning:=False;
iHandle:=0;
iMainForm:=nil;
iExeName:=ParamStr(0);
end;
//## destroy ##
destructor TApp.destroy;
begin
try
{other}
iRunning:=false;
iTerminated:=true;
{OnClose}
if Assigned(FOnClose) then FOnClose(Self) else Close(Self);
{PostQuitMessage}
PostQuitMessage(0);
//self
inherited;
except;end;
end;
//## Run ##
Procedure TApp.Run;
begin
try
{Ignore}
If iRunning then exit;
{Run}
iRunning:=True;
{Update}
App.ProcessMessages;
{App Message Loop}
Repeat HandleMessage until Terminated;
{Free}
Free;
except;end;
end;
//## Terminate ##
Procedure TApp.Terminate;
begin
try;If Not iTerminated then iTerminated:=True;except;end;
end;
//## ProcessMessages ##
Procedure TApp.ProcessMessages;
begin
try;while ProcessMessage do {loop};except;end;
end;
//## ProcessMessage ##
Function TApp.ProcessMessage:Boolean;
Var
  Handled:Boolean;
  Msg:TMsg;
begin
try
Result:=False;
if PeekMessage(Msg,0,0,0,PM_REMOVE) then
   begin
   Result:=True;
   Case (Msg.Message<>WM_QUIT) of
   True:begin
       Handled:=False;
       If Assigned(FOnMessage) then FOnMessage(Msg,Handled);
      //yyyyyyyyyyyyyyyyyif not IsHintMsg(Msg) and not Handled and not IsMDIMsg(Msg) and
       If (not IsKeyMsg(Msg)) then
          begin
          TranslateMessage(Msg);
          DispatchMessage(Msg);
          end;//end of if
       end;//end of begin
   False:iTerminated:=True;
   end;//end of case
   end;//end of if
except;end;
end;
//## HandleMessage ##
Procedure TApp.HandleMessage;
begin
try;if not ProcessMessage then Idle;except;end;
end;
//## Idle ##
Procedure TApp.Idle;
Var
  Done:Boolean;
begin
try
Done:=True;
{OnIdle}
if Assigned(FOnIdle) then FOnIdle(Self, Done);
{Wait}
if Done then WaitMessage;
except;end;
end;
//## IsKeyMsg ##
Function TApp.IsKeyMsg(var Msg:TMsg):Boolean;
Var
   WND:HWND;
begin
try
Result:=False;
with Msg do
if (Message>=WM_KEYFIRST) and (Message<=WM_KEYLAST) and (GetCapture=0) then
   begin
   Wnd:=HWnd;
   {MainForm}
   //yyyyyyyyyyyyyyyyyif (MainForm<>nil) then Wnd:=MainForm;//yyyyyyyyyyyyyyyyy (Wnd=MainForm.ClientHandle) then Wnd:=MainForm.Handle;
   {Send Message}
   if (SendMessage(Wnd,CN_BASE+Message,WParam,LParam)<>0) then Result:=True;
   end;//end of if
except;end;
end;
//## Close ##
Procedure TApp.Close(Sender:TObject);
begin{Place App Close Code Here}
try
{nil}
except;end;
end;
//## rthtranslate ##
function rthtranslate(x:string):string;//05OCT2007 - don't translate, just mark the text for "sniffer", since text will be translated in realtime on demand
var
   tmp,e:string;
begin
try
//custom translator - just fill with empty translation
multilingual.translate(x,tmp,e,stHelp);
//return raw data - controls use this for bait and to fill "tsup" for later use
result:=x;
except;end;
end;
//## ntranslate ##
function ntranslate(x:string):string;
begin
try;result:=general.asname(translate(x));except;end;
end;
//## translate ##
function translate(x:string):string;
var
   e:string;
begin
try;result:=x;multilingual.translate(x,result,e,stMain);except;end;
end;
//## TranslateParts ##
Function TranslateParts(x:string):String;
label
     redo,skipone;
var
   a:tstringlist;
   op,s,zlen,p2,p:integer;
   sc:char;{search character = first character per line}
   z:string;
   Y:Boolean;{Found Y=True}
begin
try
{prepare}
a:=nil;
a:=tstringlist.create;
a.text:=x;
{process}
for p:=0 to (a.count-1) do
begin
//get
z:=a.strings[p];
zlen:=length(z);
//check
if (zLen<2) then
   begin
   z:='';
   goto skipone;
   end;//end of if
//sc
sc:=z[1];
z:=copy(z,2,zLen);
zLen:=zLen-1;
//scan
redo:
s:=-1;
for p2:=1 to zLen do
begin
//start
case s of
-1:if (z[p2]=sc) then s:=p2;
else
if ((z[p2]=sc) or (p2=zlen)) then
   begin
   z:=copy(z,1,s-1)+Translate(copy(z,s+1,p2-s-1))+copy(z,p2+1,zLen);
   goto redo;
   end;//end of if
end;//end of case
end;//end of loop
//set
a.strings[p]:=z;
skipone:
end;//end of loop
{return result}
result:=a.text;
except;end;
try;freeobj(@a);except;end;
end;

{
//## TranslateAssign ##
Function TranslateAssign(FromOld:Boolean;Var ErrMsg:String):Boolean;
Label
     SkipEnd;
Var
   MaxP,P:Integer;
   A:TLiteLanguage;
   B:TLanguage;
begin//Interconnects TLanguage<->TLiteLanguage
try
//Error
Result:=False;
ErrMsg:=gecOutOfMemory;
//Prepare
A:=LiteLanguage;
B:=Language;
//Process
Case FromOld of
True:begin
    //Info
    A.Clear;
    A.Caption:=B.Caption;
    A.TEP:=B.TEP;
    A.ExtraInfo1:='';
    A.ExtraInfo2:='';
    A.KeyA:=B.KeyA;
    A.KeyB:=B.KeyB;
    A.Details:=B.Details;
    //Items
    MaxP:=B.Items.Count-1;
    For P:=0 to MaxP Do If (-1=A.Add(B.Items.Items[P][0],B.Items.Items[P][1])) then
        begin
        ErrMsg:=A.ErrorMessage;
        A.Clear;
        Goto SkipEnd;
        end;//end of if
    end;//end of begin
False:begin
    //Info
    B.Clear;
    B.Caption:=A.Caption;
    B.TEP:=A.TEP;
    B.KeyA:=A.KeyA;
    B.KeyB:=A.KeyB;
    B.Details:=A.Details;
    //Items
    MaxP:=A.Items.Count-1;
    For P:=0 to MaxP Do If (-1=B.Add(A.Items.Items[P][0],A.Items.Items[P][1])) then
        begin
        Case (B.ErrorMessage=gecCapacityReached) of
        True:break;//At Limit - No Error
        False:begin//Other Error
            ErrMsg:=B.ErrorMessage;
            B.Clear;
            Goto SkipEnd;
            end;//end of begin
        end;//end of case
        end;//end of if
    end;//end of begin
end;//end of case
//Successful
Result:=True;
SkipEnd:
except;end;
end;
{}
//## App ##
Function App:TApp;
begin
try;if (FApp=nil) then FApp:=TApp.Create;Result:=FApp;except;end;
end;
//## MsgList ##
Function MsgList:TMsgList;
begin
try
if (FMsgList=nil) then FMsgList:=TMsgList.create;
result:=FMsgList;
except;end;
end;


const
  Z_NO_FLUSH      = 0;
  Z_PARTIAL_FLUSH = 1;
  Z_SYNC_FLUSH    = 2;
  Z_FULL_FLUSH    = 3;
  Z_FINISH        = 4;
  Z_OK            = 0;
  Z_STREAM_END    = 1;
  Z_NEED_DICT     = 2;
  Z_ERRNO         = (-1);
  Z_STREAM_ERROR  = (-2);
  Z_DATA_ERROR    = (-3);
  Z_MEM_ERROR     = (-4);
  Z_BUF_ERROR     = (-5);
  Z_VERSION_ERROR = (-6);
  Z_NO_COMPRESSION       =   0;
  Z_BEST_SPEED           =   1;
  Z_BEST_COMPRESSION     =   9;
  Z_DEFAULT_COMPRESSION  = (-1);
  Z_FILTERED            = 1;
  Z_HUFFMAN_ONLY        = 2;
  Z_DEFAULT_STRATEGY    = 0;
  Z_BINARY   = 0;
  Z_ASCII    = 1;
  Z_UNKNOWN  = 2;
  Z_DEFLATED = 8;

{$L deflate.obj}
{$L inflate.obj}
{$L inftrees.obj}
{$L trees.obj}
{$L adler32.obj}
{$L infblock.obj}
{$L infcodes.obj}
{$L infutil.obj}
{$L inffast.obj}

procedure _tr_init; external;
procedure _tr_tally; external;
procedure _tr_flush_block; external;
procedure _tr_align; external;
procedure _tr_stored_block; external;
procedure adler32; external;

procedure inflate_blocks_new; external;
procedure inflate_blocks; external;
procedure inflate_blocks_reset; external;
procedure inflate_blocks_free; external;
procedure inflate_set_dictionary; external;
procedure inflate_trees_bits; external;
procedure inflate_trees_dynamic; external;
procedure inflate_trees_fixed; external;
procedure inflate_trees_free; external;
procedure inflate_codes_new; external;
procedure inflate_codes; external;
procedure inflate_codes_free; external;
procedure _inflate_mask; external;
procedure inflate_flush; external;
procedure inflate_fast; external;

procedure _memset(P: Pointer; B: Byte; count: Integer);cdecl;
begin
  FillChar(P^, count, B);
end;

procedure _memcpy(dest, source: Pointer; count: Integer);cdecl;
begin
  Move(source^, dest^, count);
end;

// deflate compresses data
function deflateInit_(var strm: TZStreamRec; level: Integer; version: PChar;
  recsize: Integer): Integer; external;
function deflate(var strm: TZStreamRec; flush: Integer): Integer; external;
function deflateEnd(var strm: TZStreamRec): Integer; external;

// inflate decompresses data
function inflateInit_(var strm: TZStreamRec; version: PChar;
  recsize: Integer): Integer; external;
function inflate(var strm: TZStreamRec; flush: Integer): Integer; external;
function inflateEnd(var strm: TZStreamRec): Integer; external;
function inflateReset(var strm: TZStreamRec): Integer; external;

function zlibAllocMem(AppData: Pointer; Items, Size: Integer): Pointer;
begin
  GetMem(Result, Items*Size);
end;

procedure zlibFreeMem(AppData, Block: Pointer);
begin
  FreeMem(Block);
end;

//############################ tnv #############################################
//## create ##
constructor tnv.create;
begin
inherited;
data:=nil;
//defaults
clear;
end;
//## clear ##
procedure tnv.clear;
begin
try
//process
if (data<>nil) then data^:='';
data:=nil;
idatalen:=0;
ipos:=0;
icount:=0;
except;end;
end;
//## initwrite ##
function tnv.initwrite(_hdr:string;var e:string):boolean;
begin//custom header
try
//error
result:=false;
//check
e:=gecIndexOutOfRange;
if (data=nil) then exit;
//process
e:=gecOutOfMemory;
data^:=_hdr;
idatalen:=length(data^);
ipos:=idatalen+1;
icount:=0;
//successful
result:=true;
except;end;
end;
//## writeb ##
function tnv.writeb(n,v:string;var e:string):boolean;
begin
try;result:=write(n,v,e);except;end;
end;
//## write ##
function tnv.write(n:string;var v,e:string):boolean;
label
     skipend;
const
   nMAXSIZE=high(word);
var
   nLEN:twrd2;
   vLEN:tint4;
   nL:integer;
begin
try
//error
result:=false;
e:=gecOutOfMemory;
//process
//.get
nL:=length(n);
//.set
if (nL>=1) then
   begin
   //.enforce range
   if (nL>nMAXSIZE) then
      begin
      delete(n,nMAXSIZE+1,nL);
      nL:=nMAXSIZE;
      end;//end of if
   //.info+name+value
   nLEN.val:=nL;
   vLEN.val:=length(v);
   if not pushb(idatalen,data^,
      nLEN.chars[0]+nLEN.chars[1]+
      vLEN.chars[0]+vLEN.chars[1]+vLEN.chars[2]+vLEN.chars[3]
      ) then goto skipend;
   if not push(idatalen,data^,n) then goto skipend;
   if not push(idatalen,data^,v) then goto skipend;
   //.count
   icount:=icount+1;
   end
   //.finalise
   else if not pushb(idatalen,data^,'') then goto skipend;
   //end of if
//successful
result:=true;
skipend:
except;end;
end;
//## initread ##
function tnv.initread(_hdr:string;var e:string):boolean;
var
   z:integer;
begin
try
result:=false;
//process
//.nil
e:=gecIndexOutOfRange;
if (data=nil) then exit;
//.format
e:=gecUnknownFormat;
z:=length(_hdr);
if (copy(data^,1,z)<>_hdr) then exit;
//.pos
idataLEN:=length(data^);
ipos:=z+1;
icount:=0;
//successful
result:=true;
except;end;
end;
//## canread ##
function tnv.canread:boolean;
begin
try;result:=(ipos>=1) and (ipos<=idataLEN);except;end;
end;
//## read ##
function tnv.read(var n,v,e:string):boolean;
label
     skipend;
var
   nLEN:twrd2;
   vLEN:tint4;
begin
try
//error
result:=false;
//.check
e:=gecDataCorrupt;
if ((ipos+5)>idataLEN) then goto skipend;
//process
//.info
nLEN.chars[0]:=data^[ipos];
nLEN.chars[1]:=data^[ipos+1];
vLEN.chars[0]:=data^[ipos+2];
vLEN.chars[1]:=data^[ipos+3];
vLEN.chars[2]:=data^[ipos+4];
vLEN.chars[3]:=data^[ipos+5];
ipos:=ipos+6;//word+integer
if (vLEN.val<0) or ((ipos+nLEN.val+vLEN.val-1)>idataLEN) then goto skipend;
//.name
e:=gecOutOfMemory;
n:=copy(data^,ipos,nLEN.val);
ipos:=ipos+nLEN.val;
//.value
v:=copy(data^,ipos,vLEN.val);
ipos:=ipos+vLEN.val;
//.count
icount:=icount+1;
//successful
result:=true;
skipend:
except;end;
try
if not result then
   begin
   n:='';
   v:='';
   end;//end of if
except;end;
end;

//############################ tdualmask #######################################
//## create ##
constructor tdualmask.create;
begin
inherited;
//defaults
imask:=nil;
emask:=nil;
prepad:='';
postpad:='';
sep:='=';
isc:=false;
end;
//## destroy ##
destructor tdualmask.destroy;
begin
try
freeObj(@imask);
freeObj(@emask);
//self
inherited;
except;end;
end;
//## setmasks ##
procedure tdualmask.setmasks(x:string);
var
   iv,ev:string;
   p,p2:integer;
begin
try
//defaults
iv:='';
ev:='';
//process
//.include
p:=1;
if general.findtext(p,x,sep) then
   begin
   iv:=copy(x,1,p-1);
   //.exclude
   p:=p+1;p2:=p;
   if general.findtext(p2,x,sep) then ev:=copy(x,p,p2-p) else ev:=copy(x,p2,length(x));
   end
   else iv:=x;
//.set
init(iv,ev);
except;end;
end;
//## getmasks ##
function tdualmask.getmasks:string;
begin
try;result:=imask.mask+sep+emask.mask;except;end;
end;
//## init ##
procedure tdualmask.init(_include,_exclude:string);
begin
try
//process
//.include
if (_include='') then freeObj(@imask)
else
    begin
    if (imask=nil) then imask:=tmasks.create;
    imask.dmask:='';
    imask.prepad:=prepad;
    imask.postpad:=postpad;
    imask.mask:=_INCLUDE;
    imask.isc:=isc;
    end;//end of if
//.exclude
if (_exclude='') then freeObj(@emask)
else
    begin
    if (emask=nil) then emask:=tmasks.create;
    emask.dmask:='';
    emask.prepad:=prepad;
    emask.postpad:=postpad;
    emask.mask:=_EXCLUDE;
    emask.isc:=isc;
    end;//end of if
except;end;
end;
//## inmask ##
function tdualmask.inmask(x:string):boolean;
begin
try;result:=((imask=nil) or imask.wm(x)) and ((emask=nil) or (not emask.wm(x)));except;end;
end;
//## inlist ##
function tdualmask.inlist(x:string):string;//filters supplied list
var
   a:tstringlist;
   p:integer;
begin
try
//defaults
result:='';
//process
a:=newstringlist(x);
for p:=(a.count-1) downto 0 do if not inmask(a.strings[p]) then a.delete(p);
//return result
result:=a.text;
except;end;
try;freeObj(@a);except;end;
end;

//############################ tio #############################################
//## pushb ##
function pushb(var _dataLEN:integer;var _data:string;_add:string):boolean;
begin
try;result:=pushbx(_dataLEN,tio1Mb,_data,_add);except;end;
end;
//## push ##
function push(var _dataLEN:integer;var _data,_add:string):boolean;
begin
try;result:=pushx(_dataLEN,tio1Mb,_data,_add);except;end;
end;
//## pushbx ##
function pushbx(var _dataLEN:integer;_bufferSTEP:integer;var _data:string;_add:string):boolean;
begin
try;result:=pushx(_dataLEN,_bufferSTEP,_data,_add);except;end;
end;
//## pushx ##
function pushx(var _dataLEN:integer;_bufferSTEP:integer;var _data,_add:string):boolean;
var//high capacity, rapid string assembler
   //note: _dataLEN must initially be set by host
   p,s,_addLEN:integer;
begin
try
//error
result:=false;
//prepare
_addLEN:=length(_add);
//process
//.finalise
if (_addLEN=0) then
   begin
   delete(_data,_dataLEN+1,length(_data));
   result:=true;
   exit;
   end;//end of if
//.size
if ((_dataLEN+_addLEN)>length(_data)) then
   begin
   s:=_addLEN;
   if (s<_bufferSTEP) then s:=_bufferSTEP;
   setlength(_data,_dataLEN+s);
   end;//end of if
//.set (work down to fisrt, 15% faster @ 200Mhz)
for p:=_addLEN downto 1 do _data[_dataLEN+p]:=_add[p];
//.inc
_dataLEN:=_dataLEN+_addLEN;
//successful
result:=true;
except;end;
end;
//## pushlimit ##
function pushlimit(var _dataLEN:integer;_bufferSTEP,_limit:integer;var _data,_add:string):boolean;
var//high capacity, rapid string assembler
   //note: _dataLEN must initially be set by host
   p,s,_addLEN:integer;
begin
try
//error
result:=false;
//prepare
_addLEN:=length(_add);
//process
//.finalise
if (_addLEN=0) then
   begin
   //.range
   if (_dataLEN>_limit) then _dataLEN:=_limit;
   //.set
   delete(_data,_dataLEN+1,length(_data));
   result:=true;
   exit;
   end;//end of if
//.limit - Note: "limit<=-1" = unlimited (no limit)
if (_limit>=0) and ((_dataLEN+_addLEN)>_limit) then
   begin
   _addLEN:=_limit-_dataLEN;
   if (_addLEN<=0) then
      begin
      result:=true;
      exit;
      end;//end of if
   end;//end of if
//.size
if ((_dataLEN+_addLEN)>length(_data)) then
   begin
   s:=_addLEN;
   if (s<_bufferSTEP) then s:=_bufferSTEP;
   setlength(_data,_dataLEN+s);
   end;//end of if
//.set (work down to fisrt, 15% faster @ 200Mhz)
for p:=_addLEN downto 1 do _data[_dataLEN+p]:=_add[p];
//.inc
_dataLEN:=_dataLEN+_addLEN;
//successful
result:=true;
except;end;
end;
//## pushlimitb ##
function pushlimitb(var _dataLEN:integer;_bufferSTEP,_limit:integer;var _data:string;_add:string):boolean;
begin
try;result:=pushlimit(_dataLEN,_bufferSTEP,_limit,_data,_add);except;end;
end;

//## create ##
constructor tio.create;
begin
inherited;
//ipinfo
ipinfo:=@iinfo;
//vars
blocking:=false;
hml:=true;
hfls:=true;
imask:=nil;
iinfo.cantotal:=false;
itlFileName:='';
//.lock
ilock:=nil;
ilockfn:='';
//defaults
clear;
end;
//## destroy ##
destructor tio.destroy;
begin
try
//controls
freeObj(@imask);
//self
inherited;
except;end;
end;
//## lock ##
function tio.lock(_name:string):boolean;
var
   x:string;
begin
try
//defaults
result:=false;
//check
if (ilock<>nil) then exit;
//process
//.get
x:=bvfportable(bvfCritical+'Lock\')+_name;
//.delete
remfile(x);
//.set
ilock:=tfilestream.create(x,fmCreate);
ilockfn:=x;
//successful
result:=true;
except;end;
try;if not result then freeobj(@ilock);except;end;
end;
//## unlock ##
function tio.unlock:boolean;
begin
try
//defaults
result:=false;
//check
if (ilock=nil) then
   begin
   result:=true;
   exit;
   end;//end of if
//process
//.release file
freeobj(@ilock);
//.delete file
if (ilockfn<>'') then
   begin
   remfile(ilockfn);
   ilockfn:='';
   end;//end of if
//successful
result:=true;
sleep(100);
except;end;
end;
//## eatread ##
function tio.eatread(var eat:string;name:string;var value,e:string):boolean;
label
   skipend;
var
   a:tnamevalue;
   p:integer;
   tmp:string;
begin
try
//error
result:=false;
a:=nil;
value:='';
//check
e:=gecUnexpectedError;
if (length(eat)=0) then exit;
//prepare
a:=tnamevalue.create;
a.nativeformat:=tiohEAT;
//process
//.str -> .eat list
if not a.push(tiohEAT,eat,e) then goto skipend;
//.find
p:=a.findmask('*'+name,'|*');
if (p>=0) then
   begin
   tmp:=a.valuesptr[p]^;
   if io.fromC(tmp,e) then value:=tmp;
   //successful
   result:=true;
   end;//end of if
skipend:
except;end;
try;freeobj(@a);except;end;
end;
//## pushvalueb ##
function tio.pushvalueb(n,v:string;var e:string):boolean;
begin
try;result:=pushvalue(n,v,e);except;end;
end;
//## pushvalue ##
function tio.pushvalue(n:string;var v,e:string):boolean;
begin
try
//prepare
n:=bvfportable(bvfSettings)+extractfilename(n);
//process
result:=toFile(n,v,e);
except;end;
end;
//## pullvalue ##
function tio.pullvalue(n:string;var v,e:string):boolean;
begin
try
//defaults
v:='';
//prepare
n:=bvfportable(bvfSettings)+extractfilename(n);
//process
result:=fromFilec(n,v,e,-1);
except;end;
end;
//## getsnippetfilename ##
function tio.getsnippetfilename(name:string):string;
begin
try;result:=bvfportable(bvfSnippet)+programname+'-'+name+'.snippet';except;end;
end;
//## getsnippet ##
function tio.getsnippet(name:string):string;
var
   e:string;
begin
try;fromfile(snippetfilename[name],result,e);except;end;
end;
//## setsnippet ##
procedure tio.setsnippet(name:string;value:string);
var
   e:string;
begin
try;tofile(snippetfilename[name],value,e);except;end;
end;
//## _extractfilename ##
function tio._extractfilename(x:string;_style:tioUnpackStyle):string;
begin
try
//process
if (ioupTitleName in _style) then result:=general.asname(extractfilename(x))
else result:=lowercase(extractfilename(x));
except;end;
end;
//## unpackto ##
function tio.unpackto(var eat:string;_destpath:string;var _count,_total:integer;_style:tioUnpackStyle;var e:string):boolean;//09OCT2007
label//Note: use "ioupAutoPath" to extract files automatically to "start button"
     skipend;
var
   a:tnamevalue;
   c:tstringlist;
   dn,v,n:string;//Note: dn2=2nd destination filename, for say "chatimages" which now supports "gif,bmp,ico etc" - only for "ioupAutoPath"
   p:integer;
begin
try
//error
result:=false;
a:=nil;
c:=nil;
_count:=0;
_total:=0;
//check
e:=gecUnexpectedError;
if (length(eat)=0) then exit;
//prepare
a:=tnamevalue.create;
a.nativeformat:=tiohEAT;
_destpath:=asfolder(_destpath);
//process
//.str -> .eat list
if not a.push(tiohEAT,eat,e) then goto skipend;
//.get
c:=tstringlist.create;
c.text:=a.allnames;
for p:=0 to (c.count-1) do
begin
n:=c.strings[p];
if (n<>'') and (n[1]<>'|') then
   begin
   //.total
   inc(_total);
   //.get
   if (ioupAutoPath in _style) then
      begin
      //get
      dn:=extfolder(n)+_extractfilename(n,_style);
      end
   else
      begin
      //.path
      if not directoryexists(_destpath) then
         begin
         forcedirectories(_destpath);
         e:=gecOutOfDiskSpace;
         if not directoryexists(_destpath) then goto skipend;
         end;//end of if
      //.filename
      dn:=lowercase(_destpath)+_extractfilename(n,_style);
      end;//end of if
   v:=a.values[n];
   //.decode
   if not io.fromC(v,e) then goto skipend;
   //file 1
   if ((ioupOverwrite in _style) or (not fileexists(dn))) and (not io.toFILE(dn,v,e)) then
      begin
      if not (ioupPersistWithErrors in _style) then goto skipend;
      end
   else inc(_count);//inc
   end;//end of if
end;//end of loop
//successful
result:=(_count=_total);
skipend:
except;end;
try;freeobj(@a);freeobj(@c);except;end;
end;
//## tls ##
procedure tio.tls;//translate labels
begin
try
//check
if (itlFileName<>'') then exit;
//process
itlFileName:=ntranslate('file name')+': '+#9;
itlSize:=ntranslate('size')+': '+#9;
itlDate:=ntranslate('date')+': '+#9;
itlByte:=translate('bytes');
except;end;
end;
//## dds ##
function tio.dds(var x:string):integer;//determine data type
var
   z:string;
begin
try
//defaults
result:=tiohUnknown;
//process
z:=copy(x,1,10);
if (copy(z,1,2)='C!') then result:=tiohC
else if (copy(z,1,2)='BM') then result:=tiohBMP
else if (copy(z,1,4)='EAT!') then result:=tiohEAT
else if (copy(z,1,4)='LST!') then result:=tiohLST
else if isMTXT(x) then result:=tiohMTXT;
except;end;
end;
//## decode ##
function tio.decode(var x:string;_nv:tobject;_destformat:integer;var e:string):boolean;
label
     skipend;
var
   ok:boolean;
   c,p:integer;
begin
try
//error
result:=false;
e:=gecUnknownFormat;
//prepare
ok:=true;
c:=0;
//process
while TRUE do
begin
//.determine data style
p:=dds(x);
case p of
tiohC:ok:=fromC(x,e);
tiohBMP:ok:=fromBMPb(x,e);
tiohEAT:begin
        ok:=fromEAT(_nv,x,e);
        p:=_destformat;
        end;//end of begin
tiohLST:begin
        ok:=fromNV(_nv,'LST!',x,e);
        p:=_destformat;
        end;//end of begin
tiohMTXT:begin
        ok:=fromMTXT(_nv,x,e);
        p:=_destformat;
        end;//end of begin
tioEML:begin
        ok:=fromMTXT(_nv,x,e);
        p:=_destformat;
        end;//end of begin
else//tiohUnknown
    begin
    e:=gecUnknownFormat;
    ok:=false;
    end;//end of begin
end;//end of case
//.error
if icancelled or (not ok) then goto skipend;
//.check
if (p=_destformat) then break;
//.safety check
c:=c+1;
if (c>=10) then goto skipend;
end;//end of with
//successful
result:=true;
skipend:
except;end;
try;aem(e);except;end;
end;
//## encode ##
function tio.encode(var x:string;_nv:tobject;_destformat:integer;var e:string):boolean;
label
     skipend;
var
   a:tnamevalue;
   ok:boolean;
   z:string;
   d:integer;
begin
try
//error
result:=false;
//prepare
ok:=true;
//.list ->str
if isNVobj(_nv,e) then
   begin
   a:=_nv as tnamevalue;
   //.use native or switch to alternative "list style" format
   case _destformat of
   tiohEAT,tiohLST,tiohMTXT:d:=_destformat;
   else d:=a.nativeformat;
   end;//end of case
   //.set
   case d of
   tiohEAT:ok:=toEAT(a,x,e);
   tiohLST:ok:=toNV(a,'LST!',x,e);
   tiohMTXT:ok:=toMTXT(a,x,e);
   else
       begin
       e:=gecUnknownFormat;
       goto skipend;
       end;//end of begin
   end;//end of case
   if not ok then goto skipend;
   end;//end of if
//process
//.set
case _destformat of
tiohC:ok:=toC(x,e);
tiohBMP:ok:=toBMPb(x,e);
tioTXT:begin
      ok:=toTXT(x,z,e);
      x:='';
      x:=z;
      end;//end of begin
end;//end of case
if icancelled or (not ok) then goto skipend;
//successful
result:=true;
skipend:
except;end;
try;aem(e);except;end;
end;
//## wsvb16 ##
function tio.wsvb16(var x:string;v:string):boolean;//write string value (16bit length)
begin
try;result:=wsv16(x,v);except;end;
end;
//## wsv16 ##
function tio.wsv16(var x,v:string):boolean;//write string value (16bit length)
const
     vMAXSIZE=high(word);
var
   a:twrd2;
   p,xlen:integer;
begin
try
//error
result:=false;
//process
//.get
a.val:=length(v);if (a.val>vMAXSIZE) then a.val:=vMAXSIZE;
xlen:=length(x);
//.size
setlength(x,xlen+2+a.val);
//.header
x[xlen+2]:=a.chars[1];
x[xlen+1]:=a.chars[0];
//.data
for p:=a.val downto 1 do x[xlen+2+p]:=v[p];
//successful
result:=true;
except;end;
end;
//## rsv16 ##
function tio.rsv16(var p:integer;var x,v:string):boolean;//read str value (16bit length)
label
     skipend;
var
   a:twrd2;
   xlen,vlen:integer;
begin
try
//error
result:=false;
//prepare
xlen:=length(x);
if (p<1) or ((p+1)>xlen) then goto skipend;
//process
//.get
a.chars[1]:=x[p+1];
a.chars[0]:=x[p];
if (a.val<0) or ((p+1+a.val)>xlen) then goto skipend;
//.set
v:=copy(x,p+2,a.val);
//.inc
p:=p+2+a.val;
//successful
result:=(length(v)=a.val);
skipend:
except;end;
try;if not result then v:='';except;end;
end;
//## wsvb32 ##
function tio.wsvb32(var x:string;v:string):boolean;//write string value (32bit length)
begin
try;result:=wsv32(x,v);except;end;
end;
//## wsv32 ##
function tio.wsv32(var x,v:string):boolean;//write string value (32bit length)
var
   a:tint4;
   p,xlen:integer;
begin
try
//error
result:=false;
//process
//.get
a.val:=length(v);
xlen:=length(x);
//.size
setlength(x,xlen+4+a.val);
//.header
x[xlen+4]:=a.chars[3];
x[xlen+3]:=a.chars[2];
x[xlen+2]:=a.chars[1];
x[xlen+1]:=a.chars[0];
//.data
for p:=a.val downto 1 do x[xlen+4+p]:=v[p];
//successful
result:=true;
except;end;
end;
//## rsv32 ##
function tio.rsv32(var p:integer;var x,v:string):boolean;//read str value
label
     skipend;
var
   a:tint4;
   xlen,vlen:integer;
begin
try
//error
result:=false;
//prepare
xlen:=length(x);
if (p<1) or ((p+3)>xlen) then goto skipend;
//process
//.get
a.chars[3]:=x[p+3];
a.chars[2]:=x[p+2];
a.chars[1]:=x[p+1];
a.chars[0]:=x[p];
if (a.val<0) or ((p+3+a.val)>xlen) then goto skipend;
//.set
v:=copy(x,p+4,a.val);
//.inc
p:=p+4+a.val;
//successful
result:=(length(v)=a.val);
skipend:
except;end;
try;if not result then v:='';except;end;
end;
//## clear ##
procedure tio.clear;
begin
try;_init(0,0,0,iosNone);except;end;
end;
//## _init ##
procedure tio._init(_size:integer;_width,_height:integer;_style:tiostyle);
begin
try
//process
icancelled:=false;
with iinfo do
begin
instance:=self;
style:=_style;
//.position
position:=0;
outputsize:=0;
size:=frcmin(_size,0);
percentage:=0;
//.totals
if not cantotal then
   begin
   positionTOTAL:=0;
   sizeTOTAL:=0;
   percentageTOTAL:=0;
   end;//end of if
//.image
width:=frcmin(_width,0);
height:=frcmin(_height,0);
posH:=0;
end;//end of with
except;end;
end;
//## cancel ##
procedure tio.cancel;
begin
try;icancelled:=true;except;end;
end;
//## compress ##
function tio.compress(var x,e:string):boolean;
begin
try;result:=_compress(x,e,[iocsCompress]);except;end;
end;
//## decompress ##
function tio.decompress(var x,e:string):boolean;
begin
try;result:=_compress(x,e,[iocsDecompress]);except;end;
end;
//## toC ##
function tio.toC(var x,e:string):boolean;
begin
try;result:=_compress(x,e,[iocsCompress,iocsHeader]);except;end;
end;
//## fromC ##
function tio.fromC(var x,e:string):boolean;
begin
try;result:=_compress(x,e,[iocsDecompress,iocsHeader]);except;end;
end;
//## eventSTRM ##
procedure tio.eventSTRM(x:TZStreamRec);
begin
try;incpos(x.total_in,x.total_out,0);except;end;
end;
//## incpos ##
procedure tio.incpos(_p,_op,_ph:integer);
var
   a:single;
   dp:integer;
begin
try
//.check
if icancelled then exit;
//.set
try
with iinfo do
begin
_p:=frcrange(_p,0,size);
dp:=frcmin(_p-position,0);
position:=_p;
outputsize:=frcmin(_op,0);
posH:=frcrange(_pH,0,height-1);
if (size>=1) then
   begin
   a:=(position/size)*100;
   if (a<0) then a:=0 else if (a>100) then a:=100;
   percentage:=a;
   if (sizeTOTAL<=0) then sizeTOTAL:=size;
   end;//end of if
//totals
if cantotal then
   begin
   positionTOTAL:=FrcCurRange(positionTOTAL+dp,0,sizeTOTAL);
   if (sizeTOTAL>=1) then
      begin
      a:=(positionTOTAL/sizeTOTAL)*100;
      if (a<0) then a:=0 else if (a>100) then a:=100;
      positionTOTAL:=a;
      end;//end of if
   end;//end of if
end;//end of with
except;end;
//.onchange
fireevent(onchange,self);
//.update system
if (not blocking) then application.processmessages;
except;end;
end;
//## aem ##
procedure tio.aem(var e:string);//adjust error message
begin
try;if icancelled then e:=gecTaskCancelled;except;end;
end;
//## _compress ##
function tio._compress(var x,e:string;_style:tiocompressstyle):boolean;
label
     skipend;
const
   a:array[boolean] of tiostyle =(iosFromC,iosToC);
var
  strm:TZStreamRec;
  tmp,p:pointer;
  v2,v,incBY,ip,xLEN,tmpLEN:integer;
  c:boolean;
  _hdr:string;
begin
try
//error
result:=false;
e:=gecOutOfMemory;
//prepare
tmp:=nil;
c:=(iocsCompress in _style);
v:=0;
v2:=0;
p:=nil;
xLEN:=length(x);
//.read header - decompression
_hdr:='';
if (not c) and (iocsHeader in _style) and (xLEN>=3) then
   begin
   //.get
   _hdr:=copy(x,1,3);
   //.read
   if (_hdr=tiocmRAW) then
      begin
      delete(x,1,3);//remove header
      result:=true;
      goto skipend;
      end
   else if (_hdr=tiocmCompressed) then
      begin
      delete(x,1,3);//remove header
      xLEN:=length(x);
      end
   else
       begin
       e:=gecUnknownFormat;
       goto skipend;
       end;//end of if
   end;//end of if
//.other
_init(xLEN,0,0,a[c]);
fillchar(strm,sizeof(strm),0);
strm.zalloc:=zlibAllocMem;
strm.zfree:=zlibFreeMem;
if c then
   begin//compress
   tmpLEN:=((xLEN+(xLEN div 10)+12)+255) and not 255;
   incBY:=256;
   end
   else
   begin//decompress
   incBY:=(xLEN+255) and not 255;
   tmpLEN:=incBY;
   end;//end of if
getmem(tmp,tmpLEN);
//process
strm.next_in:=pchar(x);
strm.avail_in:=length(x);
strm.next_out:=tmp;
strm.avail_out:=incBY;
//.init
if c then v:=deflateInit_(strm,Z_BEST_SPEED,zlib_version,sizeof(strm)) else v:=inflateInit_(strm,zlib_version,sizeof(strm));
if (v<0) then goto skipend;
try
//.work
while true do
begin
//.get
if c then v:=deflate(strm,z_FINISH) else v:=inflate(strm,z_FINISH);
if (v=Z_STREAM_END) or (v<0) then break;
//.set
if (strm.avail_out=0) then
   begin
   //.inc
   p:=tmp;
   inc(tmpLEN,incBY);
   reallocmem(tmp,tmpLEN);
   strm.next_out:=pchar(integer(tmp)+(integer(strm.next_out)-integer(p)));
   strm.avail_out:=incBY;
   //.event
   if general.pause then eventSTRM(strm);
   //.check
   if icancelled then break;
   end;//end of if
end;//end of with
finally
//.finalise
eventSTRM(strm);
if c then v2:=deflateEnd(strm) else v2:=inflateEnd(strm);
end;
if (v<0) or (v2<0) then goto skipend;
//.get
reallocmem(tmp,strm.total_out);
tmpLEN:=strm.total_out;
//.prepare header - compression
if c and (iocsHeader in _style) then
   begin
   if (tmpLEN<xLEN) then _hdr:=tiocmCompressed else _hdr:=tiocmRAW;
   end;//end of if
//.fill data
if (_hdr<>tiocmRAW) then
   begin
   x:='';
   setstring(x,pchar(tmp),tmpLEN);
   end;//end of if
//.write header
if c and (_hdr<>'') then insert(_hdr,x,1);
//successful
result:=true;
skipend:
except;end;
try
if not result then x:='';
aem(e);
freemem(tmp);
except;end;
end;
//## toBMPb ##
function tio.toBMPb(var x,e:string):boolean;
label//Cycle: x -> input data -> square bmp -> x
     skipend;
var
   a:tbitmap;
   b:tstreamstr;
begin
try
//error
result:=false;
e:=gecOutOfMemory;
//prepare
a:=nil;
b:=nil;
//process
//.str -> bitmap
if not toBMP(a,x,e) then goto skipend;
//.stream -> bitmap
e:=gecOutOfMemory;
x:='';
b:=tstreamstr.create(@x);
a.savetostream(b);
freeObj(@a);
//successful
result:=true;
skipend:
except;end;
try
freeobj(@a);
freeobj(@b);
except;end;
end;
//## toBMP ##
function tio.toBMP(var a:tbitmap;var x,e:string):boolean;
label//returns a "bmp" only if successful, else "a" remains nil
     //7Mb+/sec at 200Mhz
     skipend;
const
     whMAX=20000;
var
   r:prgbcolorrow;
   ox,xp,xLEN,s,dx,dy,maxy:integer;
   _stop:boolean;
   z:trgbcolor;
begin
try
//error
result:=false;
e:=gecUnexpectedError;
if (a<>nil) then exit;
//prepare
xLEN:=length(x);
//.calc "square storage is most optimal"
e:=gecCapacityReached;
s:=round(sqrt((xLEN+1) div 3))+1;//round up (xLEN+1 is for data+stop code)
if (s>whMAX) then exit;
_init(xLEN,s,s,iosToBMP);
//.set
e:=gecOutOfMemory;
a:=ccs.newbmp(s,s);
if (a.width<>s) or (a.height<>s) then goto skipend;
xp:=0;
ox:=0;
maxy:=s-1;
_stop:=true;
//process
for dy:=0 to maxy do
begin
r:=a.scanline[dy];
 for dx:=0 to (s-1) do
 begin
 //.get
 z:=r[dx];
 //.stop
 if (xp>=xLEN) then
    begin
    if _stop then _stop:=false else break;
    z.r:=ox;//indicates end of data
    end;//end of if
 //.r
 if (xp<xLEN) then
    begin
    xp:=xp+1;
    z.r:=byte(x[xp]);
    ox:=2;
    end;//end of if
    //.g
 if (xp<xLEN) then
    begin
    xp:=xp+1;
    z.g:=byte(x[xp]);
    ox:=1;
    end;//end of if
 //.b
 if (xp<xLEN) then
    begin
    xp:=xp+1;
    z.b:=byte(x[xp]);
    ox:=0;
    end;//end of if
 //.set
 r[dx]:=z;
 end;//end of loop
//.event
if general.pause or (not _stop) then incpos(xp,(dy+1)*s*3,dy);
//.check
if not _stop then break;
if icancelled then goto skipend;
end;//end of loop
//successful
result:=true;
skipend:
except;end;
try
if not result then freeObj(@a);
aem(e);
except;end;
end;
//## fromBMPb ##
function tio.fromBMPb(var x,e:string):boolean;
var
   a:tbitmap;
   m:tstreamstr;
begin
try
//error
result:=false;
e:=gecOutOfMemory;
//prepare
a:=nil;
m:=nil;
//process
//.get
m:=tstreamstr.create(@x);
e:=gecUnknownFormat;
a:=tbitmap.create;
a.loadfromstream(m);
freeObj(@m);
x:='';
//.bitmap -> str
result:=fromBMP(a,x,e);
except;end;
try
freeobj(@a);
freeobj(@m);
except;end;
end;
//## fromBMP ##
function tio.fromBMP(var a:tbitmap;var x,e:string):boolean;
label
     skipend;
var
   r:prgbcolorrow;
   _textLEN,xp,xLEN,s,dx,dy,maxy:integer;
   _stop:boolean;
   z:trgbcolor;
begin
try
//error
result:=false;
e:=gecUnexpectedError;
//defaults
x:='';
//.check
if (a=nil) then exit;
e:=gecUnknownFormat;
if (a.pixelformat<>pf24bit) then exit;
if (a.width<>a.height) then exit;
//prepare
e:=gecOutOfMemory;
s:=a.width;
maxy:=s-1;
_init(0,s,s,iosFromBMP);//size not known yet
//.set
xp:=0;
_stop:=true;
xLEN:=-1;
_textLEN:=0;
//process
//.stop code
for dy:=(s-1) downto 0 do
    begin
    r:=a.scanline[dy];
    for dx:=(s-1) downto 0 do if (r[dx].r<=2) then
        begin
        xLEN:=(dy*s+dx)*3-r[dx].r;//off set adjustment
        break;
        end;//end of if
    if (xLEN<>-1) then break;
    end;//end of loop
//.check
if (xLEN=-1) then exit;
_init(xLEN,s,s,iosFromBMP);//update size
//.get data
for dy:=0 to maxy do
begin
r:=a.scanline[dy];
 for dx:=0 to (s-1) do
 begin
 //.stop
 if (xp>=xLEN) then _stop:=false;
 //.get
 z:=r[dx];
 //.size
 if ((xp+3)>_textLEN) then
    begin
    setlength(x,_textLEN+tio1Mb);
    _textLEN:=length(x);
    end;//end of if
 //.r
 if (xp<xLEN) then
    begin
    xp:=xp+1;
    x[xp]:=chr(z.r);
    end;//end of if
    //.g
 if (xp<xLEN) then
    begin
    xp:=xp+1;
    x[xp]:=chr(z.g);
    end;//end of if
 //.b
 if (xp<xLEN) then
    begin
    xp:=xp+1;
    x[xp]:=chr(z.b);
    end;//end of if
 //.set
 r[dx]:=z;
 end;//end of loop
//.event
if general.pause or (not _stop) then incpos(xp,(dy+1)*s*3,dy);
//.check
if not _stop then break;
if icancelled then goto skipend;
end;//end of loop
//.trim
delete(x,xLEN+1,length(x));
//successful
result:=true;
skipend:
except;end;
try
if not result then x:='';
aem(e);
except;end;
end;
//## toTXT ##
function tio.toTXT(var x,y:string;var e:string):boolean;//binary to text
label//Speed: 2.5Mb/sec @ 200Mhz, Mem: Optimised to ~y+"bit" of RAM, 03-OCT-2004
     skipend;
var
   a,b:byte;
   op,pref,lc,i,_textLEN,xLEN,p:integer;
begin
try
//error
result:=false;
e:=gecOutOfMemory;
//prepare
y:='';
xLEN:=length(x);
//check
if (x='') then
   begin
   result:=true;
   exit;
   end;
//.pad
_init(xLEN,0,0,iosToTXT);
_textLEN:=0;
//process
i:=-1;
lc:=0;
pref:=1;
op:=0;
for p:=1 to xLEN do
begin
//.get
a:=byte(x[p+op]);
b:=a div 16;
a:=a-(b*16);
//.inc
i:=i+2;
lc:=lc+2;
if ((i+3)>_textLEN) then
   begin
   //.enlarge
   setlength(y,_textLEN+tio1Mb);
   _textLEN:=length(y);
   //.shrink x (1mb) - uses upto 50% less RAM
   if ((p+op)>=1000000) then
      begin
      delete(x,1,p+op);
      op:=-p;
      end;//end of if
   end;//end of if
y[i]:=chr(97+a);
y[i+1]:=chr(97+b);
if (lc>=70) then
   begin
   lc:=0;
   i:=i+2;
   y[i]:=#13;
   y[i+1]:=#10;
   //.event
   if (p>pref) or (p>=xLEN) then
      begin
      pref:=p+32768;
      if general.pause or (p>=xLEN) then incpos(p,i,0);
      //.check
      if icancelled then goto skipend;
      end;//end of if
   end;//end of if
end;//end of loop
//.trim
incpos(xLEN,i+1,0);
x:='';
delete(y,i+2,length(y));
//successful
result:=true;
skipend:
except;end;
try
if not result then
   begin
   x:='';
   y:='';
   end;//end of if
aem(e);
except;end;
end;
//## fromTXT ##
function tio.fromTXT(var x:string;var e:string):boolean;//binary to text
label
     skipend;
var
   a,b,v:integer;
   pref,xLEN,lc,i,p:integer;
begin
try
//error
result:=false;
e:=gecOutOfMemory;
//prepare
xLEN:=length(x);
//check
if (xLEN<2) then
   begin
   x:='';
   result:=true;
   exit;
   end;
//process
_init(xLEN,0,0,iosFromTXT);
i:=0;
a:=-1;
b:=-1;
pref:=1;
for p:=1 to xLEN do
begin
//.get
v:=byte(x[p]);
if (v>=97) and (v<=112) then
   begin
   //.set
   if (a=-1) then a:=v-97
   else if (b=-1) then b:=v-97;
   //.fill
   if (a>=0) and (b>=0) then
      begin
      i:=i+1;
      x[i]:=chr(a+b*16);
      a:=-1;
      b:=-1;
      end;//end of if
   end;//end of if
//.event
if (p>(pref+32768)) or (p>=xLEN) then
   begin
   pref:=p;
   if general.pause or (p>=xLEN) then incpos(p,i,0);
   //.check
   if icancelled then goto skipend;
   end;//end of if
end;//end of loop
//.trim
delete(x,i+1,length(x));
//successful
result:=true;
skipend:
except;end;
try
if not result then x:='';
aem(e);
except;end;
end;
//## tob64 ##
function tio.tob64(var s,d:string;linelength:integer;var e:string):boolean;//to base64
label//Speed: 2,997Kb in 3320ms (~0.902Mb/sec) @ 200Mhz
   skipend;
var
   a,b:tint4;
   tmpi,ll,sLEN,dLEN,p,i:integer;
   tmp:string;
begin
try
//defaults
result:=false;
e:=gecOutOfMemory;
d:='';
sLEN:=length(s);
dLEN:=0;
ll:=0;
p:=1;
if (linelength<0) then linelength:=0;
//check
if (sLEN=0) then exit;
//process
//.init
_init(sLEN,0,0,iosToB64);
//.tmp
tmpi:=0;
setlength(tmp,4096+6);
repeat
//.get
a.val:=0;
a.bytes[2]:=byte(s[p]);
if ((p+1)<=sLEN) then a.bytes[1]:=byte(s[p+1]) else a.bytes[1]:=0;
if ((p+0)<=sLEN) then a.bytes[0]:=byte(s[p+2]) else a.bytes[0]:=0;
//.soup (3 -> 4)
b.bytes[0]:=(a.val div 262144);
dec(a.val,b.bytes[0]*262144);
b.bytes[1]:=(a.val div 4096);
dec(a.val,b.bytes[1]*4096);
if ((p+1)<=sLEN) then
   begin
   b.bytes[2]:=a.val div 64;
   dec(a.val,b.bytes[2]*64);
   end else b.bytes[2]:=64;
if ((p+2)<=sLEN) then b.bytes[3]:=a.val else b.bytes[3]:=64;
//.encode
for i:=0 to 3 do b.chars[i]:=base64[b.bytes[i]];
//.tmp
inc(tmpi,4);
tmp[tmpi-3]:=b.chars[0];
tmp[tmpi-2]:=b.chars[1];
tmp[tmpi-1]:=b.chars[2];
tmp[tmpi]:=b.chars[3];
if (tmpi>=4096) then//allows for previous line code of 2 char's (-6 for safty)
   begin
   //.100Kb buffer
   pushbx(dLEN,102400,d,copy(tmp,1,tmpi));
   tmpi:=0;
   //.event
   if general.pause then incpos(p,dLEN,0);
   //.check
   if icancelled then goto skipend;
   end;//end of if
//.line
if (linelength<>0) then
   begin
   inc(ll,4);
   if (ll>=linelength) then
      begin
      inc(tmpi,2);
      tmp[tmpi-1]:=#13;
      tmp[tmpi]:=#10;
      ll:=0;
      end;//end of if
   end;//end of if
//.inc
inc(p,3);
until (p>sLEN);
//.finalise
if (tmpi>=1) then pushb(dLEN,d,copy(tmp,1,tmpi));
pushb(dLEN,d,'');
//successful
result:=true;
skipend:
except;end;
try
if not result then d:='';
aem(e);
except;end;
end;
//## tob64b ##
function tio.tob64b(s:string;linelength:integer):string;
var
   e:string;
begin
try;tob64(s,result,linelength,e);except;end;
end;
//## fromb64 ##
function tio.fromb64(var s,d:string;var e:string):boolean;//from base64
label//Speed: 4,101Kb in 3150ms (~1.301Mb/sec) @ 200Mhz
   skipend;
var
   b,a:tint4;
   tmpi,sLEN,dLEN,c,p,i:integer;
   v:byte;
   tmp:string;
begin
try
//defaults
result:=false;
e:=gecOutOfMemory;
d:='';
sLEN:=length(s);
dLEN:=0;
p:=1;
//check
if (sLEN=0) then exit;
//process
//.init
_init(sLEN,0,0,iosFromB64);
//.tmp
tmpi:=0;
setlength(tmp,300);
repeat
//.get
a.val:=0;
c:=0;
repeat
//.store
v:=byte(base64r[byte(s[p])])-48;
if (v>=0) and (v<=63) then
   begin
   //.set
   case c of
   0:inc(a.val,v*262144);
   1:inc(a.val,v*4096);
   2:inc(a.val,v*64);
   3:begin
     inc(a.val,v);
     inc(c);
     inc(p);
     break;
     end;//end of begin
   end;//end of case
   //.inc
   inc(c,1);
   end
else if (v=64) then
   begin
   p:=sLEN;
   break;{=}
   end;//end of if
//.inc
inc(p);
until (p>sLEN);
//.split (4 -> 3)
b.bytes[0]:=a.val div 65536;
dec(a.val,b.bytes[0]*65536);
b.bytes[1]:=a.val div 256;
dec(a.val,b.bytes[1]*256);
b.bytes[2]:=a.val;
//.set
case c of
4:begin
  inc(tmpi,3);
  tmp[tmpi-2]:=b.chars[0];
  tmp[tmpi-1]:=b.chars[1];
  tmp[tmpi]:=b.chars[2];
  end;//end of begin
3:begin//finishing #1
  inc(tmpi,2);
  tmp[tmpi-1]:=b.chars[0];
  tmp[tmpi]:=b.chars[1];
  end;//end of begin
1..2:begin//finishing #2
  inc(tmpi,1);
  tmp[tmpi]:=b.chars[0];
  end;//end of begin
end;//end of case
//.tmp
if (tmpi>=300) then//always 300 exactly until last when "finishing #1/#2 or exact"
   begin
   pushb(dLEN,d,tmp);
   tmpi:=0;
   //.event
   if general.pause then incpos(p,dLEN,0);
   //.check
   if icancelled then goto skipend;
   end;//end of if
until (p>=sLEN);
//.finalise
if (tmpi>=1) then pushb(dLEN,d,copy(tmp,1,tmpi));
pushb(dLEN,d,'');
//successful
result:=true;
skipend:
except;end;
try
if not result then d:='';
aem(e);
except;end;
end;
//## fromb64b ##
function tio.fromb64b(s:string):string;
var
   e:string;
begin
try;fromb64(s,result,e);except;end;
end;
//## getint ##
function tio.getint(x:string):integer;
var
   z,e:string;
begin
try;if fromfile(x,z,e) then result:=strint(z) else result:=0;except;end;
end;
//## setint ##
procedure tio.setint(x:string;value:integer);
var
   e:string;
begin
try;tofileb(x,inttostr(value),e);except;end;
end;
//## toFILEc ##
function tio.toFILEc(x:string;var y,e:string;_trycount:integer):boolean;
label
     redo;
var
   c:integer;
begin
try
//prepare
c:=1;
if (_trycount<=-1) then _trycount:=5;//default of 5 retrys
//process
redo:
result:=toFILE(x,y,e);
//retry
if (not result) and (e=gecFileInUse) and (c<=_trycount) then
    begin
    //inc
    c:=c+1;
    //random pause & loop
    sleep(50+random(150));
    goto redo;
    end;//end of if
except;end;
end;
//## toFILEb ##
function tio.toFILEb(x:string;y:string;var e:string):boolean;
begin
try;result:=toFILE(x,y,e);except;end;
end;
//## toFILE ##
function tio.toFILE(x:string;var y,e:string):boolean;
label
     skipend;
const
   aMAX=32767;
var
   a:array[0..aMAX] of byte;
   yLEN,p,ap:integer;
   b:tfilestream;
begin
try
//error
result:=false;
e:=gecOutOfMemory;
//prepare
b:=nil;
yLEN:=length(y);
_init(yLEN,0,0,iosToFILE);
//process
//.delete
e:=gecFileInUse;
if not remFile(x) then goto skipend;
//.open
e:=gecFileInUse;
b:=tfilestream.create(x,fmCreate);
//.size
e:=gecOutOfDiskSpace;
b.size:=yLen;
b.position:=0;
p:=1;
ap:=0;
//.write
for p:=1 to yLEN do
begin
//.fill
a[ap]:=byte(y[p]);
//.store
if (ap>=aMAX) or (p=yLEN) then
   begin
   if ((ap+1)<>b.write(a,(ap+1))) then goto skipend;
   ap:=-1;
   //.event
   if (not blocking) and (general.pause or (p>=yLEN)) then incpos(p,b.position+1,0);
   //.check
   if icancelled then goto skipend;
   end;//end of if
//.inc
ap:=ap+1;
end;//end of loop
//successful
result:=true;
skipend:
except;end;
try
freeObj(@b);
if not result then remfile(x);
aem(e);
except;end;
end;
//## toFILEAPPEND ##
function tio.toFILEAPPEND(x:string;var y,e:string):boolean;
label
     skipend;
const
   aMAX=32767;
var
   a:array[0..aMAX] of byte;
   yLEN,p,ap:integer;
   b:tfilestream;
begin
try
//error
result:=false;
e:=gecOutOfMemory;
//prepare
b:=nil;
yLEN:=length(y);
_init(yLEN,0,0,iosToFILE);
//process
//.open
case fileexists(x) of
true:begin
     e:=gecFileInUse;
     b:=tfilestream.create(x,fmOpenReadWrite+fmShareDenyWrite);
     end;//end of begin
false:begin
     e:=gecOutOfDiskSpace;
     b:=tfilestream.create(x,fmCreate);
     end;//end of begin
end;//end of case
//.size
e:=gecOutOfDiskSpace;
b.position:=b.size;
p:=1;
ap:=0;
//.write
for p:=1 to yLEN do
begin
//.fill
a[ap]:=byte(y[p]);
//.store
if (ap>=aMAX) or (p=yLEN) then
   begin
   if ((ap+1)<>b.write(a,(ap+1))) then goto skipend;
   ap:=-1;
   //.event
   if (not blocking) and (general.pause or (p>=yLEN)) then incpos(p,b.position+1,0);
   //.check
   if icancelled then goto skipend;
   end;//end of if
//.inc
ap:=ap+1;
end;//end of loop
//successful
result:=true;
skipend:
except;end;
try;aem(e);b.free;except;end;
end;
//## fromFILEc ##
function tio.fromFILEc(x:string;var y,e:string;_trycount:integer):boolean;
label
     redo;
var
   c:integer;
begin
try
//prepare
c:=1;
if (_trycount<=-1) then _trycount:=5;//default of 5 retrys
//process
redo:
result:=fromFILE(x,y,e);
//retry
if (not result) and (e=gecFileInUse) and (c<=_trycount) then
    begin
    //inc
    c:=c+1;
    //random pause & loop
    sleep(50+random(150));
    goto redo;
    end;//end of if
except;end;
end;
//## fromFILEd ##
function tio.fromFILEd(x:string):string;
var
   fsize,pos:integer;
   fdate:tdatetime;
   e:string;
begin
try;pos:=0;fromFILEb(x,result,e,fsize,pos,-1,fdate);except;end;
end;
//## fromFILE ##
function tio.fromFILE(x:string;var y,e:string):boolean;
var
   fsize,pos:integer;
   fdate:tdatetime;
begin
try;pos:=0;result:=fromFILEb(x,y,e,fsize,pos,-1,fdate);except;end;
end;
//## fromFILEb ##
function tio.fromFILEb(x:string;var y,e:string;var _filesize,_from:integer;_size:integer;var _date:tdatetime):boolean;//20-OCT-2006
label//Speed: ~5.9Mb/s = 137% faster, 03-OCT-2004
     skipend;
const
   aMAX=32767;
var
   a:array[0..aMAX] of byte;
   i,p,ac:integer;
   b:tfilestream;
begin
try
//error
result:=false;
e:=gecOutOfMemory;
//prepare
_date:=now;
_filesize:=0;
b:=nil;
y:='';
//process
//.check
e:=gecFileNotFound;
if not fileexists(x) then goto skipend;
//.open
e:=gecFileInUse;
b:=tfilestream.create(x,fmOpenRead+fmShareDenyNone);
_date:=dates.fileage(b.handle);//date
_filesize:=b.size;
_init(b.size,0,0,iosFromFILE);
//._from
if (_from<0) then _from:=0
else if (_from>=b.size) then
   begin
   result:=true;
   goto skipend;
   end;//end of if
b.position:=_from;
//.size
if (_size=0) then//0=read NO data
   begin
   result:=true;
   goto skipend;
   end
else if (_size<0) then _size:=b.size//-X..-1=read ALL data
else if (_size>b.size) then _size:=b.size;//1..X=read SPECIFIED data
e:=gecOutOfMemory;
setlength(y,_size);
i:=0;
//.write
while TRUE do
begin
//.get
ac:=b.read(a,aMAX+1);
//.event
if (not blocking) and (general.pause or (ac=0)) then incpos(b.position+1,i,0);
//.check
if icancelled then goto skipend;
if (ac=0) then break;
//.fill
for p:=0 to frcmax(ac-1,_size-i-1) do
begin
i:=i+1;
y[i]:=chr(a[p]);
end;//end of loop
//.quit
if (i>=_size) then break;
end;//end of loop
//successful
inc(_from,i);
if (b.size=_size) and (_from=0) then result:=(i=_size)
else
   begin
   if (i<>_size) then setlength(y,i);
   result:=(i>=1);
   end;//end of if
skipend:
except;end;
try
if not result then y:='';
aem(e);
freeobj(@b);
except;end;
end;
//## fromFILEDATE ##
function tio.fromFILEDATE(x:string;var y:tdatetime):boolean;
var
   a:tfilestream;
begin
try
//defaults
result:=false;
a:=nil;
//open
a:=tfilestream.create(x,fmOpenRead+fmShareDenyNone);
y:=dates.fileage(a.handle);
//successful
result:=true;
except;end;
try;freeobj(@a);except;end;
end;
//## toEAT ##
function tio.toEAT(_nv:tobject;var y,e:string):boolean;
begin
try;result:=toNV(_nv,'EAT!',y,e);except;end;
end;
//## fromEAT ##
function tio.fromEAT(_nv:tobject;var y,e:string):boolean;
begin
try;result:=fromNV(_nv,'EAT!',y,e);except;end;
end;
//## isNVobj ##
function tio.isNVobj(_nv:tobject;var e:string):boolean;
begin
try;result:=(_nv<>nil) and (_nv is tnamevalue);if not result then e:=gecIndexOutOfRange;except;end;
end;
//## toNV ##
function tio.toNV(_nv:tobject;_hdr:string;var y,e:string):boolean;
label
     skipend;
var
   a:tnv;
   b:tnamevalue;
   c:tstringlist;
   n:string;
   v:pstring;
   _pos,_size,maxp,p:integer;
   ok:boolean;
begin
try
//error
result:=false;
if not isNVobj(_nv,e) then exit;
//prepare
e:=gecOutOfMemory;
a:=nil;
c:=nil;
a:=newnv;
c:=tstringlist.create;
b:=(_nv as tnamevalue);
//.names
c.text:=b.ionames;
maxp:=c.count-1;
//process
//.init
a.data:=@y;
if not a.initwrite(_hdr,e) then goto skipend;
//.size
_size:=b.ias(c.text);//all items calculated as size
_init(_size+((maxp+1)*6),0,0,iosToNV);
_pos:=0;
//.loop
for p:=0 to maxp do
begin
//.get
e:=gecOutOfMemory;
n:=c.strings[p];
v:=b.valuesptr[b.findname(n)];
//.set
if (v<>nil) then ok:=a.write(n,v^,e)
else ok:=a.writeb(n,'',e);
if not ok then goto skipend;
//.event
_pos:=_pos+6+length(n);//6=info size=word+integer
if (v<>nil) then _pos:=_pos+length(v^);
if general.pause or (p>=maxp) then incpos(_pos,_pos,0);
//.check
if icancelled then goto skipend;
end;//end of with
//.finalise
if not a.writeb('','',e) then goto skipend;
//successful
result:=true;
skipend:
except;end;
try;aem(e);freeobj(@a);freeobj(@c);except;end;
end;
//## fromNV ##
function tio.fromNV(_nv:tobject;_hdr:string;var y,e:string):boolean;
label
     skipend;
var
   a:tnv;
   b:tnamevalue;
   n,v:string;
   i:integer;
begin
try
//error
result:=false;
if not isNVobj(_nv,e) then exit;
e:=gecOutOfMemory;
//prepare
a:=nil;
a:=newnv;
b:=(_nv as tnamevalue);
//process
//.init
a.data:=@y;
if not a.initread(_hdr,e) then goto skipend;
_init(a.dataLEN,0,0,iosFromNV);
//.loop
while a.canread do
begin
//.get
if not a.read(n,v,e) then goto skipend;
//.set
if (n<>'') then
   begin
   i:=b.newname(n);
   if (i=-1) then
      begin
      e:=gecCapacityReached;
      goto skipend;
      end;//end of if
   b.valuesptr[i]^:=v;
   end;//end of if
//.event
if general.pause then incpos(a.pos,a.pos,0);
//.check
if icancelled then goto skipend;
end;//end of with
//successful
result:=true;
skipend:
except;end;
try;aem(e);a.free;except;end;
end;
//## toINFO ##
function tio.toINFO(x:string):tiofileinfo;
var
   a:tnv;
   n,v,e:string;
begin
try
//defaults
result.date:=now;
result.size:=0;
a:=newnv;
a.data:=@x;
//process
if a.initread('',e) then
   begin
   if a.read(n,v,e) and (n='d') then result.date:=to64bit(v);
   if a.read(n,v,e) and (n='s') then result.size:=to32bit(v);
   end;//end of if
except;end;
try;a.free;except;end;
end;
//## fromINFO ##
function tio.fromINFO(var x:tiofileinfo):string;
var
   a:tnv;
   e:string;
begin
try
//defaults
result:='';
a:=newnv;
a.data:=@result;
//process
if a.initwrite('',e) then
   begin
   a.writeb('d',from64bit(x.date),e);
   a.writeb('s',from32bit(x.size),e);
   a.writeb('','',e);
   end;//end of if
except;end;
try;a.free;except;end;
end;
//## isMTXT ##
function tio.isMTXT(var x:string):boolean;
var
   p,xLEN:integer;
   ok:boolean;
begin
try
//defaults
result:=false;
//prepare
xLEN:=length(x);
if (xLEN=0) then exit;
ok:=false;
//process
for p:=1 to xLEN do
   if (x[p]='[') and (copy(x,p,6)='[-----') then ok:=true
   else if ok and (x[p]=']') and (copy(x,p,6)=']-----') then
        begin
        result:=true;
        break;
        end;//end of if
except;end;
end;
//## fromMTXT ##
function tio.fromMTXT(_nv:tobject;var x,e:string):boolean;
label
     skipone,skipend;
var
   a:tnv;
   b:tnamevalue;
   pref,count,xLEN,s,i,p:integer;
   n,v,z:string;
begin
try
//error
result:=false;
if not isNVobj(_nv,e) then exit;
//prepare
e:=gecOutOfMemory;
a:=newnv;
b:=(_nv as tnamevalue);
s:=-1;
xLEN:=length(x);
count:=0;
//check
if (xLEN=0) then goto skipend;
_init(xLEN,0,0,iosFromMTXT);
pref:=1;
//process
for p:=1 to xLEN do
begin
if (x[p]='[') and (copy(x,p,6)='[-----') then s:=p
else if (s<>-1) and (x[p]=']') and (copy(x,p,6)=']-----') then
   begin
   //.get
   z:=copy(x,s,p-s+1);
   //.decode
   if not fromTXT(z,e) then goto skipone;
   //.pull
   a.data:=@z;
   if not a.initread('!',e) then goto skipone;
   //..set - 0=file data, 1=file info
   while a.canread do if a.read(n,v,e) and (a.count<=2) then
         begin
         i:=b.newname(n);
         if (i<>-1) then b.valuesptr[i]^:=v;
         v:='';
         if (a.count>=1) then count:=count+1;
         end else break;//end of if
   //reset
   s:=-1;
   end;//end of if
skipone:
if (z<>'') then z:='';
//.event
if ((p-pref)>=32768) or (p>=xLEN) then
   begin
   pref:=p;
   if general.pause or (p>=xLEN) then incpos(p,p,0);
   //.check
   if icancelled then goto skipend;
   end;//end of if
end;//end of loop
//return result
skipend:
result:=(count>=1);
if not result then e:=gecUnknownFormat;
except;end;
try;a.free;except;end;
end;
//## toMTXT ##
function tio.toMTXT(_nv:tobject;var x,e:string):boolean;
label
     skipone,skipend;
var
   a:tnv;
   b:tnamevalue;
   c:tstringlist;
   d:tiofileinfo;
   maxp,_pos,len,nii,p:integer;
   vp,niv:pstring;
   _com,ni,_bytes,_filename,_size,_date,_start,_finish,zd,z,n:string;
   _il:boolean;
begin
try
//error
result:=false;
if not isNVobj(_nv,e) then exit;
//prepare
e:=gecOutOfMemory;
x:='';
len:=0;
c:=nil;
a:=newnv;
b:=_nv as tnamevalue;
c:=tstringlist.create;
c.text:=b.ionames;
//.translate labels
tls;
//.start-finish (use dash "-", since it's left unaltered in MIME-HTML mode in Outlook ".eml" files)
_start:=general.nullstr(70,'-');
_finish:=_start;
inserttext(_start,' START ',31);_start[1]:='[';
inserttext(_finish,' FINISH ',30);_finish[1]:=']';
_pos:=0;
maxp:=c.count-1;
_init(b.ias(c.text),0,0,iosToMTXT);
//.main label
if not hml then
   begin
   _com:=ecap('=9;0C5H11,:(2:`ff`ffa_hTwP}Y`ff`ffa_ukp^ynuq~ZYY'+'rca`brqfwsscag|qcYsTwM]Ycc',false);
   general.swapstrs(_com,'<tab>',#9);
   general.swapstrs(_com,'<br>',rcode);
   general.swapstrs(_com,'V!',programversion);
   if not pushb(len,x,_com+rcode) then goto skipend;
   end;//end of if
//process
for p:=0 to maxp do
begin
//.get
n:=c.strings[p];
if (n='') or (n[1]='|') then goto skipone;
//.ni - info name
ni:='|'+n;
nii:=b.findname(ni);
niv:=b.valuesptr[nii];
//.comment header
if (not hfls) and (niv<>nil) then
   begin
   d:=toINFO(b.valuesptr[nii]^);
   pushb(len,x,itlFilename+extractfilename(n)+' ('+n+')'+rcode);
   pushb(len,x,itlSize+general.thousands(d.size)+#32+itlByte+rcode);
   pushb(len,x,itlDate+dates.shortdate(d.date,true)+rcode);
   end;//end of if
//.get value
vp:=b.valuesptr[b.findname(n)];
if (vp=nil) then goto skipone;
//.header
if not pushb(len,x,_start+rcode) then goto skipend;
//.pack data
a.data:=@z;
if not a.initwrite('!',e) then goto skipend;
  //.file
  _pos:=_pos+length(n)+length(vp^);
  if not a.write(n,vp^,e) then goto skipend;
  //.info - if any "|<name>"
  if (nii<>-1) and (niv<>nil) then
     begin
     _pos:=_pos+length(ni)+length(niv^);
     if not a.write(ni,niv^,e) then goto skipend;
     end;//end of if
  //.finalise
  if not a.writeb('','',e) then goto skipend;
//.encode packed data
if not toTXT(z,zd,e) then goto skipend;
//.push data
e:=gecOutOfMemory;
if not push(len,x,zd) then goto skipend;
//.trailer
if not pushb(len,x,rcode+_finish+rcode+rcode+rcode) then goto skipend;
skipone:
//.z
if (z<>'') then z:='';
if (zd<>'') then zd:='';
//.event
if general.pause or (p>=maxp) then incpos(_pos,len,0);
//.check
if icancelled then goto skipend;
end;//end of loop
//.finalise
if not pushb(len,x,'') then goto skipend;
//successful
result:=true;
skipend:
except;end;
try;freeobj(@a);freeobj(@c);except;end;
try;if not result then x:='';except;end;
end;
//## getmask ##
function tio.getmask:tdualmask;
begin
try
if (imask=nil) then imask:=newdualmask('*','');
result:=imask;
except;end;
end;
//----------- SCANNER -----------
//## ccmatch ##
function tio.ccmatch(x,y:integer):boolean;
begin
try;result:=((x-100)<=y) and ((x+100)>=y);except;end;
end;
//## scan ##
procedure tio.scan(x,y:integer);
var
   a:tioscaninfo;
   Debug:Boolean;
begin
try
//prepare
sysscanned:=true;//10aug2025

{
a.filename:=app.exename;
a.scanto:=y;
debug:=(x<=0) or (y<=0);
//process
case debug of
false:if (not scanfile(a)) or (not ccmatch(a.cc,x)) then
         begin
         if not ccmatch(A.CC,X) then showerror60(viruswarntext(17));
         sihalt;
         end;//end of if
true:begin
    case scanfile(a) of
    true:begin
        showerror60(ntranslate(gecVirusWarning)+RCode+inttostr(a.cc)+','+inttostr(a.scanto));
        //***
        clipboard.astext:=inttostr(a.cc)+','+inttostr(a.scanto);
        end;//end of begin
    false:showerror60(ntranslate(gecUnexpectedError));
    end;//end of case
    sihalt;
    end;//end of begin
end;//end of case
{}//xxxxxxxxxxxxxxx
except;end;
end;
//## scanfile ##
function tio.scanfile(var x:tioscaninfo):boolean;
//Label
//     redo,skipone,skipend;
const
     by=200;
var
   a:tfilestream;
   b:array[0..999] of byte;
   v,cc,count,maxp,p3,p2,p:integer;
begin
result:=true;//10aug2025
{
try
//error
result:=false;
a:=nil;
//check
if not fileexists(x.filename) then goto skipend;
//prepare
a:=tfilestream.create(x.filename,fmOpenRead+fmShareDenyNone);
if (x.scanto<=0) then x.scanto:=a.size;
cc:=39;
count:=0;
p3:=-by;
//process
//.loop
redo:
count:=a.read(b,sizeof(b));
//.scan
maxp:=(count div by)-1;
for p:=0 to maxp Do
begin
p2:=by*p;
p3:=p3+by;
If ((p3+p2)>(x.scanto-1)) then goto skipone;
v:=b[p2];
cc:=cc+v;
case ((v Div 2)*2=v) of
true:begin//even
   case v of
   0..30:cc:=cc+3;
   60..100:cc:=cc+35;
   end;//end of case
   end;//end of begin
false:begin//odd
   case v of
   0..5:cc:=cc+71;
   9:cc:=cc+1;
   10:cc:=cc+14;
   14:cc:=cc+47;
   33:cc:=cc+97;
   end;//end of case
   end;//end of begin
end;//end of case
end;//end of loop
if (count>=1) then goto redo;
skipone:
//return result
x.cc:=cc;
result:=true;
skipend:
except;end;
try;a.free;except;end;
{}
end;
//---------- OTHER --------
//## inserttext ##
procedure tio.inserttext(var x:string;y:string;yp:integer);
var
   p,maxp,xLEN,yLEN:integer;
begin
try
//prepare
xLen:=length(x);
yLen:=length(y);
//check
if (yp<1) or (yp>xLen) then exit;
maxp:=frcmax(yp+yLen-1,xLen);
//process
for p:=yp to maxp do x[p]:=y[p-yp+1];
except;end;
end;
//## forcefilename ##
function tio.forcefilename(_master,_slave:string;_style:tioforcestyle):string;//force PATH/FILENAME/EXTENSION
var
   mp,mn,me,sp,sn,se:string;
begin
try
//defaults
result:='';
//process
//.get
general.fapne(_master,mp,mn,me);
general.fapne(_slave,sp,sn,se);
//.set
if (iofsPath in _style) then result:=result+sp else result:=result+mp;
if (iofsName in _style) then result:=result+sn else result:=result+mn;
if (se<>'') then se:='.'+se;
if (me<>'') then me:='.'+me;
if (iofsExt in _style) then result:=result+se else result:=result+me;
//.other
if (iofsUpperCase in _style) then result:=uppercase(result);
if (iofsLowerCase in _style) then result:=lowercase(result);
if (iofsTitle in _style) then result:=general.asname(result);
except;end;
end;
//## formatsize ##
function tio.formatsize(x:currency;style:integer):string;
begin
try
//get
if (style=tiofsAuto) then style:=tiofsBytes;//yyyyyyyyyyyyyyyyyumi.int[umi.psSizeStyle];
//set
tls;
if (style=tiofsBytes) then result:=misc.b(x,true)
else if (style=tiofsKB) then result:=misc.kb(x,true)
else if (style=tiofsGB) then result:=misc.gb(x,true)
else result:=misc.mb(x,true);
except;end;
end;

//################### TBinaryFile ##############################################
//## create ##
constructor TBinaryFile.create(x:string);
var
   a:TBinaryFileBuffer;
begin
{prepare}
iFileStream:=nil;
iLockCount:=0;
iLocked:=false;
//flush
flush;
//iNullStr - for Read System
iNullStr:=general.NullStr(SizeOf(a),#0);
{process}
_Open(x);
end;
//## destroy ##
destructor TBinaryFile.destroy;
begin
try
//controls
iCanWrite:=false;
iOpen:=false;
freeObj(@ifilestream);
//self
inherited;
except;end;
end;
//## size ##
function TBinaryFile.size:integer;
begin
try;result:=ifilestream.size;except;end;
end;
//## flush ##
procedure TBinaryFile.flush;
begin
try;ipushTMP:='';except;end;
end;
//## push ##
function TBinaryFile.push(x:string):boolean;
label
     skipend;
begin
try
{error}
result:=false;
{process}
//set
ipushTMP:=ipushTMP+x;
if (length(ipushTMP)>=4096) or (x='') then
   begin
   //write
   if (ipushTMP<>'') and (not WriteStr(-1,ipushTMP)) then goto skipend;
   //reset
   ipushTMP:='';
   end;//end of if
//successful
result:=true;
skipend:
except;end;
end;
//## Lock ##
procedure TBinaryFile.Lock;
begin
try
general.incxInt(iLockCount,1);
iLocked:=(iLockCount<>0);
except;end;
end;
//## Unlock ##
procedure TBinaryFile.Unlock;
begin
try
general.incxInt(iLockCount,-1);
iLocked:=(iLockCount<>0);
except;end;
end;
//## SetFileName ##
procedure TBinaryFile.SetFileName(x:string);
begin
try
{check}
if (uppercase(x)=uppercase(filename)) then exit;
{set}
_Open(x);
except;end;
end;
//## _Open ##
procedure TBinaryFile._Open(x:string);
var
   xOk,_CanWrite,_Open,_New:boolean;
   oldf,f:TFileStream;
begin
try
{lock}
lock;
{prepare}
_CanWrite:=false;
_Open:=false;
_New:=false;
xOk:=FileExists(x);
f:=nil;
{process}
try///.Create-ReadWrite
case xOk of
true:begin
    f:=TFileStream.create(x,fmOpenReadWrite+fmShareDenyWrite);
    _Open:=true;
    end;//end of begin
false:begin
    f:=TFileStream.create(x,fmCreate);
    _Open:=true;
    _New:=true;
    end;//end of begin
end;//end of case
except;
try//.ReadOnly
if xOk then
   begin
   f:=TFileStream.create(x,fmOpenRead+fmShareDenyNone);
   _Open:=true;
   end;//end of if
except;end;
end;
{CanWrite}
_CanWrite:=_CanWriteTo(x);
except;end;
try
{set}
//iFileStream
oldf:=iFileStream;
iFileStream:=f;
oldf.free;
//Indicators
iFileName:=x;
iCanWrite:=_CanWrite;
iNew:=_New;
iOpen:=_Open;
Unlock;
except;end;
end;
//## _CanWriteTo ##
function TBinaryFile._CanWriteTo(x:string):boolean;
var
   a:tstringlist;
   z:string;
begin
try
{no}
result:=false;
if (x='') then exit;
{prepare}
a:=nil;
z:=extractFilePath(x)+'~~TMP~~.TMP';
{process}
a:=tstringlist.create;
a.text:='1';
a.savetofile(z);
{yes}
result:=true;
except;end;
try
freeobj(@a);
if (z<>'') then remFile(z);
except;end;
end;
//## WriteStr ##
function TBinaryFile.WriteStr(x:integer;var y:string):boolean;
label
     SkipEnd;
var
   a:TBinaryFileBuffer;
   ap,yLen,p,aSize,yPos:integer;
begin
try
{error}
result:=false;
{check}
iErrorMessage:=gecReadOnly;
if not CanWrite then exit;
{prepare}
iErrorMessage:=gecOutOfDiskSpace;
aSize:=SizeOf(a);
yLen:=length(y);
yPos:=1;
{process}
//seek
if (x>=0) then position:=x;
//write
for p:=1 to yLen do
begin
//fill
ap:=p-yPos+1;
a[ap-1]:=byte(y[p]);
//store
if ((ap)>=aSize) or (p=yLen) then
   begin
   yPos:=p+1;
   if (ap<>iFileStream.write(a,ap)) then goto SkipEnd;
   end;//end of if
end;//end of loop
{Successful}
result:=true;
SkipEnd:
except;end;
end;
//## ReadStr ##
function TBinaryFile.ReadStr(x:integer;yc:integer;var y:string):boolean;{3.1Mb/sec/yc=32,000 on CPU:200Mhz}
var
   a:TBinaryFileBuffer;
   i,ap,p,aSize:integer;
   z:string;
begin
try
{error}
result:=false;
{check}
iErrorMessage:=gecEmpty;
y:='';
if not Open then exit;
{prepare}
iErrorMessage:=gecOutOfDiskSpace;
aSize:=SizeOf(a);
if (yc<=0) then
   begin
   result:=true;
   exit;
   end;
{process}
//seek
if (x>=0) then position:=x;
//write
for p:=1 to yc do
begin
//get
ap:=frcmax(yc,aSize);
yc:=yc-ap;
ap:=iFileStream.read(a,ap);
if (ap=0) then break;
//set
if (ap>=1) then
   begin
   z:=copy(iNullStr,1,ap);
   for i:=1 to ap do z[i]:=chr(a[i-1]);
   y:=y+z;
   z:='';
   end;//end of if
//check
if (yc<1) then break;
end;//end of loop
{Successful}
result:=true;
except;end;
end;
//## Wipe ##
function TBinaryFile.Wipe(x,yc:integer):boolean;
var
   z:string;
   c:integer;
begin
try
{error}
result:=false;
iErrorMessage:=gecOutOfMemory;
{check}
if (yc<1) then
   begin
   result:=true;
   exit;
   end;//end of if
{prepare}
z:=copy(iNullStr,1,yc);
c:=0;
if (x>=0) then position:=x;
{process}
while TRUE do
begin
//set
if not WriteStr(-1,z) then exit;
//fill
yc:=yc-length(z);
if (yc<1) then break
else if (yc<length(z)) then z:=copy(z,1,yc);
end;//end of while
{successful}
result:=true;
except;end;
end;
//## GetPosition ##
function TBinaryFile.GetPosition:integer;
begin
try
case open of
false:result:=0;
true:result:=iFileStream.position;
end;//end of case
except;end;
end;
//## SetPosition ##
procedure TBinaryFile.SetPosition(x:integer);
begin
try
//check
if not open then exit;
//seek
if (x>=0) and (iFileStream.position<>x) then iFileStream.position:=x;
except;end;
end;

//############################## tfilepush #####################################
//## create ##
constructor tfilepush.create;
begin
//vars
ifilestream:=nil;
clear;
end;
//## destroy ##
destructor tfilepush.destroy;
begin
try
//controls
clear;
//self
inherited;
except;end;
end;
//## clear ##
procedure tfilepush.clear;
begin
try
istage:=fesClosing;
freeObj(@ifilestream);
ifilename:='';
ibytes:=0;
istage:=fesClosed;
except;end;
end;
//## canopen ##
function tfilepush.canopen:boolean;
begin
try;result:=(istage=fesClosed);except;end;
end;
//## open ##
function tfilepush.open(x:string;var e:string):boolean;
label
   skipend;
begin
try
//defaults
result:=false;
e:=gecUnexpectedError;
//process
if canopen then
   begin
   //.get
   istage:=fesOpening;
   //.delete
   e:=gecFileInUse;
   if not remfile(x) then goto skipend;
   //.set
   e:=gecBadFileName;
   ifilestream:=tfilestream.create(x,fmCreate);
   ifilename:=x;
   ibytes:=0;
   istage:=fesOpen;
   //successful
   result:=true;
   end;//end of if
skipend:
except;end;
try;if not result then clear;except;end;
end;
//## canpush ##
function tfilepush.canpush:boolean;
begin
try;result:=(istage=fesOpen);except;end;
end;
//## push ##
function tfilepush.push(x:string;var e:string):boolean;
label
   skipend;
const
   bufsize=32768;//26-JAN-2006
var
   buf:array[0..(bufsize-1)] of char;
   tmp:string;
   p,tmpLEN:integer;
begin
try
//defaults
result:=false;
e:=gecUnexpectedError;
//process
if canpush then
   begin
   e:=gecOutOfDiskSpace;
   repeat
   //.get
   tmp:=copy(x,1,bufsize);
   tmpLEN:=length(tmp);
   delete(x,1,tmpLEN);
   //.set
   if (tmpLEN>=1) then
      begin
      for p:=1 to tmpLEN do buf[p-1]:=tmp[p];
      //.write
      if (tmpLEN<>ifilestream.write(buf,tmpLEN)) then goto skipend;
      //.inc
      general.croll(ibytes,tmpLEN);
      end;//end of if
   //.breath
   if general.pause then application.processmessages;
   until (tmpLEN<=0);
   //successful
   result:=true;
   end;//end of if
skipend:
except;end;
end;
//## canclose ##
function tfilepush.canclose:boolean;
begin
try;result:=(istage=fesOpen);except;end;
end;
//## close ##
procedure tfilepush.close;
begin
try;if canclose then clear;except;end;
end;

//## tstreamstr ################################################################
//## create ##
constructor tstreamstr.create(_ptr:pstring);
begin
//self
inherited create;
//set
iptr:=_ptr;
iposition:=0;
end;
//## read ##
function tstreamstr.read(var x;xlen:longint):longint;
begin
try
//set
if (iptr=nil) then result:=0
else
   begin
   result:=length(iptr^)-iposition;
   if (result>xlen) then result:=xlen;
   move(pchar(@iptr^[iposition+1])^,x,result);
   inc(iposition,result);
   end;//end of if
except;end;
end;
//## write ##
function tstreamstr.write(const x;xlen:longint):longint;
begin
try
//set
if (iptr=nil) then result:=0
else
  begin
  result:=xlen;
  setlength(iptr^,(iposition+result));
  move(x,pchar(@iptr^[iposition+1])^,result);
  inc(iposition,result);
  end;//end of if
except;end;
end;
//## seek ##
function tstreamstr.seek(offset:longint;origin:word):longint;
begin
try
//check
if (iptr=nil) then
   begin
   iposition:=0;
   result:=0;
   exit;
   end;//end of if
//set
case Origin of
soFromBeginning:iposition:=offset;
soFromCurrent:iposition:=iposition+offset;
soFromEnd:iposition:=length(iptr^)-offset;
end;//end of case
//range
iposition:=frcrange(iposition,0,length(iptr^));
//return result
result:=iposition;
except;end;
end;
//## readstring ##
function tstreamstr.readstring(count:longint):string;
var
  len:integer;
begin
try
//defaults
result:='';
//check
if (iptr=nil) then exit;
//process
len:=length(iptr^)-iposition;
if (len>count) then len:=count;
setstring(result,pchar(@iptr^[iposition+1]),len);
inc(iposition,len);
except;end;
end;
//## writestring ##
procedure tstreamstr.writestring(const x:string);
begin
try;write(pchar(x)^,length(x));except;end;
end;
//## setsize ##
procedure tstreamstr.setsize(newsize:longint);
begin
try
//check
if (iptr=nil) then exit;
//set
setlength(iptr^,newsize);
if (iposition>newsize) then iposition:=newsize;
except;end;
end;

//## tstreammem ################################################################
//## clear ##
procedure tstreammem.clear;
begin
try
setsize(0);
iposition:=0;
except;end;
end;
//## loadfromstream ##
procedure tstreammem.loadfromstream(stream:tstream);
var
   a:array[0..1023] of char;
   ac,count:longint;
begin
//.init
stream.position:=0;
count:=stream.size;
setsize(count);
//.set
if (count<>0) then
   while TRUE do
   begin
   ac:=stream.read(a,sizeof(a));
   if (ac>=1) and (ac<>write(a,ac)) then break
   else if (ac<=0) then break;
   end;//end of while
end;
//## loadfromfile ##
procedure tstreammem.loadfromfile(const FileName: string);
var
   stream:tstream;
begin
stream:=tfileStream.create(filename,fmOpenRead);
try
   loadfromstream(stream);
finally
   stream.free;
end;
end;
//## write ##
function tstreammem.write(const x;xlen:longint):longint;
begin
try
//set
if (iptr=nil) or (iposition<0) then result:=0
else
  begin
  result:=xlen;
  if ((iposition+result)>length(iptr^)) then setlength(iptr^,(iposition+result));
  move(x,pchar(@iptr^[iposition+1])^,result);
  inc(iposition,result);
  end;//end of if
except;end;
end;

//## tzof ######################################################################
//## create ##
constructor tzof.create;
begin
//self
inherited;
//defaults
istrm.zalloc:=nil;
istrm.zfree:=nil;
istrm.appdata:=nil;
end;
//## destroy ##
destructor tzof.destroy;
begin
try
//controls
stop;
//self
inherited;
except;end;
end;
//## gzHEAD ##
function tzof.gzHEAD(filename:string):string;
var//Note: stores ONLY name section, must be able to handle both dos and web path seps (\ or /)
   p:integer;
begin
try
//process
//.get
for p:=length(filename) downto 1 do if (filename[p]='/') or (filename[p]='\') then
   begin
   filename:=copy(filename,p+1,length(filename));
   break;
   end;//end of if
//.set
//      header       //space       //filename - null terminated
result:=#31#139#8#8 +#0#0#0#0#0#0 +extractfilename(filename)+#0;
except;end;
end;
//## fileGZIP ##
function tzof.fileGZIP(filename,x:string):string;
var
   e:string;
begin
try
//head
result:=gzHEAD(filename);
//compress
start(true,e);
compress(x,result,e,true);
stop;
except;end;
end;
//## httpGZIP ##
function tzof.httpGZIP(x:string):string;
var
   e:string;
begin
try
//head  header3,flags1,mTIME4,xfl1,os (255=unknown)
result:=#31#139#8#0#0#0#0#0#0#255;
//compress
start(true,e);
compress(x,result,e,true);
stop;
except;end;
end;
//## start ##
function tzof.start(trimfirstbytes:boolean;var e:string):boolean;
begin
try
//error
result:=false;
e:=gecUnexpectedError;
//check
if icompressing then exit;
//prepare
e:=gecOutOfMemory;
fillchar(istrm,sizeof(istrm),0);
istrm.zalloc:=zlibAllocMem;
istrm.zfree:=zlibFreeMem;
istrm.appdata:=nil;
icrc32.val:=0;
isize.val:=0;
if (z_ok<>deflateInit_(istrm,Z_BEST_SPEED,zlib_version,sizeof(istrm))) then
   begin
   e:='init failed';
   exit;
   end;//end of if
icompressing:=true;
ifirst:=true;
//first bytes count
if trimfirstbytes then ifbc:=0 else ifbc:=maxint;
//successful
result:=true;
except;end;
end;
//## stop ##
procedure tzof.stop;
begin
try
//check
if not icompressing then exit;
//process
icompressing:=false;
deflateEnd(istrm);
except;end;
end;
//## compressflush ##
procedure tzof.compressflush(var data:string;tmp:pointer;tmpLEN:integer);
label
   redo;
var
   z:string;
   zlen:integer;
begin
try
//check
if not icompressing then exit;
//process
//.get
setstring(z,pchar(tmp),tmpLEN-istrm.avail_out);
zlen:=tmpLEN-istrm.avail_out;
//.strip first 2 bytes automatically (makes it GZ compatiable)
redo:
if (zlen>=1) and (ifbc<2) then
   begin
   inc(ifbc);
   delete(z,1,1);
   dec(zlen);
   goto redo;
   end;//end of if
//.append
data:=data+z;
//.reset
istrm.next_out:=tmp;
istrm.avail_out:=tmpLEN;
istrm.total_out:=0;
except;end;
end;
//## insertcrc32 ##
procedure tzof.insertcrc32(var d:string);
var
   xlen:integer;
begin
try
//get
xlen:=length(d);
//set
if (xlen>=4) then
   begin
   d[xlen-3]:=icrc32.chars[0];
   d[xlen-2]:=icrc32.chars[1];
   d[xlen-1]:=icrc32.chars[2];
   d[xlen-0]:=icrc32.chars[3];
   end;//end of if
except;end;
end;
//## compress ##
function tzof.compress(x:string;var d,e:string;readall:boolean):boolean;
label
  skipend;
var
  tmp,p:pointer;
  v2,v,incBY,ip,xlen,tmpLEN:integer;
  z:string;
  dendOK:boolean;
begin
try
//defaults
result:=false;
e:=gecOutOfMemory;
p:=nil;
tmp:=nil;
dendOK:=false;
//check
if not icompressing then exit;
//setup
//.out buffer
tmpLEN:=4096;
getmem(tmp,tmpLEN);
istrm.next_out:=tmp;
istrm.avail_out:=tmpLEN;
//.in buffer
istrm.next_in:=pchar(x);
istrm.avail_in:=length(x);
//process
//.size & crc32
xlen:=length(x);
misc.crc32(icrc32.val,x,1,xlen);
general.iroll(isize.val,xlen);
//.work
while (istrm.avail_in<>0) do
begin
//.get
v:=deflate(istrm,z_NO_FLUSH);
if (v<0) then
   begin
   e:='deflate error';
   goto skipend;
   end;//end of if
//.set
if (istrm.avail_out=0) then compressflush(d,tmp,tmpLEN);
end;//end of while
//.partial
if (istrm.avail_out<>tmpLEN) then compressflush(d,tmp,tmpLEN);
//.finalise
if readall then
   begin
   istrm.total_out:=0;
   while TRUE do
   begin
   v:=deflate(istrm,Z_FINISH);
   if (v=Z_STREAM_END) then break
   else if (v<>z_ok) then
      begin
      e:='stream end error';
      goto skipend;
      end;//end of if
   //.set
   if (istrm.avail_out=0) then compressflush(d,tmp,tmpLEN);
   end;//end of while
   if (istrm.avail_out<>tmpLEN) then compressflush(d,tmp,tmpLEN);
   //.reset total out to ZERO
   v:=deflateEnd(istrm);
   if (v<0) then
      begin
      e:=inttostr(v)+'deflate end error';
      goto skipend;
      end
   else dendOK:=true
   end;//end of if
//.get
if readall then
   begin
   reallocmem(tmp,istrm.total_out);
   tmpLEN:=istrm.total_out;
   //.write
   setstring(z,pchar(tmp),tmpLEN);
   d:=d+z;
   //GZ TRAILING INFORMATION (CRC-32[4] and SIZE[4])
   //.insert new CRC-32 (replacing old ADLER32)
   insertcrc32(d);
   //.size
   d:=d+isize.chars[0]+isize.chars[1]+isize.chars[2]+isize.chars[3];
   end;//end of if
//successful
result:=true;
skipend:
except;end;
try;if readall and (not dendOK) then stop;except;end;
try;freemem(tmp);except;end;
end;
//## zof ##
function tzof.zof(var x,e:string;c:boolean):boolean;//passed
label//Note: Uses out-of-date "ADLER32" checksum, use start-compress-stop for upto date "CRC-32"
     skipend;
var
  strm:TZStreamRec;
  tmp,p:pointer;
  v2,v,incBY,ip,xlen,tmpLEN:integer;
begin
try
//error
result:=false;
e:=gecOutOfMemory;
//prepare
tmp:=nil;
v:=0;
v2:=0;
p:=nil;
xlen:=length(x);
fillchar(strm,sizeof(strm),0);
strm.zalloc:=zlibAllocMem;
strm.zfree:=zlibFreeMem;
if c then
   begin//compress
   tmpLEN:=((xLEN+(xLEN div 10)+12)+255) and not 255;
   incBY:=256;
   end
   else
   begin//decompress
   incBY:=(xLEN+255) and not 255;
   tmpLEN:=incBY;
   end;//end of if
getmem(tmp,tmpLEN);
//process
strm.next_in:=pchar(x);
strm.avail_in:=length(x);
strm.next_out:=tmp;
strm.avail_out:=incBY;
//.init
if c then v:=deflateInit_(strm,Z_BEST_SPEED,zlib_version,sizeof(strm)) else v:=inflateInit_(strm,zlib_version,sizeof(strm));
if (v<0) then goto skipend;
try
//.work
while true do
begin
//.get
if c then v:=deflate(strm,z_FINISH) else v:=inflate(strm,z_FINISH);
if (v=Z_STREAM_END) or (v<0) then break;
//.set
if (strm.avail_out=0) then
   begin
   //.inc
   p:=tmp;
   inc(tmpLEN,incBY);
   reallocmem(tmp,tmpLEN);
   strm.next_out:=pchar(integer(tmp)+(integer(strm.next_out)-integer(p)));
   strm.avail_out:=incBY;
   end;//end of if
end;//end of with
finally
//.finalise
if c then v2:=deflateEnd(strm) else v2:=inflateEnd(strm);
end;
if (v<0) or (v2<0) then goto skipend;
//.get
reallocmem(tmp,strm.total_out);
tmpLEN:=strm.total_out;
//.write
x:='';
setstring(x,pchar(tmp),tmpLEN);
//successful
result:=true;
skipend:
except;end;
try
if not result then x:='';
freemem(tmp);
except;end;
end;

//######################### ttesting ###########################################
//## create ##
constructor ttesting.create;
begin
inherited;
end;
//## destroy ##
destructor ttesting.destroy;
begin
inherited;
end;
//## showmsg ##
procedure ttesting.showmsg(x:string);
begin
showinfo(x);
end;

//## getcursorpointer ##
function getcursorpointer(x:tvirtualcursor):integer;
begin
try
if (x=vcArrow) then result:=vsCursorArrow
else if (x=vcLink) then result:=vsCursorHand
else if (x=vcText) then result:=vsCursorText
else if (x=vcBusy) then result:=vsCursorBusy
else if (x=vcSize) then result:=vsCursorSize
else result:=vsNil;
except;end;
end;
//## getcursorlabel ##
function getcursorlabel(x:tvirtualcursor):string;
begin
try
if (x=vcArrow) then result:=ntranslate('arrow')
else if (x=vcLink) then result:=ntranslate('link')
else if (x=vcText) then result:=ntranslate('text')
else if (x=vcBusy) then result:=ntranslate('busy')
else if (x=vcSize) then result:=ntranslate('size')
else result:='?';
except;end;
end;
//## nocursors ##
procedure nocursors;
begin
try
setcursordata(crArrow,vs.default[getcursorpointer(vcArrow)]);
setcursordata(crHandPoint,vs.default[getcursorpointer(vcLink)]);
setcursordata(crIBeam,vs.default[getcursorpointer(vcText)]);
setcursordata(crAppStart,vs.default[getcursorpointer(vcBusy)]);
setcursordata(crSize,vs.default[getcursorpointer(vcSize)]);
except;end;
end;
//## setcursordata ##
procedure setcursordata(x:tcursor;y:string);
const
   IDC_HANDPT =   PChar(32761);
var
   ok:boolean;
   e,tmp:string;
   z:pchar;
   h:HINST;
begin
try
//defaults
ok:=false;
tmp:='';
//check
case x of
crArrow,crHandPoint,crIBeam,crAppStart,crSize:;
else exit;
end;//end of case
//process
try
if (y<>'') then
   begin
   //.file
   if (copy(y,1,2)='\\') or (copy(y,2,2)=':\') then
      begin
      screen.cursors[x]:=loadcursorfromfile(pchar(y));
      ok:=true;
      end
   //.data
   else
      begin
      tmp:=bvfportable(bvfTemp)+'TMP.CUR';
      if io.tofile(tmp,y,e) then
         begin
         screen.cursors[x]:=loadcursorfromfile(pchar(tmp));
         ok:=true;
         end;//end of if
      end;//end of if
   end;//end of if
except;end;
//.default
if not ok then
   begin
   //.get
   case x of
   crArrow:begin
      h:=0;
      z:=IDC_ARROW;
      end;
   crHandPoint,crSize:begin
      h:=hinstance;//*special case*
      z:=IDC_HANDPT;
      end;
   crIBeam:begin
      h:=0;
      z:=IDC_IBEAM;
      end;
   crAppStart:begin
      h:=0;
      z:=IDC_APPSTARTING;
      end;
   else
      z:=idc_arrow;
   end;//end of case
   //.set
   screen.cursors[x]:=LoadCursor(h,z);
   end;//end of if
except;end;
try;if (tmp<>'') then remfile(tmp);except;end;
end;
//## viSync ##
procedure viSync;//05JAN2008
var
   tmpmap:tfontmap;
   _viNormalFN,_viTitleFN:string;
   _fontsize,bs,a,b:integer;
   tmps:single;
   tmp:string;
begin
try
//defaults
tmpmap:=nil;
//check
if (sysstate>=ssClosed) then exit;
//SUP.TRANS.
if (comparetext(programnameHARD,'select language')<>0) then st.text:=vs.s[vsSuptrans];
//FONT
//init
_viNormalFN:=vs.s[vsFontName];
_viTitleFN:=vs.s[vsTitleFontName];
_fontsize:=vs.i[vsFontsize];
//get
viNormal.fontmap.font.name:=_viNormalFN;
viNormal.fontmap.font.size:=_fontsize;
if viNormal.fontmap.canupdate then viNormal.fontmap.update;
viTitle.fontmap.font.name:=_viTitleFN;
viTitle.fontmap.font.size:=_fontsize;
if viTitle.fontmap.canupdate then viTitle.fontmap.update;
//set
viFontHeight:=largest(viNormal.fontmap.maxH,viTitle.fontmap.maxH);
//width ratio
//.init
a:=1;
b:=1;
tmpmap:=tfontmap.create;
//.system standard
tmpmap.font.name:='ms sans serif';
tmpmap.font.size:=8;
tmpmap.update;
b:=frcmin(tmpmap.aveW,1);
//.user
a:=largest(viNormal.fontmap.aveW,viTitle.fontmap.aveW);
//.font width ratio
tmps:=(a/b);
if (tmps<=0) then tmps:=1;
viFontWidthRatio:=tmps;
//.tab ratio
if (tmps<0.5) then tmps:=0.5
else if (tmps>2.3) then tmps:=2.3;
viTabRatio:=tmps;
//OTHER
viHelp:=vs.b[vsHelp];
viSizeBalanced:=vs.b[vsSizeBalanced];
viSizeFast:=vs.b[vsSizeFast];
viSafeArea:=vs.b[vsSafeArea];
viEnhanced:=vs.b[vsEnhanced];
viCompact:=vs.b[vsCompact];
viBufferedPaint:=vs.b[vsBufferedPaint];
viOnTop:=vs.b[vsOnTop];
viScrollSize:=vs.i[vsScrollSize];
viMainScrollSize:=vs.i[vsScrollSizeMain];
viRounded:=vs.b[vsRound];
viBorder:=vs.b[vsBorderSize];
viShowSoft:=vs.b[vsShowSoft];
//.normal
with viNormal do
begin
//.colors
border:=vs.i[vsBorder];
background:=vs.i[vsBackground];
highlight:=vs.i[vsHighlight];
hover:=vs.i[vsHover];
disable:=vs.i[vsDisable];
disableborder:=vs.i[vsDisableBorder];
disablefont:=vs.i[vsDisableFont];
font:=vs.i[vsFont];
fonthighlight:=vs.i[vsFonthighlight];
fontname:=_viNormalFN;
//.color ranges
highlight:=ccs.ecv(highlight,background,20);
font:=ccs.ecv(font,background,30);
fonthighlight:=ccs.ecv(fonthighlight,highlight,30);
disableborder:=ccs.ecv(disableborder,disable,20);
disablefont:=ccs.ecv(disablefont,disable,30);
//.HTML
a:=general.aorb(highlight,fonthighlight,font<>fonthighlight);
bs:=general.dc(background,10);
hfontname:=fontname;
general.swapstrs(hfontname,',','');
general.swapstrs(hfontname,'"','');
general.swapstrs(hfontname,'''','');
general.swapstrs(hfontname,'<','');
general.swapstrs(hfontname,'>','');
hborder:=general.toHEX(border,true);
hbackground:=general.toHEX(background,true);
hbackshade:=general.toHEX(bs,true);
hfont:=general.toHEX(font,true);
hlink:=hfont;
if (not ccs.cv(a,background,40)) or (not ccs.cv(a,bs,40)) then
   begin
   a:=highlight;
   if (not ccs.cv(a,background,40)) or (not ccs.cv(a,bs,40)) then
      begin
      a:=hover;
      if (not ccs.cv(a,background,40)) or (not ccs.cv(a,bs,40)) then
         begin
         a:=ccs.ecv(border,background,40);
         end;//end of if
      end;//end of if
   end;//end ofif
halink:=general.toHEX(a,true);
hvlink:=hfont;
hstyle:=
 '<style><!--'+
 'body {font-family:'+hfontname+',Tahoma,Arial,sans-serif;color:'+hfont+';background-color:'+hbackground+';} '+
 'a {color:'+hlink+'; text-decoration: none}'+
 'a:visited {color:'+hvlink+';}'+
 'a:active {color:'+halink+';}'+
 'a:hover {color:'+halink+';}'+
 'a.name {color: '+hlink+';} '+
 '--></style>';
hbody:='<body bgcolor='+hbackground+' text='+hfont+' link='+hlink+' vlink='+hvlink+' alink='+halink+'>';
end;//end of with

//.title
with viTitle do
begin
//.colors
border:=vs.i[vsTitleBorder];
background:=vs.i[vsTitleBackground];
highlight:=vs.i[vsTitleHighlight];
hover:=vs.i[vsTitleHover];
disable:=vs.i[vsTitleDisable];
disableborder:=vs.i[vsTitleDisableBorder];
disablefont:=vs.i[vsTitleDisableFont];
font:=vs.i[vsTitleFont];
fonthighlight:=vs.i[vsTitleFonthighlight];
fontname:=_viTitleFN;
//.color ranges
highlight:=ccs.ecv(highlight,background,20);
font:=ccs.ecv(font,background,30);
fonthighlight:=ccs.ecv(fonthighlight,highlight,30);
disableborder:=ccs.ecv(disableborder,disable,20);
disablefont:=ccs.ecv(disablefont,disable,30);
//.HTML
a:=general.aorb(highlight,fonthighlight,font<>fonthighlight);
bs:=general.dc(background,10);
hfontname:=fontname;
general.swapstrs(hfontname,',','');
general.swapstrs(hfontname,'"','');
general.swapstrs(hfontname,'''','');
general.swapstrs(hfontname,'<','');
general.swapstrs(hfontname,'>','');
hborder:=general.toHEX(border,true);
hbackground:=general.toHEX(background,true);
hbackshade:=general.toHEX(bs,true);
hfont:=general.toHEX(font,true);
hlink:=hfont;
if (not ccs.cv(a,background,40)) or (not ccs.cv(a,bs,40)) then
   begin
   a:=highlight;
   if (not ccs.cv(a,background,40)) or (not ccs.cv(a,bs,40)) then
      begin
      a:=hover;
      if (not ccs.cv(a,background,40)) or (not ccs.cv(a,bs,40)) then
         begin
         a:=ccs.ecv(border,background,40);
         end;//end of if
      end;//end of if
   end;//end ofif
halink:=general.toHEX(a,true);
hvlink:=hfont;
hstyle:=
 '<style><!--'+
 'body {font-family:'+hfontname+',Tahoma,Arial,sans-serif;color:'+hfont+';background-color:'+hbackground+';} '+
 'a {color:'+hlink+';}'+
 'a:visited {color:'+hvlink+';}'+
 'a:active {color:'+halink+';}'+
 'a:hover {color:'+halink+';}'+
 'a.name {color: '+hlink+';} '+
 '--></style>';
hbody:='<body bgcolor='+hbackground+' text='+hfont+' link='+hlink+' vlink='+hvlink+' alink='+halink+'>';
end;//end of with
//.extra html - 07-MAY-2007 - inserts ".... by Blaiz Enterprises" when "not licensed"
viHtmlEnd:=
general.insstr(
 '<br>'+rcode+
 '<br>'+rcode+
 '<p align=center><font size="-1">'+
 programnameHARD+' v'+programversion+' engineered by <a target=_blank href="http://www.blaizenterprises.com">Blaiz Enterprises</a></font></p>'+rcode,
 true)+
//.honepot link 05JAN2008
wec.honeypotLINK+
'</body>'+rcode+
'</html>'+rcode;
//.cursors
setcursordata(crArrow,vs.s[vsCursorArrow]);
setcursordata(crHandPoint,vs.s[vsCursorHand]);
setcursordata(crIBeam,vs.s[vsCursorText]);
setcursordata(crAppStart,vs.s[vsCursorBusy]);
setcursordata(crSize,vs.s[vsCursorSize]);
//.options
pg.boot          :=vs.b[vsAutoStartup];
pg.systray       :=vs.b[vsSystemTray];
pg.ontop         :=vs.b[vsOnTop];
pg.startminimised:=vs.b[vsStartMinimised];
pg.cansplash     :=vs.b[vsShowSplash];
//.app event
appsync;
except;end;
try;freeobj(@tmpmap);except;end;
end;
//## showerror60 ##
function showerror60(_msg:string):boolean;
begin//dual layer
try
if (sysstate<>ssOK) or (viNormal.fontmap=nil) then
   begin
   result:=true;
   messagebox(application.handle,_msg,ntranslate('Error')+'!',mbError+MB_OK);
   end
else result:=showmsg(ntranslate('Error')+'!',_msg,tepError32,60);
except;end;
end;
//## _sdbm ##
procedure _sdbm(_msg:string);//special DEBUG message box, not to be used by program, only for debugging - all instances are automatically removed
const
   match='';
//yyyyyyyyyyyyyyyyyyyyyyyy
var
   e:string;
begin
try
{//yyyyyyyyyyyyyyyyyy
if (match<>'') then
   begin
   if (copy(_msg,1,length(match))<>match) then exit;
   end;//end of if
_msg:='NAME:'+programname+' >MSG>>'+_msg+' >LABEL>>'+_sdbmLABEL+' >SUB>>'+_sdbmLABEL_SUB+' >OBJ>>'+_sdbmLABEL_OBJ+' >TIME>>'+datetostr(now)+', '+timetostr(now)+rcode;
io.toFILEAPPEND('C:\DEBUG-RGS.TXT',_msg,e);
//yyyyyyyyyyyyyyyyyymessagebox(application.handle,_msg,'Information',mbInformation+MB_OK);
{}//yyyyyyyyyyyyyyyyy
except;end;
end;
//## showerror ##
procedure showerror(_msg:string);
begin//**
try;messagebox(application.handle,_msg,'Error!',mbError+MB_OK);except;end;
end;
//## showbasic ##
procedure showbasic(_msg:string);
begin//** - Message windows must NOT use any support routines, since these windows
     //     must be displayable at any point of execution, especially during INIT and HALT.
try;messagebox(application.handle,_msg,'Information',mbInformation+MB_OK);except;end;
end;
//## showinfo ##
function showinfo(_msg:string):boolean;
begin
try;result:=showinfo60(_msg);except;end;
end;
//## showinfo60 ##
function showinfo60(_msg:string):boolean;
begin//dual layer
try
if (sysstate<>ssOK) or (viNormal.fontmap=nil) then
   begin
   result:=true;
   messagebox(application.handle,_msg,ntranslate('information'),mbInformation+MB_OK);
   end
else result:=showmsg(ntranslate('information'),_msg,tepInfo32,60);
except;end;
end;
//## showmsg ##
function showmsg(_title,_msg,_tep:string;_autoclick:integer):boolean;
begin
try;result:=showmsgex(_title,_msg,_tep,_autoclick,viShowSoft);except;end;
end;
//## showmsgex ##
function showmsgex(_title,_msg,_tep:string;_autoclick:integer;_soft:boolean):boolean;
var
   a:tvirtualdlg;
   e:string;
begin
try
//defaults
result:=false;
a:=nil;
//process
a:=tvirtualdlg.create(nil);
a.caption:=general.aorbstr(ntranslate('dialog'),_title,_title<>'');
a.newbutton(translate('&OK'),tepYes20,mrOK).autoclick:=frcmin(_autoclick,0);
with a.newtext('',_msg,true) as tvirtualbasetext do
begin
readonly:=true;
bordersize:=0;
end;//end of with
//prompt
a.head.image.setanimation(general.aorbstr(tepInfo32,_tep,_tep<>''),e);
a.head.image.run:=viEnhanced;
if _soft then result:=a.showwait else result:=(modaloc(a.showmodal)=mrOK);
except;end;
try;freeobj(@a);except;end;
end;
//## showconfirm ##
function showconfirm(_msg:string):boolean;
var
   xof:string;
begin
try
xof:=lowercase(translate('of'));
result:=
   showqueryb(ntranslate('Confirm')+' - 1 '+xof+' 2',_msg,-60) and
   showqueryb(ntranslate('Confirm')+' - 2 '+xof+' 2',translate('Confirm')+': '+_msg,-60);
except;end;
end;
//## showquery60 ##
function showquery60(_msg:string):boolean;
begin
try;result:=showquery(_msg,-60);except;end;
end;
//## showquery ##
function showquery(_msg:string;_autoclick:integer):boolean;
begin
try;result:=showqueryb('',_msg,_autoclick);except;end;
end;
//## showqueryb ##
function showqueryb(_title,_msg:string;_autoclick:integer):boolean;
begin
try;result:=showqueryex(_title,_msg,_autoclick,viShowSoft);except;end;
end;
//## showqueryex ##
function showqueryex(_title,_msg:string;_autoclick:integer;_soft:boolean):boolean;
var
   a:tvirtualdlg;
   b:tvirtualbutton;
   e:string;
begin
try
//defaults
result:=false;
a:=nil;
//process
a:=tvirtualdlg.create(nil);
a.caption:=general.udv(_title,ntranslate('Query'));
//.cancel
b:=a.newbutton(translate('&Cancel'),tepCancel20,mrCancel);
if (_autoclick<=-1) then b.autoclick:=-_autoclick;
//.yes
b:=a.newbutton(translate('&Yes'),tepYes20,mrOK);
if (_autoclick>=1) then b.autoclick:=_autoclick;
//.msg
with a.newtext('',_msg,true) as tvirtualbasetext do
begin
readonly:=true;
bordersize:=0;
end;//end of with
//prompt
a.head.image.setanimation(tepQuery32,e);
a.head.image.run:=viEnhanced;
if _soft then result:=a.showwait else result:=(modaloc(a.showmodal)=mrOK);
except;end;
try;freeobj(@a);except;end;
end;
//## showYNC ##
function showYNC(_msg:string;_autoclick:integer):tmodalresult;
var//Reply: mrCancel, mrNo, mrOk
   a:tvirtualdlg;
   b:tvirtualbutton;
   e:string;
begin
try
//defaults
result:=mrCANCEL;
a:=nil;
//process
a:=tvirtualdlg.create(nil);
a.caption:=ntranslate('Query');
//.cancel
b:=a.newbutton(translate('&Cancel'),tepCancel20,mrCancel);
if (_autoclick<=-1) then b.autoclick:=-_autoclick;
//.no
b:=a.newbutton(translate('&No'),tepNo20,mrNO);
//.yes
b:=a.newbutton(translate('&Yes'),tepYes20,mrOK);
if (_autoclick>=1) then b.autoclick:=_autoclick;
//.msg
with a.newtext('',_msg,true) as tvirtualbasetext do
begin
readonly:=true;
bordersize:=0;
end;//end of with
//prompt
a.head.image.setanimation(tepQuery32,e);
a.head.image.run:=viEnhanced;
if viShowSoft then a.showwait else a.showmodal;
result:=modalONC(a.modalresult);
except;end;
try;freeobj(@a);except;end;
end;
//## showreplacefile ##
function showreplacefile(filename:string;fullpath:boolean):boolean;
begin
try;result:=showreplacefileb(filename,'',fullpath);except;end;
end;
//## showreplacefileb ##
function showreplacefileb(filename,_filelabel:string;fullpath:boolean):boolean;
var
   tmp:string;
begin
try
//defaults
result:=true;
//process
if fileexists(filename) then
   begin
   tmp:=general.aorbstr(extractfilename(filename),filename,fullpath);
   result:=showquery(translate('Replace existing')+#32+general.aorbstr('file',_filelabel,general.textgood(_filelabel))+':'+rcode+tmp+'?',-60);
   end;//end of if
except;end;
end;
//## newfilename60 ##
function newfilename60(var sfilename,dfilename:string):boolean;//04OCT2007 - just prompts user for a "new filename" tied to current "ext"
begin
try;result:=newfilename60ex(sfilename,dfilename,'');except;end;
end;
//## newfilename60ex ##
function newfilename60ex(var sfilename,dfilename:string;newext:string):boolean;//04OCT2007 - just prompts user for a "new filename" tied to current "ext"
label
   redo;
var//Internal error handling and display
   oext,tmp,msg1,_type,ext,_old,_new:string;
begin
try
//defaults
result:=false;
msg1:=translate('Name already exists, use another.');
dfilename:=sfilename;
//process
redo:
if fileexists(sfilename) then
   begin
   //init
   ext:=readfileext(sfilename,false);
   _type:=ext;
   if (ext<>'') then ext:='.'+ext;
   oext:=ext;
   //.change to new extension - if one has been provided
   if (newext<>'') then
      begin
      newext:=readfileext('.'+newext,false);
      if (newext<>'') then
         begin
         _type:=newext;
         newext:='.'+newext;
         ext:=newext;
         end;//end of if
      end;//end of if
   _old:=general.remlastext(extractfilename(sfilename));
   _new:=_old;
   //get
   if showedit60(_new,ntranslate('rename file'),translate('New name for file')+general.insstr(#32+translate('of type')+' "'+uppercase(_type)+'"',_type<>''),'') then
      begin
      _new:=general.safefilename(_new,false);
      if ((_old+oext)=(_new+ext)) then
         begin
         showerror60(msg1);
         goto redo;
         end
      else
         begin
         tmp:=extractfilepath(sfilename)+_new+ext;
         //check
         if fileexists(tmp) then
            begin
            showerror60(msg1);
            goto redo;
            end;//end of if
         //set
         dfilename:=tmp;
         result:=true;
         end;//end of if
      end;//end of if
   end
else result:=true;
except;end;
end;
//## showrenamefile60 ##
function showrenamefile60(sfilename:string;var dfilename:string):boolean;//04OCT2007
begin
try
//defaults
result:=false;
//get
if newfilename60(sfilename,dfilename) then
   begin
   //set
   result:=renamefile(sfilename,dfilename);
   if not result then showerror60(translate(gecTaskFailed));
   end;//end of if
except;end;
end;
//## showedit60 ##
function showedit60(var _text:string;_title,_caption,_okbutton:string):boolean;
begin
try;result:=showedit(_text,_title,_caption,_okbutton,-60);except;end;
end;
//## showedit ##
function showedit(var _text:string;_title,_caption,_okbutton:string;_autoclick:integer):boolean;
begin
try;result:=showeditex(_text,'','',_title,_caption,_okbutton,_autoclick);except;end;
end;
//## showdroplist60 ##
function showdroplist60(var _text:string;_list,_listtep,_title,_caption,_okbutton:string):boolean;//27SEP2007
begin
try;result:=showdroplist(_text,_list,_listtep,_title,_caption,_okbutton,-60);except;end;
end;
//## showedit ##
function showdroplist(var _text:string;_list,_listtep,_title,_caption,_okbutton:string;_autoclick:integer):boolean;//27SEP2007
begin
try;result:=showeditex(_text,_list,general.udv(_listtep,tepWebPage14),_title,_caption,_okbutton,_autoclick);except;end;
end;
//## showeditex ##
function showeditex(var _text:string;_list,_listtep,_title,_caption,_okbutton:string;_autoclick:integer):boolean;
var
   a:tvirtualdlg;
   b:tvirtualbutton;
   t:tvirtualedit;
   l:tvirtualdroplist;
   e:string;
begin
try
//defaults
result:=false;
a:=nil;
t:=nil;
l:=nil;
//process
a:=tvirtualdlg.create(nil);
a.caption:=general.aorbstr(translate('Text'),_title,_title<>'');
//.cancel
b:=a.newbutton(ntranslate('&cancel'),tepCancel20,mrCancel);
if (_autoclick<=-1) then b.autoclick:=-_autoclick;
//.yes
b:=a.newbutton(general.aorbstr(translate('&OK'),_okbutton,_okbutton<>''),tepYes20,mrOK);
if (_autoclick>=1) then b.autoclick:=_autoclick;
//.edit
case (_list='') of
true:t:=a.newedit(_caption,_text);
false:l:=a.newdroplist(_caption,_text,_list,_listtep);
end;//end of case
//focus
if (t<>nil) then a.focuscontrol:=t
else if (l<>nil) then a.focuscontrol:=l;
//prompt
a.head.image.setanimation(tepInfo32,e);
a.head.image.run:=viEnhanced;
if viShowSoft then result:=a.showwait else result:=(modaloc(a.showmodal)=mrOK);
if result then
   begin
   if (t<>nil) then _text:=t.text
   else if (l<>nil) then _text:=l.value;
   end;//end of if
except;end;
try;freeobj(@a);except;end;
end;
//## showUUP60 ##
function showUUP60(var _url,_username,_password:string;_title,_okbutton:string):boolean;//url, username and password entry window
begin
try;result:=showUUP(_url,_username,_password,_title,'','','',_okbutton,-60);except;end;
end;
//## showUUP ##
function showUUP(var _url,_username,_password:string;_title,_urlcap,_usernamecap,_passwordcap,_okbutton:string;_autoclick:integer):boolean;//url, username and password entry window
var
   a:tvirtualdlg;
   b:tvirtualbutton;
   ul,un:tvirtualedit;
   pw:tvirtualpassword;
   e:string;
begin
try
//defaults
result:=false;
a:=nil;
//process
a:=tvirtualdlg.create(nil);
a.caption:=general.udv(_title,ntranslate('Url')+'/'+ntranslate('User Name')+'/'+ntranslate('Password'));
//.cancel
b:=a.newbutton(translate('&Cancel'),tepCancel20,mrCancel);
if (_autoclick<=-1) then b.autoclick:=-_autoclick;
//.yes
b:=a.newbutton(general.aorbstr(translate('&OK'),_okbutton,_okbutton<>''),tepYes20,mrOK);
if (_autoclick>=1) then b.autoclick:=_autoclick;
//USER INPUT
//.url
ul:=a.newedit(general.udv(_urlcap,ntranslate('Url')),_url) as tvirtualedit;
//.username
un:=a.newedit(general.udv(_usernamecap,ntranslate('User Name')),_username) as tvirtualedit;
//.password
pw:=a.newpassword(general.udv(_passwordcap,ntranslate('Password')),_password) as tvirtualpassword;
//.auto height
a.focuscontrol:=ul;
//prompt
a.head.image.setanimation(tepSecure32,e);
a.head.image.run:=viEnhanced;
if viShowSoft then result:=a.showwait else result:=(modaloc(a.showmodal)=mrOK);
if result then
   begin
   _url:=ul.text;
   _username:=un.text;
   _password:=pw.text;
   end;//end of if
except;end;
try;freeobj(@a);except;end;
end;
//## showlist60 ##
function showlist60(var _text,_value:string;_title,_caption,_okbutton:string;_large,_readonly,_multiselect:boolean):boolean;
begin
try;result:=showlist(_text,_value,_title,_caption,_okbutton,_large,_readonly,_multiselect,-60);except;end;
end;
//## showlist ##
function showlist(var _text,_value:string;_title,_caption,_okbutton:string;_large,_readonly,_multiselect:boolean;_autoclick:integer):boolean;
var
   a:tvirtualdlg;
   b:tvirtualbutton;
   t:tvirtuallist;
   e:string;
begin
try
//defaults
result:=false;
a:=nil;
//process
a:=tvirtualdlg.create(nil);
a.caption:=general.aorbstr(translate('List'),_title,_title<>'');
//.cancel
b:=a.newbutton(translate('&Cancel'),tepCancel20,mrCancel);
if (_autoclick<=-1) then b.autoclick:=-_autoclick;
//.yes
b:=a.newbutton(general.aorbstr(translate('&OK'),_okbutton,_okbutton<>''),tepYes20,mrOK);
if (_autoclick>=1) then b.autoclick:=_autoclick;
//.newlist
t:=a.newlist(_caption,_text) as tvirtuallist;
t.readonly:=_readonly;
t.multiselect:=_multiselect;
if (_value<>'') then t.itemindex:=t.findvalue(_value);
t.oShowmenu:=not _readonly;
//.auto height
a.focuscontrol:=t;
//prompt
a.head.image.setanimation(tepInfo32,e);
a.head.image.run:=viEnhanced;
if viShowSoft then result:=a.showwait else result:=(modaloc(a.showmodal)=mrOK);
if result then
   begin
   _text:=t.text;
   if (t.itemindex=-1) or (t.count=0) then _value:=''
   else
      case _multiselect of
      false:_value:=t.items[t.itemindex];
      true:_value:=t.seltext;
      end;//end of case
   end;//end of if
except;end;
try;freeobj(@a);except;end;
end;
//## showfind ##
procedure showfind(_host:tvirtualform;var x:string;_onfind:tnotifyevent;tag:integer);
begin
try;showfindex(_host,x,_onfind,tag,'','','','');except;end;
end;
//## showextract ##
procedure showextract(_host:tvirtualform;var x:string;_onfind:tnotifyevent;tag:integer);
begin
try;showfindex(_host,x,_onfind,tag,'',ntranslate('extract'),'',ntranslate('extract'));except;end;
end;
//## showfindex ##
procedure showfindex(_host:tvirtualform;var x:string;_onfind:tnotifyevent;tag:integer;wndtep,wndcap,buttep,butcap:string);
var
   a:tvirtualdlg;
   b:tvirtualbutton;
   t:tvirtualedit;
   e:string;
begin
try
//defaults
a:=nil;
//range
if (wndtep='') then wndtep:=tepFind32;
if (wndcap='') then wndcap:=ntranslate('find');
if (buttep='') then buttep:=tepFind20;
if (butcap='') then butcap:=ntranslate('&find');
//process
a:=tvirtualdlg.create(nil);
a.caption:=wndcap;
a.mkReturn:=false;
//.tag
a.tag:=tag;
//.close
b:=a.newbutton(translate('&Close'),tepCancel20,mrCancel);
b.shortcut:='CTRL+C';
//.find
b:=a.newbutton(butcap,buttep,mrNone);
b.onclick:=_onfind;
b.shortcut:='CTRL+F';
//.edit
t:=a.newedit(ntranslate('Find Text'),x) as tvirtualedit;
t.onreturn:=_onfind;//14-DEC-2006
a.findtext:=t;
//.auto height
a.focuscontrol:=t;
//return result
a.popuphost:=_host;
a.head.image.setanimation(wndtep,e);
a.head.image.run:=viEnhanced;
if viShowSoft then a.showwait else a.showmodal;
x:=t.text;
except;end;
try;freeobj(@a);except;end;
end;
//## showtext ##
function showtext(var x:string;_wordwrap,_large:boolean):boolean;
begin
try;result:=showtextb('','',x,_wordwrap,_large);except;end;
end;
//## showtextb ##
function showtextb(title,caption:string;var x:string;_wordwrap,_large:boolean):boolean;
const
   vsp=2;
var
   a:tdlgform;
   b:tmemo;
   e:tlabel;
   p:tpanel;
   c,o:tbutton;
begin
try
//defaults
result:=false;
a:=nil;
b:=nil;
e:=nil;
//process
//.get
a:=tdlgform.create(nil);
a.borderstyle:=bsSizeable;
a.bordericons:=[biSystemMenu];
a.caption:=general.udv(title,ntranslate('text'));
case _large of
true:a.setbounds(0,0,550,400);
false:a.setbounds(0,0,350,250);
end;//end of case
general.center(a,a.width,a.height,false);
//controls
//.e
if (caption<>'') then
   begin
   e:=tlabel.create(a);
   e.parent:=a;
   e.caption:=caption;
   e.align:=alTop;
   e.visible:=true;
   end;//end of if
//.b
b:=tmemo.create(a);
b.parent:=a;
b.align:=alClient;
b.borderstyle:=bsNone;
b.cursor:=crIBeam;
if _wordwrap then
   begin
   b.scrollbars:=ssVertical;
   b.wordwrap:=true;
   end
else
   begin
   b.scrollbars:=ssBoth;
   b.wordwrap:=false;
   end;//end of if
b.font.assign(viNormal.fontmap.font);
b.visible:=true;
b.text:=x;
//.p
p:=tpanel.create(a);
p.parent:=a;
p.height:=25+vsp;
p.bevelinner:=bvNone;
p.bevelouter:=bvNone;
p.align:=alBottom;
p.cursor:=crArrow;
//.c
c:=tbutton.create(p);
c.parent:=p;
c.setbounds(0,vsp,115,p.height-vsp);
c.modalresult:=mrCancel;
c.caption:=ntranslate('Cancel');
c.cursor:=crHandPoint;
c.visible:=true;
//.o
o:=tbutton.create(p);
o.parent:=p;
o.setbounds(c.left+c.width+10,vsp,115,p.height-vsp);
o.modalresult:=mrOk;
o.caption:=ntranslate('Ok');
o.cursor:=crHandPoint;
o.visible:=true;
//.center
general.centerbyapp(a,a.width,a.height,false);
//.prompt
a.showmodal;
//.set
result:=(modalOC(a.modalresult)=mrOK);
if result then x:=b.text;
except;end;
try;freeobj(@a);except;end;
end;
//## pop ##
procedure pop(_popuphost:tvirtualform;x,y,yh:integer);
var//Note: destroys self
   tmp:tpop;
begin
try
tmp:=tpop.create(nil);
tmp.pop(_popuphost,x,y,yh);
except;end;
try;freeobj(@tmp);except;end;
end;
//## workarea ##
function workarea:trect;
begin
try
//defaults
result:=rect(0,0,0,0);
//process
systemparametersinfo(SPI_GETWORKAREA,0,@result,0);
except;end;
end;
//## screenarea ##
function screenarea:trect;
begin
try;result:=rect(0,0,screenwidth,screenheight);except;end;
end;
//## safebounds ##
function safebounds(left,top,width,height,margin:integer;area:trect):trect;
var
   tmp:trect;
begin
try
//range
margin:=frcmin(margin,0);
//enforce range
//.left
if ((left+width)<(area.left+margin)) then left:=area.left-width+margin
else if (left>(area.right-margin)) then left:=area.right-margin;
//.top
if ((top+height)<(area.top+margin)) then top:=area.top-height+margin
else if (top>(area.bottom-margin)) then top:=area.bottom-margin;
//set
result:=rect(left,top,width,height);
except;end;
end;
//## safeboundsb ##
procedure safeboundsb(x:twincontrol;_margin:integer;_workarea:boolean);
var
   tmp:trect;
begin
try
//get
if _workarea then tmp:=workarea else tmp:=screenarea;
//calc
tmp:=safebounds(x.left,x.top,x.width,x.height,_margin,tmp);
//set
x.setbounds(tmp.left,tmp.top,tmp.right,tmp.bottom);
except;end;
end;

//## tfontmap ##################################################################
//## create ##
constructor tfontmap.create;
begin
//controls
ifont:=tfont.create;
//vars
iminw:=1;
iminh:=1;
imaxw:=1;
imaxh:=1;
ipw:=@iw;
iph:=@ih;
iid:=0;
ilast.name:='';
ilast.height:=0;
ilast.style:=[];
//defaults
update;
end;
//## destroy ##
destructor tfontmap.destroy;
begin
try
//controls
freeobj(@ifont);
//self
inherited;
except;end;
end;
//## copyfrom ##
procedure tfontmap.copyfrom(x:tfont);
begin
try
//check
if (x=nil) then exit;
//set
ifont.assign(x);
//update
update;
except;end;
end;
//## textwidthc ##
function tfontmap.textwidthc(x:string):integer;
begin
try;result:=textwidth(x);except;end;
end;
//## textwidth ##
function tfontmap.textwidth(var x:string):integer;
begin
try;result:=textwidthb(x,1,length(x));except;end;
end;
//## textwidthb ##
function tfontmap.textwidthb(var x:string;s,f:integer):integer;
var
   xlen,p:integer;
begin
try
//defaults
result:=0;
xlen:=length(x);
s:=frcrange(s,1,xlen);
f:=frcrange(f,s,xlen);
//process
if (xlen>=1) then for p:=s to f do inc(result,iw[byte(x[p])]);
except;end;
end;
//## textwidthi ##
function tfontmap.textwidthi(var x:string;ingorechar:char;s,f:integer):integer;
var
   v,i:byte;
   xlen,p:integer;
begin
try
//defaults
result:=0;
xlen:=length(x);
s:=frcrange(s,1,xlen);
f:=frcrange(f,s,xlen);
i:=byte(ingorechar);
//process
if (xlen>=1) then for p:=s to f do
   begin
   v:=byte(x[p]);
   if (i=0) or (v<>i) then inc(result,iw[v]);
   end;//end of if
except;end;
end;
//## countchars ##
function tfontmap.countchars(var x:string;s,maxwidth:integer;lefttoright:boolean):integer;
var
   w,xlen,p:integer;
   tmp:integer;
begin
try
//defaults
result:=0;
xlen:=length(x);
s:=frcrange(s,1,xlen);
w:=0;
//process
case lefttoright of
true:if (xlen>=1) then for p:=s to xlen do
   begin
   //.get
   tmp:=iw[byte(x[p])];
   inc(w,tmp);
   //.decide
   if (w>=maxwidth) then break else inc(result);
   end;//end of if
false:if (xlen>=1) then for p:=xlen downto s do
   begin
   //.get
   tmp:=iw[byte(x[p])];
   inc(w,tmp);
   //.decide
   if (w>=maxwidth) then break else inc(result);
   end;//end of if
end;//end of case
except;end;
end;
//## canupdate ##
function tfontmap.canupdate:boolean;
begin
try;result:=(0<>comparetext(ilast.name,ifont.name)) or (ilast.height<>ifont.height) or (ilast.style<>ifont.style);except;end;
end;
//## update ##
function tfontmap.update:boolean;
var
   a:tsize;
   b:tbitmap;
   miw,mih,maxw,maxh:word;
   p:integer;
   _avew,_aveh:single;
begin
try
//defaults
result:=false;
b:=nil;
//check
if canupdate then
   begin
   //.inc id
   general.incint(iid);
   //.update last
   with ilast do
   begin
   name:=ifont.name;
   height:=ifont.height;
   style:=ifont.style;
   end;//end of with
   end
else exit;//no changes
//defaults
b:=tbitmap.create;
b.canvas.font.assign(ifont);
miw:=maxword;
mih:=maxword;
maxw:=0;
maxh:=0;
_avew:=0;
_aveh:=0;
//process
for p:=0 to 255 do
begin
//.get
a:=b.canvas.textextent(char(p));
//.range
a.cx:=word(a.cx);
a.cy:=word(a.cy);
//.set
iw[p]:=word(a.cx);
ih[p]:=word(a.cy);
//.min
if (a.cx<miw) then miw:=a.cx;
if (a.cy<mih) then mih:=a.cy;
//.max
if (a.cx>maxw) then maxw:=a.cx;
if (a.cy>maxh) then maxh:=a.cy;
//.ave
if (_avew=0) then _avew:=a.cx else _avew:=((_avew+a.cx)/2);
if (_aveh=0) then _aveh:=a.cy else _aveh:=((_aveh+a.cy)/2);
end;//end of loop
//.set - max
iminw:=frcmin(miw,1);
iminh:=frcmin(mih,1);
imaxw:=frcmin(maxw,1);
imaxh:=frcmin(maxh,1);
iavew:=frcrange(round(_avew),iminw,imaxw);
iaveh:=frcrange(round(_aveh),iminh,imaxh);
except;end;
try;result:=true;freeobj(@b);except;end;
end;

//## tdraws ####################################################################
//## numberspace ##
function tdraws.numberspace(normal:boolean;count:integer):integer;
var
   a:pvirtualinfo;
begin
try
//defaults
result:=0;
//setup
if normal then a:=@viNormal else a:=@viTitle;
//process
result:=(length(inttostr(count))+2)*a^.fontmap.textwidthc('9');
except;end;
end;
//## drawitem ##
procedure tdraws.drawitem(control:tvirtualcontrol;canvas:tcanvas;index:integer;area:trect;state:tvirtualdrawstate;ontext:tvirtualtextevent;onimage:tvirtualimageevent);
const
   startx=2;
var
   v:tstringlist;
   a:talignment;
   tmpv,ow,tw,count,cw,p,bc,tc,left,right,lastright,mx,ox,x,y,th:integer;
   ib:word;
   tmp2,tmp:string;
   vb:tvirtualbitmap;//pointer only
   f:tpixelfilter;
   _oAllowblack:boolean;
begin
try
//check
if (control=nil) or (canvas=nil) then exit;
//defaults
_oAllowblack:=false;
tmp:='';
v:=nil;
vb:=nil;
ow:=0;
ox:=area.left+startx;
y:=area.top;
ib:=0;//indent by
f:=nil;
//type
if (control is tvirtualrows) then
   begin
   //.info
   cw:=control.clientwidth;
   y:=area.top+(((area.bottom-area.top)-canvas.textheight('#')) div 2);
   count:=(control as tvirtualrows).items.count;
   //.text
   if assigned(ontext) then ontext(control,canvas,index,tmp)
   else tmp:=(control as tvirtualrows).items.strings[index];
   //.image
   _oAllowblack:=control.oAllowblack;
   if assigned(onimage) then onimage(control,index,vb);
   end
else if (control is tvirtualbaselist) then
   begin
   //.info
   cw:=area.right;
   y:=area.top+(((area.bottom-area.top)-canvas.textheight('#')) div 2);
   count:=(control as tvirtualbaselist).count;
   //.text
   if assigned(ontext) then ontext(control,canvas,index,tmp)
   else tmp:=(control as tvirtualbaselist).items[index];
   //.oAsname - 16-DEC-2006
   if (control as tvirtualbaselist).oasname then tmp:=general.asname(tmp);
   //.oIndent - 18-DEC-2006
   if (control as tvirtualbaselist).oIndent then ib:=(control as tvirtualbaselist).indents[index];
   //.image
   _oAllowblack:=control.oAllowblack;
   if assigned(onimage) then onimage(control,index,vb);
   end
else exit;
//process
//.color
if (vdsSelected in state) then
   begin
   bc:=control.info^.highlight;
   tc:=control.info^.fonthighlight;
   if (index=((index div 2)*2)) then bc:=general.dc(bc,10);
   end
else if (index=((index div 2)*2)) then
   begin
   bc:=canvas.brush.color;
   tc:=canvas.font.color;
   end
else
   begin
   bc:=general.dc(general.aorb(control.info^.disable,control.info^.background,control.enabled),10);
   tc:=canvas.font.color;
   end;//end of if
//.set
if (canvas.brush.color<>bc) then canvas.brush.color:=bc;
if (canvas.font.color<>tc) then canvas.font.color:=tc;
//.cls
canvas.fillrect(area);
canvas.brush.style:=bsClear;
//.ib
if (ib<>0) then inc(ox,ib);
//.image
if (vb<>nil) then
   begin
   //..f
   if (not control.enabled) or (vdsGrayed in state) or (vdsDisabled in state) then f:=plfDisabled
   else if (vdsSelected in state) then f:=plfFocused
   else f:=nil;
   //..transparent
   case _oAllowblack of
   false:vb.setfilters(f,plsReplace,vb.pixels[0,0],bc,0,tc);
   true:vb.setfilters(f,plsReplace,vb.pixels[0,0],bc,clNone,clNone);
   end;//end of case
   //..get
   vb.lock;
   vb.pullall(false,false);
   //..draw
   canvas.draw(ox,area.top+(((area.bottom-area.top)-vb.height) div 2),vb.buffer);
   vb.unlock;
   //..inc
   ow:=vb.width+5;
   inc(ox,ow);
   end;//end of if
//.number
if control.oNumbered then
   begin
   //..draw
   tmp2:=general.thousands(index+1)+'.';
   canvas.textout(ox,y,tmp2);
   tmpv:=numberspace(control.normal,count);
   inc(ox,tmpv);
   inc(ow,tmpv);
   end;//end of if
//.draw
if (control.tabcount=0) then canvas.textout(ox,y,tmp)
else
   begin
   //.filter
   general.swapchars(tmp,#9,#10);
   v:=tstringlist.create;
   v.text:=tmp;
   //.set
   lastright:=low(integer);
   for p:=0 to (v.count-1) do
   begin
   //..get
   if not control.tabget(p+1,a,right) then right:=cw;
   if not control.tabget(p,a,left) then left:=cw;
   right:=frcmin(right-control.tabspace,left);
   if (p=0) then dec(right,ow);
   tw:=0;
   //..set
   if (right>left) then
      begin
      //.textwidth
      tw:=canvas.textwidth(v.strings[p]);
      //.draw
      x:=misc.alignmentcalc(a,left,tw,right);
      canvas.textrect(rect(ox+left,y,ox+right,area.bottom),ox+x,y,v.strings[p])
      end;//end of if
   //.last right
   lastright:=left+tw;
   //.reset
   if (p=0) then ox:=startx;
   end;//end of loop
   end;//end of if
except;end;
try;freeObj(@v);except;end;
end;
//## drawtabs ##
procedure tdraws.drawtabs(control:tvirtualcontrol;canvas:tcanvas;offx,offy:integer;var tmp:string);
const
   al:array[talignment] of word = (DT_LEFT, DT_RIGHT, DT_CENTER);
var
   v:tstringlist;
   a:talignment;
   count,tw,ch,cw,p,bc,tc,left,right,lastright,x,y,th:integer;
   r:trect;
begin
try
//defaults
v:=nil;
//check
if (control=nil) or (canvas=nil) then exit;
//type
cw:=control.clientwidth;
ch:=control.clientheight;
y:=(ch-canvas.textheight('#')) div 2;
//process
//.draw
if (control.tabcount=0) then
   begin
   r:=rect(offx,y,offx+cw,ch);
   drawtext(
    canvas.handle,
    pchar(tmp),
    length(tmp),
    r,
    dt_left or dt_singleline);
   end
else
   begin
   //.filter
   general.swapchars(tmp,#9,#10);
   v:=tstringlist.create;
   v.text:=tmp;
   //.set
   lastright:=low(integer);
   for p:=0 to (v.count-1) do
   begin
   //..get
   if not control.tabget(p+1,a,right) then right:=cw;
   if not control.tabget(p,a,left) then left:=cw;
   right:=frcmin(right-control.tabspace,left);
   tw:=0;
   //..set
   if (right>left) then
      begin
      //.textwidth
      tw:=canvas.textwidth(v.strings[p]);
      //.draw
      r:=rect(offx+left,y,offx+right,ch);
      drawtext(
       canvas.handle,
       pchar(v.strings[p]),
       length(v.strings[p]),
       r,
       al[a] or dt_singleline);
      end;//end of if
   //.last right
   lastright:=left+tw;
   end;//end of loop
   end;//end of if
except;end;
try;freeObj(@v);except;end;
end;

//## tmenus ####################################################################
//## create ##
constructor tmenus.create;
begin
//self
inherited;
//controls
ishowing:=tdynamicboolean.create;
ienabled:=tdynamicboolean.create;
iinuse:=tdynamicboolean.create;
icaption:=tdynamicstring.create;
itep:=tdynamicstring.create;
ishortcut:=tdynamicstring.create;
icode:=tdynamicinteger.create;
end;
//## destroy ##
destructor tmenus.destroy;
begin
try
//controls
freeobj(@iinuse);
freeobj(@ishowing);
freeobj(@ienabled);
freeobj(@icaption);
freeobj(@itep);
freeobj(@ishortcut);
freeobj(@icode);
//self
inherited;
except;end;
end;
//## findshortcut ##
function tmenus.findshortcut(_shortcut:string):integer;
var
   p:integer;
   notshowing,ctrl,alt:boolean;
begin
try
//defaults
result:=0;
//setup
ctrl:=(0=comparetext(copy(_shortcut,1,5),'CTRL+'));
alt:=(0=comparetext(copy(_shortcut,1,4),'ALT+'));
notshowing:=ctrl or alt;
//process
//.find
for p:=1 to (iinuse.count-1) do if
   iinuse.items[p] and ienabled.items[p] and (notshowing or ishowing.items[p]) and
   (ishortcut.items[p]^<>'') and (0=comparetext(ishortcut.items[p]^,_shortcut)) then
   begin
   result:=p;
   break;
   end;//end of if
except;end;
end;
//## newindex ##
function tmenus.newindex:integer;
var
   p:integer;
begin
try
//defaults
result:=0;
//process
//.get
for p:=1 to (iinuse.count-1) do if not iinuse.items[p] then
   begin
   result:=p;
   break;
   end;//end of if
//.inc
if (result=0) then
   begin
   //..get
   result:=frcmin(iinuse.count,1);
   p:=result+1;
   //..set
   iinuse.setparams(p,p,0);
   ishowing.setparams(p,p,0);
   ienabled.setparams(p,p,0);
   icaption.setparams(p,p,0);
   itep.setparams(p,p,0);
   ishortcut.setparams(p,p,0);
   icode.setparams(p,p,0);
   end;//end of if
except;end;
end;
//## addsep ##
function tmenus.addsep(_menu:pstring):integer;
begin
try;result:=additem(_menu,'-','','',0,false);except;end;
end;
//## additem ##
function tmenus.additem(_menu:pstring;_caption,_tep,_shortcut:string;_code:integer;_enabled:boolean):integer;
var
   p:integer;
begin
try
//defaults
result:=0;
//process
//.new
p:=newindex;
if (p=0) then exit;
//.set
icaption.items[p]^:=_caption;
if ccs.isgraphic(_tep) then itep.items[p]^:=_tep else itep.items[p]^:='';
ienabled.items[p]:=_enabled;
ishortcut.items[p]^:=uppercase(_shortcut);
icode.items[p]:=_code;
iinuse.items[p]:=true;
//.menu
if (_menu<>nil) and (p<>0) then
   begin
   //..head
   if not ismenu(_menu) then newmenu(_menu);
   //..item pointer
   _menu^:=_menu^+from32bit(p);
   end;//end of if
//return result
result:=p;
except;end;
end;
//## delitem ##
function tmenus.delitem(x:integer):boolean;
begin
try
//defaults
result:=false;
//process
if valid(x) then
   begin
   //reset
   icaption.items[x]^:='';
   itep.items[x]^:='';
   ienabled.items[x]:=false;
   ishortcut.items[x]^:='';
   icode.items[x]:=0;
   iinuse.items[x]:=false;
   //successful
   result:=true;
   end;//end of if
except;end;
end;
//## ismenu ##
function tmenus.ismenu(_menu:pstring):boolean;
begin
try;result:=(_menu<>nil) and (0=comparetext(copy(_menu^,1,4),'MENU'));except;end;
end;
//## newmenu ##
function tmenus.newmenu(_menu:pstring):boolean;
begin
try
//defaults
result:=false;
//check
if ismenu(_menu) then
   begin
   result:=true;
   exit;
   end;//end of if
if (_menu=nil) then exit;
//set
_menu^:='MENU';
result:=true;
except;end;
end;
//## delmenu ##
function tmenus.delmenu(_menu:pstring):boolean;
var
   xlen,p,i:integer;
begin
try
//defaults
result:=false;
//check
if not ismenu(_menu) then
   begin
   result:=false;
   exit;
   end;//end of if
//setup
xlen:=length(_menu^) div 4;
//process - skip first block = "MENU"
for p:=2 to xlen do
begin
//.get
i:=to32bit(copy(_menu^,p*4-3,4));
//.del
if delitem(i) then result:=true;
end;//end of loop
//.reset
_menu^:='';
except;end;
end;
//## safeAKEY ##
function tmenus.safeAKEY(x:string):char;
begin
try
//range
if (x='') then x:=#0;
//range
if (x[1]>='a') and (x[1]<='z') then x[1]:=char(byte(x[1])-32);
//return result
result:=x[1];
except;end;
end;
//## extractAKEY ##
function tmenus.extractAKEY(x:string):char;
var
   p,xlen:integer;
   ok:boolean;
begin
try
//defaults
result:=#0;//non
xlen:=length(x);
ok:=false;
//check
if (xlen=0) then exit;
//process
for p:=1 to xlen do
 if (not ok) and (x[p]='&') then ok:=true
 else if ok and (x[p]<>'&') then
   begin
   result:=safeAKEY(x[p]);
   break;
   end;//end of if
except;end;
end;
//## readmenu ##
function tmenus.readmenu(_gui:tvirtualform;_menu:pstring):boolean;
const
   sp=5;
var
   a:tvirtualmenuitem;
   scLEN,w,h,z,imgw,captionw,shortcutw,i,p,xlen:integer;
   sc,_tabs:string;
begin
try
//defaults
result:=false;
a:=nil;
imgw:=0;
captionw:=0;
shortcutw:=0;
_tabs:='';
//check
if (_gui=nil) or (not ismenu(_menu)) then exit;
//init
xlen:=length(_menu^) div 4;
//process
//CREATE
for p:=2 to xlen do
begin
//.find
i:=to32bit(copy(_menu^,p*4-3,4));
//.get
if valid(i) then
   begin
   //.separator
   if (icaption.items[i]^='-') then _gui.new('sep','','','',valTop,nil,nil)
   else
      begin
      //.short cut
      sc:=ishortcut.items[i]^;
      scLEN:=length(sc);
      if (scLEN=1) then sc:=uppercase(sc)
      else if (scLEN>=2) then sc:=uppercase(sc[1])+lowercase(copy(sc,2,scLEN-2))+uppercase(sc[scLEN]);
      //.button
      a:=_gui.new('menuitem',icaption.items[i]^+#9+sc,itep.items[i]^,'',valTop,nil,_gui._onpop) as tvirtualmenuitem;
      //.mode
      a.enabled:=ienabled.items[i];
      //.code
      a.tag:=i;//menu handle
      a.shortcut:=ishortcut.items[i]^;
      a.akey:=extractAKEY(icaption.items[i]^);
      //.style
      a.fBorder:=false;
      a.bordersize:=0;
      //.image width
      if a.haveimage and (a.image.pai.cellwidth>imgw) then imgw:=a.image.pai.cellwidth;
      //.caption width
      if (icaption.items[i]^<>'') then
         begin
         z:=viNormal.fontmap.textwidth(icaption.items[i]^);
         if (z>captionw) then captionw:=z;
         end;//end of if
      //.shortcut width
      if (sc<>'') then
         begin
         z:=viNormal.fontmap.textwidth(sc);
         if (z>shortcutw) then shortcutw:=z;
         end;//end of if
      end;//end of if
   end;//end of if
end;//end of loop
//SIZE - Note: tabs are automatically scaled with font so scale them down with "viTabRatio" so they are consistent with font
if (imgw>=1) then inc(imgw,5);//space of 5 pixel between image end and text begin - 08FEB2008
_tabs:='TABS:S1,L0,L'+inttostr(round((captionw)/viTabRatio));
for p:=0 to (_gui.root.controls.count-1) do if (_gui.root.controls.items[p] is tvirtualmenuitem) then
   begin
   with _gui.root.controls.items[p] as tvirtualmenuitem do
   begin
   tabs:=_tabs;
   offx:=imgw;
   end;//end of with
   end;//end of loop
//.auto-width/height
_gui.root.doalign;
if (_gui.root.bottommost<>nil) then
   begin
   //..width
   w:=(_gui.root.bordersize*2)+
   dwtbX+
   imgw+
   captionw+
   shortcutw+
   sp;
   //..height
   h:=(_gui.root.bordersize*2)+(_gui.root.bottommost.top+_gui.root.bottommost.height);
   _gui.setbounds(_gui.left,_gui.top,w,h);
   end;//end of if
except;end;
end;
//## finditem ##
function tmenus.finditem(_menu:pstring;_code:integer):integer;
var
   xlen,i,p:integer;
begin
try
//defaults
result:=0;
//check
if (not ismenu(_menu)) or (_code=0) then exit;
//init
xlen:=length(_menu^) div 4;
//process
//CREATE
for p:=2 to xlen do
begin
//.find
i:=to32bit(copy(_menu^,p*4-3,4));
//.get
if valid(i) and (icode.items[i]=_code) then
   begin
   result:=i;
   break;
   end;//end of if
end;//end of loop
except;end;
end;
//## setitemenabled ##
procedure tmenus.setitemenabled(_menu:pstring;_code:integer;_enabled:boolean);
begin
try;enabled[finditem(_menu,_code)]:=_enabled;except;end;
end;
//## getitemenabled ##
function tmenus.getitemenabled(_menu:pstring;_code:integer):boolean;
begin
try;result:=enabled[finditem(_menu,_code)];except;end;
end;
//## valid ##
function tmenus.valid(x:integer):boolean;
begin
try;result:=(x>=1) and (x<iinuse.count) and iinuse.items[x];except;end;
end;
//## getcaption ##
function tmenus.getcaption(x:integer):string;
begin
try;if valid(x) then result:=icaption.items[x]^ else result:='';except;end;
end;
//## gettep ##
function tmenus.gettep(x:integer):string;
begin
try;if valid(x) then result:=itep.items[x]^ else result:='';except;end;
end;
//## getenabled ##
function tmenus.getenabled(x:integer):boolean;
begin
try;if valid(x) then result:=ienabled.items[x] else result:=false;except;end;
end;
//## getcode ##
function tmenus.getcode(x:integer):integer;
begin
try;if valid(x) then result:=icode.items[x] else result:=0;except;end;
end;
//## getshowing ##
function tmenus.getshowing(x:integer):boolean;
begin
try;if valid(x) then result:=ishowing.items[x] else result:=false;except;end;
end;
//## getshortcut ##
function tmenus.getshortcut(x:integer):string;
begin
try;if valid(x) then result:=ishortcut.items[x]^ else result:='';except;end;
end;
//## setcaption ##
procedure tmenus.setcaption(x:integer;y:string);
begin
try;if valid(x) then icaption.items[x]^:=y;except;end;
end;
//## settep ##
procedure tmenus.settep(x:integer;y:string);
begin
try;if valid(x) then itep.items[x]^:=general.aorbstr('',y,ccs.isgraphic(y));except;end;
end;
//## setenabled ##
procedure tmenus.setenabled(x:integer;y:boolean);
begin
try;if valid(x) then ienabled.items[x]:=y;except;end;
end;
//## setshortcut ##
procedure tmenus.setshortcut(x:integer;y:string);
begin
try;if valid(x) then ishortcut.items[x]^:=uppercase(y);except;end;
end;
//## setcode ##
procedure tmenus.setcode(x:integer;y:integer);
begin
try;if valid(x) then icode.items[x]:=y;except;end;
end;

//## tvirtualmenuitem ##########################################################
//## create ##
constructor tvirtualmenuitem.create(_gui:tvirtualform);
begin
//self
inherited create(_gui);
//controls
iimage:=nil;
//other
buffer:=true;
fDown:=true;
icursor:=vcLink;
clickkey:=clkyDefault;
//help
help:=rthtranslate('Click option to perform action/task');
end;
//## destroy ##
destructor tvirtualmenuitem.destroy;
begin
try
//init
destroyinit;
//controls
freeobj(@iimage);
//self
inherited;
except;end;
end;
//## gethaveimage ##
function tvirtualmenuitem.gethaveimage:boolean;
begin
try;result:=(iimage<>nil);except;end;
end;
//## setanimation ##
procedure tvirtualmenuitem.setanimation(x:string);
begin
try;_setanimation(iimage,self,x);except;end;
end;
//## _onpaint ##
procedure tvirtualmenuitem._onpaint(sender:tobject;canvas:tcanvas);
var
   a:tsize;
   _offy,_offx,oxy,sp,dx,dy:integer;
   tmp:string;
   f:tpixelfilter;
begin
try
//calc
tmp:=vcaption;
a:=canvas.textextent(tmp);
oxy:=0;
if fDown and down then oxy:=2;
sp:=general.aorb(0,2,(a.cx<>0) or (a.cy<>0));
dx:=2;
_offx:=0;
_offy:=0;
//focus indicator - additional
if (not fBorder) and (not fBackground) then
   begin
   if focused or hovering then canvas.font.style:=canvas.font.style+[fsUnderline];
   end;//end of if
//cls
canvas.fillrect(clientrect);
//image - symbol!
if haveimage and (not iimage.empty) then
   begin
   //.filters
   statefilter(f);
   //..imagealign
   dy:=(clientheight-iimage.pai.cellheight) div 2;
   //..paint
   iimage.drawto(canvas,rect(dx+oxy,dy+oxy,iimage.pai.cellwidth,iimage.pai.cellheight),true,f,canvas.brush.color,general.aorb(canvas.font.color,clNone,oAllowBlack));
   //.inc
   inc(_offx,iimage.pai.cellwidth+5);
   end;//end of if
//text
dy:=(clientheight-viFontHeight) div 2;
canvas.brush.style:=bsClear;
//.draw
if (offx<>0) then _offx:=offx;//external override
inc(_offx,oxy);
inc(_offy,oxy);
draws.drawtabs(self,canvas,dwtbX+_offx,_offy,tmp);
except;end;
end;

//## tpop ######################################################################
//## create ##
constructor tpop.create(aowner:tcomponent);
begin
//self
inherited create(aowner);
//defaults
iroot.bordersize:=1;
head.visible:=false;
oResizeable:=false;//fixed size form
iminwidth:=viFontHeight+(2*iroot.bordersize);
iminheight:=viFontHeight+(2*iroot.bordersize);
setbounds(left,top,100,100);
mkEscape:=true;
mkReturn:=true;
end;
//## canpop ##
function tpop.canpop:boolean;
begin
try;result:=(not showingwait) and (not showingmodal) and (not showing);except;end;
end;
//## popcursor ##
function tpop.popcursor(_popuphost:tvirtualform):boolean;
var
   a:tpoint;
begin
try;getcursorpos(a);result:=pop(_popuphost,a.x,a.y,0);except;end;
end;
//## pop ##
function tpop.pop(_popuphost:tvirtualform;x,y,yh:integer):boolean;
begin
try;result:=popwh(_popuphost,x,y,yh,width,height);except;end;
end;
//## popwh ##
function tpop.popwh(_popuphost:tvirtualform;x,y,yh,w,h:integer):boolean;
begin
try
//defaults
result:=false;
//check
if not canpop then exit;
//defaults
w:=frcmin(w,16);
h:=frcmin(h,16);
//process
//..x
if (x<0) then x:=0
else if ((x+w)>screenwidth) then x:=screenwidth-w;
//..y
if (y<0) then y:=0
else if ((y+h)>screenheight) then
   begin
   if (yh>=1) then y:=frcmin(y-yh-h,0) else y:=screenheight-h;
   end;//end of if
//.set
setbounds(x,y,w,h);
//.show
popuphost:=_popuphost;
aKeys:=true;
//return result
result:=showwait;
except;end;
end;
//## _onpop ##
procedure tpop._onpop(sender:tobject);
begin
try
//.close
showclose(mrOK);
//.update system
application.processmessages;
//.event
if assigned(fonpop) then fonpop(self);
except;end;
end;

//## tpoplist ##################################################################
//## create ##
constructor tpoplist.create(aowner:tcomponent);
begin
//self
inherited create(aowner);
root.bordersize:=0;
//vars
oAutoliststyle:=true;
//controls
//.title
ititle:=new('titlesmall','','','',valTop,nil,nil) as tvirtualtitle;
iclose:=ititle.newlink(ntranslate('close'),'',rthtranslate('Close list'),__onclick);
//.ilist
ilist:=nil;
ilist:=new('list','','','',valTop,nil,nil) as tvirtuallist;
//defaults
itext:='';
ivalue:='';
ivalueindex:=0;
idropcount:=10;
end;
//## settep ##
procedure tpoplist.settep(x:string);
begin
try;ilist.tep:=x;except;end;
end;
//## gettep ##
function tpoplist.gettep:string;
begin
try;result:=ilist.tep;except;end;
end;
//## __onclick ##
procedure tpoplist.__onclick(sender:tobject);
begin
try
if (sender=iclose) then _onpop(nil)
else if (sender=ilist) then
   begin
   syncvalue;
   fireevent(onitemindex,self);
   end;//end of if
except;end;
end;
//## syncvalue ##
procedure tpoplist.syncvalue;
begin
try
if (ilist.itemindex>=0) then
   begin
   ivalue:=ilist.items[ilist.itemindex];
   ivalueindex:=ilist.itemindex;
   end;//end of if
except;end;
end;
//## popwh ##
function tpoplist.popwh(_popuphost:tvirtualform;x,y,yh,w,h:integer):boolean;
var
   oldp,p:integer;
begin
try
//defaults
result:=false;
//check
if not canpop then exit;
//init
ilist.onitemindex:=nil;
ilist.onitemhard:=nil;
ititle.visible:=(title<>'');
ititle.caption:=title;
iroot.bordersize:=general.insint(3,ititle.visible);
iclose.visible:=ititle.visible and oAutoliststyle;
//items
ilist.items.text:=itext;
p:=ilist.findvalue(ivalue);
if (p<0) then p:=ivalueindex;//25SEP2007
ilist.itemindex:=p;
ilist.topindex:=frcrange(p-(dropcount div 2)+1,0,ilist.count-1);
//options
ilist.oNumbered:=oNumbered;
ilist.tabs:=tabs;
//width & height
h:=general.insint(ititle.height,ititle.visible)+(2*(ilist.bordersize+root.bordersize))+(ilist.paintitemheight*frcmin(frcmax(idropcount,ilist.items.count),1));
//focus
focuscontrol:=ilist;
//events
ilist.onitemindex:=__onclick;//optional
if (not oAutoliststyle) or (not ititle.visible) then ilist.onitemhard:=_onpop;
//pop
result:=inherited popwh(_popuphost,x,y,yh,w,h);
if result and (ilist.itemindex>=0) then syncvalue;
except;end;
end;
//## _onpop ##
procedure tpoplist._onpop(sender:tobject);
begin//Event "fonpop" is not used
try
//.close
showclose(mrOK);
//.update system
application.processmessages;
except;end;
end;

//## tpopmenu ##################################################################
//## create ##
constructor tpopmenu.create(aowner:tcomponent);
begin
//self
inherited create(aowner);
//controls
menus.newmenu(@imenu);
//defaults
imenudel:=true;
ihandle:=0;//nil
icode:=0;//nil
mkEscape:=true;
mkReturn:=false;//return is reserved for clicking menu items
end;
//## destroy ##
destructor tpopmenu.destroy;
begin
try
//controls
if imenudel then menus.delmenu(ipmenu);
//self
inherited;
except;end;
end;
//## setmenu ##
procedure tpopmenu.setmenu(x:pstring);
begin
try
if (x=nil) then
   begin
   ipmenu:=@imenu;
   imenudel:=true;
   end
else
   begin
   ipmenu:=x;
   imenudel:=false;
   end;//end of if
except;end;
end;
//## addsep ##
function tpopmenu.addsep:integer;
begin
try;result:=menus.addsep(ipmenu);except;end;
end;
//## additem ##
function tpopmenu.additem(_caption,_tep,_shortcut:string;_code:integer;_enabled:boolean):integer;
begin
try;menus.additem(ipmenu,_caption,_tep,_shortcut,_code,_enabled);except;end;
end;
//## popcursor ##
function tpopmenu.popcursor(_popuphost:tvirtualform):integer;
var
   a:tpoint;
begin
try;getcursorpos(a);result:=pop(_popuphost,a.x,a.y,0);except;end;
end;
//## pop ##
function tpopmenu.pop(_popuphost:tvirtualform;x,y,yh:integer):integer;
begin
try
//defaults
result:=0;
ihandle:=0;//nil
icode:=0;//nil
aExtendedfocusshift:=true;
//menu
menus.readmenu(self,ipmenu);
//pop
if (inherited pop(_popuphost,x,y,yh)) then result:=icode;
//clean
clientclean;
except;end;
end;
//## _onpop ##
procedure tpopmenu._onpop(sender:tobject);
begin
try
//code
if (sender<>nil) and (sender is tvirtualcontrol) then
   begin
   ihandle:=(sender as tvirtualcontrol).tag;
   icode:=menus.code[ihandle];
   end
else
   begin
   ihandle:=0;//nil;
   icode:=0;//nil
   end;//end of if
//.close
showclose(mrOK);
//.update system
application.processmessages;
except;end;
end;

//## tvirtualcontrols ##########################################################
//## _init ##
procedure tvirtualcontrols._init;
begin
try
_setparams(0,0,4,false);
ilockedBPI:=true;
except;end;
end;
//## _corehandle ##
procedure tvirtualcontrols._corehandle;
begin
iitems:=core;
end;
//## getvalue ##
function tvirtualcontrols.getvalue(_index:integer):tvirtualcontrol;
begin
//.check
if (_index<0) or (_index>=count) then result:=nil
else result:=items[_index];
end;
//## setvalue ##
procedure tvirtualcontrols.setvalue(_index:integer;_value:tvirtualcontrol);
begin
//.check
if (_index<0) then exit
else if (_index>=size) and (not atleast(_index)) then exit;
//.count
if (_index>=icount) then icount:=_index+1;
//.set
items[_index]:=_value;
end;
//## getsvalue ##
function tvirtualcontrols.getsvalue(_index:integer):tvirtualcontrol;
begin
result:=value[sindex(_index)];
end;
//## setsvalue ##
procedure tvirtualcontrols.setsvalue(_index:integer;_value:tvirtualcontrol);
begin
value[sindex(_index)]:=_value;
end;
//## find ##
function tvirtualcontrols.find(_start:integer;_value:tvirtualcontrol):integer;
var
   p:integer;
begin
try
//defaults
result:=-1;
//check
if (_start<0) or (_start>=count) then exit;
//process
for p:=_start to (icount-1) do if (iitems[p]=_value) then
    begin
    result:=p;
    break;
    end;//end of if
except;end;
end;
//## new ##
function tvirtualcontrols.new(obj:tvirtualcontrol):integer;
var
   c,p:integer;
begin
try
//defaults
result:=-1;
//check
if (obj=nil) then exit;
//process
p:=find(0,obj);
if (p=-1) then
   begin
   p:=find(0,nil);
   if (p=-1) then
      begin
      c:=count;
      setparams(c+1,c+1,0);
      p:=c;
      end;//end of if
   //.set
   items[p]:=obj;
   end;//end of if
//return result
result:=p;
except;end;
end;
//## freeValue ##
procedure tvirtualcontrols.freeValue(p:integer);
var
   a:tobject;
begin
try
if (p>=0) and (p<icount) then
   begin
   a:=value[p];
   if (a<>nil) then
      begin
      value[p]:=nil;
      freeobj(@a);
      end;//end of if
   end;//end of if
except;end;
end;
//## freeValues ##
procedure tvirtualcontrols.freeValues;
var
   p:integer;
begin
try;for p:=0 to (icount-1) do freeValue(p);except;end;
end;

//## tdlgform ##################################################################
//## create ##
constructor tdlgform.create(aowner:tcomponent);
begin
//self
inherited createnew(owner);
bordericons:=[biSystemMenu];
borderstyle:=bsSizeable;
keypreview:=true;
cursor:=crArrow;
//events
onkeydown:=_onkeydown;
end;
//## _onkeydown ##
procedure tdlgform._onkeydown(sender:tobject;var key:word;shift:tshiftstate);
begin
try;if (key=vk_escape) then modalresult:=mrCancel;except;end;
end;

//## tvirtualdlg ###############################################################
//## create ##
constructor tvirtualdlg.create(aowner:tcomponent);
begin
//self
inherited create(owner);
//vars
ivpad:=5;
iroot.bordersize:=4;
//controls
//.iclient
iclient:=new('page','','','',valNone,nil,nil) as tvirtualpage;
iclient.bordersize:=0;
iclient.oHeight:=vhsHeight;
iclient.oAllowvariableheights:=true;
ihost:=iclient;
//.ipanel
ipanel:=new('page','','','',valNone,nil,nil) as tvirtualpage;
ipanel.bordersize:=0;
ipanel.oHeight:=vhsClient;//for resize/repaint simplicity
//defaults
caption:='';
mkEscape:=true;
mkReturn:=true;
aKeys:=true;
dialog:=true;
//events
root.onresize:=__onresize;
end;
//## scroll ##
procedure tvirtualdlg.scroll;
begin
try
//check
if (iclient2<>nil) then exit;
//get
iclient2:=iclient.new('pagescroll','','','',valTop,nil) as tvirtualpagescroll;
ihost:=iclient2.client;
except;end;
end;
//## newbutton ##
function tvirtualdlg.newbutton(_caption,_tep:string;_reply:tmodalresult):tvirtualbutton;
begin
try
//defaults
result:=nil;
//check
if ishowingmodal then exit;
//process
result:=ipanel.new('button',_caption,_tep,'',valRight,nil) as tvirtualbutton;
result.oModalresult:=_reply;
result.alignsep:=5;
except;end;
end;
//## newtext ##
function tvirtualdlg.newtext(_caption,_text:string;_wordwrap:boolean):tvirtualbasetext;
begin
try
//defaults
result:=nil;
//check
if ishowingmodal then exit;
//process
result:=ihost.new('text'+general.insstr('wrap',_wordwrap),_caption,'','',valTop,nil) as tvirtualbasetext;
result.text:=_text;
result.height:=viFontHeight*8;
except;end;
end;
//## newlabel ##
function tvirtualdlg.newlabel(_caption,_tep:string):tvirtuallabel;
begin
try;if ishowingmodal then result:=nil else result:=ihost.new('label',_caption,_tep,'',valTop,nil) as tvirtuallabel;except;end;
end;
//## newtick ##
function tvirtualdlg.newtick(_caption,_tep:string):tvirtualtick;
begin
try;if ishowingmodal then result:=nil else result:=ihost.new('tick',_caption,_tep,'',valTop,nil) as tvirtualtick;except;end;
end;
//## newedit ##
function tvirtualdlg.newedit(_caption,_text:string):tvirtualedit;
begin
try
//defaults
result:=nil;
//check
if ishowingmodal then exit;
//process
result:=ihost.new('edit',_caption,'','',valTop,nil) as tvirtualedit;
result.text:=_text;
except;end;
end;
//## newdroplist ##
function tvirtualdlg.newdroplist(_caption,_text,_list,_listtep:string):tvirtualdroplist;
begin
try
//defaults
result:=nil;
//check
if ishowingmodal then exit;
//process
result:=ihost.new('droplist',_caption,_list,'',valTop,nil) as tvirtualdroplist;
result.value:=_text;
result.tep:=_listtep;
except;end;
end;
//## newpassword ##
function tvirtualdlg.newpassword(_caption,_text:string):tvirtualbasetext;
begin
try
//defaults
result:=nil;
//check
if ishowingmodal then exit;
//process
result:=ihost.new('password',_caption,'','',valTop,nil) as tvirtualbasetext;
result.text:=_text;
except;end;
end;
//## newlist ##
function tvirtualdlg.newlist(_caption,_text:string):tvirtualbaselist;
begin
try
//defaults
result:=nil;
//check
if ishowingmodal then exit;
//process
result:=ihost.new('list',_caption,'','',valTop,nil) as tvirtualbaselist;
result.text:=_text;
result.oHeight:=vhsHeight;
result.height:=viFontHeight*8;
except;end;
end;
//## __onresize ##
procedure tvirtualdlg.__onresize(sender:tobject);
var
   w,ph:integer;
begin
try
//get
ph:=ipanel.getalignheight;
w:=width-2*root.bordersize;//root.clientwidth is not yet
//toolbar
ipanel.setboundsb(0,root.clientheight-ph,w,ph);
//client
iclient.setboundsb(0,head.height,w,frcmin(root.clientheight-ph-ivpad-head.height,0));
except;end;
end;
//## _getautoheight ##
function tvirtualdlg._autoheight:integer;
var
   ch,w,h:integer;
begin
try
//calc
iclient.oAllowvariableheights:=false;
//.w - calc min. width required to display all buttons
ipanel.width:=screen.width;
ipanel.doalign;
ipanel._vhsControls;
w:=0;
if (ipanel.bottommost<>nil) then
   begin
   case ipanel.bottommost.align of
   valRight:w:=screen.width-ipanel.bottommost.left;
   valLeft:w:=ipanel.bottommost.left+ipanel.bottommost.width;
   end;//end of case
   inc(w,2*root.bordersize);
   //allow a safety margin
   inc(w,viNormal.fontmap.maxW*8);
   end;//end of if
//.ch
case (iclient2=nil) of
true:ch:=iclient._vhsControls;
false:ch:=iclient2.client._vhsControls;
end;//end of case
//.h
h:=
 (2*root.bordersize)+
 (2*head.bordersize)+
 head.getalignheight+
 ch+
 ivpad+
 ipanel.getalignheight;
iclient.oAllowvariableheights:=true;
//set
width:=frcmin(frcmin(width,w),450);//minimum overal width of 450 pixels
height:=h;
__onresize(self);
except;end;
end;
//## showmodal ##
function tvirtualdlg.showmodal:tmodalresult;
begin
try
//auto height
_autoheight;
//center
general.centerbyapp(self,width,height,false);
//return result
result:=inherited showmodal;
except;end;
end;
//## showwait ##
function tvirtualdlg.showwait:boolean;
var
   x,y:integer;
begin
try
//auto height
_autoheight;
//center
general.centerbyapp(self,width,height,false);
//return result
result:=inherited showwait;
except;end;
end;

//## tvirtualform ##############################################################
//## create ##
constructor tvirtualform.create(aowner:tcomponent);
begin
//self
createnew(aowner);
controlstyle:=[csCaptureMouse,csClickEvents];
//vars
ilastvisible:=visible;
ipaintxy:=point(0,0);
ipaintrgn:=nullregion;
paintallowed:=true;
iempty:=true;
mt.slowon(islowref);
itmpxy:=point(-1,-1);
safearea:=true;//form must be within visible area of current screen
iwindowstate:=wsNormal;
imaxtime:=ms64;
itimepaint:=imaxtime;
isafetime:=imaxtime;
ifocuscontrol:=nil;
ihovercontrol:=nil;
keypreview:=true;
tabstop:=true;
oResizeable:=true;
//controls
//.iform
if (aowner is twincontrol) then parent:=aowner as twincontrol;
bordericons:=[];
borderstyle:=bsNone;
vertscrollbar.visible:=false;
horzscrollbar.visible:=false;
caption:='';
hint:='';
showHint:=false;
align:=alClient;
//.iroot
iroot:=tvirtualpage.create(self);//destroys it's own children. Note: destroy's igui.head last
with iroot do
begin
enabled:=true;
visible:=true;
bordersize:=5;
hold:=false;
end;//end of with
//.head
head:=new('head',ProgramnameHARD,'','',valTop,nil,nil) as tvirtualhead;
//.min dimensions
iminspace:=50;
iminwidth:=170;
iminheight:=head.height+2*iroot.bordersize;
inormalrect:=rect(left,top,left+width,top+height);
//events
//.self
onpaint:=_onpaint;
onresize:=_onresize;
onmousedown:=_onmousedown;
onmousemove:=_onmousemove;
onmouseup:=_onmouseup;
onkeydown:=_onkeydown;
onkeypress:=_onkeypress;
onkeyup:=_onkeyup;
//.iroot
iroot.onpaintborder:=_onpaintborder;
//defaults
head.syncbuttons;
//.cursor
screencursor:=vcLink;
screencursor:=vcArrow;
//visible
if (parent<>nil) then visible:=true;
//timer
itimer:=mt.new(_ontimer,200,true);
end;
//## destroyinit ##
procedure tvirtualform.destroyinit;
begin
try
//check
if idestroying then exit;
//flag
idestroying:=true;
//states
lockalign:=true;
visible:=false;
parent:=nil;
//timer
mt.del(itimer);
//onresize
if (parent<>nil) and (parent is tform) then (parent as tform).onresize:=nil;
except;end;
end;
//## destroy ##
destructor tvirtualform.destroy;
begin
try
//init
destroyinit;
//controls
freeobj(@iroot);//self + children
//self
inherited;
except;end;
end;
//## getpainting ##
function tvirtualform.getpainting:boolean;
begin
try;result:=(ipaintcount<>0);except;end;
end;
//## wmsyscommand ##
procedure tvirtualform.wmsyscommand(var Message: TWmSysCommand);
begin
try
case (Message.CmdType and $FFF0) of
SC_MINIMIZE:begin
   ShowWindow(Handle, SW_MINIMIZE);
   Message.Result := 0;
   end;
SC_RESTORE:begin
   ShowWindow(Handle, SW_RESTORE);
   Message.Result := 0;
   end;
else inherited;
end;//end of case
_paintallowed;//yyyyyyyyyyyyyyyyyy
except;end;
end;
{
//## createwindowhandle ##
procedure tvirtualform.createwindowhandle(const params:tcreateparams);
begin
try
if (tvirtualformclass.hinstance=0) then tvirtualformclass.hinstance:=hinstance;
//yyyyyyyyyyyyyyyyyywith params do windowhandle:=createwindow(tvirtualformclass.lpszClassName,pchar(caption),tvirtualformclass.style,x,y,width,height,wndparent,0,tvirtualformclass.hinstance,param);
with params do windowhandle:=createwindow(tvirtualformclass.lpszClassName,pchar(caption),tvirtualformclass.style,x,y,width,height,0,0,tvirtualformclass.hinstance,param);
except;end;
end;
{}//yyyyyyyyyyyyyyyyyy
//## setminwidth ##
procedure tvirtualform.setminwidth(x:integer);
begin
try;iminwidth:=frcmin(x,0);except;end;
end;
//## setminheight ##
procedure tvirtualform.setminheight(x:integer);
begin
try;iminheight:=frcmin(x,0);except;end;
end;
//## setminspace ##
procedure tvirtualform.setminspace(x:integer);
begin
try;iminspace:=frcmin(x,0);except;end;
end;
//## displayhint ##
procedure tvirtualform.displayhint(x:tvirtualcontrol);
var
   t:integer;
   z:string;
begin
try
//check
if (x=ilasthint) then exit;
ilasthint:=x;
//process
//.get
if (x<>nil) and x.visible then
   begin
   z:=x.hint;
   t:=x.hinttime;
   end
else
   begin
   z:='';
   t:=3000;
   end;//end of if
//.set
if (hint<>z) then
   begin
   application.cancelhint;
   hint:=z;
   showhint:=(z<>'');
   application.hinthidepause:=t;
   end;//end of if
except;end;
end;
//## _oic ##
procedure tvirtualform._oic(sender:tobject);//on internal click - system only
begin
try
//check
if (sender=nil) or (not (sender is tvirtualcontrol)) then exit;
doaction((sender as tvirtualcontrol).tag);
except;end;
end;
//## doaction ##
procedure tvirtualform.doaction(c:integer);
var
   w,h:integer;
   e:string;
begin
try
//process
case c of
smcHelp:pg.showhelp(false);
smcPlainTextHelp:pg.showhelp(true);
smcAbout:splash.about;
smcUnlock:;//yyyyyyyyyyyyyy
smcExtractSupportFiles:pg.usprompt(true);
smcCategory:showcategory;
smcSystemFolder:showsystem;
smcProgramSite:Programsite;
smcRawGruntSite:rawgruntsite;
smcFreeSite:freesite;
smcBlaizSite:blaizsite;
smcBlaizFiles:blaizfiles;
smcCenterWindow:if (windowstate=wsNormal) then general.center(self,width,height,false);
smcRawGruntAddUrl:rawgruntaddurl;
smcBlaizContact:blaizcontact;
smcNewInstance:run(application.exename,'');
smcClose:if (sysstate=ssOK) and appprompt then siClose;
smcClone:pg.clone;
smcMINSIZE..smcMAXSIZE:if (windowstate=wsNormal) then
   begin
   w:=width;
   h:=height;
   case c of
   smcEnlarge:begin
      inc(w,50);
      inc(h,50);
      end;//end of begin
   smcShrink:begin
      dec(w,50);
      dec(h,50);
      end;//end of begin
   end;//end of case
   if (w<>width) or (h<>height) then setbounds(left,top,w,h);
   end;//end of if
end;//end of case
except;end;
end;
//## setlockalign ##
procedure tvirtualform.setlockalign(x:boolean);
begin
try;if general.setbol(x,ilockalign) and (not x) then iroot.realign(false);except;end;
end;
//## clientclean ##
procedure tvirtualform.clientclean;
begin
try;iroot.controls.delall(head);except;end;
end;
//## asshortcut ##
function tvirtualform.asshortcut(k:byte):string;
begin
try
//defaults
result:='';
//check
if (k=0) then exit;
//process
//.ctrl - 1=A, 2=B, 3=C
if ictrl and (not ialt) then
   begin
   case k of
   1..26:result:='CTRL+'+char(64+k);//CTRL+A..Z
   end;//end of case
   end
else if (not ictrl) and ialt then
   begin
   case k of
   48..57,65..90:result:='ALT+'+char(k);//ALT+A..Z, ALT+0..9
   end;//end of case
   end
else if (not ictrl) and (not ialt) then
   begin
   case k of
   48..57,65..90:result:=char(k);//A..Z, 0..9
   end;//end of case
   end;//end of if
except;end;
end;
//## wmgetdlgcode ##
procedure tvirtualform.wmgetdlgcode(var Message: TWMGetDlgCode);
begin//Allow tab key to be passed onto "onkeydown/onkeypress"
try;message.result:=message.result or DLGC_WANTTAB;except;end;
end;
//## syncmaximized ##
procedure tvirtualform.syncmaximized;
var
   tmp:trect;
begin
try
if (not idestroying) and (windowstate=wsMaximized) then
   begin
   systemparametersinfo(SPI_GETWORKAREA,0,@tmp,0);
   //check
   if (tmp.left<>left) or (tmp.top<>top) or (tmp.right<>(left+width)) or (tmp.bottom<>(top+height)) then
      begin
      setbounds(tmp.left,tmp.top,tmp.right-tmp.left,tmp.bottom-tmp.top);
      end;//end of if
   end;//end of if
except;end;
end;
//## setwindowstate ##
procedure tvirtualform.setwindowstate(x:twindowstate);
var
   tmp:trect;
begin
try
//check
if (x=windowstate) or idestroying then exit;
//set
iwindowstate:=x;
//buttons
head.syncbuttons;
//size
if (x=wsMaximized) then
   begin
   inormalrect:=rect(left,top,left+width,top+height);
   syncmaximized;
   end
else if (x=wsNormal) then
   begin
   tmp:=inormalrect;
   setbounds(tmp.left,tmp.top,tmp.right-tmp.left,tmp.bottom-tmp.top);
   end
else inherited windowstate:=x;//end of if
except;end;
end;
//## getwindowstate ##
function tvirtualform.getwindowstate:twindowstate;
begin
try
//get
result:=inherited windowstate;
//override
if (result<>wsMinimized) then result:=iwindowstate;
except;end;
end;
//## _onpaintborder ##
procedure tvirtualform._onpaintborder(sender:tobject;canvas:tcanvas);
var
   a:trect;
   c,bs,maxp,p:integer;
begin
try
//process
//.get
a:=iroot.area;
c:=canvas.pen.color;
if (not viBorder) then c:=iroot.info^.border;
if isizing or imoving then c:=iroot.info^.highlight;//03OCT2007
bs:=iroot.bordersize;
//.set
for p:=1 to bs do
begin
canvas.brush.color:=general.dc(c,(p-1)*5);
if (p<bs) then canvas.framerect(ccs.rectgrow(a,1-p))
else canvas.fillrect(ccs.rectgrow(a,1-p));
end;//end of if
except;end;
end;
//## wndproc ##
procedure tvirtualform.wndproc(var message:tmessage);
var
   a:prect;
   tmp:trect;
begin
try
//process
//.close
if (fmt<>nil) then
   begin
   if (message.msg=wm_close) then
      begin
      if (sysstate=ssOK) and appprompt then siClose;
      message.result:=0;//OK
      exit;
      end
   else if (message.msg=wm_queryendsession) then//Note: this message is not always called, system overrides can bypass this and skip straight to "wm_endsession"
      begin
      message.result:=integer(appprompt);
      if twmendsession(message).endsession then siClose;
      exit;
      end
   else if (message.msg=wm_endsession) then//called if "wm_queryendsession=true"
      begin
      if twmendsession(message).endsession then siClose;
      message.result:=0;//OK
      exit;
      end;//end of if
   end;//end of if
//.self
inherited wndproc(message);
//.check
if idestroying then exit;
//MESSAGES
case message.msg of
//.dimensions of window range
WM_SIZING:begin
   a:=prect(message.lparam);
   tmp:=a^;
   //..decide
   case message.wparam of
   //..CORNERS
   wmsz_topleft:begin
      if (a^.left>(a^.right-iminwidth)) then a^.left:=a^.right-iminwidth;
      if (a^.top>(a^.bottom-iminheight)) then a^.top:=a^.bottom-iminheight;
      end;//end of begin
   wmsz_topright:begin
      if (a^.right<(a^.left+iminwidth)) then a^.right:=a^.left+iminwidth;
      if (a^.top>(a^.bottom-iminheight)) then a^.top:=a^.bottom-iminheight;
      end;//end of begin
   wmsz_bottomleft:begin
      if (a^.left>(a^.right-iminwidth)) then a^.left:=a^.right-iminwidth;
      if (a^.bottom<(a^.top+iminheight)) then a^.bottom:=a^.top+iminheight;
      end;//end of begin
   wmsz_bottomright:begin
      if (a^.right<(a^.left+iminwidth)) then a^.right:=a^.left+iminwidth;
      if (a^.bottom<(a^.top+iminheight)) then a^.bottom:=a^.top+iminheight;
      end;//end of begin
   //..EDGES
   wmsz_left:if (a^.left>(a^.right-iminwidth)) then a^.left:=a^.right-iminwidth;
   wmsz_right:if (a^.right<(a^.left+iminwidth)) then a^.right:=a^.left+iminwidth;
   wmsz_top:if (a^.top>(a^.bottom-iminheight)) then a^.top:=a^.bottom-iminheight;
   wmsz_bottom:if (a^.bottom<(a^.top+iminheight)) then a^.bottom:=a^.top+iminheight;
   end;//end of case
   //..set
   if not equalrect(a^,tmp) then message.result:=1;
   end;//end of begin
end;//end of case
except;end;
end;
//## setcaption ##
procedure tvirtualform.setcaption(x:string);
begin
try;if (not idestroying) and (head<>nil) and (x<>head.caption) then head.caption:=x;except;end;
end;
//## getcaption ##
function tvirtualform.getcaption:string;
begin
try;if not idestroying then result:=head.caption else result:='';except;end;
end;
//## setbounds ##
procedure tvirtualform.setbounds(_left,_top,_width,_height:integer);
begin
try
//range
boundsfilter(_left,_top,_width,_height);
//set
inherited setbounds(_left,_top,_width,_height);
except;end;
end;
//## boundsfilter ##
function tvirtualform.boundsfilter(var _left,_top,_width,_height:integer):boolean;
var
   tmp:trect;
   _margin:integer;
begin
try
//defaults
result:=false;//no change
_margin:=iminspace;
//range
_width:=frcrange(_width,iminwidth,screen.width);
_height:=frcrange(_height,iminheight,screen.height);
//.calc
if viSafeArea and safearea then
   begin
   //.area
   if (windowstate=wsMaximized) then tmp:=screenarea
   else tmp:=workarea;
   //.left
   if ((_left+_width)<(tmp.left+_margin)) then
      begin
      _left:=tmp.left-_width+_margin;
      result:=true;
      end
   else if (_left>(tmp.right-_margin)) then
      begin
      _left:=tmp.right-_margin;
      result:=true;
      end;//end of if
   //.top
   if (_top<0) and head.visible then
      begin
      _top:=0;
      result:=true;
      end
   else if ((_top+_height)<(tmp.top+_margin)) then
      begin
      _top:=tmp.top-_height+_margin;
      result:=true;
      end
   else if (_top>(tmp.bottom-_margin)) then
      begin
      _top:=tmp.bottom-_margin;
      result:=true;
      end;//end of if
   end;//end of if
except;end;
end;
//## cancenter ##
function tvirtualform.cancenter:boolean;
begin
try;result:=(windowstate=wsNormal);except;end;
end;
//## center ##
procedure tvirtualform.center;
begin
try;if cancenter then general.center(self,width,height,false);except;end;
end;
//## canenlarge ##
function tvirtualform.canenlarge:boolean;
begin
try;result:=(windowstate=wsNormal);except;end;
end;
//## enlarge ##
procedure tvirtualform.enlarge(wBy,hBy:integer);
var
   w,h:integer;
begin
try
if canenlarge then
   begin
   //get
   w:=width+wBy;
   h:=height+hBy;
   //set
   if (w<>width) or (h<>height) then setbounds(left,top,w,h);
   end;//end of if
except;end;
end;
//## cansizeto ##
function tvirtualform.cansizeto(w,h:integer):boolean;
begin
try;result:=(windowstate=wsNormal) and ((w<>width) or (h<>height));except;end;
end;
//## sizeto ##
procedure tvirtualform.sizeto(w,h:integer);
begin
try;if cansizeto(w,h) then general.center(self,w,h,false);except;end;
end;
//## wmqueryendsession ##
procedure tvirtualform.wmqueryendsession(var Message:TWMQueryEndSession);
begin
try;message.result:=integer(closequery);except;end;//don't "callterminateprocs"
end;
//## newlink ##
function tvirtualform.newlink(_caption,_tep,_help:string;_onclick:tnotifyevent):tvirtuallink;
begin
try;result:=new('link',_caption,_tep,_help,valNone,nil,_onclick) as tvirtuallink;except;end;
end;
//## new ##
function tvirtualform.new(_type:string;_caption,_tep,_help:string;_align:tvirtualalign;_newparent:tvirtualcontrol;_onclick:tnotifyevent):tvirtualcontrol;
begin
try;result:=newb(_type,_caption,_tep,_help,_align,_newparent,_onclick,vsNil,sgsNil,'','');except;end;
end;
//## newb ##
function tvirtualform.newb(_type:string;_caption,_tep,_help:string;_align:tvirtualalign;_newparent:tvirtualcontrol;_onclick:tnotifyevent;_sysptr:integer;_style:tstoragestyle;_default,_range:string):tvirtualcontrol;
label
   skipend;
const
   sp=5;
var
   g:tvirtualgrid;
   ignorecaption:boolean;
   _min,_max,tmp:integer;
   tmpc:tvirtualcontrol;
begin
try
//defaults
result:=nil;
ignorecaption:=false;
//setup
_type:=uppercase(_type);
//process
//.label
if (_caption<>'') and
(
(_type='*') or//special external label
(_type='PAGEVSPLIT') or (_type='PAGEHSPLIT') or  (_type='PROGRESS') or (_type='CHART') or
(_type='PAGES') or (_type='PAGE') or (_type='PAGESSCROLL') or (_type='PATH') or (_type='FILE') or
(_type='PANEL') or (_type='ROWS') or (_type='GRID') or (_type='LIST') or (_type='LISTB') or
(_type='BASELIST') or (_type='DROPLIST') or (_type='DROPLISTSTATIC') or (_type='PASSWORD') or (_type='EDIT') or
(_type='TEXT') or (_type='TEXTWRAP') or (_type='CONTROL') or (_type='FONTS') or (_type='FONTSIZE') or (_type='CURSOR') or
(_type='CURSORS') or (_type='SCHEMES') or (_type='COLORS') or (_type='FLASH') or
(_type='SCROLLBAR') or (_type='ALERTAUDIO3') or (_type='GLYPH')
)  then
   begin
   result:=tvirtuallabelb.create(self);//no image support and compact
   (result as tvirtuallabelb).valignsep:=3;//top space
   //.parent
   if (_newparent=nil) then _newparent:=iroot;
   if (result.parent=nil) then result.parent:=_newparent;
   //.other
   with (result as tvirtualcontrol) do
   begin
   onclick:=nil;
   align:=_align;
   caption:=_caption;
   enabled:=true;
   hold:=false;
   visible:=true;
   //help
   help:=_help;
   end;//end of with
   end;//end of if
//.control
if (_type='*') then
   begin
   //nil - we only want the label (similar to "HIDDEN" but with a label)
   end
else if (_type='HEAD') then result:=tvirtualhead.create(self)
else if (_type='LABEL') or (_type='LABELSMALL') then
   begin
   if ccs.isgraphic(_tep) then
      begin
      result:=tvirtuallabel.create(self);
      (result as tvirtuallabel).animation:=_tep;
      end
   else result:=tvirtuallabelb.create(self);
   end
else if (_type='LABELLINK') then
   begin
   result:=tvirtuallink.create(self);
   result.oHeight:=vhsFont;//same as label
   end
else if (_type='TITLE') or (_type='TITLESMALL') then//height:=22+border
   begin
   if ccs.isgraphic(_tep) then
      begin
      result:=tvirtualtitle.create(self);
      (result as tvirtualtitle).animation:=_tep;
      end
   else result:=tvirtualtitleb.create(self);
   if (_type='TITLESMALL') then result.oHeight:=vhsClient;
   ilinkparent:=result as tvirtualtitle;
   end
else if (_type='TITLEGRID') then//height:=24 with leftpad grid - 30-NOV-2006
   begin
   result:=tvirtualgrid.create(self);
   with (result as tvirtualgrid) do
   begin
   normal:=false;
   space:=0;
   fDisable:=false;
   bordersize:=1;
   end;//end of with
   ilinkparent:=result as tvirtualgrid;
   end
else if (_type='BUTTON') then
   begin
   result:=tvirtualbutton.create(self);
   if (_tep<>'') then
      begin
      with (result as tvirtualbutton) do
      begin
      setanimation(_tep);
      padwidth:=6;
      end;//end of with
      end
   else
      begin
      with result as tvirtualbutton do
      begin
      imagealign:=valNone;
      padwidth:=20;
      end;//end of with
      end;//end of if
   end
else if (_type='TOOLBUT') then
   begin
   result:=tvirtualbutton.create(self);
   with (result as tvirtualbutton) do
   begin
   animation:=_tep;
   imagealign:=valTop;
   end;//end of with
   end
else if (_type='TICK') then result:=tvirtualtick.create(self)
else if (_type='PANEL') then
   begin
   result:=tvirtualpanel.create(self);
   _caption:='';//*
   end
else if (_type='FLASH') then
   begin
   result:=tvirtualflash.create(self);
   _caption:='';//*
   end
else if (_type='PROGRESS') then
   begin
   result:=tvirtualprogress.create(self);
   _caption:='';//*
   end
else if (_type='CHART') then
   begin
   result:=tvirtualchart.create(self);
   _caption:='';//*
   end
else if (_type='LINK') or (_type='LLINK') then
   begin
   if (ilinkparent<>nil) then
      begin                   
      result:=ilinkparent.newlink(_caption,_tep,_help,_onclick);
      goto skipend;
      end
   else
      begin
      result:=tvirtuallink.create(self);
      (result as tvirtuallink).setanimation(_tep);
      result.parent:=ilinkparent;
      if (ilinkparent<>nil) then result.normal:=ilinkparent.normal;
      end;//end of if
   //.left aligned link
   if (result<>nil) and (_type='LLINK') then result.align:=valLeft;
   end
else if (_type='GLYPH') then
   begin
   result:=tvirtualglyph.create(self);
   if (_tep<>'') then (result as tvirtualglyph).setanimation(_tep);
   if (ilinkparent<>nil) then
      begin
      result.parent:=ilinkparent;
      result.normal:=ilinkparent.normal;
      end;//end of if
   end
else if (_type='ROWS') then//with tabs
   begin
   result:=tvirtualrows.create(self);
   _caption:='';//*
   end
else if (_type='COLOR') then result:=tvirtualcolor.create(self)
else if (_type='COLORS') then
   begin
   new('titlesmall',ntranslate('standard colors'),'',rthtranslate('Customise set of display colors for standard controls'),valTop,_newparent,nil).valignsep:=5;
   g:=new('grid','','','',_align,_newparent,_onclick) as tvirtualgrid;
   result:=g;
   g.new('color',translate('Background'),'','',valLeft,nil).sysptr:=vsBackground;
   g.new('color',translate('Border'),'','',valLeft,nil).sysptr:=vsBorder;
   g.new('color',translate('Highlight'),'','',valLeft,nil).sysptr:=vsHighlight;
   g.new('color',translate('Hover'),'','',valLeft,nil).sysptr:=vsHover;
   g.new('color',translate('Font'),'','',valLeft,nil).sysptr:=vsFont;
   g.new('color',translate('Font Highlight'),'','',valLeft,nil).sysptr:=vsFontHighlight;
   g.new('color',translate('Font Disable'),'','',valLeft,nil).sysptr:=vsDisableFont;
   g.new('color',translate('Disable'),'','',valLeft,nil).sysptr:=vsDisable;
   g.new('color',translate('Disable Border'),'','',valLeft,nil).sysptr:=vsDisableBorder;

   new('titlesmall',ntranslate('title colors'),'',rthtranslate('Customise set of display colors for title (important) controls'),valTop,_newparent,nil).valignsep:=5;
   g:=new('grid','','','',_align,_newparent,_onclick) as tvirtualgrid;
   result:=g;
   g.new('color',translate('Background'),'','',valLeft,nil).sysptr:=vsTitleBackground;
   g.new('color',translate('Border'),'','',valLeft,nil).sysptr:=vsTitleBorder;
   g.new('color',translate('Highlight'),'','',valLeft,nil).sysptr:=vsTitleHighlight;
   g.new('color',translate('Hover'),'','',valLeft,nil).sysptr:=vsTitleHover;
   g.new('color',translate('Font'),'','',valLeft,nil).sysptr:=vsTitleFont;
   g.new('color',translate('Font Highlight'),'','',valLeft,nil).sysptr:=vsTitleFontHighlight;
   g.new('color',translate('Font Disable'),'','',valLeft,nil).sysptr:=vsTitleDisableFont;
   g.new('color',translate('Disable'),'','',valLeft,nil).sysptr:=vsTitleDisable;
   g.new('color',translate('Disable Border'),'','',valLeft,nil).sysptr:=vsTitleDisableBorder;

   _caption:='';//*
   end
else if (_type='SCROLLBAR') then
   begin
   result:=tvirtualscrollbar.create(self);//horizontal by default
   if (_range<>'') then
      begin
      vs.rangerefi(_range,_min,_max);
      with result as tvirtualscrollbar do
      begin
      min:=_min;
      max:=_max;
      end;//end of with
      end;//end of if
   end
else if (_type='PAGEVSPLIT') then
   begin
   result:=tvirtualpagevsplit.create(self);
   _caption:='';//*
   end
else if (_type='PAGEHSPLIT') then
   begin
   result:=tvirtualpagevsplit.create(self);
   (result as tvirtualpagevsplit).horizontal:=true;
   _caption:='';//*
   end
else if (_type='PAGE') then
   begin
   result:=tvirtualpage.create(self);
   _caption:='';//*
   end
else if (_type='PAGESCROLL') then
   begin
   result:=tvirtualpagescroll.create(self);
   _caption:='';//*
   end
else if (_type='PAGES') then
   begin
   result:=tvirtualpages.create(self);
   ilastpages:=result as tvirtualpages;
   _caption:='';//*
   end
else if (_type='PAGES_') then//_ underscore denotes special case, where no memory is kept
   begin
   result:=tvirtualpages.create(self);
   _caption:='';//*
   end
else if (_type='GRID') then
   begin
   result:=tvirtualgrid.create(self);
   _caption:='';//*
   end
else if (_type='LIST') then
   begin
   result:=tvirtuallist.create(self);
   if not result.istabs(_tep) then (result as tvirtuallist).text:=aslist(_tep);
   _caption:='';//*
   end
else if (_type='LISTB') then
   begin
   result:=tvirtuallist.create(self);
   (result as tvirtuallist).text:=aslist(_tep);
   with result as tvirtuallist do
   begin
   height:=(2*bordersize)+(count*itemheight);
   oVariableheight:=false;
   end;//end of with
   _caption:='';//*
   end
else if (_type='DROPLIST') then
   begin
   result:=tvirtualdroplist.create(self);
   (result as tvirtualdroplist).text:=aslist(_tep);
   _caption:='';//*
   end
else if (_type='DROPLISTSTATIC') then
   begin
   result:=tvirtualdropliststatic.create(self);
   (result as tvirtualdropliststatic).text:=aslist(_tep);
   (result as tvirtualdropliststatic).valignsep:=2;
   _caption:='';//*
   ignorecaption:=true;
   end
else if (_type='FONTS') then
   begin
   result:=tvirtualdroplist.create(self);
   fonts.style:=fnsBoth;
   (result as tvirtualdroplist).text:=fonts.text;
   _caption:='';//*
   end
else if (_type='FONTSIZE') then
   begin
   result:=tvirtualdroplist.create(self);
   (result as tvirtualdroplist).text:=general.swapcharsb('6,7,8,9,10,11,12,14,16,18,20,22,24,26,28,36,48,72',',',#10);
   _caption:='';//*
   end
else if (_type='BASELIST') then
   begin
   result:=tvirtualbaselist.create(self);
   _caption:='';//*
   end
else if (_type='PASSWORD') then
   begin
   result:=tvirtualpassword.create(self);
   _caption:='';//*
   end
else if (_type='EDIT') then
   begin
   result:=tvirtualedit.create(self);
   _caption:='';//*
   end
else if (_type='TEXT') then
   begin
   result:=tvirtualtext.create(self);
   (result as tvirtualtext).text:=_tep;
   _caption:='';//*
   end
else if (_type='TEXTWRAP') then
   begin
   result:=tvirtualtextwrap.create(self);
   (result as tvirtualtextwrap).text:=_tep;
   _caption:='';//*
   end
else if (_type='MENUITEM') then
   begin
   result:=tvirtualmenuitem.create(self);
   if ccs.isgraphic(_tep) then (result as tvirtualmenuitem).animation:=_tep;
   if result.istabs(_tep) then (result as tvirtualmenuitem).tabs:=_tep;
   end
else if (_type='SEP') then
   begin
   result:=tvirtualsep.create(self);
   _caption:='';//*
   end
else if (_type='CONTROL') then
   begin
   result:=tvirtualcontrol.create(self);
   _caption:='';//*
   end
else if (_type='CURSOR') then
   begin
   result:=tvirtualmousecursor.create(self);
   _caption:='';//*
   end
else if (_type='CURSORS') then
   begin
   new('titlesmall',ntranslate('cursors'),'',rthtranslate('Customisable cursor set'),valTop,_newparent,nil).valignsep:=5;
   g:=new('grid','','','',_align,_newparent,_onclick) as tvirtualgrid;
   result:=g;
   (g.new('cursor','','','',valLeft,nil) as tvirtualmousecursor).cursor:=vcArrow;
   g.new('cursor','','','',valLeft,nil).cursor:=vcLink;
   g.new('cursor','','','',valLeft,nil).cursor:=vcText;
   g.new('cursor','','','',valLeft,nil).cursor:=vcBusy;
   g.new('cursor','','','',valLeft,nil).cursor:=vcSize;
   _caption:='';//*
   end
else if (_type='SCHEMES') then
   begin
   result:=tvirtualschemes.create(self);
   _caption:='';//*
   end
else if (_type='ANIMATIONVIEWER') then
   begin
   result:=tvirtualanimationviewer.create(self,_caption);
   _caption:='';//*
   end
else if (_type='FILELIST') then
   begin
   result:=tvirtualfilelist.create(self,_caption,'');
   (result as tvirtualfilelist).tep:=_tep;
   _caption:='';//*
   end
else if (_type='CONTACTS') then
   begin
   result:=tvirtualcontacts.create(self,_caption);
   _caption:='';//*
   end
else if (_type='ALERTAUDIO3') then//3=sysptr+(3 variables)
   begin
   result:=tvirtualalertaudio.create(self,_sysptr,_tep);
   _caption:='';//*
   _sysptr:=vsNil;
   end
else if (_type='SYSINFO') then
   begin
   result:=tvirtualsysinfo.create(self);
   _caption:='';//*
   end
else if (copy(_type,1,3)='SB-') then
   begin
   result:=tvirtualsystembutton.create(self);
   with result as tvirtualsystembutton do
   begin
   animation:=_tep;
   imagealign:=valNone;
   alignsep:=5;
   padwidth:=6;
   if (_type='SB-APPLY') then option:=vsoApply
   else if (_type='SB-DEFAULTS') then option:=vsoDefaults
   else if (_type='SB-DEFAULTAPPEARANCE') then option:=vsoDefaultAppearance
   else option:=vsoExit;
   end;//end of with
   ignorecaption:=true;
   end
else if (copy(_type,1,3)='SL-') then
   begin
   result:=tvirtualsystemlink.create(self);
   with result as tvirtualsystemlink do
   begin
   if (_type='SL-APPLY') then option:=vsoApply
   else if (_type='SL-DEFAULTS') then option:=vsoDefaults
   else if (_type='SL-DEFAULTAPPEARANCE') then option:=vsoDefaultAppearance
   else option:=vsoExit;
   end;//end of with
   ignorecaption:=true;
   end
else if (_type='WEBEDIT') then
   begin
   result:=tvirtualwebedit.create(self);
   with (result as tvirtualwebedit) do
   begin
   url:=_caption;
   animation:=_tep;
   end;//end of if
   _caption:='';//*
   end
else if (_type='USER MANAGEMENT') then
   begin
   //check
   if (ilastpages=nil) then
      begin
      showerror60(translate('No control'));
      siClose;
      goto skipend;
      end;//end of if

   //PROGRAM
   result:=ilastpages.newpage(ntranslate('&User Management'),tepUserManagement,rthtranslate('Customise cursors, scrollbars, font, foreground/background colors and behaviour. Click "Apply" button for changes to take effect'),vpsScrolling,tmp);
   with result as tvirtualpage do
   begin
   //.title
   new('title',ntranslate('User Management'),'',button.help,valTop,nil);
   //.bar
   if (result is tvirtualpagescroll) then (result as tvirtualpagescroll).fillbar;
   //.options
   new('label',ntranslate('options'),'','',valTop,nil);
   new('tick',ntranslate('realtime help'),'',rthtranslate('Bullet: Display Realtime Help bar (top of program). Hover cursor over any section of program for easy, specific and instant Help'),valTop,nil).sysptr:=vsHelp;
   new('tick',ntranslate('automatic startup'),'',rthtranslate('Bullet: Automatic program run upon computer startup'),valTop,nil).sysptr:=vsAutoStartup;
   new('tick',ntranslate('start minimised'),'',rthtranslate('Bullet: Run program hidden (minimised)'),valTop,nil).sysptr:=vsStartMinimised;
   new('tick',ntranslate('display')+#32+ntranslate('splash screen'),'',rthtranslate('Bullet: Display splash screen on program startup'),valTop,nil).sysptr:=vsShowSplash;
   if (programclonename<>'') then new('tick',ntranslate('display')+#32+ntranslate('clone name'),'',rthtranslate('Bulleted: Display name of cloned program in brackets within title. Note: Cloned programs posses identical functionality with additional ability to store their own unique options/settings and appearance information.'),valTop,nil).sysptr:=vsShowClone;
   new('tick',ntranslate('system tray'),'',rthtranslate('Bullet: Display program icon in system tray (usually bottom right of screen), default Taskbar'),valTop,nil).sysptr:=vsSystemTray;
   new('tick',ntranslate('on top'),'',rthtranslate('Bullet: Program on top'),valTop,nil).sysptr:=vsOnTop;
   new('tick',ntranslate('rounded'),'',rthtranslate('Bullet: Rounded corners on Graphical User Interface and controls'),valTop,nil).sysptr:=vsRound;
   new('tick',ntranslate('borders'),'',rthtranslate('Bullet: Border on Controls'),valTop,nil).sysptr:=vsBordersize;
   new('tick',ntranslate('soft close dialog windows'),'',rthtranslate('Bullet: Native dialog Windows automatically close on outside click'),valTop,nil).sysptr:=vsShowSoft;
   new('tick',ntranslate('enhanced'),'',rthtranslate('Bullet: Shaded title display on program/dialog Window'),valTop,nil).sysptr:=vsEnhanced;
   new('tick',ntranslate('safe area'),'',rthtranslate('Bullet: Always on screen, ensuring accessibility/visibility'),valTop,nil).sysptr:=vsSafeArea;
   new('tick',ntranslate('fast resize/move'),'',rthtranslate('Bullet: Efficient, clean, fast display during Window resize/move operation'),valTop,nil).sysptr:=vsSizeFast;
   new('tick',ntranslate('balanced resize'),'',rthtranslate('Bullet: Equal vertical/horizontal adjustment'),valTop,nil).sysptr:=vsSizeBalanced;
   new('tick',ntranslate('compact'),'',rthtranslate('Bullet: Shrink main tabs height - maximum vertical area'),valTop,nil).sysptr:=vsCompact;
   new('tick',ntranslate('flicker free painting'),'',rthtranslate('Bullet: Flicker free, smooth painting via internal buffers '),valTop,nil).sysptr:=vsBufferedPaint;
   with new('tick',ntranslate('animate icon'),'',rthtranslate('Bullet: Display icon animation'),valTop,nil) as tvirtualtick do
   begin
   sysptr:=vsAnimateIcon;
   //hide option if "no animated icon" is present
   visible:=(programanimatedicon<>'');
   end;//end of with
   //.font
   new('fonts',ntranslate('font name'),'',rthtranslate('Standard font for entire program. To restore default, clear text box (press "delete" key) and click "Apply" button'),valTop,nil).sysptr:=vsFontName;
   new('fonts',ntranslate('font name')+#32+ntranslate('Title'),'',rthtranslate('Title text font. To restore default, clear text box (press "delete" key) and click "Apply" button'),valTop,nil).sysptr:=vsTitleFontName;
   //.font size
   new('fontsize',ntranslate('font size'),'',rthtranslate('Font size of standard and title for entire program. To restore default, clear text box (press "delete" key) and click "Apply" button'),valTop,nil).sysptr:=vsFontsize;
   //.scrollbar
   new('droplist',ntranslate('Main Scrollbar Size'),',8,12,16,20 - '+ntranslate('Default')+',24,32,48,64,72,96,128',rthtranslate('Size of page scrollbars. Type size or select from dropdown list'),valTop,nil).sysptr:=vsScrollSizeMain;
   new('droplist',ntranslate('Scrollbar Size'),',8,12,16 - '+ntranslate('Default')+',20,24,32,48,64,72,96,128',rthtranslate('Size of control scrollbars (list/dropdown list/text box controls). Type size or select from dropdown list'),valTop,nil).sysptr:=vsScrollSize;
   //.cursors
   new('cursors','','','',valTop,nil);
   //.colors
   new('colors','','','',valTop,nil);
   end;//end of with
   //SCHEMES - "tvirtualschemes" is a tvirtualpage class control
   tmpc:=new('schemes','','','',valTop,nil,nil);
   result:=ilastpages.newpageb(ntranslate('Sche&mes'),tepSchemes,tmpc.help,vpsNormal,tmpc as tvirtualpage,tmp);
   //HELP & INFORMATION
   result:=ilastpages.newpage(ntranslate('&Help / Information'),tepHelpInfo,rthtranslate('Program specific information/statistic panels'),vpsNormal,tmp);
   with result as tvirtualpage do
   begin
   //information
   new('sysinfo','','','',valTop,nil);
   end;//end of with - outer
   goto skipend;
   end
else if (_type='PATH') then
   begin
   result:=tvirtualpath.create(self);
   _caption:='';//*
   end
else if (_type='FILE') then
   begin
   result:=tvirtualfile.create(self);
   (result as tvirtualfile).filters:=_tep;
   _caption:='';//*
   end
else if (_type='TILE') then
   begin
   result:=tvirtualtile.create(self,_caption);
   _caption:='';//*
   end
else if (_type='PANELSERVER') then
   begin
   result:=tvirtualpanelserver.create(self,_caption);
   _caption:='';//*
   end
else if (_type='HIDDEN') then
   begin
   //nil
   end
else if not newb3(self,_type,_caption,_tep,_align,_newparent,_onclick,_sysptr,_style,_default,_range,result) then
   begin
   showerror60(ntranslate('undefined control')+' ['+_type+']');
   siClose;
   end;//end of if
//.finalise
if (result<>nil) then
   begin
   //.parent
   if (_newparent=nil) then _newparent:=iroot;
   if (result.parent=nil) then result.parent:=_newparent;
   //.other
   with (result as tvirtualcontrol) do
   begin
   onclick:=_onclick;
   align:=_align;
   if not ignorecaption then caption:=_caption;
   enabled:=true;
   hold:=false;
   visible:=true;
   if istabs(_tep) then tabs:=_tep;
   //help - control may have internal help "help" which should be used if externalhelp "_help" has not been set
   if (_help<>'') then help:=_help;
   end;//end of with
   end;//end of if
//.system pointer
if (_sysptr>vsNil) then
   begin
   vs.init(_sysptr,_style);
   if (_range<>'') then vs.range[_sysptr]:=_range;
   if (_default<>'') then vs.default[_sysptr]:=_default;
   if (result<>nil) then result.sysptr:=_sysptr;
   end;//end of if
skipend:
except;end;
end;
//## setparent ##
procedure tvirtualform.setparent(x:twincontrol);
begin
try
//check
if (x=self) or idestroying then exit;
//process
//.delete old
if (parent<>nil) and (parent is tcustomform) then (parent as tform).onresize:=nil;
//.set
inherited;
if (x<>nil) and (x is tform) then (x as tform).onresize:=_onresize;
except;end;
end;
//## wmerasebkgnd ##
procedure tvirtualform.wmerasebkgnd(var message:twmerasebkgnd);
begin
try
if not isiconic(Handle) then message.result:=1
else
   begin
   message.msg:=wm_iconerasebkgnd;
   defaulthandler(message);
   end;//end of if
//update paint status
_paintallowed;
except;end;
end;
//## _paintallowed ##
procedure tvirtualform._paintallowed;
begin
try
if (((application.mainform=self) or (piggyform=self)) and isiconic(application.handle)) or (windowstate=wsMinimized) then paintallowed:=false
else paintallowed:=true;
except;end;
end;
//## wmactivate ##
procedure tvirtualform.wmactivate(var Message: TWMActivate);
var
   a:boolean;
begin
try
//self
inherited;
//event
a:=(message.active=WA_ACTIVE) or (message.active=WA_CLICKACTIVE);
if (iactive<>a) then
   begin
   iactive:=a;
   if not idestroying then fireevent(onactive,self);
   end;//end of if
except;end;
end;
//## setPHAL ##
procedure tvirtualform.setPHAL(x:boolean);//popup host active locked
begin
try
if (popuphost<>nil) then
   begin
   //re-active popuphost
   if (not x) and iwasactive then popuphost.bringtofront;
   //.unlock
   popuphost.activelocked:=x;
   end;//end of if
except;end;
end;
//## getPHAL ##
function tvirtualform.getPHAL:boolean;
begin
try;if (popuphost<>nil) then result:=popuphost.activelocked else result:=false;except;end;
end;
//## showmodal ##
function tvirtualform.showmodal:tmodalresult;
begin
try
//check
if ishowingmodal then
   begin
   result:=mrCANCEL;
   exit;
   end;//end of if
//process
iwasactive:=false;
ishowingmodal:=true;
ishowresult:=false;
phal:=true;
pg.modal(true);
if viOnTop then formstyle:=fsStayOnTop;//force to be "OnTop", since it needs the boost in some instances - very important do not remove!
//.show form - modal 15-JUL-2005
inherited showmodal;
pg.modal(false);
except;end;
try
phal:=false;
result:=modalresult;
ishowingmodal:=false;
except;end;
end;
//## showwait ##
function tvirtualform.showwait:boolean;
var
   wasactive:boolean;
begin//Note: activelocked prevents closure if "non-active"
try
//defaults
result:=false;
//check
if ishowingwait then exit;
//process
activelocked:=false;
iwasactive:=false;
ishowingwait:=true;
ishowresult:=false;
phal:=true;
//.style - must always be ontop, since host form can also be ontop
application.normalizealltopmosts;//#1 - un-top forms
formstyle:=fsStayOnTop;//destroys root form's ONTOP status!
show;
//.focus form
application.processmessages;
application.bringtofront;//re-activate application #1
bringtofront;//re-activate form #2
application.processmessages;
//.wait
while visible and (activelocked or active) and ishowingwait and (sysstate=ssOK) and ((popuphost=nil) or popuphost.showing) do
begin
sleep(20);
application.processmessages;
end;//end of loop
hide;
except;end;
try
phal:=false;
popuphost:=nil;
ishowingwait:=false;
activelocked:=false;
result:=ishowresult;
//#2 - re-top forms
application.RestoreTopMosts;
except;end;
end;
//## showclose ##
procedure tvirtualform.showclose(_reply:tmodalresult);
begin
try
//.modal
if ishowingmodal then
   begin
   iwasactive:=active;
   modalresult:=_reply;
   ishowresult:=(modalOC(_reply)=mrOK);
   //.showmodal must be forced to close
   hide;
   end;//end of if
//.wait
if ishowingwait then
   begin
   iwasactive:=active;
   modalresult:=_reply;
   ishowresult:=(modalOC(_reply)=mrOK);
   ishowingwait:=false;
   //.close
   hide;
   end;//end of if
except;end;
end;
//## setmodalresult ##
procedure tvirtualform.setmodalresult(x:tmodalresult);
begin
try
if (x<>mrNONE) and ishowingmodal then ishowingmodal:=false;
inherited modalresult:=x;
except;end;
end;
//## getmodalresult ##
function tvirtualform.getmodalresult:tmodalresult;
begin
try;result:=inherited modalresult;except;end;
end;
//## controlatpos ##
function tvirtualform.controlatpos(x,y:integer;var z:tvirtualcontrol):boolean;
begin
try;result:=controlatposb(x,y,z,false,true);except;end;
end;
//## controlatposb ##
function tvirtualform.controlatposb(x,y:integer;var z:tvirtualcontrol;mustfocus,mustenable:boolean):boolean;
var
   p:integer;
   tmp:tvirtualcontrol;
begin
try
//defaults
result:=false;
z:=nil;
//check
if idestroying then exit;
//process
for p:=(iroot.controls.count-1) downto 0 do if _controlatpos(x,y,iroot.controls.items[p],tmp,mustfocus,mustenable) then
   begin
   z:=tmp;
   result:=true;
   break;
   end;//end of if
except;end;
end;
//## _controlatpos ##
function tvirtualform._controlatpos(x,y:integer;z:tvirtualcontrol;var r:tvirtualcontrol;mustfocus,mustenable:boolean):boolean;
var
   tmp:tvirtualcontrol;
   p:integer;
begin
try
//defaults
result:=false;
r:=nil;
//check
if (z=nil) or z.destroying or (not z.visible) or (mustenable and (not z.enabled)) or (not ptinrect(x,y,z.srv)) then exit;
//process
//.children
for p:=(z.controls.count-1) downto 0 do if _controlatpos(x,y,z.controls.items[p],tmp,mustfocus,mustenable) then
   begin
   if tmp.showing then
      begin
      r:=tmp;
      result:=true;
      end;//end of if
   break;
   end;//end of if
//.self
if (not result) and ((not mustfocus) or (vlsFocus in z.style)) then
   begin
   if z.showing then
      begin
      r:=z;
      result:=true;
      end;//end of if
   end;//end of if
except;end;
end;
//## isve ##
function tvirtualform.isve(x:tvirtualcontrol):boolean;//visible and enabled
begin
try;result:=(not idestroying) and (x<>nil) and x.visible and x.enabled;except;end;
end;
//## controlsAslist ##
function tvirtualform.controlsAslist:tvirtualcontrols;
begin
try;result:=controlsAslistb(true,true);except;end;
end;
//## controlsAslistb ##
function tvirtualform.controlsAslistb(mustbeVisible,mustbeEnabled:boolean):tvirtualcontrols;
begin//returns an inorder list of controls that are visible and enabled
try
//defaults
result:=nil;
result:=tvirtualcontrols.create;
//check
if idestroying then exit;
if mustbeVisible and (not iroot.visible) then exit;
if mustbeEnabled and (not iroot.enabled) then exit;
//process
//.set
result.value[result.count]:=iroot;
children(result,iroot,mustbeVisible,mustbeEnabled);
except;end;
end;
//## children ##
procedure tvirtualform.children(x:tvirtualcontrols;y:tvirtualcontrol;mustbeVisible,mustbeEnabled:boolean);
var
   p:integer;
begin
try
//check
if idestroying or (x=nil) or (y=nil) then exit;
if mustbeVisible and (not y.visible) then exit;
if mustbeEnabled and (not y.enabled) then exit;
//process
//.set
for p:=0 to (y.controls.count-1) do if (not y.controls.items[p].destroying) and
   ((not mustbeVisible) or y.controls.items[p].visible) and
   ((not mustbeEnabled) or y.controls.items[p].enabled) then
   begin
   //.child
   x.value[x.count]:=y.controls.items[p];
   //.child's children
   if (y.controls.items[p].controls.count>=1) then children(x,y.controls.items[p],mustbeVisible,mustbeEnabled);
   end;//end of if
except;end;
end;
//## nextcontrol ##
function tvirtualform.nextcontrol(next:boolean):tvirtualcontrol;
label
   skipend;
var
   a:tvirtualcontrols;
   i,minp,maxp,p:integer;
begin
try
//defaults
result:=nil;
a:=nil;
i:=-1;
//check
if idestroying then exit;
//process
//.get
a:=controlsAslist;
maxp:=a.count-1;
//.check
if (maxp=-1) then goto skipend;
//.find focused
if (ifocuscontrol<>nil) then for p:=0 to maxp do if (a.items[p]=ifocuscontrol) then
   begin
   i:=p;
   break;
   end;//end of if
//.find next
if next then
   begin
   //FORWARD
   if (i=-1) then minp:=0 else minp:=i+1;
   //.1
   for p:=minp to maxp do if a.items[p].tabstop and (vlsFocus in a.items[p].style) then
      begin
      result:=a.items[p];
      break;
      end;//end of if
   //.2
   if (result=nil) then for p:=0 to frcmax(minp,maxp) do if a.items[p].tabstop and (vlsFocus in a.items[p].style) then
      begin
      result:=a.items[p];
      break;
      end;//end of if
   end
else
   begin
   //BACKWARD
   if (i=-1) then minp:=maxp else minp:=i-1;
   //.1
   for p:=minp downto 0 do if a.items[p].tabstop and (vlsFocus in a.items[p].style) then
      begin
      result:=a.items[p];
      break;
      end;//end of if
   //.2
   if (result=nil) then for p:=maxp downto frcmin(minp,0) do if a.items[p].tabstop and (vlsFocus in a.items[p].style) then
      begin
      result:=a.items[p];
      break;
      end;//end of if
   end;//end of if
skipend:
except;end;
try;freeObj(@a);except;end;
end;
//## groupnotify ##
procedure tvirtualform.groupnotify(sender:tobject;group:integer;event:tgroupevent);
var//Notify all controls (except sender) with same "group" value
   a:tvirtualcontrols;
   p:integer;
begin
try
//defaults
a:=nil;
//check
if idestroying or (group=0) or (not assigned(event)) then exit;
//set
a:=controlsAslistb(false,false);
if (a.count>=1) then for p:=0 to (a.count-1) do if (a.items[p].group=group) and (sender<>a.items[p]) then event(sender,a.items[p],group);
except;end;
try;freeObj(@a);except;end;
end;
//## checkfocuscontrol ##
procedure tvirtualform.checkfocuscontrol;
begin
try;if (ifocuscontrol<>nil) and ((not ifocuscontrol.canfocus) or (not ifocuscontrol.showing)) then focuscontrol:=nil;except;end;
end;
//## setfocuscontrol ##
procedure tvirtualform.setfocuscontrol(x:tvirtualcontrol);
var
   a:tvirtualcontrol;
begin
try
//check
if idestroying then exit;
//range
if (x<>nil) and (not x.canfocus) then x:=nil;
//process
if (x<>ifocuscontrol) then
   begin
   //.store old
   a:=ifocuscontrol;
   //.set
   ifocuscontrol:=x;
   //.reset control related values
   iwheelv:=0;
   //.update
   if (a<>nil) then a.updateb(a.groupfocus);
   if (ifocuscontrol<>nil) then ifocuscontrol.updateb(ifocuscontrol.groupfocus);
   end;//end of if
except;end;
end;
//## _onnotify ##
procedure tvirtualform._onnotify(sender:tobject);
label
   skipcontrols;
var
   tc,c:tvirtualcursor;
   z,tmp,host,sub:tvirtualcontrol;
   sp,mw,mh,ax,ay,aw,ah,cw,ch:integer;
   m:longint;
   a:tpoint;
   _help:string;
begin
try
//defaults
_help:='';
//check
if idestroying then exit;
//defaults
tmp:=nil;
c:=screencursor;
if isizing and (ifocuscontrol=nil) then goto skipcontrols;
//process
//.keyboard
if iskeyboard then
   begin
   if (ifocuscontrol<>nil) then ifocuscontrol._onnotify(self);
   end
//.mouse
else if ismouse then
   begin
   //focused
   if (ifocuscontrol<>nil) and wasdown then
      begin
      tmp:=ifocuscontrol;
      if (not ifocuscontrol.destroying) then ifocuscontrol._onnotify(self);
      end
   //top most visible control
   else if controlatposb(x,y,tmp,down or wasdown,true) then
      begin
      //.focus
      if (act=aDown) then focuscontrol:=tmp;
      //.notify
      if (not tmp.destroying) then tmp._onnotify(self);
      end
   //no active control
   else if down then focuscontrol:=nil;
   end;//end of if
//.cursor
if ismouse then
   begin
   z:=tmp;
   if (z=nil) and iroot.showing then z:=iroot;
   if (z<>nil) then c:=z.cursor else c:=vcArrow;
   end;//end of if
//.check
if (tmp<>nil) and tmp.destroying then tmp:=nil;
//.hovering
if ismouse then
   begin
   //groupfocus
   if (tmp<>nil) and tmp.groupfocus and (tmp.parent<>nil) and tmp.parent.groupfocus then tmp:=tmp.parent;
   //check
   if (tmp<>nil) and (not tmp.canhover) then tmp:=nil;
   //set
   if (ihovercontrol<>tmp) then
      begin
      //.store
      z:=ihovercontrol;
      ihovercontrol:=nil;
      //.old
      if (z<>nil) then z.paintb(z.groupfocus);
      //.new
      ihovercontrol:=tmp;
      if (ihovercontrol<>nil) and (not ihovercontrol.destroying) and (vlsHover in ihovercontrol.style) then ihovercontrol.paintb(ihovercontrol.groupfocus);
      end;//end of if
   end;//end of if
//SIZING
skipcontrols:
//.start
if (sender=self) and (not iroot.destroying) and (iroot.bordersize>=1) and ismouse and
   (windowstate=wsNormal) and oResizeable and (not iroot.inclient) then
   begin
   if down and (not wasdown) then
      begin
      if (key=mLeft) then sizing:=true//start sizing system
      else if (key=mRight) then center;//center program if "right-clicked" on border
      end;//end of if
   //hover cursor for size
   c:=vcSize;
   //help
   _help:=rthtranslate('Hold down left mouse button and drag to resize Window, or right click, to center Window');
   end;//end of if
//.stop
if ((not ismouse) or (not down) or (key<>mLeft)) then
   begin
   if isizing then sizing:=false;//stop sizing
   if imoving then moving:=false;//stop moving
   end;//end of if
//.act
if isizing and ismouse and down and (key=mLeft) and (ifocuscontrol=nil) then sizenow;
//.cursor - set
if isizing then c:=vcSize;
if (c<>screencursor) then screencursor:=c;
//NON-WINDOWS MOVE SYSTEM
if oRealtimeDrag then
   begin
   //.mouse
   if ismouse and down then
      begin
      if not wasdown then
         begin
         getcursorpos(a);
         ilastdragx:=left-a.x;
         ilastdragy:=top-a.y;
         end
      else if (act=aMove) then
         begin
         getcursorpos(a);
         setbounds(ilastdragx+a.x,ilastdragy+a.y,width,height);
         end;//end of if
      end;//end of if
   //.keyboard
   if iskeyboard and down and (clas=recKeyX) then
      begin
      //.get
      sp:=general.aorb(10,1,shift);
      //.set
      if (windowstate=wsNormal) then
         begin
         case key of
         vk_left:left:=left-sp;
         vk_right:left:=left+sp;
         vk_up:top:=top-sp;
         vk_down:top:=top+sp;
         vk_prior:top:=top-general.aorb(sp,5*sp,sp>=2);
         vk_next:top:=top+general.aorb(sp,5*sp,sp>=2);
         vk_home:general.center(self,self.width,self.height,false);
         end;//end of case
         end;//end of if
      end;//end of if
   end;//end of if
//FEEDBACK
if ismouse then
   begin
   //hint
   if not down then
      begin
      controlatposb(x,y,tmp,false,false);
      displayhint(tmp);
      end;//end of if
   //help                                                              //07MAR2008
   if (_help='') and findhelp(nil,true,host,sub) then _help:=host.help+host.help2+rcode+sub.internalhelp;//help and internalhelp(last)
   end
else if iskeyboard and (_help='') then _help:=pg.help;//retain current help while using keyboard keys - 12FEB2008
//.system vars
systemidleref:=ms64;
//.help
pg.help:=_help;
//.pass on event
if assigned(onnotify) then onnotify(self);
except;end;
end;
//## findhelp ##
function tvirtualform.findhelp(from:tvirtualcontrol;musthavehelp:boolean;var host,sub:tvirtualcontrol):boolean;
label
   redo;
var
   count:integer;
begin
try
//defaults
host:=nil;//main outer control that contains all inner controls (if a multicontrol object)
sub:=nil;//actual inner control with focus, or if single control, then that control
result:=false;
count:=20;
//get
if (from=nil) then controlatposb(x,y,from,false,false);
redo:
if (from<>nil) and from.visible then
   begin
   //get
   host:=from;
   if (sub=nil) then sub:=host;
   //set
   if from.groupfocus and (from.parent<>nil) and from.parent.visible and from.parent.groupfocus then
      begin
      from:=from.parent;
      //prevent spiral loop error
      dec(count);
      if (count>=0) and ((not musthavehelp) or (from.help<>'')) then goto redo;
      end;//end of if
   end;//end of if
//successful
result:=(host<>nil);
except;end;
end;
//## sizenow ##
procedure tvirtualform.sizenow;
begin
try;sizenowex(sisAuto);except;end;
end;
//## sizenowex ##
procedure tvirtualform.sizenowex(s:tsizestyle);
var
   a:tpoint;
   by,ax,ay,aw,ah,mw,mh:integer;
begin
try
//init
sizing:=true;
//get
if isizing and ismouse and down then
   begin
   //init
   if viSizeBalanced then by:=2 else by:=1;
   if (s=sisAuto) then
      begin
      s:=isizingstyle;
      if (s=sisAuto) then s:=sisTL;
      end;//end of if
   //range
   if (s=sisTRRAW) then
      begin
      by:=1;
      s:=sisTR;
      end;//end of if
   //get
   getcursorpos(a);
   mw:=a.x-imovepos.x;
   mh:=a.y-imovepos.y;
   ax:=ilastleft;
   ay:=ilasttop;
   aw:=ilastwidth;
   ah:=ilastheight;
   //size
   case s of
   sisTL:begin//top-left
      inc(ax,mw);
      inc(ay,mh);
      dec(aw,mw*by);
      dec(ah,mh*by);
      end;//end of begin
   sisBL:begin//bottom-left
      if (by>=2) then dec(ay,mh);
      inc(ax,mw);
      dec(aw,mw*by);
      inc(ah,mh*by);
      end;//end of begin
   sisTR:begin//top-right
      inc(ay,mh);
      if (by>=2) then dec(ax,mw);
      inc(aw,mw*by);
      dec(ah,mh*by);
      end;//end of begin
   sisBR:begin//bottom-right
      if (by>=2) then
         begin
         dec(ax,mw);
         dec(ay,mh);
         end;//end of if
      inc(aw,mw*by);
      inc(ah,mh*by);
      end;//end of begin
   end;//end of case
   //set
   setbounds(ax,ay,aw,ah);
   end;//end of if
except;end;
end;
//## setsizing ##
procedure tvirtualform.setsizing(a:boolean);//used to switch form into "sizing" mode, which can effect how controls are painted etc - 03OCT2007
var
   cw,ch:integer;
begin
try
//check
if (a=isizing) or (not oResizeable) then exit else isizing:=a;
//set
if a then
   begin
   //init
   cw:=clientwidth;
   ch:=clientheight;
   //style
   if (x<(cw div 2)) and (y<(ch div 2)) then isizingstyle:=sisTL//top-left
   else if (x<(cw div 2)) and (y>=(ch div 2)) then isizingstyle:=sisBL//bottom-left
   else if (x>=(cw div 2)) and (y<(ch div 2)) then isizingstyle:=sisTR//top-right
   else isizingstyle:=sisBR;//bottom-right
   //set
   ilastleft:=left;
   ilasttop:=top;
   ilastwidth:=width;
   ilastheight:=height;
   getcursorpos(imovepos);
   end;//end of if
//paint
paint;
except;end;
end;
//## setmoving ##
procedure tvirtualform.setmoving(a:boolean);//used to switch form into "moving" mode, which can effect how controls are painted etc - 03OCT2007
begin
try
//check
if (a=imoving) or (windowstate<>wsNormal) then exit else imoving:=a;
//set
if a then
   begin
   //set
   ilastleft:=left;
   ilasttop:=top;
   ilastwidth:=width;
   ilastheight:=height;
   getcursorpos(imovepos);
   end;//end of if
//paint
paint;
except;end;
end;
//## movenow ##
procedure tvirtualform.movenow;//03OCT2007
label
   redo;
var
   a:tpoint;
   ax,ay:integer;
   once:boolean;
begin
try
//get
once:=true;
if ismouse and down then
   begin
   //init
   if not wasdown then getcursorpos(imovepos);
redo:
   getcursorpos(a);
   //calc
   ax:=a.x-imovepos.x;
   ay:=a.y-imovepos.y;
   //get
   if once and (not imoving) and ((not general.nrw(ax,0,5)) or (not general.nrw(ay,0,5))) then
      begin
      moving:=true;
      once:=false;
      goto redo;
      end;//end of if
   //set
   if moving and ((ax<>0) or (ay<>0)) then
      begin
      setbounds(ilastleft+ax,ilasttop+ay,ilastwidth,ilastheight);
      paint;
      end;//end of if
   end;//end of if
except;end;
end;
//## getscreencursor ##
function tvirtualform.getscreencursor:tvirtualcursor;
begin
try
if (screen.cursor=crHandPoint) then result:=vcLink
else if (screen.cursor=crIBeam) then result:=vcText
else if (screen.cursor=crAppStart) then result:=vcBusy
else if (screen.cursor=crSize) then result:=vcSize
else result:=vcArrow;
except;end;
end;
//## setscreencursor ##
procedure tvirtualform.setscreencursor(x:tvirtualcursor);
var
   tmp:tcursor;
begin
try
//set
if (x<>screencursor) then
   begin
   if (x=vcLink) then tmp:=crHandPoint
   else if (x=vcText) then tmp:=crIBeam
   else if (x=vcBusy) then tmp:=crAppStart
   else if (x=vcSize) then tmp:=crSize
   else tmp:=crArrow;
   cursor:=tmp;
   screen.cursor:=tmp;
   end;//end of if
except;end;
end;
//## beginchange ##
function tvirtualform.beginchange:boolean;
begin
try
case ichanging of
true:result:=false;
false:
   begin
   ichanging:=true;
   result:=true;
   end;//end of begin
end;//end of case
except;end;
end;
//## endchange ##
function tvirtualform.endchange:boolean;
begin
try
case ichanging of
true:
   begin
   ichanging:=false;
   result:=true;
   end;//end of begin
false:result:=false;
end;//end of case
except;end;
end;
//## changedsize ##
function tvirtualform.changedsize(sender:tvirtualcontrol):boolean;
begin
try;result:=changedsizeb(sender,true,true);except;end;
end;
//## changedsizeb ##
function tvirtualform.changedsizeb(sender:tvirtualcontrol;dopaint,fromparent:boolean):boolean;//13-DEC-2006
var
   tmp:tvirtualcontrol;
begin
try
//defaults
result:=false;
//check
if not visible then exit;
if idestroying then exit;
if ichanging then exit;
if (sender=nil) then sender:=iroot;
if ((sender<>iroot) and (sender.parent=nil)) then exit;
//process
//.root
iroot.controls.changed:=false;
iroot.setboundsb(0,0,clientwidth,clientheight);//no notification
iroot.sr:=rect(0,0,clientwidth,clientheight);
iroot.srv:=iroot.sr;
iroot.srfull:=equalrect(iroot.srv,iroot.sr);
//.set
tmp:=sender;
if (tmp<>iroot) and fromparent then tmp:=tmp.parent;
_changedsize(tmp,tmp.scr);
//.paint - current control's parent
if (sender<>iroot) and fromparent then sender:=sender.parent;
if dopaint and showing then paintfrom(sender,true);
//successful
result:=true;
except;end;
end;
//## _changedsize ##
procedure tvirtualform._changedsize(x:tvirtualcontrol;y:trect);
var
   x1,y1,x2,y2:integer;
   p:integer;
   tmp:trect;
begin
try
//check
if (x=nil) or idestroying then exit;
//process
//.set
x1:=x.left;
x2:=x1+x.width;
y1:=x.top;
y2:=y1+x.height;
if (x.parent<>nil) then
   begin
   inc(x1,x.parent.scr.left);
   inc(x2,x.parent.scr.left);
   inc(y1,x.parent.scr.top);
   inc(y2,x.parent.scr.top);
   y:=x.parent.srv;
   end;
tmp.left:=frcrange(x1,y.left,y.right);
tmp.right:=frcrange(x2,x1,y.right);
tmp.top:=frcrange(y1,y.top,y.bottom);
tmp.bottom:=frcrange(y2,y1,y.bottom);
x.srv:=tmp;
x.sr:=rect(x1,y1,x2,y2);
x.srfull:=equalrect(x.srv,x.sr);
//.controls
for p:=0 to (x.controls.count-1) do _changedsize(x.controls.items[p],y);
except;end;
end;
//## newcontrol ##
function tvirtualform.newcontrol:tvirtualcontrol;
begin
try
//set
result:=tvirtualcontrol.create(self);
result.parent:=iroot;
result.setbounds(0,0,32,32);
result.visible:=false;
//unhold
result.hold:=false;
except;end;
end;
//## _onpaint ##
procedure tvirtualform._onpaint(sender:tobject);
var
   _painting:boolean;
begin
try
//check
if (not showing) or idestroying then exit;
_painting:=painting;
//.force full screen repaint
if
(canvas.cliprect.left<>0) or
(canvas.cliprect.top<>0) or
(canvas.cliprect.right<>clientrect.right) or
(canvas.cliprect.bottom<>clientrect.bottom) then
   begin
   if not irepaintloop then
      begin
      irepaintloop:=true;
      repaint;
      exit;
      end;//end of if
   end;//end of if
irepaintloop:=false;
//process
//.size & paint
if (ilastvisible<>visible) or (iroot.width<>clientwidth) or (iroot.height<>clientheight) or iroot.controls.changed then
   begin
   ilastvisible:=visible;//30JAN2008 - critical fix, Problem: paint demands may occur before form has been properly sized on fast machines causing complete control/paint mis-alignment and a bordered blank form only to display, this catches these sync problems and fixes them on the fly
   changedsizeb(iroot,false,true);
   if not _painting then repaint;
   end
//.paint
else if not _painting then paintfrom(iroot,true);
//.painting
if _painting then ipaintdelayed:=true;
except;end;
end;
//## sync ##
procedure tvirtualform.sync;
begin
try
//check
if idestroying then exit;
//.set - redraw (works on corners for parentless control when going from Maximized -> Normal)
syncsrr;
//.size and paint
iroot.setboundsex(0,0,clientwidth,clientheight,true);
changedsizeb(iroot,true,false);
except;end;
end;
//## _onresize ##
procedure tvirtualform._onresize(sender:tobject);
begin
try
//check
if idestroying then exit;
//.set - redraw (works on corners for parentless control when going from Maximized -> Normal)
syncsrr;
//.repaint
repaint;
except;end;
end;
//## syncsrr ##
procedure tvirtualform.syncsrr;
begin
try
//.set - redraw (works on corners for parentless control when going from Maximized -> Normal)
ccs.srr(self,viRounded,true);
except;end;
end;
//## validrect ##
function tvirtualform.validrect(x:trect):boolean;
begin
result:=(x.right>x.left) and (x.bottom>x.top);
end;
//## ptinrect ##
function tvirtualform.ptinrect(x,y:integer;z:trect):boolean;
begin//z.rect=(x,y)...(x+width,y+height)
result:=
validrect(z) and
(x>=z.left) and (x<z.right) and
(y>=z.top) and (y<z.bottom);
end;
//## paintfrom ##
function tvirtualform.paintfrom(x:tvirtualcontrol;recurs:boolean):boolean;
var
   _paintxy:tpoint;
   _paintrgn:hrgn;
begin
try
//get
inc(ipaintcount);
_paintxy:=ipaintxy;
_paintrgn:=ipaintrgn;
//set
result:=_paintfrom(x,recurs);
//restore
ipaintcount:=frcmin(ipaintcount-1,0);
paintstart(_paintxy.x,_paintxy.y,_paintrgn);
except;end;
end;
//## paintfrom ##
function tvirtualform._paintfrom(x:tvirtualcontrol;recurs:boolean):boolean;
label
   skipend;
const
   asize=100;
var
   buffer:tbitmap;
   buffercanvas:tcanvas;
   tmp3,tmp2,tmp,base,top:hrgn;
   z:tvirtualcontrol;
   ac,p:integer;
   tmpr,clientr,baser,topr:trect;
   sizepaint,ok,clientOK:boolean;
   a:array[0..asize-1] of tvirtualcontrol;
   str:string;
begin
try
//defaults
result:=false;
buffer:=nil;
buffercanvas:=canvas;
top:=nullregion;
base:=nullregion;
tmp:=nullregion;
sizepaint:=(isizing or imoving) and viSizeFast;
//check
if (vs.mode<>vsmNone) or idestroying or (not showing) or
   //.safety check - don't paint if control is "not visible" else unexpected paint results will occur 19-JAN-2006
   ((x<>iroot) and (not x.canpaint)) then exit;
if
 (x=nil) or (not x.visible) or x.hold or
 ((x<>nil) and (x<>iroot) and (x.parent=nil)) or
 ((x<>nil) and (x=x.parent)) or
 (not validrect(x.sr))
 then exit;

//ensure control is on screen
if (x.sr.right<0) or (x.sr.left>clientwidth) or (x.sr.bottom<0) or (x.sr.top>clientheight) then exit;
//process
//-- BASE --
//.base
if (x=iroot) then
   begin
   baser:=x.sr;
   topr:=baser;
   if (not validrect(baser)) then exit;
   base:=ccs.newrgn(baser.left,baser.top,baser.right,baser.bottom,x.rounded);
   end
else
   begin
   //sizing - don't paint control while sizing form
   if sizepaint then exit;
   //GET
   z:=x;
   ac:=0;
   ok:=false;
   repeat
   //.get
   a[ac]:=z;
   inc(ac);
   //.set
   if (not z.visible) or z.hold then goto skipend;
   if (ac>=2) and z.srfull then break;
   //.inc
   z:=z.parent;
   until (z=nil) or (ac>=asize);
   if (ac=0) then goto skipend;
   //SET
   baser:=a[ac-1].scr;
   if (not validrect(baser)) then goto skipend;
   base:=ccs.newrgn(baser.left,baser.top,baser.right,baser.bottom,a[ac-1].rounded);
   for p:=(ac-2) downto 0 do
   begin
   if (p=0) then topr:=a[p].sr else topr:=a[p].scr;
   if (not validrect(topr)) then goto skipend;
   //.get
   tmp:=createrectrgn(0,0,0,0);
   top:=ccs.newrgn(topr.left,topr.top,topr.right,topr.bottom,a[p].rounded);
   combinergn(tmp,base,top,RGN_AND);
   ccs.delrgn(top);
   ccs.delrgn(base);
   base:=tmp;
   end;//end of loop
   end;//end of if
//.exclude above - client
clientr:=x.scr;
clientOK:=validrect(clientr);
if clientOK then
   begin
   //.buffer - used for "_onpaint" only
   if (not sizepaint) and (viBufferedPaint or x.buffer) then
      begin
      buffer:=tbitmap.create;
      buffer.width:=x.width;
      buffer.height:=x.height;
      buffercanvas:=buffer.canvas;
      x.bufferbmp:=buffer;
      end;//end of if
   //.get
   tmp:=createrectrgn(0,0,0,0);
   top:=ccs.newrgn(clientr.left,clientr.top,clientr.right,clientr.bottom,x.rounded);
   combinergn(tmp,base,top,RGN_DIFF);
   ccs.delrgn(top);
   //.set
   paintstart(topr.left,topr.top,tmp);
   //.paint
   resetcanvas(x,canvas);
   x._onpaintborder(self,canvas);
   //.del
   ccs.delrgn(tmp);
   //.get
   tmp:=createrectrgn(0,0,0,0);
   top:=ccs.newrgn(clientr.left,clientr.top,clientr.right,clientr.bottom,x.rounded);
   combinergn(tmp,base,top,RGN_AND);
   ccs.delrgn(top);
   //.exclude above
   if (not sizepaint) and (x.controls.count>=1) then
      begin
      ccs.delrgn(base);
      base:=tmp;
      //.exclude base's of all children - those sitting on top (within self)
      for p:=0 to (x.controls.count-1) do
      begin
      z:=x.controls.items[p];
      tmpr:=z.sr;
      if z.visible and (not z.hold) and validrect(tmpr) and canpaint(z) then
         begin
         tmp:=createrectrgn(0,0,0,0);
         top:=ccs.newrgn(tmpr.left,tmpr.top,tmpr.right,tmpr.bottom,z.rounded);
         combinergn(tmp,base,top,RGN_DIFF);
         deleteobject(base);
         deleteobject(top);
         base:=tmp;
         end;//end of if
      end;//end of loop
      tmp:=base;
      end;//end of if
   //.set
   paintstart(clientr.left,clientr.top,tmp);
   //.paint
   resetcanvas(x,buffercanvas);
   if (not sizepaint) then x._onpaint(self,buffercanvas)
   else if (x=iroot) then
      begin
      buffercanvas.fillrect(clientrect);
      if isizing then str:=general.thousands(width)+tsW+' x '+general.thousands(height)+tsH
      else str:=general.thousands(self.left)+tsX+' , '+general.thousands(self.top)+tsY;
      buffercanvas.textout((width-iroot.info^.fontmap.textwidth(str)) div 2,(height-iroot.info^.fontmap.maxh) div 2,str);
      end;//end of if
   //.draw
   x.bufferbmp:=nil;
   if (buffer<>nil) then canvas.draw(0,0,buffer);
   //.del
   ccs.delrgn(tmp);
   end
else
   begin
   //.set
   paintstart(topr.left,topr.top,base);
   //.paint
   resetcanvas(x,canvas);
   x._onpaintborder(self,canvas);
   end;//end of if
//successful
result:=true;
skipend:
except;end;
try
x.bufferbmp:=nil;
ccs.delrgn(base);
freeobj(@buffer);
except;end;
try
//CHILDREN
if result and recurs then for p:=0 to (x.controls.count-1) do if (x<>x.controls.items[p]) then _paintfrom(x.controls.items[p],recurs);
except;end;
end;
//## paintstart ##
procedure tvirtualform.paintstart(_x,_y:integer;_rgn:hrgn);
begin
try
ipaintxy:=point(_x,_y);
ipaintrgn:=_rgn;
if (_rgn<>nullregion) then
   begin
   selectcliprgn(canvas.handle,_rgn);
   setviewportorgex(canvas.handle,_x,_y,nil);
   end;//end of if
except;end;
end;
//## resetcanvas ##
procedure tvirtualform.resetcanvas(x:tvirtualcontrol;c:tcanvas);
var
   s:tfontstyles;
   a:integer;
   d,f,h,all:boolean;
begin
try
if (x<>nil) and (not idestroying) then
   begin
   //get
   d:=x.down;
   f:=x.focused;
   h:=x.hovering;
   all:=d or f or h;
   //set
   if (c.font.name<>x.info^.fontname) then c.font.name:=x.info^.fontname;
   if (c.font.size<>x.info^.fontmap.font.size) then c.font.size:=x.info^.fontmap.font.size;//13OCT2007
   if (c.brush.style<>bsSolid) then c.brush.style:=bsSolid;
   if (c.pen.style<>psSolid) then c.pen.style:=psSolid;
   //focus controllers
   //.font color
   a:=general.aorb(x.info^.font,x.info^.fonthighlight,x.fFontcolor and d);
   if x.fDisable and (not x.enabled) then a:=x.info^.disablefont;
   if (a<>c.font.color) then c.font.color:=a;
   //.style
   s:=[];
   if (x.fUnderline and (d or h)) then s:=[fsUnderline];
   if (s<>c.font.style) then c.font.style:=s;
   //.background
   a:=x.info^.background;
   if x.fBackground then
      begin
      if d then a:=x.info^.highlight
      else if f or h then a:=x.info^.hover;
      //.disable
      if x.fDisable and (not x.enabled) then a:=x.info^.disable;
      end
   else if (x.oBgcolor<>clNone) then a:=x.oBgcolor;//25SEP2007
   if (a<>c.brush.color) then c.brush.color:=a;
   //.border - uses background color if not "viBorder"
   if viBorder then a:=general.aorb(x.info^.border,x.info^.highlight,x.fBorder and all);
   if x.fDisable and (not x.enabled) then a:=x.info^.disableborder;
   if (a<>c.pen.color) then c.pen.color:=a;
   end;//end of if
except;end;
end;
//## canpaint ##
function tvirtualform.canpaint(x:tvirtualcontrol):boolean;
begin
try
//process
result:=(vs.mode=vsmNone) and (not idestroying) and paintallowed and
(x<>nil) and ((x=iroot) or (x.parent<>nil)) and (not iroot.locked) and (not x.locked) and (not x.hold) and x.visible and validrect(x.srv);
except;end;
end;
//## ismouse ##
function tvirtualform.ismouse:boolean;
begin
try;result:=(iclas=recMouse);except;end;
end;
//## iskeyboard ##
function tvirtualform.iskeyboard:boolean;
begin
try;result:=(iclas=recKey) or (iclas=recKeyX);except;end;
end;
//## validgui ##
function tvirtualform.validgui(x:tobject;var y:tvirtualform):boolean;
begin
try
//defaults
result:=false;
y:=nil;
//process
if (not idestroying) and (x<>nil) and (x is tvirtualform) then
   begin
   result:=true;
   y:=x as tvirtualform;
   end;//end of if
except;end;
end;
//## doevent ##
procedure tvirtualform.doevent;
begin
try;_onnotify(self);except;end;
end;
//## guilocked ##
function tvirtualform.guilocked(x:tobject):boolean;
begin
try;result:=(x<>self);except;end;
end;
//## _ontimer ##
procedure tvirtualform._ontimer(sender:tobject);
var
   _left,_top,_width,_height:integer;
   t:currency;
   oneormore:boolean;
begin
try
//check
if idestroying then exit;
//defaults
oneormore:=false;
t:=ms64;
//process
//.repeat
if isrepeat then
   begin
   oneormore:=true;
   ifocuscontrol._onrepeat(self);
   end;//end of if
//.mouseoff - delayed
if imouseoffWAIT then
   begin
   oneormore:=true;
   mouseoff;
   end;//end of if
//.sync maximised
if ((t-imaxtime)>=250) then
   begin
   syncmaximized;
   imaxtime:=ms64;
   end;//end of if
//.paintallowed
if ((t-itimepaint)>=1000) then
   begin
   _paintallowed;
   itimepaint:=ms64;
   end;//end of if
//.paintdelayed
if ipaintdelayed and (not painting) then
   begin
   ipaintdelayed:=false;
   paintfrom(iroot,true);
   end;//end of if
//.safe
if ((t-isafetime)>=500) then
   begin
   //get
   _left:=left;
   _top:=top;
   _width:=width;
   _height:=height;
   //set
   if safearea and boundsfilter(_left,_top,_width,_height) then setbounds(_left,_top,_width,_height);
   //reset
   isafetime:=t;
   end;//end of if
//.slow
if oneormore then mt.slowoff(islowref);
mt.interval[itimer]:=mt.slowauto(islowref,50);//50 ms
//.event
if assigned(ontimer) then ontimer(self);
except;end;
end;
//## isrepeat ##
function tvirtualform.isrepeat:boolean;
begin
try;result:=(not idestroying) and (ifocuscontrol<>nil) and idown and ((ms64-idowntime)>=500);except;end;
end;
//## wmmousewheel ##
procedure tvirtualform.wmmousewheel(var Message:tmessage);
var//Tested and correct on XP HOME on 05-FEB-2006
   a:tint4;
   b:smallint;
begin
try
//handled
message.result:=0;
//process
if (not idestroying) then
   begin
   //.get
   a.val:=message.wparam;
   b:=smallint(a.wrds[1]);
   //.set
   iwheelv:=iwheelv+(b/120);
   //.event
   if (ifocuscontrol<>nil) and (not ifocuscontrol.destroying) then ifocuscontrol._onwheelv(self);
   end;//end of if
except;end;
end;
//## _onmousedown ##
procedure tvirtualform._onmousedown(sender:tobject;button:tmousebutton;shift:tshiftstate;x,y:integer);
begin
try
//check
if idestroying or ilocked or idown or (iclas<>recNone) or guilocked(sender) or (not validgui(sender,self)) then exit else ilocked:=true;
//set
idowntime:=ms64;
iclas:=recMouse;
idown:=true;
iact:=aDown;
imove:=false;
if (button=mbLeft) then ikey:=mLeft
else if (button=mbMiddle) then ikey:=mCenter
else ikey:=mRight;
ix:=x;
iy:=y;
idx:=x;
idy:=y;
itmpxy:=point(ix+1,iy+1);
//sysinfo
general.croll(virtualclicks,1);
//event
doevent;
iwasdown:=true;
except;end;
try;ilocked:=false;except;end;
end;
//## _onmousemove ##
procedure tvirtualform._onmousemove(sender:tobject;shift:tshiftstate;x,y:integer);
var
   ioff:boolean;
begin
try
//check
if idestroying or ilocked or ((iclas<>recNone) and (iclas<>recMouse)) or guilocked(sender) or (not validgui(sender,self)) then exit else ilocked:=true;
//set
ioff:=(iclas=recNone);
iclas:=recMouse;//since mouse may not be down
imove:=true;
iact:=aMove;
ix:=x;
iy:=y;
//event
doevent;
//after
itmpxy:=point(x,y);
except;end;
try
if ioff then iclas:=recNone;
ilocked:=false;
except;end;
end;
//## _onmouseup ##
procedure tvirtualform._onmouseup(sender:tobject;button:tmousebutton;shift:tshiftstate;x,y:integer);
begin
try;if (not idestroying) and idown and (not guilocked(sender)) then mouseoff;except;end;
end;
//## mouseoff ##
function tvirtualform.mouseoff:boolean;
begin
try;mouseoffb(false);except;end;
end;
//## mouseoffb ##
function tvirtualform.mouseoffb(force:boolean):boolean;
begin
try
//defaults
result:=false;
//check
if idestroying then exit;
if ((not force) and ilocked) or (iclas<>recMouse) or guilocked(self) then
   begin
   imouseoffWAIT:=true;
   exit;
   end
else ilocked:=true;
//set
idown:=false;
imove:=false;
iact:=aUp;
//event
doevent;
except;end;
try
iclas:=recNone;
iact:=aNone;
ilocked:=false;
iwasdown:=false;
imouseoffWAIT:=false;
result:=true;
except;end;
end;
//## focuskey ##
function tvirtualform.focuskey(key:word;extended:boolean):boolean;
begin
try
result:=(key=vk_tab) or
(extended and ((key=vk_left) or (key=vk_up) or (key=vk_right) or (key=vk_down)));
except;end;
end;
//## specialkey ##
function tvirtualform.specialkey(key:word):boolean;
begin
try
result:=(key=vk_left) or (key=vk_up) or (key=vk_right) or (key=vk_down) or
(key=vk_home) or (key=vk_end) or (key=vk_prior) or (key=vk_next) or
(key=vk_escape) or (key=vk_return) or (key=vk_tab) or (key=vk_back) or (key=vk_delete) or
((key>=VK_F1) and (key<=VK_F24));
except;end;
end;
//## safekey ##
function tvirtualform.safekey(x:word):byte;
begin
try
if (x>255) then x:=255;
result:=x;
except;end;
end;
//## _onkeydown ##
procedure tvirtualform._onkeydown(sender:tobject;var key:word;shift:tshiftstate);
var
   ck:byte;
   n,os,oa,oc:boolean;
begin
try
//check
if idestroying then exit;
//state
//.store
os:=ishift;
oa:=ialt;
oc:=ictrl;
//.set
ishift:=(ssShift in shift);
ialt:=(ssAlt in shift);
ictrl:=(ssCtrl in shift);
//.special
if ((ishift<>os) or (ialt<>oa) or (ictrl<>oc)) and (ifocuscontrol<>nil) then ifocuscontrol._onstate(self);
//.shortcut - ALT+[*]
if ialt and oa and (not ictrl) then _onshortcut(asshortcut(key));
if (ialt or ictrl) then
   begin
   _onaltctrl(key);//28NOV2007 - internal use only
   exit;
   end;//end of if
//.ck
if isve(ifocuscontrol) and (ifocuscontrol.clickkey<>clkyNone) then ck:=ifocuscontrol.clickkey;
//check
if ilocked or ((iclas<>recNone) and (iclas<>recKey) and (iclas<>recKeyX)) or guilocked(sender) then exit
else if mkEscape and (key=27) then _onMasterkey(mrCANCEL)
else if mkReturn and (key=13) then _onMasterkey(mrOK)
else if (key<>ck) and (not specialkey(key)) then exit
else if tabstop and focuskey(key,aExtendedfocusshift) then//tab and others [Others only]
   begin
   if (key=vk_left) or (key=vk_up) then n:=false
   else if (key=vk_right) or (key=vk_down) then n:=true
   else exit;
   focuscontrol:=nextcontrol(n);
   exit;
   end
else ilocked:=true;
validgui(sender,self);
iclas:=recKeyX;
idown:=true;
iact:=aDown;
imove:=false;
ikey:=safekey(key);
//event
doevent;
//.clickey
if isve(ifocuscontrol) and (ifocuscontrol.clickkey<>clkyNone) and (ifocuscontrol.clickkey=ikey) then
   begin
   iclickkey:=ikey;
   ifocuscontrol.paint;
   end;//end of if
iwasdown:=true;
except;end;
try
if (iclickkey=clkyNone) then
   begin
   ilocked:=false;
   keyoff;
   end;//end of if
except;end;
end;
//## canAKEY ##
function tvirtualform.canAKEY(x:tvirtualcontrol):boolean;//28SEP2007 - Special controls MUST be specified to ignore "akey" (ie. edit,text,list and droplist)
begin
try
//defaults
result:=false;
//process
//.nil
if (x=nil) then
   begin
   result:=true;
   exit;
   end;//end of if
//.text control
if (x is tvirtualbasetext) then exit;
//.list control
if (x is tvirtualbaselist) then exit;
//.droplist control
if (x is tvirtualdroplist) then exit;//28SEP2007
//successful
result:=true;
except;end;
end;
//## _onkeypress ##
procedure tvirtualform._onkeypress(sender:tobject;var key:char);
var
   b:char;
   keyv:byte;
   n:boolean;
begin
try
//check
if idestroying then exit;
//check
keyv:=byte(key);
b:=menus.safeAKEY(key);
//.clickkey
if (keyv<>clkyNone) and (iclickkey=keyv) then exit;
//.shortcut - CTRL+A..Z or Accelerator=A..Z, 0..9
if (ictrl and (not ialt)) then _onshortcut(asshortcut(keyv));
if (ialt or ictrl) then exit;
//key
if ilocked or (iclas<>recNone) or guilocked(sender) then exit
else if (keyv<vk_tab) or (keyv=vk_escape) or (keyv=vk_return) then exit//vk_delete=ignore
else if tabstop and focuskey(keyv,aExtendedfocusshift) then//tab and others [TAB only]
   begin
   if (keyv=vk_tab) then focuscontrol:=nextcontrol(not ishift);
   exit;
   end
else if isve(ifocuscontrol) and (ifocuscontrol.clickkey<>clkyNone) and (ifocuscontrol.clickkey=keyv) then exit
//.accelerator keys
else if akeys and canAKEY(ifocuscontrol) and (((b>='A') and (b<='Z')) or (b>='0') and (b<='9')) and _onshortcut(key) then exit
else ilocked:=true;
//set
validgui(sender,self);
iclas:=recKey;
idown:=true;
iact:=aDown;
imove:=false;
ikey:=byte(key);
//event
doevent;
iwasdown:=false;
except;end;
try
ilocked:=false;
keyoff;
except;end;
end;
//## _onkeyup ##
procedure tvirtualform._onkeyup(sender:tobject;var key:word;shift:tshiftstate);
var
   os,oa,oc:boolean;
begin
try
//check
if idestroying then exit;
//sysinfo
general.croll(virtualkeystrokes,1);
//state
//.store
os:=ishift;
oa:=ialt;
oc:=ictrl;
//.set
ishift:=(ssShift in shift);
ialt:=(ssAlt in shift);
ictrl:=(ssCtrl in shift);
//.remember
if (ifocuscontrol<>nil) and ((ishift<>os) or (ialt<>oa) or (ictrl<>oc)) then ifocuscontrol._onstate(self);
//.clickkey
if ilocked and (iclickkey<>0) and (iclickkey=key) then
   begin
   //.click
   if isve(ifocuscontrol) and (ifocuscontrol.clickkey<>0) and (ifocuscontrol.clickkey=iclickkey) then
      begin
      idown:=false;
      ifocuscontrol.paint;
      ifocuscontrol.click;
      end;//end of if
   //.off
   ilocked:=false;
   keyoff;
   iclickkey:=0;
   end;//end of if
except;end;
end;
//## keyoff ##
function tvirtualform.keyoff:boolean;
begin
try
//check
if idestroying then exit;
//defaults
result:=false;
//check
if ilocked or ((iclas<>recKey) and (iclas<>recKeyX)) or guilocked(self) then exit else ilocked:=true;
//set
idown:=false;
iact:=aUp;
imove:=false;
//event
doevent;
except;end;
try
iclas:=recNone;
ilocked:=false;
iwasdown:=false;
result:=true;
except;end;
end;
//## _onMasterkey ##
procedure tvirtualform._onMasterkey(key:tmodalresult);
begin
try
//check
if idestroying then exit;
//.close
showclose(key);
//.flush current keyboard key - important when using "mkReturn or mkEscape"
application.processmessages;
except;end;
end;
//## _onpop ##
procedure tvirtualform._onpop(sender:tobject);
begin
//nil
end;
//## _onshortcut ##
function tvirtualform._onshortcut(_shortcut:string):boolean;
label
   skipend;
var
   a:tvirtualcontrols;
   p:integer;
   b:char;
   ctrl,alt:boolean;
begin
try
//defaults
result:=false;
a:=nil;
//check
if idestroying then exit;
if (_shortcut='') then exit;
//process
b:=#0;
ctrl:=(0=comparetext(copy(_shortcut,1,5),'CTRL+'));
alt:=(0=comparetext(copy(_shortcut,1,4),'ALT+'));
//.accelerator (uppercase only)
if (not ctrl) and (not alt) and aKeys then b:=menus.safeAKEY(_shortcut);
//FOCUSED CONTROL
if (ctrl or alt) and isve(ifocuscontrol) then
   begin
   result:=ifocuscontrol._onshortcut(_shortcut);
   if result then goto skipend;
   end;//end of if
//.setup
a:=controlsAslist;
//CONTROLS
//.akey
if (not result) and (b<>#0) then for p:=0 to (a.count-1) do if
   (a.items[p]<>nil) and isve(a.items[p]) and
   (a.items[p].akey<>#0) and (a.items[p].akey=b)
    then
   begin
   result:=true;
   a.items[p].click;
   break;
   end;//end of if
//.ctrl/alt
if (not result) and (ctrl or alt) then for p:=0 to (a.count-1) do if
   (a.items[p]<>nil) and isve(a.items[p]) and
   (a.items[p].shortcut<>'') and (0=comparetext(a.items[p].shortcut,_shortcut))
    then
   begin
   result:=true;
   a.items[p].click;
   break;
   end;//end of if
skipend:
except;end;
try;freeobj(@a);except;end;
end;
//## _onaltctrl ##
procedure tvirtualform._onaltctrl(key:word);//28NOV2007
label
   skipend;
var
   a:tpoint;
   dx,dy,sp:integer;
   rightclick,leftclick:boolean;
begin
try
//check
if (not ialt) and (not ictrl) then exit;
//CONTROL MOUSE using KEYBOARD
//key combinations:
//CTRL+ENTER............left click
//CTRL+SPACE............right click
//CTRL+HOME.............center cursor on screen
//CTRL+ARROWS...........to move cursor by 16 pixels (coarse)
//CTRL+SHIFT+ARROWS.....to move cursor by 1 pixel (fine)
if ictrl then
   begin
   //defaults
   leftclick:=false;
   //get
   sp:=general.aorb(16,1,shift);
   getcursorpos(a);
   dx:=a.x;
   dy:=a.y;
   //decide
   case key of
   vk_left:dec(dx,sp);
   vk_right:inc(dx,sp);
   vk_up:dec(dy,sp);
   vk_down:inc(dy,sp);
   vk_home:begin
      dx:=screen.width div 2;
      dy:=screen.height div 2;
      end;//end of begin
   vk_return:leftclick:=true;
   vk_space:rightclick:=true;
      else goto skipend;
   end;//end of case
   //set
   if (dx<>a.x) or (dy<>a.y) then setcursorpos(dx,dy);
   if leftclick then
      begin
      mouse_event(mouseeventf_leftdown,0,0,0,0);
      sleep(100);
      mouse_event(mouseeventf_leftup,0,0,0,0);
      end
   else if rightclick then
      begin
      mouse_event(mouseeventf_rightdown,0,0,0,0);
      sleep(100);
      mouse_event(mouseeventf_rightup,0,0,0,0);
      end;//end of if
   end;//end of if
skipend:
except;end;
end;

//## tvirtualcontrollist #######################################################
//## create ##
constructor tvirtualcontrollist.create;
begin
//self
inherited;
//controls
icontrols:=tdynamicobject.create;
end;
//## destroy ##
destructor tvirtualcontrollist.destroy;
begin
try
//controls
freeObj(@icontrols);
//self
inherited;
except;end;
end;
//## lock ##
procedure tvirtualcontrollist.lock;
begin
try;inc(ilockcount);except;end;
end;
//## unlock ##
procedure tvirtualcontrollist.unlock;
begin
try;dec(ilockcount);except;end;
end;
//## find ##
function tvirtualcontrollist.find(x:tobject):integer;
begin
try
//defaults
result:=-1;
//check
if (ilockcount<>0) then exit;
//process
result:=icontrols.find(0,x);
except;end;
end;
//## add ##
function tvirtualcontrollist.add(x:tobject;top:boolean):integer;
var
   p:integer;
begin
try
//defaults
result:=-1;
//check
if (ilockcount<>0) then exit;
//process
//.find
p:=find(x);
if (p>=0) then
   begin
   icontrols.del(p);
   ichanged:=true;
   end;//end of if
//.add
if top then
   begin
   result:=icontrols.count;
   icontrols.value[result]:=x;
   ichanged:=true;
   end
else
   begin
   result:=0;
   icontrols.ins(0);
   icontrols.value[0]:=x;
   ichanged:=true;
   end;//end of if
except;end;
end;
//## del ##
function tvirtualcontrollist.del(x:tobject):boolean;
var
   a:tvirtualcontrol;
   p:integer;
begin
try
//defaults
result:=false;
//check
if (ilockcount<>0) then exit;
//process
p:=find(x);
if (p>=0) then
   begin
   result:=true;
   icontrols.del(p);
   ichanged:=true;
   end;//end of if
except;end;
end;
//## flush ##
procedure tvirtualcontrollist.flush;
begin
try;icontrols.setparams(0,0,0);except;end;
end;
//## delall ##
procedure tvirtualcontrollist.delall(butthis:tvirtualcontrol);//13NOV2007
var
   p:integer;
begin
try
//check
if (ilockcount<>0) or (icontrols.count=0) then exit;
//process
ichanged:=true;
if (butthis=nil) then
   begin
   icontrols.freeValues;
   icontrols.setparams(0,0,0);
   end
else for p:=(icontrols.count-1) downto 0 do if (icontrols.items[p]<>butthis) then
   begin
   icontrols.freeValue(p);//use "freeValue", otherwise value[p] must be set to nil before destroy object else virtualcontrols will double delete and cause some to not be deleted properly/at all - 13NOV2007
   icontrols.del(p);
   end;//end of if
except;end;
end;
//## getcount ##
function tvirtualcontrollist.getcount:integer;
begin
try;result:=icontrols.count;except;end;
end;
//## getcontrol ##
function tvirtualcontrollist.getcontrol(x:integer):tvirtualcontrol;
begin//allow to work even when "locked"
try
//defaults
result:=nil;
//process
if (x>=0) and (x<icontrols.count) then result:=(icontrols.items[x] as tvirtualcontrol);
except;end;
end;

//## tvirtualcontrol ###########################################################
//## create ##
constructor tvirtualcontrol.create(_gui:tvirtualform);
begin
//vars
hunits:=2;
ioheight:=vhsClient;
iowidth:=vwsInternal;
isystem:=-1;
general.iroll(viControlsCreated,1);
iid:=viControlsCreated;
general.iroll(viControlsActive,1);
icontrols:=nil;
ilastclicktime:=ms64;
//check
if (_gui=nil) then showinfo('Error: unspecified gui'+rcode+'ID: '+floattostrex2(iid));
//set
igui:=_gui;
iroot:=_gui.root;
ipinfo:=@viNormal;
//focus controllers
fFontcolor:=true;
fUnderline:=true;
fDisable:=true;
fBackground:=true;
fBorder:=true;
fUpdnpaint:=true;//auto paint control on mouse down/up
//options
oModalresult:=mrNONE;
oPaintonvisible:=true;
oBgcolor:=clNone;//use system color
//action modifiers
oAllowvariableheights:=true;
aDownrelaxed:=true;
//default overrides
dtransparent:=true;
//style
istyle:=[vlsHover,vlsFocus];
//vars
isysptr:=vsNil;
iscrollnotify:=true;
akey:=#0;//none
icursor:=vcArrow;
paintcount:=0;
ibordersize:=1;
icx:=0;
icy:=0;
ienabled:=true;
ialign:=valLeft;
ileft:=0;
itop:=0;
iwidth:=32;
iheight:=32;
itabspace:=2;
tabstop:=true;
ihinttime:=3000;
//defaults
icontrols:=tvirtualcontrollist.create;
hold:=true;
//system
isystem:=vs.connect(onsystem);
end;
//## destroy ##
destructor tvirtualcontrol.destroy;
var
   p:integer;
   tmp:tvirtualcontrol;
begin
try
//init
destroyinit;
//list
freeobj(@icontrols);
//info
general.iroll(viControlsDestroyed,1);
general.iroll(viControlsActive,-1);
//self
inherited;
except;end;
end;
//## destroyinit ##
procedure tvirtualcontrol.destroyinit;
begin
try
//check
if idestroying then exit;
//flag
idestroying:=true;
//system
vs.disconnect(isystem);
//states
hold:=true;
visible:=false;
parent:=nil;
//focus
igui.checkfocuscontrol;
//timers
if (itimer<>mtNilTimer) then mt.del(itimer);
if (imt<>nil) then freeobj(@imt);
except;end;
end;
//## destroychildren ##
procedure tvirtualcontrol.destroychildren;
var//Destroy's igui.head last if "self=igui.root"
   isroot:boolean;
   h:tvirtualhead;
   tmp:tvirtualcontrol;
   p:integer;
begin
try
if (icontrols<>nil) and (icontrols.count>=1) then
   begin
   //LOCK
   icontrols.lock;
   h:=nil;
   isroot:=(self=igui.root);
   //DESTROY
   for p:=0 to (icontrols.count-1) do
   begin
   //.get
   tmp:=icontrols.items[p];
   //.free
   if (tmp<>nil) then
      begin
      if isroot and (tmp=igui.head) then h:=igui.head
      else freeObj(@tmp);
      end;//end of if
   end;//end of loop
   //.head - destroy last - safe for children to refer to igui.head when being destroyed
   freeobj(@h);
   //CLEAR
   icontrols.flush;
   //UNLOCK
   icontrols.unlock;
   end;//end of if
except;end;
end;
//## copytoclipboard ##
function tvirtualcontrol.copytoclipboard:boolean;//12FEB2008
begin
try;result:=false;clipboard.astext:=childrenastext;result:=true;except;end;
end;
//## astext ##
function tvirtualcontrol.astext:string;//must always terminate with a "rcode" - 12FEB2008
begin
try;result:=misc.enforceEOLex(caption,false);except;end;
end;
//## childrenastext ##
function tvirtualcontrol.childrenastext:string;//12FEB2008
begin
try;result:=childrenastextex(false);except;end;
end;
//## childrenastextex ##
function tvirtualcontrol.childrenastextex(includeall:boolean):string;//12FEB2008
var
   tmp:tvirtualcontrol;
   len,p:integer;
   z:string;
   all:boolean;
   function caninclude(includeall:boolean;x:tvirtualcontrol):boolean;
   begin
   try
   //defaults
   result:=(x<>nil) and includeall;
   //check
   if (x=nil) then exit;
   //get
   if not result then
      begin
      if (comparetext(x.classname,'tvirtualbutton')=0) then exit;
      if (comparetext(x.classname,'tvirtuallink')=0) then exit;
      //successful
      result:=true;
      end;//end of if
   except;end;
   end;
begin
try
//defaults
result:='';
len:=0;
//get
if (icontrols<>nil) and (icontrols.count>=1) then
   begin
   for p:=0 to (icontrols.count-1) do
   begin
   tmp:=icontrols.items[p];
   if (tmp<>nil) and tmp.visible then
      begin
      if caninclude(includeall,tmp) then pushb(len,result,tmp.astext);
      pushb(len,result,tmp.childrenastextex(includeall))
      end;//end of if
   end;//end of loop
   end;//end of if
//finalise
pushb(len,result,'');
except;end;
end;
//## setoheight ##
procedure tvirtualcontrol.setoheight(x:tvirtualheightstyle);
begin
try;ioheight:=x;except;end;
end;
//## compact ##
function tvirtualcontrol.compact:boolean;
begin
try;if oAllowCompact then result:=viCompact else result:=false;except;end;
end;
//## setup ##
procedure tvirtualcontrol.setup(_parent:tvirtualcontrol);
begin
try
parent:=_parent;
align:=valTop;
enabled:=true;
hold:=false;
visible:=true;
except;end;
end;
//## newlink ##
function tvirtualcontrol.newlink(_caption,_tep,_help:string;_onclick:tnotifyevent):tvirtuallink;
begin
try;result:=newlinkex(_caption,_tep,_help,_onclick,false);except;end;
end;
//## newllink ##
function tvirtualcontrol.newllink(_caption,_tep,_help:string;_onclick:tnotifyevent):tvirtuallink;
begin
try;result:=newlinkex(_caption,_tep,_help,_onclick,true);except;end;
end;
//## newlinkex ##
function tvirtualcontrol.newlinkex(_caption,_tep,_help:string;_onclick:tnotifyevent;_left:boolean):tvirtuallink;
begin
try
//process
//.get
result:=tvirtuallink.create(igui);
//.set
result.normal:=normal;
result.parent:=self;
with result do
begin
case _left of
true:align:=valLeft;
false:align:=valRight;
end;//end of case
alignsep:=general.aorb(2,0,_caption='');
caption:=_caption;
if (length(_tep)>=1) then animation:=_tep;
onclick:=_onclick;
visible:=true;
enabled:=true;
hold:=false;
help:=_help;
end;//end of with
except;end;
end;
//## getrounded ##
function tvirtualcontrol.getrounded:boolean;
begin
try;result:=((ishape=vcsAuto) and viRounded) or (ishape=vcsRounded);except;end;
end;
//## sethinttime ##
procedure tvirtualcontrol.sethinttime(x:integer);
begin//100ms - Xms
try;ihinttime:=frcmin(x,100);except;end;
end;
//## doonchange ##
procedure tvirtualcontrol.doonchange;
begin
try;fireevent(fonchange,self);except;end;
end;
//## onsystem ##
procedure tvirtualcontrol.onsystem(sender:tobject);
begin
try;readwrite(vs.mode);except;end;
end;
//## setcursor ##
procedure tvirtualcontrol.setcursor(x:tvirtualcursor);
begin
try;icursor:=x;except;end;
end;
//## readwrite ##
procedure tvirtualcontrol.readwrite(mode:tvirtualstoragemode);
begin
//nil
end;
//## new ##
function tvirtualcontrol.new(_type:string;_caption,_tep,_help:string;_align:tvirtualalign;_onclick:tnotifyevent):tvirtualcontrol;
begin
try;if (igui<>nil) then result:=igui.new(_type,_caption,_tep,_help,_align,self,_onclick) else result:=nil;except;end;
end;
//## newb ##
function tvirtualcontrol.newb(_type:string;_caption,_tep,_help:string;_align:tvirtualalign;_onclick:tnotifyevent;_sysptr:integer;_style:tstoragestyle;_default,_range:string):tvirtualcontrol;
begin
try;if (igui<>nil) then result:=igui.newb(_type,_caption,_tep,_help,_align,self,_onclick,_sysptr,_style,_default,_range) else result:=nil;except;end;
end;
//## placeon ##
function tvirtualcontrol.placeon(x:tvirtualcontrol):tvirtualcontrol;
begin
try
result:=x;
if (result<>nil) then result.setup(self);
except;end;
end;
//## _onshortcut ##
function tvirtualcontrol._onshortcut(_shortcut:string):boolean;
begin
try;result:=false;except;end;
end;
//## statefilter ##
procedure tvirtualcontrol.statefilter(var x:tpixelfilter);
begin
try
if (not enabled) then x:=plfDisabled
else if hovering then x:=plfFocused
else if focused then x:=plfFocused
else x:=nil;
except;end;
end;
//## x ##
function tvirtualcontrol.x:integer;//local x
begin
try;if (igui<>nil) then result:=igui.x-isr.left-bordersize else result:=0;except;end;
end;
//## y ##
function tvirtualcontrol.y:integer;//local y
begin
try;if (igui<>nil) then result:=igui.y-isr.top-bordersize else result:=0;except;end;
end;
//## dx ##
function tvirtualcontrol.dx:integer;//local dx
begin
try;if (igui<>nil) then result:=igui.dx-isr.left-bordersize else result:=0;except;end;
end;
//## dy ##
function tvirtualcontrol.dy:integer;//local dy
begin
try;if (igui<>nil) then result:=igui.dy-isr.top-bordersize else result:=0;except;end;
end;
//## screenx ##
function tvirtualcontrol.screenx:integer;
begin
try;if (igui<>nil) then result:=igui.left+isr.left else result:=0;except;end;
end;
//## screeny ##
function tvirtualcontrol.screeny:integer;
begin
try;if (igui<>nil) then result:=igui.top+isr.top else result:=0;except;end;
end;
//## scroll ##
function tvirtualcontrol.scroll(x,y:integer;_notify:boolean):boolean;
begin
try
//defaults
result:=false;
//check
if (x=iscrollx) and (y=iscrolly) then exit;
//process
//.set
iscrollx:=x;
iscrolly:=y;
//.notify
if _notify then scrollchanged;
except;end;
end;
//## setscrollx ##
procedure tvirtualcontrol.setscrollx(x:integer);
begin
try;scroll(x,scrolly,scrollnotify);except;end;
end;
//## setscrolly ##
procedure tvirtualcontrol.setscrolly(x:integer);
begin
try;scroll(scrollx,x,scrollnotify);except;end;
end;
//## scrollchanged ##
procedure tvirtualcontrol.scrollchanged;
begin
try
//update
doalign;
gui.changedsizeb(self,true,false);
//event
fireevent(fonscroll,self);
except;end;
end;
//## inclient ##
function tvirtualcontrol.inclient:boolean;
begin
try
if (igui<>nil) then result:=(x>=0) and (x<clientwidth) and (y>=0) and (y<clientheight)
else result:=false;
except;end;
end;
//## inborder ##
function tvirtualcontrol.inborder:boolean;
begin
try;result:=(igui<>nil) and (bordersize>=1) and ((x<0) or (y<0) or (x>=clientwidth) or (y>=clientheight));except;end;
end;
//## tabset ##
function tvirtualcontrol.tabset(x:integer;a:talignment;y:integer):boolean;
var
   tmp:twrd2;
begin
try
//defaults
result:=false;
//check
if (x>=0) and (x<tabcount) then
   begin
   //range
   y:=frcrange(round(y/viTabRatio),0,maxword);
   //get
   x:=(x*3)+1;
   tmp.val:=word(y);
   //set
   itabs[x+0]:=tabFromalign(a);
   itabs[x+1]:=tmp.chars[0];
   itabs[x+2]:=tmp.chars[1];
   //successful
   result:=true;
   end;//end of if
except;end;
end;
//## tabget ##
function tvirtualcontrol.tabget(x:integer;var a:talignment;var y:integer):boolean;
var
   tmp:twrd2;
begin
try
//defaults
result:=false;
a:=taLeftJustify;
y:=0;
//check
if (x>=0) and (x<tabcount) then
   begin
   //get
   x:=(x*3)+1;
   //set
   a:=tabToalign(itabs[x+0]);
   tmp.chars[0]:=itabs[x+1];
   tmp.chars[1]:=itabs[x+2];
   y:=tmp.val;
   //adjust
   y:=round(y*viTabRatio);
   //successful
   result:=true;
   end;//end of if
except;end;
end;
//## gettabcount ##
function tvirtualcontrol.gettabcount:integer;
begin
try;result:=length(itabs) div 3;except;end;
end;
//## tabFromalign ##
function tvirtualcontrol.tabFromalign(a:talignment):char;
begin
try
if (a=taCenter) then result:=#1
else if (a=taRightJustify) then result:=#2
else result:=#0;//left
except;end;
end;
//## tabToalign ##
function tvirtualcontrol.tabToalign(x:char):talignment;
begin
try
//process
if (x=#1) then result:=taCenter
else if (x=#2) then result:=taRightJustify
else result:=taLeftJustify;
except;end;
end;
//## istabs ##
function tvirtualcontrol.istabs(x:string):boolean;
begin
try;result:=(0=comparetext(copy(x,1,5),'TABS:'));except;end;
end;
//## settabs ##
procedure tvirtualcontrol.settabs(x:string);
var
   tmp:string;
   a:talignment;
   b:twrd2;
   p:integer;
begin
try
//defaults
itabs:='';
itabspace:=0;
p:=1;
//check
if not istabs(x) then exit
else x:=copy(x,6,length(x));
//process
//.filter
general.swapchars(x,',',#10);
//.get
while general.nextline(p,x,tmp) do if (tmp<>'') then
   begin
   //..alignment
   if (tmp[1]='r') or (tmp[1]='R') then a:=taRightJustify
   else if (tmp[1]='c') or (tmp[1]='C') then a:=taCenter
   else a:=taLeftJustify;
   //..position
   b.val:=frcrange(strint(copy(tmp,2,length(tmp))),0,65535);
   //..set
   if (tmp[1]='s') or (tmp[1]='S') then itabspace:=b.val
   else itabs:=itabs+tabFromalign(a)+b.chars[0]+b.chars[1];
   end;//end of if
except;end;
end;
//## gettabs ##
function tvirtualcontrol.gettabs:string;
var
   a:talignment;
   p,b:integer;
   atmp:char;
begin
try
//defaults
result:='';
//process
//.space
result:=result+'TABS:S'+inttostr(itabspace)+',';
//.tabs
for p:=0 to (tabcount-1) do
begin
//.get
tabget(p,a,b);
if (a=taRightJustify) then atmp:='R'
else if (a=taCenter) then atmp:='C'
else atmp:='L';
//.set
result:=result+atmp+inttostr(b)+',';
end;//end of loop
except;end;
end;
//## getalignwidth ##
function tvirtualcontrol.getalignwidth:integer;
begin
try
if (ioWidth=vwsInternal) then result:=_vwsInternal
else if (ioWidth=vwsWidth) then result:=_vwsWidth
else if (ioWidth=vwsClient) then result:=_vwsClient
else if (ioWidth=vwsHost) then result:=_vwsHost
else if (ioWidth=vwsParent) then result:=_vwsParent
else result:=width;
except;end;
end;
//## _vwsInternal ##
function tvirtualcontrol._vwsInternal:integer;
begin
try;result:=_vwsClient;except;end;
end;
//## _vwsWidth ##
function tvirtualcontrol._vwsWidth:integer;
begin//Always returns own width
try;result:=width;except;end;
end;
//## _vwsClient ##
function tvirtualcontrol._vwsClient:integer;
begin
try;result:=frcmin(2+viFontHeight+(2*bordersize),20);except;end;
end;
//## _vwsHost ##
function tvirtualcontrol._vwsHost:integer;
begin
try;result:=frcmin(_vwsClient+(4*bordersize),24);except;end;
end;
//## _vwsParent ##
function tvirtualcontrol._vwsParent:integer;
begin
try
result:=_vwsClient;
if (parent<>nil) then result:=parent.clientwidth;
except;end;
end;
//## getalignheight ##
function tvirtualcontrol.getalignheight:integer;
begin
try
if (ioHeight=vhsInternal) then result:=_vhsInternal
else if (ioHeight=vhsHeight) then result:=_vhsHeight
else if (ioHeight=vhsFont) then result:=_vhsFont
else if (ioHeight=vhsClient) then result:=_vhsClient
else if (ioHeight=vhsUnit) then result:=_vhsUnit
else if (ioHeight=vhsHost) then result:=_vhsHost
else if (ioHeight=vhsParent) then result:=_vhsParent
else if (ioHeight=vhsControls) then result:=_vhsControls
else result:=height;
except;end;
end;
//## _vhsInternal ##
function tvirtualcontrol._vhsInternal:integer;
begin
try;result:=_vhsClient;except;end;
end;
//## _vhsHeight ##
function tvirtualcontrol._vhsHeight:integer;
begin//Always returns own height
try;result:=height;except;end;
end;
//## _vhsFont ##
function tvirtualcontrol._vhsFont:integer;
begin
try;result:=frcmin(viFontHeight,14);except;end;
end;
//## _vhsClient ##
function tvirtualcontrol._vhsClient:integer;
begin//assumes a bordersize of 1 or more (even if zero)
try;result:=frcmin(2+viFontHeight+(2*frcmin(bordersize,1)),20);except;end;
end;
//## _vhsUnit ##
function tvirtualcontrol._vhsUnit:integer;
begin//assumes a bordersize of 1 or more (even if zero)
try
case oVariableheight of
true:result:=height;
false:result:=frcmin(hunits,1)*_vhsClient;
end;//end of case
except;end;
end;
//## _vhsHost ##
function tvirtualcontrol._vhsHost:integer;
begin//assumes a bordersize of 1 or more (even if zero)
try;result:=frcmin(_vhsClient+(4*frcmin(bordersize,1)),24);except;end;
end;
//## _vhsParent ##
function tvirtualcontrol._vhsParent:integer;
begin
try
result:=_vhsClient;
if (parent<>nil) then result:=parent.clientheight;
except;end;
end;
//## _vhsControls ##
function tvirtualcontrol._vhsControls:integer;//12OCT2007
begin
try
//defaults
result:=0;
//get - controls must be aligned, especially for those that have yet to be displayed so correct and upto date calculations are performed
doalign;
//set
if (bottommost<>nil) then result:=frcmin(bottommost.top+bottommost.getalignheight,0);
except;end;
end;
//## gettimer ##
function tvirtualcontrol.gettimer:integer;
begin
try;result:=general.aorb(0,round(mt.interval[itimer]),itimer<>mtNilTimer);except;end;
end;
//## settimer ##
procedure tvirtualcontrol.settimer(x:integer);
begin
try
//check
if (sysstate>=ssClosed) then exit;
//process
//.delete
if (x<=0) and (itimer<>mtNilTimer) then mt.del(itimer)
else if (x>0) then
   begin
   //.new
   if (itimer=mtNilTimer) then itimer:=mt.new(_ontimer,x,true)
   //.adjust
   else mt.interval[itimer]:=x;
   end;//end of if
except;end;
end;
//## _ontimer ##
procedure tvirtualcontrol._ontimer(sender:tobject);
begin
//nil
end;
//## setautoclick ##
procedure tvirtualcontrol.setautoclick(x:integer);
var
   ok:boolean;
begin
try
//.stop
if (x=0) and (iautoclick>=1) then
   begin
   freeobj(@imt);
   iautoclick:=x;
   realign(true);
   fireevent(fonautoclick,self);
   click;
   end
//.start
else if (x>=1) and (iautoclick=0) and (sysstate<=ssClosing) then
   begin
   iautoclick:=x;
   realign(true);
   if (imt=nil) then
      begin
      imt:=tmt.create;
      (imt as tmt).new(_onactimer,1000,true);
      end;//end of if
   fireevent(fonautoclick,self);
   end
//.adjust
else if (x>=1) and (iautoclick>=1) then
   begin
   ok:=(parent<>nil) and (x>iautoclick);
   iautoclick:=x;
   realign(true);
   fireevent(fonautoclick,self);
   end;//end of if
except;end;
end;
//## _onactimer ##
procedure tvirtualcontrol._onactimer(sender:tobject);
begin
try;autoclick:=autoclick-1;except;end;
end;
//## setnormal ##
procedure tvirtualcontrol.setnormal(x:boolean);
begin
try
if (x<>normal) then
   begin
   if x then ipinfo:=@viNormal else ipinfo:=@viTitle;
   update;
   end;//end of if
except;end;
end;
//## getnormal ##
function tvirtualcontrol.getnormal:boolean;
begin
try;result:=(ipinfo=@viNormal);except;end;
end;
//## setstyle ##
procedure tvirtualcontrol.setstyle(x:tvirtualstyle);
begin
try
if (x<>istyle) then
   begin
   //set
   istyle:=x;
   //paint
   paint;
   end;//end of if
except;end;
end;
//## canfocus ##
function tvirtualcontrol.canfocus:boolean;
begin
try;result:=(self<>nil) and (not destroying) and (vlsFocus in istyle) and visible and enabled and (not hold);except;end;
end;
//## focused ##
function tvirtualcontrol.focused:boolean;
begin
try
result:=
(canfocus and (igui<>nil) and (igui.focuscontrol=self)) or
(igroupfocus and (parent<>nil) and parent.focused);
except;end;
end;
//## canhover ##
function tvirtualcontrol.canhover:boolean;
begin
try;result:=(not idestroying) and (vlsHover in istyle) and visible and enabled and (not hold);except;end;
end;
//## hovering ##
function tvirtualcontrol.hovering:boolean;
begin
try
result:=
(canhover and (igui<>nil) and (igui.hovercontrol=self)) or
(igroupfocus and (parent<>nil) and parent.hovering);
except;end;
end;
//## down ##
function tvirtualcontrol.down:boolean;
begin//aDownrelaxed=FALSE then cursor must actually be within control's area to trigger "DOWN" status, required for "GROUPFOCUS" situations
try;result:=igui.down and focused and (aDownrelaxed or ((x>=0) and (y>=0) and (x<clientwidth) and (y<clientheight)));except;end;
end;
//## getcaption ##
function tvirtualcontrol.getcaption:string;
begin
try;result:=icaption;except;end;
end;
//## setcaption ##
procedure tvirtualcontrol.setcaption(x:string);
begin
try
if general.setstring(x,icaption) then
   begin
   //accelerator
   akey:=menus.extractAKEY(x);
   //paint
   paint;
   end;//end of if
except;end;
end;
//## getvcaption ##
function tvirtualcontrol.getvcaption:string;
begin
try;result:=caption+general.insstr(' ['+inttostr(iautoclick)+']',iautoclick>=1);except;end;
end;
//## canclick ##
function tvirtualcontrol.canclick:boolean;//02FEB2008
begin
try;result:=igui.ismouse and (igui.act=aUp) and (igui.key=mLeft) and igui.ptinrect(igui.x,igui.y,isrv);except;end;
end;
//## click ##
procedure tvirtualcontrol.click;
begin
try
if enabled then
   begin
   //.focus
   if not focused then igui.focuscontrol:=self;
   //.modal or wait
   if (oModalresult<>mrNONE) and (igui.showingmodal or igui.showingwait) then igui.showclose(oModalresult);
   //.click
   fireevent(fonclick,self);
   //.dblclick
   if ((ms64-ilastclicktime)<500) and general.nrw(x,ilastclickpt.x,5) and general.nrw(y,ilastclickpt.y,5) then dblclick;
   ilastclicktime:=ms64;
   ilastclickpt:=point(x,y);
   end;//end of if
except;end;
end;
//## dblclickcancel ##
procedure tvirtualcontrol.dblclickcancel;
begin
try;ilastclicktime:=ms64-9999;except;end;
end;
//## dblclick ##
procedure tvirtualcontrol.dblclick;
begin
try
if enabled then
   begin
   //.focus
   if not focused then igui.focuscontrol:=self;
   //.click
   fireevent(fondblclick,self);
   end;//end of if
except;end;
end;
//## _onrepeat ##
procedure tvirtualcontrol._onrepeat(sender:tobject);
begin
try;fireevent(fonrepeat,self);except;end;
end;
//## _onwheelv ##
procedure tvirtualcontrol._onwheelv(sender:tobject);
begin
try;fireevent(fonwheelv,self);except;end;
end;
//## _onnotify ##
procedure tvirtualcontrol._onnotify(sender:tobject);
begin
try
//click
if canclick then click;
//paint on mousedown/mouseup (for focusable items only)
if fUpdnpaint and igui.ismouse and ((vlsFocus in style) or igroupfocus) and ((igui.act=aDown) or (igui.act=aUp)) then paint;
//event
fireevent(fonnotify,self);
except;end;
end;
//## _onstate ##
procedure tvirtualcontrol._onstate(sender:tobject);//for detecting change in "shift,alt and ctrl"
begin
//nil
end;
//## getscr ##
function tvirtualcontrol.getscr:trect;
begin
try;if (ibordersize<=0) then result:=isr else result:=rect(isr.left+ibordersize,isr.top+ibordersize,isr.right-ibordersize,isr.bottom-ibordersize);except;end;
end;
//## getscrv ##
function tvirtualcontrol.getscrv:trect;
begin
try;if (ibordersize<=0) then result:=isrv else result:=rect(isrv.left+ibordersize,isrv.top+ibordersize,isrv.right-ibordersize,isrv.bottom-ibordersize);except;end;
end;
//## update ##
procedure tvirtualcontrol.update;
begin
try;updateb(false);except;end;
end;
//## updateb ##
procedure tvirtualcontrol.updateb(recurs:boolean);
begin
try;paintb(recurs);except;end;
end;
//## _onpaintborder ##
procedure tvirtualcontrol._onpaintborder(sender:tobject;canvas:tcanvas);
begin
try
if assigned(fonpaintborder) then fonpaintborder(self,canvas)
else
   begin
   canvas.brush.color:=canvas.pen.color;
   canvas.fillrect(area);
   end;//end of if
except;end;
end;
//## _onpaint ##
procedure tvirtualcontrol._onpaint(sender:tobject;canvas:tcanvas);
var
   a:tsize;
   tmp:string;
begin
try
//paint
if assigned(fonpaint) then fonpaint(self,canvas)
else
   begin
   //calc
   tmp:=vcaption;
   //cls
   canvas.fillrect(clientrect);
   //text
   canvas.brush.style:=bsClear;
   draws.drawtabs(self,canvas,dwtbX,0,tmp);
   end;//end of if
except;end;
end;
//## canpaint ##
function tvirtualcontrol.canpaint:boolean;
begin
try;result:=(vs.mode=vsmNone) and (not locked) and igui.paintallowed and showing;except;end;
end;
//## lock ##
procedure tvirtualcontrol.lock;
begin
try;inc(ilockcount);except;end;
end;
//## unlock ##
procedure tvirtualcontrol.unlock;
begin
try;unlockb(true);except;end;
end;
//## unlockb ##
procedure tvirtualcontrol.unlockb(_paint:boolean);
begin
try
dec(ilockcount);
if (ilockcount=0) and _paint then paint;
except;end;
end;
//## locked ##
function tvirtualcontrol.locked:boolean;
begin
try;result:=(ilockcount<>0) or ((parent<>nil) and parent.locked);except;end;
end;
//## paint ##
procedure tvirtualcontrol.paint;
begin
try;paintb(false);except;end;
end;
//## paintb ##
procedure tvirtualcontrol.paintb(recurs:boolean);
begin
try
//check
if not canpaint then exit;
//process
if (not locked) then igui.paintfrom(self,recurs);
except;end;
end;
//## showing ##
function tvirtualcontrol.showing:boolean;
var
   x:tvirtualcontrol;
begin
try
//defaults
result:=false;
x:=self;
//process
while TRUE do
begin
if (x=iroot) then
   begin
   result:=iroot.visible;
   break;
   end
else if (x<>nil) then
   begin
   if (not x.visible) then break
   else if (x.parent=nil) then break
   else x:=x.parent;
   end
else break;
end;//end of loop
except;end;
end;
//## setbordersize ##
procedure tvirtualcontrol.setbordersize(x:integer);
begin
try
//range
x:=frcrange(x,0,10);
//set
if (x<>ibordersize) then
   begin
   ibordersize:=x;
   igui.changedsize(self);
   end;//end of if
except;end;
end;
//## setparent ##
procedure tvirtualcontrol.setparent(x:tvirtualcontrol);
var
   old:tvirtualcontrol;
begin
try
//check
if (x=self) then exit;
//process
if (iparent<>x) then
   begin
   //.delete old
   old:=iparent;
   if (iparent<>nil) then iparent.controls.del(self);
   //.add new
   if (x<>nil) then x.controls.add(self,true);
   //.set
   iparent:=x;
   //.repaint
   if (old<>nil) then old.realign(true);
   if (iparent<>nil) then iparent.realign(true);
   end;//end of if
except;end;
end;
//## setleft ##
procedure tvirtualcontrol.setleft(x:integer);
begin
try;setbounds(x,itop,iwidth,iheight);except;end;
end;
//## settop ##
procedure tvirtualcontrol.settop(x:integer);
begin
try;setbounds(ileft,x,iwidth,iheight);except;end;
end;
//## setwidth ##
procedure tvirtualcontrol.setwidth(x:integer);
begin
try;setbounds(ileft,itop,x,iheight);except;end;
end;
//## setheight ##
procedure tvirtualcontrol.setheight(x:integer);
begin
try;setbounds(ileft,itop,iwidth,x);except;end;
end;
//## setboundsb ##
function tvirtualcontrol.setboundsb(_left,_top,_width,_height:integer):boolean;
begin
try;result:=setboundsex(_left,_top,_width,_height,false);except;end;
end;
//## setboundsex ##
function tvirtualcontrol.setboundsex(_left,_top,_width,_height:integer;_forceupdate:boolean):boolean;
begin
try
//defaults
result:=false;
//range
if (_width<0) then _width:=0;
if (_height<0) then _height:=0;
//set
result:=_forceupdate or (ileft<>_left) or (itop<>_top) or (iwidth<>_width) or (iheight<>_height) or dimensionsmodified or (height<>getalignheight);
if result then
   begin
   //.set
   ileft:=_left;
   itop:=_top;
   iwidth:=_width;
   iheight:=_height;
   //.event
   fireevent(fonresize,self);
   //.doalign
   doalign;
   //.reset
   dimensionsmodified:=false;
   end;//end of if
except;end;
end;
//## setbounds ##
function tvirtualcontrol.setbounds(_left,_top,_width,_height:integer):boolean;
begin
try
result:=setboundsb(_left,_top,_width,_height);
if result then igui.changedsize(self);
except;end;
end;
//## getclientrect ##
function tvirtualcontrol.getclientrect:trect;
begin
try;result:=rect(0,0,frcmin(iwidth-2*ibordersize,0),frcmin(iheight-2*ibordersize,0));except;end;
end;
//## getclientwidth ##
function tvirtualcontrol.getclientwidth:integer;
begin
try;result:=frcmin(iwidth-2*ibordersize,0);except;end;
end;
//## getclientheight ##
function tvirtualcontrol.getclientheight:integer;
begin
try;result:=frcmin(iheight-2*ibordersize,0);except;end;
end;
//## getarea ##
function tvirtualcontrol.getarea:trect;
begin
try;result:=getareab(0,0);except;end;
end;
//## getareab ##
function tvirtualcontrol.getareab(x,y:integer):trect;
begin
try;result:=rect(x,y,x+iwidth,y+iheight);except;end;
end;
//## setvisible ##
procedure tvirtualcontrol.setvisible(x:boolean);
begin
try
if (x<>ivisible) then
   begin
   ivisible:=x;
   //active
   igui.checkfocuscontrol;
   //repaint
   if oPaintonvisible then igui.paintfrom(parent,true);
   end;//end of if
except;end;
end;
//## getenabled ##
function tvirtualcontrol.getenabled:boolean;
begin
try;result:=ienabled and ((parent=nil) or (parent.enabled));except;end;
end;
//## setenabled ##
procedure tvirtualcontrol.setenabled(x:boolean);
begin
try
if (x<>ienabled) then
   begin
   ienabled:=x;
   //active
   igui.checkfocuscontrol;
   //repaint
   igui.paintfrom(self,true);
   end;//end of if
except;end;
end;
//## realign ##
procedure tvirtualcontrol.realign(_paint:boolean);
begin
try
//check
if idestroying then exit;
//process
if (parent<>nil) then
   begin
   //.size all children controls (with inside parent)
   parent.doalign;
   //.update system - update screen rect's
   igui.changedsizeb(parent,false,true);
   //.paint
   if _paint and (not igui.lockalign) then igui.paintfrom(parent,true);
   end
else
   begin
   //.size all children controls (with inside parent)
   doalign;
   //.update system - update screen rect's
   igui.changedsizeb(self,false,true);
   //.paint
   if _paint and (not igui.lockalign) then igui.paintfrom(self,true);
   end;//end of if
except;end;
end;
//## canalign ##
function tvirtualcontrol.canalign:boolean;
begin
try;result:=(not idestroying) and (not igui.lockalign);except;end;
end;
//## setaligns ##
procedure tvirtualcontrol.setaligns(x:tvirtualalign);
var
   z:tvirtualcontrol;
   p:integer;
begin
try
for p:=0 to (icontrols.count-1) do
begin
z:=icontrols.items[p];
if (z<>nil) then z.align:=x;
end;//end of loop
except;end;
end;
//## doalign ##
procedure tvirtualcontrol.doalign;
begin
try;doalignb(0);except;end;
end;
//## doalignb ##
procedure tvirtualcontrol.doalignb(leftpad:integer);
var//Note: scrollY tested/passed, scrollX=not tested
   //Now supports "leftpad" (left margin) as of 30-NOV-2006.
   //as of 03-DEC-2006
   z:tvirtualcontrol;
   junkH,ch,cw,btmY,am,tmpW,tmpH,c,maxp,op,p,x,y,maxh:integer;
   allowvarWH,dforce:boolean;
begin
try
//check
if not canalign then exit;
//defaults
maxp:=icontrols.count-1;
ibottommost:=nil;
btmY:=iscrolly;
cw:=clientwidth-leftpad;
ch:=clientheight;
//check
if (maxp<0) then exit;
//process
//valTOP
y:=iscrolly;
for p:=0 to maxp do
begin
//.get
z:=icontrols.items[p];
//.set
if (z<>nil) and (z.align=valTop) and z.visible and (not z.hold) then
   begin
   //.get
   am:=z.alignmargin;
   //.set
   inc(y,am+z.valignsep);
   tmpH:=z.alignheight;
   z.setboundsex(am,y,cw-2*am,tmpH,true);
   //.special case - must repeat ALIGN for "tvirtualgrid", figures changed based on it's new width
   if (z is tvirtualgrid) then
      begin
      //.retry #1
      junkH:=z.alignheight;
      if (tmpH<>junkH) then
         begin
         tmpH:=junkH;
         z.setboundsex(leftpad+am,y,cw-2*am,tmpH,true);
         //.retry #2
         junkH:=z.alignheight;
         if (tmpH<>junkH) then
            begin
            tmpH:=junkH;
            z.setboundsex(leftpad+am,y,cw-2*am,tmpH,true);
            end;//end of if
         end;//end of if
      end;//end of if
   //.inc Y
   btmY:=y;
   inc(y,tmpH+am+z.alignsep);
   ibottommost:=z;
   end;//end of if
end;//end of loop

//valLEFT - 22SEP2007: supports "oVariableWidth and parent.oVariableWidths", which prevents "valLeft" from wrapping to next line, and first control that has ".oVariableWidth=TRUE" fill the remaining area on the line
allowvarWH:=false;
for p:=0 to maxp do
   begin
   z:=icontrols.items[p];
   if (z<>nil) and (z.align=valLeft) and z.visible and (not z.hold) and z.oVariableWidth then
      begin
      allowvarWH:=true;
      break;
      end;//end of if
   end;//end of loop
c:=0;
x:=iscrollx;
maxh:=0;
for p:=0 to maxp do
begin
//.get
z:=icontrols.items[p];
//.set
if (z<>nil) and (z.align=valLeft) and z.visible and (not z.hold) then
   begin
   //.get
   am:=z.alignmargin;
   tmpW:=frcmax(general.aorb(z.alignwidth,cw-2*am-x,z.oVariablewidth),cw-2*am);
   tmpH:=frcmax(z.alignheight+z.valignsep,ch-2*am);
   //.vwsWidth
   if (z.oWidth=vwsWidth) then tmpW:=frcmin(tmpW,z.width);
   //.vhsHeight
   if (z.oHeight=vhsHeight) then tmpH:=frcmin(tmpH,z.height);
   //.inc
   inc(x,am);
   //.inc Y
   if (c<>0) and ((x+tmpW)>(cw-2*am)) and (not allowvarWH) then
      begin
      btmY:=y;
      x:=iscrollx+am;
      inc(y,maxh);
      maxh:=0;
      end;//end of if
   //.set
   z.setboundsex(leftpad+x,y+am+z.valignsep,tmpW,tmpH,true);
   //.maxy
   if (tmpH>maxh) then maxh:=tmpH;
   //.inc X
   inc(x,tmpW+am+z.alignsep);
   //.bottommost
   if (ibottommost=nil) then ibottommost:=z
   else if ((z.top+z.height)>(ibottommost.top+ibottommost.height)) then ibottommost:=z;
   //.inc C
   inc(c);
   end;//end of if
end;//end of loop
inc(y,maxh);

//valRIGHT - Does not yet support "oVariableWidth" etc as above with "valLeft"
allowvarWH:=false;
for p:=0 to maxp do
   begin
   z:=icontrols.items[p];
   if (z<>nil) and (z.align=valRight) and z.visible and (not z.hold) and z.oVariableWidth then
      begin
      allowvarWH:=true;
      break;
      end;//end of if
   end;//end of loop
c:=0;
x:=iscrollx+cw;
maxh:=0;
for op:=0 to maxp do
begin
if ovalRightReverse then p:=maxp-op else p:=op;
//.get
z:=icontrols.items[p];
//.set
if (z<>nil) and (z.align=valRight) and z.visible and (not z.hold) then
   begin
   //.get
   am:=z.alignmargin;
   tmpW:=frcmax(general.aorb(z.alignwidth,frcmin(x-2*am,0),z.oVariablewidth),cw-2*am);
   tmpH:=frcmax(z.alignheight+z.valignsep,ch-2*am);
   //.vwsWidth
   if (z.oWidth=vwsWidth) then tmpW:=frcmin(tmpW,z.width);
   dec(x,am);
   //.vhsHeight
   if (z.oHeight=vhsHeight) then tmpH:=frcmin(tmpH,z.height);
   //.inc Y
   if (c<>0) and ((x-tmpW)<(0+am)) and (not allowvarWH) then
      begin
      btmY:=y;
      x:=iscrollx+cw-am;
      inc(y,maxh);
      maxh:=0;
      end;//end of if
   //.set
   z.setboundsex(leftpad+x-tmpW,y+am+z.valignsep,tmpW,tmpH,true);
   //.maxy
   if (tmpH>maxh) then maxh:=tmpH;
   //.dec X
   dec(x,tmpW+am+z.alignsep);
   //.bottommost
   if (ibottommost=nil) then ibottommost:=z
   else if ((z.top+z.height)>(ibottommost.top+ibottommost.height)) then ibottommost:=z;
   //.inc C
   inc(c);
   end;//end of if
end;//end of loop
inc(y,maxh);
//.last (align client)
if (ibottommost<>nil) and oAllowvariableheights then
   begin
   y:=btmY;
   if bottommost.oVariableheight then
      begin
      dforce:=(ibottommost.left<>0) or (ibottommost.top<>y) or
              (ibottommost.width<>cw) or (ibottommost.height<>ch-y);
      ibottommost.setboundsex(leftpad+0,y,cw,ch-y,dforce);
      end;//end of if
   end;//end of if
except;end;
end;

//## tmanaged ##################################################################
//## create ##
constructor tmanaged.create(_gui:tvirtualform;_sysptr:integer;_vars:string);
var
   pages:tvirtualpages;
   pageid:integer;
   pagetmp:tvirtualpage;
begin
//self
inherited create(_gui);
bordersize:=0;
height:=250;
//check
sysptr:=_sysptr;
if (sysptr<=vsNil) then showerror60(ntranslate(gecIndexOutOfRange));
//range - swap "sep" for #10 return codes
ivars:=tdynamictext.create;
if (length(_vars)>=1) and (_vars[1]<>#10) then general.swapchars(_vars,_vars[1],#10);
ivars.text:=_vars;
ivars.vars.debug:=true;
ivars.vars.debugtitle:=classname;
end;
//## createfinished ##
procedure tmanaged.createfinished;
begin
try;freeobj(@ivars);except;end;
end;
//## destroy ##
destructor tmanaged.destroy;
begin
try
//init
destroyinit;
//controls
freeobj(@ivars);
//self
inherited
except;end;
end;

//## tvirtualprogress ##########################################################
//## create ##
constructor tvirtualprogress.create(_gui:tvirtualform);
begin
//self
inherited create(_gui);
//defaults
buffer:=true;
ishowtext:=true;
style:=[];
iprogress:=1;
progress:=0;
timer:=100;//10 paints/second
end;
//## _ontimer ##
procedure tvirtualprogress._ontimer(sender:tobject);
begin
try;if showing and imustpaint then paint;except;end;
end;
//## setshowtext ##
procedure tvirtualprogress.setshowtext(x:boolean);
begin
try;if general.setbol(x,ishowtext) then paint;except;end;
end;
//## setprogress ##
procedure tvirtualprogress.setprogress(x:single);
var
   tmp:string;
begin
try
//range
if (x<0) then x:=0
else if (x>100) then x:=100;
//process
if (x<>iprogress) then
   begin
   iprogress:=x;
   tmp:=general.percentage(x,true);
   if (tmp<>iprogresscaption) then
      begin
      iprogresscaption:=tmp;
      imustpaint:=true;
      end;//end of if
   end;//end of if
except;end;
end;
//## _onpaint ##
procedure tvirtualprogress._onpaint(sender:tobject;canvas:tcanvas);
var
   tmp:string;
   w,x,y:integer;
begin
try
//reset
imustpaint:=false;
//cls
canvas.fillrect(clientrect);
//color
if (iprogress>0) then ccs.drect(canvas,ccs.rectgrow(rect(0,0,round(clientwidth*iprogress) div 100,clientheight),1),info^.highlight,info^.highlight,rounded);
//text
if ishowtext then
   begin
   //.get
   tmp:=iprogresscaption;
   w:=info^.fontmap.textwidth(tmp);
   x:=(clientwidth-w) div 2;
   y:=(clientheight-info^.fontmap.maxH) div 2;
   //.draw
   ccs.inverttext(canvas,x,y,w,info^.fontmap.maxH,tmp);
   end;//end of if
except;end;
end;

//## tvirtualpanelserver #######################################################
//## create ##
constructor tvirtualpanelserver.create(_gui:tvirtualform;_caption:string);
begin
//self
inherited create(_gui);
bordersize:=0;
oHeight:=vhsControls;
//vars
tsSpecifiedportinusetryanother:=translate('Specified port in use, try another');
//controls
ititle:=new('titlesmall',general.udv(_caption,ntranslate('server information')),'',rthtranslate('Server information/statistics'),valTop,nil) as tvirtualtitle;
ilogfolder:=gui.newlink(ntranslate('all logs'),tepFolder20,rthtranslate('Display Program specific log Folder'),__onclick);
itra:=gui.newlink(ntranslate('traffic')+#32+ntranslate('information'),tepView20,rthtranslate('View current Traffic Information (plain text)'),__onclick);
iban:=gui.newlink(ntranslate('banned')+#32+ntranslate('log'),tepView20,rthtranslate('View current Banned log (plain text)'),__onclick);
ilog:=gui.newlink(ntranslate('log'),tepView20,rthtranslate('View current Activity log (plain text)'),__onclick);
iinfo:=new('rows','','',ititle.help,valTop,nil) as tvirtualrows;
iinfo.itemlimit:=4;
iinfo.tabs:='TABS:S5,L0,L150';
//defaults
timer:=1000;
doinfo;
end;
//## __onclick ##
procedure tvirtualpanelserver.__onclick(sender:tobject);
begin
try
//process
if (iserver<>nil) then
   begin
   if (sender=ilog) then rawlog.view
   else if (sender=iban) then rawlog.viewban
   else if (sender=itra) then rawlog.viewtraffic
   else if (sender=ilogfolder) then rawlog.viewfolder;
   end;//end of if
except;end;
end;
//## _ontimer ##
procedure tvirtualpanelserver._ontimer(sender:tobject);
begin
try;doinfo;except;end;
end;
//## setserver ##
procedure tvirtualpanelserver.setserver(x:tobject);
begin
try
if (x<>iserver) then
   begin
   iserver:=x;
   doinfo;
   end;//end of if
except;end;
end;
//## getstatus ##
function tvirtualpanelserver.getstatus:string;
begin
try;result:=iinfo.items.text;except;end;
end;
//## doinfo ##
procedure tvirtualpanelserver.doinfo;
label
   skipstatus;
var
   a:tserverbasic;
   b:tserverudp;
   d:tudppackets;
   e:tudpbasic;
   _status,v,tmp:string;
   c:currency;
   pos,tmph,cp,cm:integer;
   portbusy,ok:boolean;
begin
try
//defaults
tmp:='';
//process
//.server
_status:='';
portbusy:=false;
a:=nil;
b:=nil;
d:=nil;
e:=nil;
tmph:=0;
if (iserver<>nil) then
   begin
   if (iserver is tserverbasic) then a:=(iserver as tserverbasic)
   else if (iserver is tserverudp) then b:=(iserver as tserverudp)
   else if (iserver is tudppackets) then
      begin
      d:=(iserver as tudppackets);
      _status:=d.status;
      end
   else if (iserver is tudpbasic) then
      begin
      e:=(iserver as tudpbasic);
      _status:=e.status;
      end;//end of if
   end;//end of if
if (_status<>'') then goto skipstatus;
//.info
c:=0;
cp:=0;
cm:=0;
if (a<>nil) then
   begin
   portbusy:=a.portbusy;
   general.croll(c,a.sendbytes);
   general.croll(c,a.recvbytes);
   cp:=a.connactivepeak(true);
   cm:=a.maxconn;
   end
else if (b<>nil) then
   begin
   general.croll(c,b.sendbytes);
   general.croll(c,b.recvbytes);
   end;//end of if
//..address
if (a<>nil) then v:=_strip(machine_ip)+':'+general.aorbstr('?',inttostr(a.port),a.online)+' / '+general.aorbstr(tsOffline,tsOnline,a.online)
else if (b<>nil) then v:=_strip(machine_ip)+':'+general.aorbstr('?',inttostr(b.port),b.online)+' / '+general.aorbstr(tsOffline,tsOnline,b.online)
else v:=tsOffline;
if portbusy and iflashok then v:=v+' - '+tsSpecifiedportinusetryanother;
tmp:=tmp+tsAddress+#9+v+rcode;
//..hits
if (a<>nil) then v:=general.curcomma(a.hits)
else if (b<>nil) then v:=general.curcomma(b.hits)
else if (d<>nil) then v:=general.curcomma(d.hits)
else v:='0';
tmp:=tmp+tsHits+#9+v+rcode;
//..bandwidth
tmp:=tmp+tsBandwidth+#9+general.curcomma(c)+#32+lowercase(tsBytes)+rcode;
//..connections (does not apply to UDP servers)
if (a<>nil) then tmp:=tmp+tsConnections+#9+general.thousands(cp)+' / '+general.thousands(cm)+rcode;
//..additional status
skipstatus:
if (_status<>'') then tmp:=tmp+_status;
//.set
tmph:=general.linecount(tmp);
if (iinfo.itemlimit<>tmph) then iinfo.itemlimit:=tmph;
if (tmp<>iinfo.items.text) and ((tmp+rcode)<>iinfo.items.text) then iinfo.items.text:=tmp;
//buttons
ok:=(a<>nil) or (b<>nil);
ilog.enabled:=(showLOG or ok) and rawlog.canview;
iban.enabled:=(showBAN or ok) and rawlog.canviewban;
itra.enabled:=(showTRA or ok) and rawlog.canviewtraffic;
ilogfolder.enabled:=showLOG or showBAN or ok;
//.visible
ok:=(d=nil) and (e=nil);
ilog.visible:=ok or showLOG;
iban.visible:=ok or showBAN;
itra.visible:=ok or showTRA;
ilogfolder.visible:=(ilog.visible or iban.visible or itra.visible);
//inc
iflashok:=not iflashok;
except;end;
end;

//## tvirtualchart #############################################################
//## create ##
constructor tvirtualchart.create(_gui:tvirtualform);
var
   p:integer;
begin
//self
inherited create(_gui);
//vars
buffer:=true;
istyle:=[vcsHorzLines,vcsVertLines,vcsMarks,vcsFill];
imovement:=vcmScrollLeft;
itext:='';
ilv:=high(ivalues);
for p:=0 to high(ivalues) do ivalues[p]:=0;
imarkpos:=0;
imaxvalue:=100;
end;
//## setstyle ##
procedure tvirtualchart.setstyle(x:tvirtualchartstyle);
begin
try
if (x<>istyle) then
   begin
   istyle:=x;
   paint;
   end;//end of if
except;end;
end;
//## setmovement ##
procedure tvirtualchart.setmovement(x:tvirtualchartmovement);
begin
try
if (x<>imovement) then
   begin
   imovement:=x;
   paint;
   end;//end of if
except;end;
end;
//## clear ##
procedure tvirtualchart.clear;
var
   p:integer;
begin
try
for p:=0 to high(ivalues) do ivalues[p]:=0;
paint;
except;end;
end;
//## setmaxvalue ##
procedure tvirtualchart.setmaxvalue(x:integer);
begin
try
x:=frcmin(x,1);
if (x<>imaxvalue) then
   begin
   imaxvalue:=x;
   paint;
   end;//end of if
except;end;
end;
//## pushvalue ##
procedure tvirtualchart.pushvalue(x:integer);
begin
try;pushvalueb(x,-1);except;end;
end;
//## pushvalueb ##
procedure tvirtualchart.pushvalueb(x,_segvalue:integer);
var
   tmp,p:integer;
begin
try
//process
//.shift up one
for p:=high(ivalues) downto 1 do ivalues[p]:=ivalues[p-1];
//.set
ivalues[0]:=x;
isegvalue:=_segvalue;
//.imarkpos - keep sync.ed
tmp:=imarkpos-1;
if (tmp<0) then tmp:=ilv;
imarkpos:=tmp;
//.paint
paint;
except;end;
end;
//## _onpaint ##
procedure tvirtualchart._onpaint(sender:tobject;canvas:tcanvas);
var
   sy,ox,bx,sx2,sx,sw,gw,w,h,v,p:integer;
   z:string;
begin
try
//setup
h:=clientheight;
w:=clientwidth;
if (vcsMini in istyle) then
   begin
   sw:=16;
   gw:=frcmin(w-sw,1);
   end
else
   begin
   sw:=0;
   gw:=w;
   end;//end of if
z:=vcaption+itext;
//process
//.cls
canvas.fillrect(clientrect);
//.points
if (vcmScrollRight=imovement) and (sw>=1) then ox:=sw else ox:=0;
for p:=0 to ilv do
begin
if (vcmScrollRight=imovement) then iv[ilv-p].x:=ox+round(p*(gw/ilv)) else iv[p].x:=ox+round(p*(gw/ilv));
iv[p].y:=h-round(h*(frcrange(ivalues[ilv-p],0,imaxvalue)/imaxvalue));
end;//end of loop
if (vcmScrollRight=imovement) then iv[ilv-p].x:=ox+-1 else iv[0].x:=ox+-1;
iv[-1].x:=iv[0].x;
iv[-1].y:=h;
iv[ilv+1].x:=iv[ilv].x;
iv[ilv+1].y:=h;
//.lines
if (vcsHorzLines in istyle) then
   begin
   v:=h div 2;canvas.moveto(0,v);canvas.lineto(w,v);
   v:=h div 4;canvas.moveto(0,v);canvas.lineto(w,v);
   v:=round(h*0.75);canvas.moveto(0,v);canvas.lineto(w,v);
   end;//end of if
//.draw
if (vcsFill in istyle) then
   begin
   canvas.brush.color:=info^.highlight;
   canvas.polygon(iv);
   canvas.polyline(iv);
   end;//end of if
//.marks
if (vcsMarks in istyle) then
   begin
   for p:=0 to ilv do
   begin
   canvas.moveto(iv[p].x,h-5);
   canvas.lineto(iv[p].x,h);
   end;//end of loop
   end;//end of if
//.markpos x2
if (vcsVertLines in istyle) then
   begin
   canvas.moveto(iv[imarkpos].x,0);
   canvas.lineto(iv[imarkpos].x,h);
   p:=imarkpos+((ilv+1) div 2);
   if (p<0) then p:=p+ilv
   else if (p>ilv) then p:=p-ilv;
   if (p>=0) and (p<=ilv) then
      begin
      canvas.moveto(iv[p].x,0);
      canvas.lineto(iv[p].x,h);
      end;//end of if
   end;//end of if
//.segvalue
if (vcsMini in istyle) and (sw>=1) then
   begin
   //.sep
   if (vcmScrollRight=imovement) then
      begin
      sx:=0;
      sx2:=sw;
      bx:=sx2;
      end
   else
      begin
      bx:=gw;
      sx:=gw+1;
      sx2:=gw+sw;
      end;//end of if
   canvas.moveto(bx,0);
   canvas.lineto(bx,h);
   //.bar
   canvas.brush.color:=canvas.pen.color;
   sy:=h-round(h*(frcrange(isegvalue,0,imaxvalue)/imaxvalue));
   canvas.fillrect(rect(sx,sy,sx2,h));
   //.top of bar
   canvas.moveto(sx,sy);
   canvas.lineto(sx2,sy);
   end;//end of if
//.text
if (z<>'') then
   begin
   canvas.brush.style:=bsClear;
   canvas.textout(1,0,z);
   end;//end of if
except;end;
end;

//## tvirtualhead ##############################################################
//## create ##
constructor tvirtualhead.create(_gui:tvirtualform);
const
   sp=3;
begin
//self
inherited create(_gui);
oHeight:=vhsInternal;
//vars
iimage:=tvirtualbitmapanimated.create(self);
normal:=false;
buffer:=true;
cursor:=vcLink;
fBackground:=false;//simple focused/not focused coloring method
//controls
//.close
iclose:=new('toolbut','',vimClose,rthtranslate('Shutdown program'),valRight,_onclick) as tvirtualbutton;
iclose.alignmargin:=sp;
iclose.alignsep:=0;//-sp+1;
iclose.hint:=ntranslate('Close');
iclose.buffer:=buffer;
iclose.oHeight:=vhsParent;
//.max
imax:=new('toolbut','',vimMaximise,rthtranslate('Full screen Window'),valRight,_onclick) as tvirtualbutton;
imax.alignmargin:=sp;
imax.alignsep:=-sp*2+1;
imax.hint:=ntranslate('full screen');
imax.buffer:=buffer;
imax.oHeight:=vhsParent;
//.wnd
iwnd:=new('toolbut','',vimNormal,rthtranslate('Floating Window'),valRight,_onclick) as tvirtualbutton;
iwnd.alignmargin:=sp;
iwnd.alignsep:=-sp*2+1;
iwnd.hint:=ntranslate('floating');
iwnd.buffer:=buffer;
iwnd.oHeight:=vhsParent;
//.min
imin:=new('toolbut','',vimMinimise,rthtranslate('Hide (minimise) Window'),valRight,_onclick) as tvirtualbutton;
imin.alignmargin:=sp;
imin.alignsep:=-sp*2+1;
imin.hint:=ntranslate('hide');
imin.buffer:=buffer;
imin.oHeight:=vhsParent;
//OTHER OPTIONS
ioth1:=new('page','','','',valRight,_onclick) as tvirtualpage;
ioth1.alignmargin:=sp;
ioth1.alignsep:=-sp*2+1;
ioth1.oHeight:=vhsParent;
ioth1.oWidth:=vwsWidth;
ioth1.width:=25;
//.size
isize:=ioth1.new('glyph','','anm:t1,c2,d500#T1K00A00))))0000~'+'000G00W300V00G000X00460m)00W100200#','',valTop,_onclick) as tvirtualglyph;
if (isize.image<>nil) then isize.image.run:=false;
isize.hint:=ntranslate('resize window')+' / '+ntranslate('center window');
isize.help:=rthtranslate('Hold down left mouse button and drag to resize Window, or right click, to center Window');
isize.bordersize:=0;
isize.cursor:=vcSize;
isize.oHeight:=vhsInternal;
//.cat - category folder 23SEP2007
icat:=ioth1.new('glyph','','anm:t1,c2,d500#T1I00900))))0000~'+'000(30000(30000(30000(30000#','',valTop,_onclick) as tvirtualglyph;
if (icat.image<>nil) then icat.image.run:=false;
icat.hint:=ntranslate('category list')+' / '+ntranslate('category folder');
icat.help:=rthtranslate('Click for dropdown Category list, or right click for Category Folder');
icat.bordersize:=0;
icat.oHeight:=vhsInternal;
//.default appearance
idef:=new('toolbut','',vimDefaults,rthtranslate('Restore default appearance settings'),valRight,_onclick) as tvirtualbutton;
idef.alignmargin:=sp;
idef.alignsep:=-sp*2+1;
idef.hint:=ntranslate('default appearance');
idef.buffer:=buffer;
idef.oHeight:=vhsParent;
//.active
igui.onactive:=_onactive;
igui.icon.onchange:=_onicon;
icat.onnotify:=_oncat;
isize.onnotify:=_onsize;
//.dblclick
ondblclick:=_ondblclick;
end;
//## destroy ##
destructor tvirtualhead.destroy;
begin
try
//init
destroyinit;
//events
igui.onactive:=nil;
igui.icon.onchange:=nil;
//options
if (icatlist<>nil) then icatlist.showclose(mrCancel);
//children
destroychildren;
//controls
freeobj(@iimage);
freeobj(@icatlist);
//self
inherited;
except;end;
end;
//## _vhsInternal ##
function tvirtualhead._vhsInternal:integer;
begin
try;result:=32+(2*bordersize);except;end;
end;
//## _oncat ##
procedure tvirtualhead._oncat(sender:tobject);
begin
try
if igui.ismouse and (igui.act=aDown) and (igui.key=mLeft) then
   begin
   //.play animation of "cat" button
   if (icat.image<>nil) then icat.image.run:=true;
   end;//end of if
//right click
if igui.ismouse and (igui.act=aUp) then
   begin
   if (igui.key=mRight) then run(exeCategory,'');
   //.stop animation of "cat" button
   if (icat.image<>nil) then icat.image.run:=false;
   end;//end of if
except;end;
end;
//## _onsize ##
procedure tvirtualhead._onsize(sender:tobject);
begin
try
//right click - center form
if igui.ismouse and (igui.act=aUp) then
   begin
   if (igui.key=mRight) then gui.center;
   //.stop animation of "size" button
   if (isize.image<>nil) then isize.image.run:=false;
   end;//end of if
//drag and size
if igui.oResizeable and igui.ismouse and igui.down and (igui.key=mLeft) then
   begin
   //.play animation of "size" button
   if (isize.image<>nil) then isize.image.run:=true;
   //.size
   igui.sizenowex(sisTRraw);
   end;//end of if
except;end;
end;
//## _onicon ##
procedure tvirtualhead._onicon(sender:tobject);
begin
try;paint;except;end;
end;
//## syncbuttons ##
procedure tvirtualhead.syncbuttons;
var
   z:string;
begin
try
//check
if destroying then exit;
//.enabled
icat.enabled:=(sysstate=ssOK);
isize.enabled:=(sysstate=ssOK) and (igui.windowstate=wsNormal);
imin.enabled:=(sysstate=ssOK) and (igui.windowstate<>wsMinimized);
iwnd.enabled:=(sysstate=ssOK) and (igui.windowstate<>wsNormal);
imax.enabled:=(sysstate=ssOK) and (igui.windowstate<>wsMaximized);
iclose.enabled:=(sysstate=ssOK);
//VISIBLE
//other
icat.visible:=not igui.dialog;
isize.visible:=not igui.dialog;
ioth1.visible:=icat.visible or isize.visible;
idef.visible:=not igui.dialog;
//main
imin.visible:=not igui.dialog;
iwnd.visible:=not igui.dialog;
imax.visible:=not igui.dialog;
//help
z:='';
if iwnd.visible then z:=z+rthtranslate('Double left click to toggle Window between floating and full screen mode')+rcode;
if (igui.windowstate=wsNormal) then
   begin
   z:=z+
   rthtranslate('Hold down left mouse button and drag to position Window')+rcode+
   rthtranslate('Click to focus Window. Use keyboard arrow keys to position, and depress shift key for precision. "Page Up"/"Page Down" keys position Window quickly, vertically. "Home" key centers Window')+rcode;
   end;//end of if
help:=z;
except;end;
end;
//## _onactive ##
procedure tvirtualhead._onactive(sender:tobject);
begin
try;syncbuttons;paint;except;end;
end;
//## _ondblclick ##
procedure tvirtualhead._ondblclick(sender:tobject);
begin
try
if iwnd.visible and imax.visible then
   begin
   if (igui.windowstate=wsNormal) then igui.windowstate:=wsMaximized
   else if (igui.windowstate=wsMaximized) then igui.windowstate:=wsNormal;
   end;//end of if
except;end;
end;
//## _cat ##
procedure tvirtualhead._cat;
var
   f,path:string;
begin
try
//check
if (icatlist<>nil) then exit;
//get
icatlist:=tpoplist.create(nil);
//fill
path:=exeCategory;
icatlist.oAutoliststyle:=false;
icatlist.title:=ntranslate('category folder');
icatlist.text:=general.filesex(path+'*.*',false,true);//sorted
icatlist.value:=ilastcat;
icatlist.dropcount:=15;
icatlist.oNumbered:=true;
icatlist.tep:=tepWebPage14;
//pop
if icatlist.popwh(igui,screenx,screeny+height,height,width,0) then
   begin
   //get
   ilastcat:=icatlist.value;
   //set
   f:=path+icatlist.value;
   if fileexists(f) then run(f,'');
   end;//end of if
except;end;
try;freeobj(@icatlist);except;end;
end;
//## _onclick ##
procedure tvirtualhead._onclick(sender:tobject);
begin
try
//special buttons
if (sender=idef) then virtualsystemclick(vsoDefaultAppearance)
else if (sender=icat) then _cat
//window specific
else if (igui=application.mainform) then
   begin
   if (sender=imin) then application.minimize
   else if (sender=iwnd) then igui.windowstate:=wsNormal
   else if (sender=imax) then igui.windowstate:=wsMaximized
   else if (sender=iclose) then
      begin
      if appprompt then siClose;
      end;//end of if
   end
else
   begin
   if (sender=imin) then igui.windowstate:=wsMinimized
   else if (sender=iwnd) then igui.windowstate:=wsNormal
   else if (sender=imax) then igui.windowstate:=wsMaximized
   else if (sender=iclose) then igui.close;
   end;//end of if
except;end;
end;
//## _onpaintborder ##
procedure tvirtualhead._onpaintborder(sender:tobject;canvas:tcanvas);
var
   notactive:boolean;
   b:integer;
begin
try
//.color
notactive:=(not igui.active) or (not enabled);
b:=canvas.pen.color;
if fBorder then b:=general.aorb(info^.background,info^.disable,notactive);
if (b<>canvas.pen.color) then canvas.pen.color:=b;
//.paint
canvas.brush.color:=canvas.pen.color;
canvas.fillrect(area);
except;end;
end;
//## _onpaint ##
procedure tvirtualhead._onpaint(sender:tobject;canvas:tcanvas);
const
   ix=3;
   isp=2;
var
   a:tsize;
   c:tbitmap;
   notactive:boolean;
   f:tpixelfilter;
   bc,b,h,w,y,dy:integer;
   e,tmp:string;
begin
try
//defaults
c:=nil;
//setup
canvas.font.height:=frcmax(clientheight,30);
h:=2+clientheight;//canvas is 2 pixels taller, so bitmap must relfect and match this
if iimage.empty then w:=(32+ix+isp) else w:=iimage.pai.cellwidth+ix+isp;
//calc
tmp:=vcaption;
//.show clone name
if ((gui=application.mainform) or (gui=piggyform)) and ishowclone and (programclonename<>'') then tmp:=tmp+#32+'['+lowercase(programclonename)+']';
a:=canvas.textextent(tmp);
//color
if (igui<>nil) then
   begin
   //.notactive
   notactive:=(not igui.active) or (not enabled);
   //.background
   bc:=canvas.brush.color;
   if fDisable and notactive then bc:=info^.disable;
   if (bc<>canvas.brush.color) then canvas.brush.color:=bc;
   //.fontcolor
   b:=canvas.font.color;
   if fDisable and notactive then b:=info^.disablefont else b:=info^.font;
   if (b<>canvas.font.color) then canvas.font.color:=b;
   end;//end of if
//cls
if viEnhanced then
   begin
   if not iimage.empty then
      begin
      c:=ccs.newbmp(w,h);
      ccs.shadevex(c.canvas,bc,25,25,false,e);//shade buffer
      ccs.shadevex(canvas,bc,25,25,false,e);//shade main canvas (non buffer)
      end
   else ccs.shadevex(canvas,bc,25,25,false,e);//shade (only good for icons, not tep's)
   end
else canvas.fillrect(clientrect);
//text
canvas.brush.style:=bsClear;
canvas.textout(w,(clientheight-a.cy) div 2,tmp);
//icon
if iimage.empty then canvas.draw(ix,0,application.icon)
else
   begin
   //.filters
   statefilter(f);
   //..imagealign
   dy:=(clientheight-iimage.pai.cellheight) div 2;
   //..paint
   iimage.pai.transparent:=true;
   if (c<>nil) then
      begin
      iimage.drawtoex(c,rect(ix,dy,iimage.pai.cellwidth,iimage.pai.cellheight),true,f,bc,clNone);
      canvas.draw(0,0,c);
      end
   else iimage.drawto(canvas,rect(ix,dy,iimage.pai.cellwidth,iimage.pai.cellheight),true,f,bc,clNone);
   end;//end of if
except;end;
try;freeobj(@c);except;end;
end;
//## _onwheelv ##
procedure tvirtualhead._onwheelv(sender:tobject);
var
   tmp:integer;
begin
try
//self
inherited;
//process
//.get
tmp:=round(igui.wheelv);
//.reset
igui.wheelv:=igui.wheelv-tmp;
//.set
if (igui.windowstate=wsNormal) and (tmp<>0) then igui.top:=igui.top-(tmp*10);
except;end;
end;
//## _onnotify ##
procedure tvirtualhead._onnotify(sender:tobject);
var
   sp:integer;
begin
try
//move
if igui.ismouse and igui.down and (igui.key=mLeft) and (igui.windowstate=wsNormal) then igui.movenow;
//click
if igui.ismouse and (igui.act=aUp) and (igui.key=mLeft) and igui.ptinrect(igui.x,igui.y,isrv) then click
//keyboard
else if igui.iskeyboard and igui.down and (igui.clas=recKeyX) then
   begin
   //.get
   sp:=general.aorb(10,1,igui.shift);
   //.set
   if (igui.key=vk_return) then
      begin
      case igui.windowstate of
      wsMinimized:igui.windowstate:=wsNormal;
      wsMaximized:igui.windowstate:=wsNormal;
      wsNormal:igui.windowstate:=wsMaximized;
      end;//end of case
      end
   else if (igui.windowstate=wsNormal) then
      begin
      case igui.key of
      vk_left:igui.left:=igui.left-sp;
      vk_right:igui.left:=igui.left+sp;
      vk_up:igui.top:=igui.top-sp;
      vk_down:igui.top:=igui.top+sp;
      vk_prior:igui.top:=igui.top-general.aorb(sp,5*sp,sp>=2);
      vk_next:igui.top:=igui.top+general.aorb(sp,5*sp,sp>=2);
      vk_home:general.center(igui,igui.width,igui.height,false);
      end;//end of case
      end;//end of if
   end;//end of if
except;end;
end;
//## readwrite ##
procedure tvirtualhead.readwrite(mode:tvirtualstoragemode);
begin
try
case mode of
vsmUpdatecontrols:ishowclone:=programrename and vs.b[vsShowClone];
end;//end of case
except;end;
end;

//## tvirtualsystembutton ######################################################
//## getvirtualsystemlabel ##
function getvirtualsystemlabel(x:tvirtualsystemoptions):string;
begin
try
if (x=vsoApply) then result:=ntranslate('Apply')
else if (x=vsoDefaults) then result:=ntranslate('Defaults')
else if (x=vsoDefaultAppearance) then result:=ntranslate('Default Appearance')
else if (x=vsoExit) then result:=ntranslate('Exit')
else result:='';
except;end;
end;
//## virtualsystemclick ##
procedure virtualsystemclick(x:tvirtualsystemoptions);
begin
try
//option
case x of
vsoNone:;
vsoApply:vs.apply;
vsoDefaults:vs.defaults(true);
vsoDefaultAppearance:vs.defaultsb(true,false);
vsoExit:if appprompt then siClose;
end;//end of case
except;end;
end;
//## settvirtualsystemoptions ##
procedure tvirtualsystembutton.settvirtualsystemoptions(x:tvirtualsystemoptions);
begin
try
if (x<>ioption) then
   begin
   ioption:=x;
   caption:=getvirtualsystemlabel(x);
   //.tep
   case x of
   vsoApply:begin
      animation:=tepApply20;
      help:=rthtranslate('Implement all changes');
      end;//end of begin
   vsoDefaults:begin
      animation:=tepDefaults20;
      help:=rthtranslate('Restore Program defaults');
      end;//end of begin
   vsoDefaultAppearance:begin
      animation:=tepDefaults20;
      help:=rthtranslate('Restore default appearance settings');
      end;//end of begin
   vsoExit:begin
      animation:=tepClose20;
      help:=rthtranslate('Shutdown program');
      end;//end of begin
   end;//end of case
   end;//end of if
except;end;
end;
//## click ##
procedure tvirtualsystembutton.click;
begin
try;inherited;virtualsystemclick(option);except;end;
end;

//## tvirtualsystemlink ########################################################
//## settvirtualsystemoptions ##
procedure tvirtualsystemlink.settvirtualsystemoptions(x:tvirtualsystemoptions);
begin
try
if (x<>ioption) then
   begin
   ioption:=x;
   caption:=getvirtualsystemlabel(x);
   end;//end of if
except;end;
end;
//## click ##
procedure tvirtualsystemlink.click;
begin
try;inherited;virtualsystemclick(option);except;end;
end;

//## tvirtualwebedit ###########################################################
//## create ##
constructor tvirtualwebedit.create(_gui:tvirtualform);
begin
//self
inherited create(_gui);
bordersize:=0;
//controls
isend:=new('button','',tepRawGruntSearch20,rthtranslate('Send internet query'),valRight,__onclick) as tvirtualbutton;
iedit:=new('edit','','',rthtranslate('Type a query'),valRight,nil) as tvirtualedit;
with isend do
begin
fBackground:=false;
fBorder:=false;
bordersize:=0;
imagealign:=valRight;
end;
iedit.oVariablewidth:=true;
//events
iedit.onreturn:=__onclick;
end;
//## setanimation ##
procedure tvirtualwebedit.setanimation(x:string);
begin
try;isend.animation:=x;except;end;
end;
//## __onclick ##
procedure tvirtualwebedit.__onclick(sender:tobject);
var
   tmp:string;
begin
try
if (sender=isend) or (sender=iedit) then
   begin
   if (iurl<>'') then
      begin
      tmp:=net_encode_str_b(iedit.text);
      tmp:=general.swapstrsb(iurl,'<text>',tmp);
      run(tmp,'');
      end;//end of if
   end;//end of if
except;end;
end;

//## tvirtualbutton ############################################################
//## create ##
constructor tvirtualbutton.create(_gui:tvirtualform);
begin
//self
inherited create(_gui);
oHeight:=vhsInternal;
//controls
iimage:=nil;
//other
iimagealign:=valLeft;
icursor:=vcLink;
clickkey:=clkyDefault;
end;
//## destroy ##
destructor tvirtualbutton.destroy;
begin
try
//init
destroyinit;
//controls
freeObj(@iimage);
//self
inherited;
except;end;
end;
//## _vhsInternal ##
function tvirtualbutton._vhsInternal:integer;
var
   ch,z:integer;
begin
try
//defaults
ch:=_vhsClient;
result:=ch;
//get
if haveimage and (not compact) then
   begin
   //get
   z:=iimage.pai.cellheight+2;
   //set
   if (iimagealign=valTop) then
      begin
      if (caption<>'') then result:=ch+z else result:=z;
      end
   else result:=largest(ch,z);
   end;//end of if
except;end;
end;
//## _vwsInternal ##
function tvirtualbutton._vwsInternal:integer;
var
   t:string;
   w,tmp:integer;
   r:trect;
begin
try
//defaults
result:=0;
//get
if (parent<>nil) then
   begin
   //.border
   tmp:=2*bordersize;
   //.content width
   t:=vcaption;
   w:=info^.fontmap.textwidthi(t,'&',1,length(t));
   if (not compact) and haveimage then
      begin
      if (iimagealign=valLeft) then inc(w,iimage.pai.cellwidth+2)
      else if (iimagealign=valNone) then inc(w,iimage.pai.cellwidth+2)
      else if (iimage.pai.cellwidth>w) then w:=iimage.pai.cellwidth;//end of if
      end;//end of if
   inc(tmp,w+6);
   if (padwidth<>0) then inc(tmp,padwidth);
   //.set
   result:=frcmin(tmp,0);
   end
else result:=inherited _vwsInternal;
except;end;
end;
//## aslink ##
procedure tvirtualbutton.aslink;
begin
try;aslinkb(true);except;end;
end;
//## aslinkb ##
procedure tvirtualbutton.aslinkb(_right:boolean);
begin
try
imagealign:=valLeft;
if _right then align:=valRight else align:=valLeft;
bordersize:=0;
cursor:=vcLink;
fBorder:=false;
fBackground:=false;
fDown:=true;
clickkey:=clkyDefault;
if (parent<>nil) then normal:=parent.normal;
except;end;
end;
//## _onnotify ##
procedure tvirtualbutton._onnotify(sender:tobject);
begin
try
//self
inherited;
//special RIGHT CLICK for IMAGE INSERTION - testing purposes only
if programtesting then
   begin
   if igui.ismouse and (igui.act=aUp) and (igui.Key=mRight) then
      begin
      //.set
      animation:=ccs.astep(clipboard,128,32);//maxW & maxH
      //.sync
      igui.sync;
      end;//end of if
   end;//end of if
except;end;
end;
//## setmark ##
procedure tvirtualbutton.setmark(x:boolean);
begin
try;if general.setbol(x,imark) then paint;except;end;
end;
//## gethaveimage ##
function tvirtualbutton.gethaveimage:boolean;
begin
try;result:=(iimage<>nil);except;end;
end;
//## setanimation ##
procedure tvirtualbutton.setanimation(x:string);
begin
try;_setanimation(iimage,self,x);except;end;
end;
//## _onpaint ##
procedure tvirtualbutton._onpaint(sender:tobject;canvas:tcanvas);
var
   a:tsize;
   oxy,sp,y,dx,dy,ix,iy:integer;
   tmp:string;
   f:tpixelfilter;
   r:trect;
begin
try
//calc
tmp:=vcaption;
a.cx:=0;
a.cy:=0;
if (tmp<>'') then
   begin
   a.cx:=info^.fontmap.textwidthi(tmp,'&',1,length(tmp));
   a.cy:=info^.fontmap.maxH;
   end;//end of if
ix:=0;
iy:=0;
oxy:=0;
if fDown and (imark or down) then oxy:=2;
sp:=general.aorb(0,2,(a.cx<>0) or (a.cy<>0));
//mark
if imark and (not focused) and (not hovering) and ((not fDisable) or enabled) then
   begin
   if fBorder then canvas.pen.color:=info^.hover;
   if fBackground then canvas.brush.color:=info^.hover;
   end;//end of if
//focus indicator - additional
if (not fBorder) and (not fBackground) then
   begin
   if focused or hovering or imark then
      begin
      canvas.font.style:=canvas.font.style+[fsUnderline];
      if enabled then canvas.font.color:=general.aorb(info^.hover,info^.fonthighlight,down or imark or focused);
      end;//end of if
   end;//end of if
//color correction - "font.color" checked against "final background color" - 22SEP2007
if enabled and (not ccs.cv(canvas.font.color,canvas.brush.color,90)) then canvas.font.color:=general.dc(canvas.font.color,90);
//cls
canvas.fillrect(clientrect);
//image - symbol!
if (not compact) and haveimage and (not iimage.empty) then
   begin
   //.filters
   statefilter(f);
   //..imagealign
   if (iimagealign=valTop) then
      begin
      dx:=(clientwidth-iimage.pai.cellwidth) div 2;
      dy:=(clientheight-iimage.pai.cellheight-a.cy-sp) div 2;
      end
   else if (iimagealign=valLeft) then
      begin
      dx:=2+(padwidth div 2);
      dy:=(clientheight-iimage.pai.cellheight) div 2;
      end
   else
      begin
      dx:=(clientwidth-iimage.pai.cellwidth-a.cx-sp) div 2;
      dy:=(clientheight-iimage.pai.cellheight) div 2;
      end;//end of if
   //..range
   dx:=frcmin(dx,0);
   dy:=frcmin(dy,0);
   //..paint
   iimage.drawto(canvas,rect(dx+oxy,dy+oxy,iimage.pai.cellwidth,iimage.pai.cellheight),true,f,canvas.brush.color,general.aorb(canvas.font.color,clNone,oAllowBlack));
   ix:=dx+iimage.pai.cellwidth;
   iy:=dy+iimage.pai.cellheight;
   //..frame image - 16SEP2007
   if oFrameimage then
      begin
      canvas.brush.color:=general.dc(info^.border,10);
      canvas.framerect(rect(dx+oxy-1,dy+oxy-1,dx+oxy+1+iimage.pai.cellwidth,dy+oxy+1+iimage.pai.cellheight));
      end;//end ofif
   end;//end of if
//text
canvas.brush.style:=bsClear;
dx:=(clientwidth-a.cx) div 2;
dy:=(clientheight-a.cy) div 2;
//.imagealign
if (ix<>0) or (iy<>0) then
   begin
   if (iimagealign=valTop) then dy:=iy+sp
   else dx:=ix+sp;//end of if
   end
else
   begin
   case iimagealign of
   valTop:dy:=2;
   valLeft:dx:=2;
   end;//end of case
   end;//end of if
//.range
dx:=frcmin(dx,0);
dy:=frcmin(dy,0);
//.draw
r:=rect(dx+oxy,dy+oxy,clientwidth,clientheight);
drawtext(
 canvas.handle,
 pchar(tmp),
 length(tmp),
 r,
 dt_left or dt_singleline);
except;end;
end;

//## tvirtualglyph #############################################################
//## create ##
constructor tvirtualglyph.create(_gui:tvirtualform);
begin
//self
inherited create(_gui);
//other
imagealign:=valTop;
end;
//## _vwsInternal ##
function tvirtualglyph._vwsInternal:integer;
begin
try
if haveimage then result:=frcmin(iimage.pai.cellwidth+2,2)
else result:=inherited _vhsInternal;
except;end;
end;//end of if

//## tvirtualmousecursor #######################################################
//## create ##
constructor tvirtualmousecursor.create(_gui:tvirtualform);
begin
//self
inherited create(_gui);
//defaults
imagealign:=valNone;
cursor:=vcArrow;
padwidth:=6;
//help
help:=rthtranslate('Bullet: Custom cursor selected - click to restore default. No bullet: Default cursor selected - click to customise. An "Open" window will display, select cursor and click "Open" button. Note: Button displays current cursor');
end;
//## havecursor ##
function tvirtualmousecursor.havecursor:boolean;
begin
try;result:=(isysptr>vsNil) and (idata<>vs.default[isysptr]);except;end;
end;
//## setcursor ##
procedure tvirtualmousecursor.setcursor(x:tvirtualcursor);
var
   z:string;
begin
try
//process
icursor:=x;
z:=getcursorlabel(x);
isysptr:=getcursorpointer(x);
if havecursor then animation:=simTicked else animation:=simUnticked;
caption:=z;
except;end;
end;
//## click ##
procedure tvirtualmousecursor.click;
var
   tmp,e:string;
begin
try
//self
inherited;
//check
if not enabled then exit;
//filters
if havecursor then
   begin
   if showquery(translate('Revert to default')+#32+translate('cursor')+'?',-60) then _nocursor;
   end
else
   begin
   //.prompt (filename -> data)
   if misc.cursordlg(tmp) and (not io.fromfile(tmp,idata,e)) then
      begin
      showerror60(translate(e));
      _nocursor;
      end;//end of if
   end;
//caption
cursor:=cursor;
//self
inherited;
except;end;
end;
//## _nocursor ##
procedure tvirtualmousecursor._nocursor;
begin
try;if (isysptr>vsNil) then idata:=vs.default[isysptr];except;end;
end;
//## readwrite ##
procedure tvirtualmousecursor.readwrite(mode:tvirtualstoragemode);
var
   tmp:string;
begin
try
case mode of
vsmReadfromcontrols:if (isysptr>vsNil) then vs.s[isysptr]:=idata;
vsmWritetocontrols:if (isysptr>vsNil) then
   begin
   tmp:=vs.s[isysptr];
   if (tmp<>idata) then
      begin
      idata:=tmp;
      //caption
      cursor:=cursor;
      end;//end of if
   end;//end of if
vsmUpdatecontrols:;
end;//end of case
except;end;
end;

//## tvirtualtick ##############################################################
//## create ##
constructor tvirtualtick.create(_gui:tvirtualform);
begin
//self
inherited create(_gui);
//defaults
bordersize:=0;
imagealign:=valLeft;
//.ticked
iticked:=true;
ticked:=false;
end;
//## readwrite ##
procedure tvirtualtick.readwrite(mode:tvirtualstoragemode);
var
   tmp:boolean;
begin
try
case mode of
vsmReadfromcontrols:if (isysptr>vsNil) then vs.b[isysptr]:=ticked;
vsmWritetocontrols:if (isysptr>vsNil) then
   begin
   tmp:=vs.b[isysptr];
   if (tmp<>ticked) then ticked:=tmp;
   end;//end of if
vsmUpdatecontrols:;
end;//end of case
except;end;
end;
//## setticked ##
procedure tvirtualtick.setticked(x:boolean);
begin
try
if general.setbol(x,iticked) then
   begin
   animation:=general.aorbstr(simUnticked,simTicked,ticked);
   fireevent(fontick,self);
   end;//end of if
except;end;
end;
//## click ##
procedure tvirtualtick.click;
begin
try
ticked:=not ticked;
inherited click;
except;end;
end;

//## tvirtuallabel #############################################################
//## create ##
constructor tvirtuallabel.create(_gui:tvirtualform);
begin
//self
inherited create(_gui);
oHeight:=vhsFont;
//defaults
style:=[];
bordersize:=0;
cursor:=vcArrow;
end;

//## tvirtuallabelb #############################################################
//## _onpaint ##
procedure tvirtuallabelb._onpaint(sender:tobject;canvas:tcanvas);
var
   tmp:string;
begin
try
//cls
canvas.fillrect(clientrect);
tmp:=vcaption;
//text
canvas.brush.style:=bsClear;
draws.drawtabs(self,canvas,dwtbX+ixshift,0,tmp);
except;end;
end;

//## tvirtualpanel #############################################################
//## create ##
constructor tvirtualpanel.create(_gui:tvirtualform);
begin
//self
inherited create(_gui);
//defaults
style:=[];
cursor:=vcArrow;
end;

//## tvirtualpanel #############################################################
//## create ##
constructor tvirtualflash.create(_gui:tvirtualform);
begin
//self
inherited create(_gui);
end;
//## settimer ##
procedure tvirtualflash.settimer(x:integer);
begin
try
if (x<>timer) then
   begin
   inherited settimer(x);
   ion:=false;
   paint;
   end;//end of if
except;end;
end;
//## _ontimer ##
procedure tvirtualflash._ontimer(sender:tobject);
begin
try
//.toggle
ion:=not ion;
if (timer=0) then ion:=false;
//.paint
paint;
except;end;
end;
//## _onpaint ##
procedure tvirtualflash._onpaint(sender:tobject;canvas:tcanvas);
begin
try
//.color
if ion and ((not fDisable) or enabled) then
   begin
   //.font color
   if fFontcolor and (info^.fonthighlight<>canvas.font.color) then canvas.font.color:=info^.fonthighlight;
   //.background
   if fBackground and (info^.highlight<>canvas.brush.color) then canvas.brush.color:=info^.highlight;
   end;//end of if
//.paint
inherited;
except;end;
end;

//## tvirtualsep ###############################################################
//## create ##
constructor tvirtualsep.create(_gui:tvirtualform);
begin
//self
inherited create(_gui);
oHeight:=vhsHeight;
//defaults
oPaintcolor:=true;
style:=[];
cursor:=vcArrow;
height:=1;
end;
//## _onpaint ##
procedure tvirtualsep._onpaint(sender:tobject;canvas:tcanvas);
var
   c:integer;
begin
try
//init
if oPaintcolor then
   begin
   if fDisable and (not enabled) then c:=info^.disableborder
   else c:=info^.border;
   //adjust
   c:=general.dc(c,20);
   canvas.brush.color:=c;
   end;//end of if
//paint
canvas.fillrect(clientrect);
except;end;
end;

//## tvirtuallink ##############################################################
//## create ##
constructor tvirtuallink.create(_gui:tvirtualform);
begin
//self
inherited create(_gui);
//defaults
bordersize:=0;
cursor:=vcLink;
align:=valRight;
fBorder:=false;
fBackground:=false;
fDown:=true;
clickkey:=clkyDefault;
end;
//## _vwsInternal ##
function tvirtuallink._vwsInternal:integer;//11OCT2007
begin
try
//defaults
result:=2;
//get
if (caption<>'') then result:=inherited _vwsInternal
else if haveimage then result:=frcmin(iimage.pai.cellwidth+2,2);
except;end;
end;//end of if

//## tvirtualtitle ##############################################################
//## create ##
constructor tvirtualtitle.create(_gui:tvirtualform);
begin
//self
inherited create(_gui);
oHeight:=vhsHost;
//defaults
style:=[];
cursor:=vcArrow;
bordersize:=1;
normal:=false;
fBold:=true;
end;
//## destroy ##
destructor tvirtualtitle.destroy;
begin
try
//init
destroyinit;
//children
destroychildren;
//self
inherited;
except;end;
end;
//## _onpaint ##
procedure tvirtualtitle._onpaint(sender:tobject;canvas:tcanvas);
const
   sp=2;
var
   a:tsize;
   y,dx,dy,ix,iy:integer;
   tmp:string;
   f:tpixelfilter;
begin
try
//setup
canvas.font.height:=clientheight-2;
if fBold then canvas.font.style:=canvas.font.style+[fsBold];
//calc
tmp:=vcaption;
a:=canvas.textextent(tmp);
ix:=0;
iy:=0;
//focus indicator - additional
if (not fBorder) and (not fBackground) then
   begin
   if focused or hovering then canvas.font.style:=canvas.font.style+[fsUnderline];
   end;//end of if
//cls
canvas.fillrect(clientrect);
//image - symbol!
if haveimage and (not iimage.empty) then
   begin
   //.filters
   statefilter(f);
   //.left
   dx:=2;
   dy:=(clientheight-iimage.pai.cellheight) div 2;
   //..range
   dx:=frcmin(dx,0);
   dy:=frcmin(dy,0);
   //..paint
   iimage.drawto(canvas,rect(dx,dy,iimage.pai.cellwidth,iimage.pai.cellheight),true,f,canvas.brush.color,general.aorb(canvas.font.color,clNone,oAllowBlack));
   ix:=dx+iimage.pai.cellwidth;
   iy:=dy+iimage.pai.cellheight;
   end;//end of if
//text
canvas.brush.style:=bsClear;
dx:=ix+sp;
dy:=(clientheight-a.cy) div 2;
//.draw
canvas.textout(dx,dy,tmp);
except;end;
end;

//## tvirtualtitleb ############################################################
//## create ##
constructor tvirtualtitleb.create(_gui:tvirtualform);
begin
//self
inherited create(_gui);
end;
//## _onpaint ##
procedure tvirtualtitleb._onpaint(sender:tobject;canvas:tcanvas);
var
   tmp:string;
begin
try
//setup
canvas.font.height:=clientheight-2;
if fBold then canvas.font.style:=canvas.font.style+[fsBold];
//calc
tmp:=vcaption;
//cls
canvas.fillrect(clientrect);
//text
canvas.brush.style:=bsClear;
draws.drawtabs(self,canvas,dwtbX+ixshift,0,tmp);
except;end;
end;

//## tvirtualrows ##############################################################
//## create ##
constructor tvirtualrows.create(_gui:tvirtualform);
begin
//self
inherited create(_gui);
oHeight:=vhsInternal;
//controls
iitems:=nil;
iitems:=tstringlist.create;
iitemlimit:=5;
//events
iitems.onchange:=__onitems;
//defaults
buffer:=true;
style:=[];
end;
//## destroy ##
destructor tvirtualrows.destroy;
begin
try
//init
destroyinit;
//controls
freeobj(@iitems);
//self
inherited;
except;end;
end;
//## astext ##
function tvirtualrows.astext:string;//12FEB2008
begin
try;result:=misc.enforceEOLex(iitems.text,false);except;end;
end;
//## __vhsOne ##
function tvirtualrows.__vhsOne:integer;
begin
try;result:=frcmin(viFontHeight+2,16);except;end;
end;
//## _vhsInternal ##
function tvirtualrows._vhsInternal:integer;
begin
try;result:=(iitemlimit*__vhsOne)+(2*bordersize);except;end;
end;
//## __onitems ##
procedure tvirtualrows.__onitems(sender:tobject);
begin
try;paint;except;end;
end;
//## setitemlimit ##
procedure tvirtualrows.setitemlimit(x:integer);
begin
try
//range
x:=frcmin(x,1);
//process
if (x<>iitemlimit) then
   begin
   iitemlimit:=x;
   realign(true);
   end;//end of if
except;end;
end;
//## _onpaint ##
procedure tvirtualrows._onpaint(sender:tobject;canvas:tcanvas);
var
   p:integer;
begin
try
//cls
canvas.fillrect(clientrect);
//items
for p:=0 to frcmax((iitems.count-1),iitemlimit-1) do _ondrawitem(nil,canvas,p,rect(0,p*__vhsOne,clientwidth,(p+1)*__vhsOne),[]);
except;end;
end;
//## _ondrawitem ##
procedure tvirtualrows._ondrawitem(control:tvirtualcontrol;canvas:tcanvas;index:integer;area:trect;state:tvirtualdrawstate);
begin
try
if assigned(ondrawitem) then ondrawitem(self,canvas,index,area,[],ontext,onimage)
else draws.drawitem(self,canvas,index,area,[],ontext,onimage);
except;end;
end;

//## tvirtualcolor #############################################################
//## create ##
constructor tvirtualcolor.create(_gui:tvirtualform);
begin
//self
inherited create(_gui);
oHeight:=vhsInternal;
//defaults
width:=100;
caption:='';
cursor:=vcLink;
icolor:=clWhite;
fBorder:=false;
fBackground:=false;
fDown:=true;
hint:='* '+translate('Click for color window')+rcode+'* '+translate('Hold down left mouse button and drag to acquire any screen color');
help:=rthtranslate('Click to display "Color" selection window. Select color and click "OK" button. Or, hold down left mouse button and drag outside color palette to acquire any screen color. Release mouse button upon selection');
end;
//## __vhsOne ##
function tvirtualcolor.__vhsOne:integer;
begin
try;result:=frcmin(viFontHeight+2,16);except;end;
end;
//## _vhsInternal ##
function tvirtualcolor._vhsInternal:integer;
begin
try;result:=(2*__vhsOne)+(2*bordersize);except;end;
end;
//## _vwsInternal ##
function tvirtualcolor._vwsInternal:integer;
var//Updated 12-DEC-2006. Now uses "info.fontmap.textwidth" for stability.
   w2,w,tmp:integer;
   z:string;
begin
try
if (parent<>nil) then
   begin
   //.border
   tmp:=2*bordersize;
   //.content width
   z:=vcaption;
   w:=info.fontmap.textwidth(z);
   z:='999r, 999g, 999b';
   w2:=info.fontmap.textwidth(z);
   if (w2>w) then w:=w2;
   inc(tmp,w+6);
   //.set
   result:=frcmin(tmp,0);
   end
else result:=inherited _vwsWidth;
except;end;
end;
//## readwrite ##
procedure tvirtualcolor.readwrite(mode:tvirtualstoragemode);
var
   tmp:integer;
begin
try
case mode of
vsmReadfromcontrols:if (isysptr>vsNil) then vs.i[isysptr]:=color;
vsmWritetocontrols:if (isysptr>vsNil) then
   begin
   tmp:=vs.i[isysptr];
   if (tmp<>color) then color:=tmp;
   end;//end of if
vsmUpdatecontrols:;
end;//end of case
except;end;
end;
//## click ##
procedure tvirtualcolor.click;
var
   tmp:integer;
begin
try
//self
inherited;
//color window
if not imovecolor then
   begin
   tmp:=icolor;
   if misc.showcolor(tmp) then color:=tmp;
   end;//end of if
except;end;
end;
//## setcolor ##
procedure tvirtualcolor.setcolor(x:integer);
begin
try
//process
//.get
x:=colortorgb(x);
//.set
if (x<>icolor) then
   begin
   //.event (once only while global eye-dropper mode in use)
   if (not imovecolor) and assigned(onchanging) then onchanging(self);
   //.set
   icolor:=x;
   //.sync
   modified:=true;
   paint;
   end;//end of if
except;end;
end;
//## _onpaintborder ##
procedure tvirtualcolor._onpaintborder(sender:tobject;canvas:tcanvas);
begin
try
if (fDisable and (not enabled)) or (not viBorder) then inherited
else
   begin
   canvas.brush.color:=ccs.ecv(invcolor(icolor,true),icolor,-20);
   canvas.fillrect(area);
   end;//end of if
except;end;
end;
//## _onpaint ##
procedure tvirtualcolor._onpaint(sender:tobject;canvas:tcanvas);
var
   oxy,dy,th:integer;
   c:tint4;
   tmp,rgb:string;
begin
try
//get
oxy:=0;
if fDown and down then oxy:=2;
c.val:=icolor;
tmp:=vcaption;
rgb:=
general.digpad(c.r,3)+'r, '+
general.digpad(c.g,3)+'g, '+
general.digpad(c.b,3)+'b';
//focus indicator - additional
if (not fBorder) and (not fBackground) then
   begin
   if focused or hovering then canvas.font.style:=canvas.font.style+[fsUnderline];
   end;//end of if
//cls
if (not fDisable) or enabled then
   begin
   canvas.brush.color:=icolor;
   canvas.font.color:=invcolor(icolor,true);
   end;//end ofif
canvas.fillrect(clientrect);
//init
th:=canvas.textheight('#');
canvas.brush.style:=bsClear;
dy:=(clientheight-(th*2+1)) div 2;
//text
//.rgb
canvas.textout(oxy+(clientwidth-canvas.textwidth(rgb)) div 2,oxy+dy+th+1,rgb);
//.caption
if highcontrast then
   begin
   canvas.brush.color:=clWhite;
   canvas.font.color:=clBlack;
   tmp:=#32+tmp+#32;
   end;//end of if
canvas.textout(oxy+(clientwidth-canvas.textwidth(tmp)) div 2,oxy+dy,tmp);
except;end;
end;
//## _onnotify ##
procedure tvirtualcolor._onnotify(sender:tobject);
var
   a:tpoint;
   oc,tmp:integer;
begin
try
//self
inherited;
//process
if igui.ismouse then
   begin
   imousedown:=igui.down;
   //.down once
   if (igui.act=aDown) then
      begin
      iwascolor:=icolor;
      imovecolor:=false;
      end
   //.move
   else if (igui.act=aMove) then
      begin
      if igui.down and (igui.key=mLeft) and (not igui.ptinrect(igui.x,igui.y,isrv)) then
         begin
         tmp:=ccs.cursorcolor;
         if (tmp<>icolor) then
            begin
            color:=tmp;
            imovecolor:=true;
            end;//end of if
         end;//end of if
      end
   //.up once
   else if (igui.act=aUp) then imovecolor:=false else color:=icolor;
   end;//end of if
except;end;
end;

//## tvirtualscrollbar #########################################################
//## create ##
constructor tvirtualscrollbar.create(_gui:tvirtualform);
begin
//self
inherited create(_gui);
//controls
iup:=tvirtualbitmap.create;
idn:=tvirtualbitmap.create;
//defaults
ismall:=1;
ilarge:=10;
stepby:=1;
setparams(0,0,100,false);
islidesize:=10;
ivertical:=true;
vertical:=false;
setbounds(left,top,100,sbrSize);
fBackground:=false;
buffer:=true;
cursor:=vcLink;
end;
//## destroy ##
destructor tvirtualscrollbar.destroy;
begin
try
//init
destroyinit;
//controls
freeObj(@iup);
freeObj(@idn);
//self
inherited;
except;end;
end;
//## readwrite ##
procedure tvirtualscrollbar.readwrite(mode:tvirtualstoragemode);
var
   tmp:integer;
begin
try
case mode of
vsmReadfromcontrols:if (isysptr>vsNil) then vs.i[isysptr]:=pos;
vsmWritetocontrols:if (isysptr>vsNil) then
   begin
   tmp:=vs.i[isysptr];
   if (tmp<>pos) then pos:=tmp;
   end;//end of if
end;//end of case
except;end;
end;
//## canalign ##
function tvirtualscrollbar.canalign:boolean;
begin
try;result:=(inherited canalign) and (iup<>nil) and (idn<>nil);except;end;
end;
//## doalign ##
procedure tvirtualscrollbar.doalign;
begin
try
//check
if not canalign then exit;
//process
inherited;
init;
except;end;
end;
//## setvertical ##
procedure tvirtualscrollbar.setvertical(x:boolean);
var
   e:string;
begin
try
//process
if general.setbol(x,ivertical) then
   begin
   //.set
   if ivertical then
      begin
      iup.settep(simUp,e);
      idn.settep(simDown,e);
      end
   else
      begin
      iup.settep(simLeft,e);
      idn.settep(simRight,e);
      end;//end of if
   //.init
   init;
   //.paint
   paint;
   end;//end of if
except;end;
end;
//## setmin ##
procedure tvirtualscrollbar.setmin(x:integer);
begin
try;if (x<>imin) then setparams(x,pos,max,true);except;end;
end;
//## setpos ##
procedure tvirtualscrollbar.setpos(x:integer);
begin
try;if (x<>ipos) then setparams(min,x,max,true);except;end;
end;
//## setmax ##
procedure tvirtualscrollbar.setmax(x:integer);
begin
try;if (x<>imax) then setparams(min,pos,x,true);except;end;
end;
//## setstepby ##
procedure tvirtualscrollbar.setstepby(x:integer);
begin
try;istepby:=frcmin(x,1);except;end;
end;
//## setparams ##
function tvirtualscrollbar.setparams(_min,_pos,_max:integer;_notify:boolean):boolean;
begin
try
//defaults
result:=false;
//process
//.range
_max:=frcmin(_max,_min);
_pos:=frcrange(_pos,_min,_max);
//.check
if (_min=imin) and (_pos=ipos) and (_max=imax) then exit;
//.set
imin:=_min;
ipos:=_pos;
imax:=_max;
imag:=imax-imin;
//.init
init;
//.paint
if _notify then
   begin
   paint;
   //.onpos
   fireevent(fonpos,self);
   end;//end of if
//successful
result:=true;
except;end;
end;
//## setsmall ##
procedure tvirtualscrollbar.setsmall(x:integer);
begin
try;ismall:=frcmin(x,1);except;end;
end;
//## setlarge ##
procedure tvirtualscrollbar.setlarge(x:integer);
begin
try;ilarge:=frcmin(x,1);except;end;
end;
//## init ##
procedure tvirtualscrollbar.init;
const
   mss=24;//min. slider size
   sp=10;
var
   tmp,p,bs:integer;
begin
try
//process
//.vertical
if ivertical then
   begin
   ibutsize:=frcmax(general.aorb(iup.height,idn.height,idn.height>iup.height)+sp,clientheight div 2);
   tmp:=clientheight-2*ibutsize;
   end
//.horizontal
else
   begin
   ibutsize:=frcmax(general.aorb(iup.width,idn.width,idn.width>iup.width)+sp,clientwidth div 2);
   tmp:=clientwidth-2*ibutsize;
   end;//end of if
//.calc
if (tmp<(mss+1)) then tmp:=0;
iscrollwidth:=frcmin(tmp,0);
//.islidesize
if (tmp<=0) or (imag<1) then islidesize:=0
else
   begin
   islidesize:=frcmin(iscrollwidth-(imag div istepby),mss);
   ipixelpower:=imag/frcmin(iscrollwidth-islidesize,1);
   end;//end of if
except;end;
end;
//## scrollx ##
function tvirtualscrollbar.scrollx:integer;
begin
try;result:=general.aorb(x,y,ivertical)-ibutsize;except;end;
end;
//## scrolldx ##
function tvirtualscrollbar.scrolldx:integer;
begin
try;result:=general.aorb(dx,dy,ivertical)-ibutsize;except;end;
end;
//## scrollrect ##
function tvirtualscrollbar.scrollrect:trect;
begin
try
//check
if (iscrollwidth<1) then result:=rect(0,0,0,0)
else
   begin
   if ivertical then result:=rect(-1,ibutsize,clientwidth+1,ibutsize+iscrollwidth-1)
   else result:=rect(ibutsize,-1,ibutsize+iscrollwidth-1,clientheight+1);
   end;//end of if
except;end;
end;
//## sliderect ##
function tvirtualscrollbar.sliderect:trect;
var
   a:tpoint;
begin
try
//check
if (islidesize<1) or (ipixelpower=0) then result:=rect(0,0,0,0)
else
   begin
   //get
   a:=slidexw;
   inc(a.x,ibutsize);
   inc(a.y,ibutsize);
   //set
   if vertical then result:=rect(0,a.x,clientwidth,a.y-1)
   else result:=rect(a.x,0,a.y-1,clientheight);
   end;//end of if
except;end;
end;
//## slidexw ##
function tvirtualscrollbar.slidexw:tpoint;
var
   a:integer;
begin
try
if (islidesize<1) or (ipixelpower=0) then result:=point(0,0)
else
   begin
   a:=ipos-imin;
   result.x:=round(a/ipixelpower);
   result.y:=result.x+islidesize;
   end;//end of if
except;end;
end;
//## movement ##
function tvirtualscrollbar.movement:tvirtualmovement;
var
   sx:integer;
begin
try
//defaults
result:=vmNone;
//keyboard
if down and igui.iskeyboard then
   begin
   case igui.key of
   vk_left,vk_up:result:=vmUp;//left,up
   vk_prior:result:=vmUpLarge;//page up
   vk_home:result:=vmUpHome;//home
   //.down
   vk_right,vk_down:result:=vmDn;//right,down
   vk_next:result:=vmDnLarge;//page down
   vk_end:result:=vmDnEnd;//end
   end;//end of case
   end
//mouse
else
   begin
   //.get
   sx:=scrollx;
   //.buttons
   if (sx<0) then result:=vmUp
   else if (sx>=scrollwidth) then result:=vmDn;
   //.slider area (large)
   if (result=vmNone) and (islidesize>=1) then
      begin
      if (sx<slidexw.x) then result:=vmUpLarge
      else if (sx>slidexw.y) then result:=vmDnLarge;//end of if
      end;//end of if
   end;//end of if
except;end;
end;
//## _onpaint ##
procedure tvirtualscrollbar._onpaint(sender:tobject;canvas:tcanvas);
var
   f:tpixelfilter;
   d,c,dx,dy:integer;
   m:tvirtualmovement;
   _up,_dn:boolean;
begin
try
//cls
canvas.fillrect(clientrect);
statefilter(f);
if igui.iskeyboard then m:=vmNone else m:=idownmovement;
_up:=((m=vmUp) or (m=vmUpLarge) or (m=vmUpHome)) and down;
_dn:=((m=vmDn) or (m=vmDnLarge) or (m=vmDnEnd)) and down;
//UP
if (not iup.empty) then with iup do
   begin
   //.filter
   if (@f=@plfFocused) and (not _up) then f:=nil;
   if (@f<>@plfDisabled) then c:=general.aorb(info^.font,info^.highlight,_up) else c:=canvas.font.color;
   setfilters(f,plsReplace,pixels[0,0],canvas.brush.color,0,c);
   //..calc
   if ivertical then
      begin
      dx:=((clientwidth-width) div 2);
      dy:=general.ifdiv(ibutsize-iup.height,2,ibutsize>iup.height);
      end
   else
      begin
      dx:=general.ifdiv(ibutsize-iup.width,2,ibutsize>iup.width);
      dy:=((clientheight-height) div 2);
      end;//end of if
   //..paint
   lock;
   pullall(false,false);
   canvas.draw(dx,dy,buffer);
   unlock;
   end;//end of with
//DN
if (not idn.empty) then with idn do
   begin
   //.filter
   if (@f=@plfFocused) and (not _dn) then f:=nil;
   if (@f<>@plfDisabled) then c:=general.aorb(info^.font,info^.highlight,_dn) else c:=canvas.font.color;
   setfilters(f,plsReplace,pixels[0,0],canvas.brush.color,0,c);
   //..calc
   if ivertical then
      begin
      dx:=clientwidth-width-((clientwidth-width) div 2);
      dy:=clientheight-height-general.ifdiv(ibutsize-idn.height,2,ibutsize>idn.height)
      end
   else
      begin
      dx:=clientwidth-width-general.ifdiv(ibutsize-idn.width,2,ibutsize>idn.width);
      dy:=(clientheight-height) div 2;
      end;//end of if
   //..paint
   lock;
   pullall(false,false);
   canvas.draw(dx,dy,buffer);
   unlock;
   end;//end of with
//INNER-BORDER
if (iscrollwidth>=1) then ccs.drect(canvas,scrollrect,canvas.pen.color,clNone,rounded);
//SLIDER
if (islidesize>=1) then
   begin
   if iscrolling and down then c:=info^.highlight
   else if focused then c:=info^.hover
   else if hovering then c:=info^.hover
   else if fDisable and (not enabled) then c:=info^.disable
   else c:=general.dc(info^.background,-30);
   ccs.drect(canvas,sliderect,canvas.pen.color,c,rounded);
   end;//end of if
except;end;
end;
//## _onrepeat ##
procedure tvirtualscrollbar._onrepeat(sender:tobject);
begin
try;if igui.ismouse and igui.wasdown and (not iscrolling) then mousedown;except;end;
end;
//## _onwheelv ##
procedure tvirtualscrollbar._onwheelv(sender:tobject);
var
   tmp:integer;
begin
try
//self
inherited;
//process
//.get
tmp:=round(igui.wheelv);
//.reset
igui.wheelv:=igui.wheelv-tmp;
//.set
if (tmp<>0) then pos:=pos-(tmp*small);
except;end;
end;
//## _onnotify ##
procedure tvirtualscrollbar._onnotify(sender:tobject);
var
   a:tpoint;
begin
try
//process
if (not iscrolling) and igui.iskeyboard and down then
   begin
   idownmovement:=movement;
   case idownmovement of
   vmUp:pos:=pos-small;
   vmUpLarge:pos:=pos-large;
   vmUpHome:pos:=min;
   vmDn:pos:=pos+small;
   vmDnLarge:pos:=pos+large;
   vmDnEnd:pos:=max;
   end;//end of case
   end
else if igui.ismouse then
   begin
   //.scrolling
   if (igui.act=aDown) and (not igui.wasdown) and (igui.key=mLeft) then
      begin
      a:=slidexw;
      iscrolling:=(scrollx>=a.x) and (scrollx<a.y);
      if iscrolling then idownpos:=pos;
      end;//end of if
   //.action
   if (igui.act=aDown) and (not iscrolling) and (igui.key=mLeft) then
      begin
      idownmovement:=movement;
      mousedown
      end
   else if iscrolling and down and (igui.key=mLeft) then pos:=frcrange(round(idownpos+(scrollx-scrolldx)*ipixelpower),min,max)
   else if (igui.act=aUp) then
      begin
      iscrolling:=false;
      idownmovement:=vmNone;
      end;//end of if
   end;//end of if
//self
inherited;
except;end;
end;
//## mousedown ##
procedure tvirtualscrollbar.mousedown;
begin
try
if enabled and (igui.key=mLeft) then
   begin
   case idownmovement of
   vmUp:pos:=pos-small;
   vmUpLarge:pos:=pos-large;
   vmUpHome:pos:=min;
   vmDn:pos:=pos+small;
   vmDnLarge:pos:=pos+large;
   vmDnEnd:pos:=max;
   end;//end of case
   end;//end of if
except;end;
end;

//## tvirtualpage ##############################################################
//## create ##
constructor tvirtualpage.create(_gui:tvirtualform);
begin//Note: destroy's it's children
//self
inherited create(_gui);
//defaults
style:=[];
cursor:=vcArrow;
end;
//## destroy ##
destructor tvirtualpage.destroy;
begin
try
//init
destroyinit;
//children
destroychildren;
//self
inherited;
except;end;
end;
//## getclient ##
function tvirtualpage.getclient:tvirtualpage;
begin
try;result:=self;except;end;
end;
//## getpagetabs ##
function tvirtualpage.getpagetabs:tvirtualpages;
begin
try
//defaults
result:=ipagetabs;
//get
if (ipagetabs=nil) then
   begin
   ipagetabs:=tvirtualpages.create(igui);
   ipagetabs.setup(client);
   ipagetabs.oseptop:=false;
   ipagetabs.aslinks;
   //set
   result:=ipagetabs;
   end;//end of if
except;end;
end;

//## tvirtualpagevsplit ########################################################
//## create ##
constructor tvirtualpagevsplit.create(_gui:tvirtualform);
var
   p:integer;
begin//Note: destroy's it's children
//self
inherited create(_gui);
//defaults
hspace:=1;
bordersize:=0;
oVariableheight:=true;
ipercentage:=50;
ipageheight:=0;
for p:=0 to high(ipages) do ipages[p]:=nil;
end;
//## createinit ##
procedure tvirtualpagevsplit.createinit(scrollTOP,scrollBOTTOM:boolean);
begin
try
//top
if (ipages[0]=nil) then
   begin
   ipages[0]:=new('page'+general.insstr('scroll',scrollTOP),'','','',valNone,nil) as tvirtualpage;
   ipages[0].bordersize:=0;
   end;//end of if
//bottom
if (ipages[1]=nil) then
   begin
   ipages[1]:=new('page'+general.insstr('scroll',scrollBOTTOM),'','','',valNone,nil) as tvirtualpage;
   ipages[1].bordersize:=0;
   end;//end of if
except;end;
end;
//## fillbar ##
procedure tvirtualpagevsplit.fillbar;
begin
try
//.check
if ifillbar or horizontal then exit else ifillbar:=true;
//process
//.init
createinit(false,false);
//.set
ihorizontal:=false;
with pages[1] do
begin
oHeight:=vhsControls;
new('sb-apply','','','',valRight,nil);
new('sb-defaults','','','',valRight,nil);
new('sb-defaultappearance','','','',valRight,nil);
end;//end of with
//.realign
realign(true);
except;end;
end;
//## sethorizontal ##
procedure tvirtualpagevsplit.sethorizontal(x:boolean);
begin
try;if general.setbol(x,ihorizontal) then realign(true);except;end;
end;
//## setpercentage ##
procedure tvirtualpagevsplit.setpercentage(x:extended);
begin
try
//range
if (x<0) then x:=0
else if (x>100) then x:=100;
//set
if (ipercentage<>x) or (ipageheight<>0) then
   begin
   ipercentage:=x;
   ipageheight:=0;
   //.realign
   realign(true);
   end;//end of if
except;end;
end;
//## setpageheight ##
procedure tvirtualpagevsplit.setpageheight(x:integer);
begin
try
//set
if (ipageheight<>x) or (ipercentage<>0) then
   begin
   ipageheight:=x;
   ipercentage:=0;
   //.realign
   realign(true);
   end;//end of if
except;end;
end;
//## getpages ##
function tvirtualpagevsplit.getpages(x:integer):tvirtualpage;
begin
try;result:=ipages[frcrange(x,0,1)];except;end;
end;
//## canalign ##
function tvirtualpagevsplit.canalign:boolean;
begin
try;result:=(inherited canalign) and (ipages[0]<>nil) and (ipages[1]<>nil);except;end;
end;
//## doalign ##
procedure tvirtualpagevsplit.doalign;
label
   skipcalc;
var//Do not call "inherited doalign", since we are to ignore all children controls
   htmp,o,cw,ch,d,h1,h2,y,h:integer;
begin
try
//check
if not canalign then exit;
//process
//pages
if (ipages[0]<>nil) and (ipages[1]<>nil) then
   begin//int
   //.d
   cw:=clientwidth;
   ch:=clientheight;
   d:=general.aorb(ch,cw,ihorizontal);
   if ihorizontal then o:=frcmin(hspace,0) else o:=0;
   //.Autoheight - vertical only
   if (not ihorizontal) and ((ipages[0].oHeight<>vhsClient) or (ipages[1].oHeight<>vhsClient)) then
      begin
      h1:=ch div 2;
      h2:=frcmin(ch-h1-o,0);
      if (ipages[0].oHeight<>vhsClient) then
         begin
         h1:=frcrange(ipages[0].getalignheight,0,d);
         h2:=frcrange(d-h1-o,0,d);
         end
      else if (ipages[1].oHeight<>vhsClient) then
         begin
         h2:=frcrange(ipages[1].getalignheight,0,d);
         h1:=frcrange(d-h2-o,0,d);
         end;//end of if
      goto skipcalc;
      end;//end of if
   //.get
   if (ipageheight<0) then
      begin
      h1:=frcrange(-ipageheight,0,d);
      h2:=frcrange(d-h1-o,0,d);
      end//int
   else if (ipageheight>0) then
      begin
      h2:=frcrange(ipageheight,0,d);
      h1:=frcrange(d-h2-o,0,d);
      end
   else//%
      begin
      h1:=frcrange(round((ipercentage*d)/100),0,d);
      h2:=frcrange(d-h1-o,0,d);
      end;//end of if
skipcalc:
   //.set
   case ihorizontal of
   true:begin
      ipages[0].setboundsex(0,0,h1,ch,true);
      ipages[1].setboundsex(h1+o,0,h2,ch,true);
      end;//end of begin
   false:begin
      ipages[0].setboundsex(0,0,cw,h1,true);
      ipages[1].setboundsex(0,ch-h2,cw,h2,true);
      end;//end of begin
   end;//end of case
   end;//end of if
except;end;
end;

//## tvirtualpagescroll ########################################################
//## create ##
constructor tvirtualpagescroll.create(_gui:tvirtualform);
begin//Note: "new" refers to controls within "iclient"
     //Note: destroy's it's children
//self
inherited create(_gui);
//controls
//.isb
isb:=igui.new('scrollbar','','','',valNone,self,nil) as tvirtualscrollbar;
isb.vertical:=true;
//.iclient
iclient:=igui.new('page','','','',valNone,self,nil) as tvirtualpage;
iclient.bordersize:=0;
iclient.oAllowvariableheights:=false;
iclient.scrollnotify:=false;
//.ibar
ibar:=igui.new('page','','','',valNone,self,nil) as tvirtualpage;
ibar.bordersize:=0;
//.events
isb.onpos:=_onpos;
//defaults
oVariableheight:=true;
end;
//## destroy ##
destructor tvirtualpagescroll.destroy;
begin
try
//init
destroyinit;
//children - client only
iclient.destroychildren;
//self
inherited;
except;end;
end;
//## getclient ##
function tvirtualpagescroll.getclient:tvirtualpage;
begin
try;result:=iclient;except;end;
end;
//## fillbar ##
procedure tvirtualpagescroll.fillbar;
begin
try
with ibar do
begin
oHeight:=vhsControls;
new('sb-apply','','','',valRight,nil);
new('sb-defaults','','','',valRight,nil);
new('sb-defaultappearance','','','',valRight,nil);
end;//end of with
except;end;
end;
//## new ##
function tvirtualpagescroll.new(_type:string;_caption,_tep,_help:string;_align:tvirtualalign;_onclick:tnotifyevent):tvirtualcontrol;
begin
try;if (igui<>nil) then result:=igui.new(_type,_caption,_tep,_help,_align,iclient,_onclick) else result:=nil;except;end;
end;
//## newb ##
function tvirtualpagescroll.newb(_type:string;_caption,_tep,_help:string;_align:tvirtualalign;_onclick:tnotifyevent;_sysptr:integer;_style:tstoragestyle;_default,_range:string):tvirtualcontrol;
begin
try;if (igui<>nil) then result:=igui.newb(_type,_caption,_tep,_help,_align,iclient,_onclick,_sysptr,_style,_default,_range) else result:=nil;except;end;
end;
//## _onpaint ##
procedure tvirtualpagescroll._onpaint(sender:tobject;canvas:tcanvas);
begin
try
//cls
canvas.fillrect(clientrect);
except;end;
end;
//## canalign ##
function tvirtualpagescroll.canalign:boolean;
begin
try;result:=(ilockalign=0) and (inherited canalign) and (iclient<>nil) and (ibar<>nil);except;end;
end;
//## doalign ##
procedure tvirtualpagescroll.doalign;
var
   barh,oldpos,max,tmp:integer;
begin
try
//check
if not canalign then exit;
//process
//.get
barh:=general.aorb(0,ibar.getalignheight,ibar.visible and (ibar.controls.count>=1));
//.isb
oldpos:=isb.pos;
isb.setboundsb(clientwidth-viMainScrollSize,0,viMainScrollSize,clientheight-barh);
//.ibar
ibar.setboundsex(0,clientheight-barh,clientwidth,barh,true);
//.iclient
iclient.setboundsb(0,0,isb.left,clientheight-barh);
//.height
tmp:=0;
if (iclient.bottommost<>nil) then tmp:=iclient.bottommost.top+iclient.bottommost.height-iclient.scrolly;
max:=frcmin(tmp-iclient.height,0);
isb.setparams(0,oldpos,max,false);
//.controls
iclient.scrolly:=-isb.pos;
iclient.doalign;
//.small/large
isb.stepby:=4;
isb.large:=frcmin(round(clientheight*0.90),4*isb.stepby);
isb.small:=4*isb.stepby;
//.update scrollbar
isb.init;
except;end;
end;
//## lockalign ##
procedure tvirtualpagescroll.lockalign;
begin
try;inc(ilockalign);except;end;
end;
//## unlockalign ##
procedure tvirtualpagescroll.unlockalign;
begin
try
dec(ilockalign);
if (ilockalign=0) then realign(true);
except;end;
end;
//## _onpos ##
procedure tvirtualpagescroll._onpos(sender:tobject);
begin
try
iclient.scrolly:=-isb.pos;
iclient.scrollchanged;
except;end;
end;
//## readwrite ##
procedure tvirtualpagescroll.readwrite(mode:tvirtualstoragemode);
begin
try
case mode of
vsmUpdatecontrols:if (isb.width<>viMainScrollSize) then doalign;
end;//end of case
except;end;
end;

//## tvirtualgrid ##############################################################
//## create ##
constructor tvirtualgrid.create(_gui:tvirtualform);
begin
//self
inherited create(_gui);
oHeight:=vhsInternal;
//defaults
ispace:=2;
oAlignpastcaption:=true;
end;
//## _vhsInternal ##
function tvirtualgrid._vhsInternal:integer;
var
   p,sp,tmp:integer;
begin
try
//defaults
result:=0;
//get
if (parent<>nil) then
   begin
   //.spacing
   sp:=frcmin(ispace,0);
   for p:=0 to (controls.count-1) do controls.items[p].alignmargin:=sp;
   //.calc
   doalign;
   //.border
   tmp:=(2*bordersize)+sp;
   //.content width
   if (bottommost<>nil) then inc(tmp,bottommost.top+bottommost.getalignheight) else inc(tmp,4);
   //.set
   result:=frcmin(tmp,0);
   end;//end of if
except;end;
end;
//## _onpaint ##
procedure tvirtualgrid._onpaint(sender:tobject;canvas:tcanvas);
const
   sp=2;
var
   a:tsize;
   dx,dy:integer;
   tmp:string;
begin
try
//check
tmp:=vcaption;
if (tmp='') then
   begin
   //cls
   canvas.fillrect(clientrect);
   exit;
   end;//end of if
//setup
canvas.font.height:=_vhsClient;
canvas.font.style:=canvas.font.style+[fsBold];
//calc
a:=canvas.textextent(tmp);
//focus indicator - additional
if (not fBorder) and (not fBackground) then
   begin
   if focused or hovering then canvas.font.style:=canvas.font.style+[fsUnderline];
   end;//end of if
//cls
canvas.fillrect(clientrect);
//text
canvas.brush.style:=bsClear;
dx:=sp;
dy:=(clientheight-a.cy) div 2;
//.draw
canvas.textout(dx,dy,tmp);
except;end;
end;
//## doalign ##
procedure tvirtualgrid.doalign;
var
   p,sp,_space:integer;
   a:tfont;
begin
try
//defaults
a:=nil;
//get
_space:=0;
if oAlignpastcaption and (caption<>'') then
   begin
   //.init
   a:=tfont.create;
   a.assign(info^.fontmap.font);
   a.height:=_vhsClient;
   a.style:=a.style+[fsBold];
   //.get
   _space:=frcmin(misc.fontwidth(a,caption),0);
   //.set - allow 5 pixel gap between caption and controls
   if (_space>=1) then inc(_space,5);
   end;//end of if
//set
inherited doalignb(_space);
except;end;
try;freeobj(@a);except;end;
end;

//## tvirtualbaselist ##########################################################
//## create ##
constructor tvirtualbaselist.create(_gui:tvirtualform);
begin
//self
inherited create(_gui);
//controls
//.isb
isb:=new('scrollbar','','','',valNone,nil) as tvirtualscrollbar;
isb.internalhelp:=rthtranslate('Scroll list vertically');
isb.vertical:=true;
isb.width:=viScrollSize;
isb.style:=[];
//.self
style:=[vlsFocus,vlsHover];
self.groupfocus:=true;
isb.groupfocus:=groupfocus;
//events
isb.onpos:=_onpos;
//defaults
ief:=[vefCut,vefCopy,vefCopyAll,vefDelete];
ilastch:=-1;
ireadonly:=true;
iautofind:=true;
iautohide:=true;
setparamsb(0,-1,0,0,16,false);
cursor:=vcLink;
fBackground:=false;
fUnderline:=false;
fUpdnpaint:=false;
oVariableheight:=true;
bufferrows:=true;//flicker free, fast operation
//init
init;
end;
//## destroy ##
destructor tvirtualbaselist.destroy;
begin
try
//init
destroyinit;
//controls
freeobj(@isb);
freeobj(@iimage);
freeobj(@ipopmenu);
//self
inherited;
except;end;
end;
//## astext ##
function tvirtualbaselist.astext:string;
begin
try;result:=misc.enforceEOLex(text,false);except;end;
end;
//## gettext ##
function tvirtualbaselist.gettext:string;
var
   len,p:integer;
begin
try
//defaults
result:='';
len:=0;
//process
//.get
for p:=0 to (count-1) do pushb(len,result,items[p]+rcode);
//.finalise
pushb(len,result,'');
except;end;
end;
//## settext ##
procedure tvirtualbaselist.settext(x:string);
begin
try;doonchange;except;end;
end;
//## readwrite ##
procedure tvirtualbaselist.readwrite(mode:tvirtualstoragemode);
begin
try
case mode of
vsmUpdatecontrols:if (viScrollSize<>isb.width) then _scrollbar;
end;//end of case
except;end;
end;
//## _scrollbar ##
procedure tvirtualbaselist._scrollbar;
begin
try;isb.setboundsb(clientwidth-viScrollSize,0,viScrollSize,clientheight);except;end;
end;
//## canalign ##
function tvirtualbaselist.canalign:boolean;
begin
try;result:=(inherited canalign) and (isb<>nil);except;end;
end;
//## doalign ##
procedure tvirtualbaselist.doalign;
begin
try
//check
if not canalign then exit;
//process
//.isb
_scrollbar;
//.init
init;
except;end;
end;
//## findvalue ##
function tvirtualbaselist.findvalue(x:string):integer;
var
   p:integer;
begin
try
//defaults
result:=-1;
//check
if (count=0) then exit;
//process
for p:=0 to (count-1) do if (0=comparetext(getitem(p),x)) then
   begin
   result:=p;
   break;
   end;//end of if
except;end;
end;
//## findtext ##
function tvirtualbaselist.findtext(x:string):integer;
begin
try;result:=findtextb(itemindex+1,x,true);except;end;
end;
//## findtextb ##
function tvirtualbaselist.findtextb(from:integer;x:string;loop:boolean):integer;
var
   xlen,p:integer;
begin
try
//defaults
result:=-1;
//check
if (count=0) then exit;
//setup
from:=frcmin(from,0);
xlen:=length(x);
//process
//.find - 1
for p:=from to (count-1) do if (0=comparetext(copy(getitem(p),1,xlen),x)) then
   begin
   result:=p;
   break;
   end;//end of if
//.find - 2
if (result=-1) and loop then for p:=0 to frcmax(from-1,count-1) do if (0=comparetext(copy(getitem(p),1,xlen),x)) then
   begin
   result:=p;
   break;
   end;//end of if
except;end;
end;
//## setautohide ##
procedure tvirtualbaselist.setautohide(x:boolean);
begin
try;if general.setbol(x,iautohide) then _autohide;except;end;
end;
//## setmultiselect ##
procedure tvirtualbaselist.setmultiselect(x:boolean);
begin
try;if general.setbol(x,imultiselect) then paint;except;end;
end;
//## selstart ##
function tvirtualbaselist.selstart:integer;
begin//always 0..X
try
//get
if imultiselect then result:=general.aorb(iitemindex,iselpos,iselpos<iitemindex)
else result:=iitemindex;
//range
result:=frcmin(result,0);
except;end;
end;
//## selcount ##
function tvirtualbaselist.selcount:integer;
var
   min,max:integer;
begin
try
//defaults
result:=1;//non-multiselect
//process
if (icount=0) or (iitemindex=-1) or (iselpos=-1) then result:=0
else if imultiselect then
   begin
   //.get
   min:=iitemindex;
   max:=iselpos;
   if (min>max) then swapint(min,max);
   //.set
   result:=frcmin(max-min+1,0);
   end;//end of if
except;end;
end;
//## seltext ##
function tvirtualbaselist.seltext:string;
begin
try;getselB(result);except;end;
end;
//## getselected ##
function tvirtualbaselist.getselected(x:integer):boolean;
var
   ss,sc:integer;
begin
try
//defaults
result:=false;
//check
if (x<0) or (x>=count) then exit;
//process
if (x=iitemindex) then result:=true
else if imultiselect then
   begin
   ss:=selstart;
   sc:=selcount;
   result:=(x>=ss) and (x<(ss+sc));
   end;//end of if
except;end;
end;
//## getitem ##
function tvirtualbaselist.getitem(x:integer):string;
begin
try
//defaults
result:='';
//process
if assigned(fongetitem) then fongetitem(self,x,result)
else
   begin
   //yyyyyyyyyyyyyyyyyy
   result:='Example'#9+'Item - '+#9+inttostr(x);
   end;//end of if
except;end;
end;
//## setitem ##
procedure tvirtualbaselist.setitem(x:integer;y:string);
begin
//nil
end;
//## getindent ##
function tvirtualbaselist.getindent(x:integer):word;
begin
try
//defaults
result:=0;
//process
if assigned(fongetindent) then fongetindent(self,x,result);
except;end;
end;
//## setindent ##
procedure tvirtualbaselist.setindent(x:integer;y:word);
begin
//nil
end;
//## init ##
procedure tvirtualbaselist.init;
begin
try;setparamsb(selpos,itemindex,topindex,count,itemheight,false);except;end;
end;
//## setparams ##
function tvirtualbaselist.setparams(_itemindex,_topindex,_count,_itemheight:integer;_paint:boolean):boolean;
begin
try;result:=setparamsb(general.aorb(_itemindex,selpos,selactive<>[]),_itemindex,_topindex,_count,_itemheight,_paint);except;end;
end;
//## setparams ##
function tvirtualbaselist.setparamsb(_selpos,_itemindex,_topindex,_count,_itemheight:integer;_paint:boolean):boolean;
var
   _paintih,vc,max,sc:integer;
   iok:boolean;
begin
try
//defaults
result:=false;
//range
_paintih:=ipaintih;
_itemheight:=frcmin(_itemheight,6);
_paintih:=largest(_itemheight,2+_vhsFont);
_count:=frcmin(_count,0);
sc:=frcmin(_count-1,0);
_topindex:=frcrange(_topindex,0,sc);
_selpos:=frcrange(_selpos,0,sc);
_itemindex:=frcrange(_itemindex,-1,sc);
//check
if (iselpos=_selpos) and
   (iitemindex=_itemindex) and
   (topindex=_topindex) and
   (icount=_count) and
   (iitemheight=_itemheight) and
   (ipaintih=_paintih) and
   (ilastch=clientheight) and
   (not dimensionsmodified) then exit;
//process
//.stoppaint
istoppaint:=true;
//.set
ipaintih:=_paintih;//internal itemheight used for variable font.height values
iitemheight:=_itemheight;
ilastch:=clientheight;
iselpos:=_selpos;
icount:=_count;
iok:=general.setint(_itemindex,iitemindex);
//.scrollbar
max:=frcmin(_count-vcount,0);
if (max>=1) and ((vcount*itemheight)>clientheight) then inc(max);
isb.setparams(0,_topindex,max,false);
isb.small:=1;
isb.large:=frcmin(vcount-1,1);
//.autohide - don't paint now, only later
isb.oPaintOnVisible:=false;
_autohide;
isb.oPaintOnVisible:=true;
//.paint
if _paint then
   begin
   paint;
   isb.paint;
   //onitem
   fireevent(fonpos,self);
   if iok then fireevent(fonitemindex,self);
   end;//end of if
//modified
result:=true;
except;end;
try;istoppaint:=false;except;end;
end;
//## _autohide ##
procedure tvirtualbaselist._autohide;
begin
try;isb.visible:=(isb.max>0) or (not autohide);except;end;
end;
//## _onpos ##
procedure tvirtualbaselist._onpos(sender:tobject);
begin
try
if not istoppaint then
   begin
   paint;
   //onpos
   fireevent(fonpos,self);
   end;//end of if
except;end;
end;
//## setcount ##
procedure tvirtualbaselist.setcount(x:integer);
begin
try;setparams(itemindex,topindex,x,itemheight,true);except;end;
end;
//## settopindex ##
procedure tvirtualbaselist.settopindex(x:integer);
begin
try;setparams(itemindex,x,count,itemheight,true);except;end;
end;
//## setitemindex ##
procedure tvirtualbaselist.setitemindex(x:integer);
var
   a,old,t:integer;
   _more,_less,_paint:boolean;
begin
try
//process
//.init
partialinit;
//.get
old:=itemindex;
a:=isb.pos;
//.set
_paint:=setparams(x,topindex,count,itemheight,false);
//.decide
_less:=(itemindex<old);
_more:=(itemindex>old);
//.topindex
t:=topindex;
if _less and ((itemindex<vstart) or (itemindex>vfinish)) then t:=itemindex
else if _more and ((itemindex<vstart) or (itemindex>vfinish)) then t:=frcmin(itemindex-vcount+1,0);
if (t<>topindex) and setparamsb(selpos,itemindex,t,count,itemheight,false) then _paint:=true;
//.paint
if _paint then
   begin
   partialpaint;
   if (a<>isb.pos) then isb.paint;
   //onitem
   fireevent(fonpos,self);
   if (old<>itemindex) then fireevent(fonitemindex,self);
   end;//end of if
except;end;
end;
//## setitemheight ##
procedure tvirtualbaselist.setitemheight(x:integer);
begin
try;setparams(itemindex,topindex,count,x,true);except;end;
end;
//## gettopindex ##
function tvirtualbaselist.gettopindex:integer;
begin
try;result:=isb.pos;except;end;
end;
//## vstart ##
function tvirtualbaselist.vstart:integer;
begin
try;result:=frcmin(isb.pos,0);except;end;
end;
//## vfinish ##
function tvirtualbaselist.vfinish:integer;
begin
try
if (icount=0) then result:=-1
else result:=frcrange(vstart+vcount-1,0,count-1);
except;end;
end;
//## vcount ##
function tvirtualbaselist.vcount:integer;
begin
try;result:=(clientheight div ipaintih);except;end;
end;
//## _onrepeat ##
procedure tvirtualbaselist._onrepeat(sender:tobject);
begin
try
if isbfocused then isb._onrepeat(isb)
else if iclientfocused then mousedown;
except;end;
end;
//## mousedown ##
procedure tvirtualbaselist.mousedown;
var
   p:integer;
begin
try
//.mouse
if iclientfocused and igui.ismouse and igui.down and (igui.key=mLeft) then
   begin
   if (y<0) then
      begin
      p:=1+((-y div ipaintih) div 2);
      itemindex:=frcmin(itemindex-p,0)
      end
   else if (y>(vcount*ipaintih)) then
      begin
      p:=1+(((y-(vcount*ipaintih)) div ipaintih) div 2);
      itemindex:=frcmax(itemindex+p,count-1);
      end;//end of if
   end;//end of if
except;end;
end;
//## _onwheelv ##
procedure tvirtualbaselist._onwheelv(sender:tobject);
var
   tmp:integer;
begin
try
//self
inherited;
//process
//.get
tmp:=round(igui.wheelv);
//.reset
igui.wheelv:=igui.wheelv-tmp;
//.set
if (tmp<>0) then isb.pos:=isb.pos-(tmp*isb.small);
except;end;
end;
//## _onnotify ##
procedure tvirtualbaselist._onnotify(sender:tobject);
var
   e:string;
   wascf,cf:boolean;
   p:integer;
   _key:byte;
begin
try
//SCROLLBAR
//.start
if igui.ismouse and (igui.act=aDown) and (x>=isb.left) then isbfocused:=true;
//.re-route
if isbfocused then
   begin
   isb._onnotify(isb);
   //..cancel double click
   dblclickcancel;
   end;//end of if
//.finish
wascf:=not isbfocused;
if igui.ismouse and (igui.act=aUp) then isbfocused:=false;

//SELF
//.start
if igui.ismouse and (igui.act=aDown) and (igui.key=mLeft) and (x<isb.left) then iclientfocused:=true;
//.mouse
if iclientfocused and igui.ismouse and (igui.key=mLeft) then
   begin
   if (igui.act=aDown) then
      begin
      itemindex:=itematpos(x,y,true);
      include(iselactive,vslMouse);
      end
   else if (igui.act=aMove) then itemindex:=itematpos(x,y,true);
   end;//end of if
//.keyboard
if (not isbfocused) and igui.iskeyboard then
   begin
   //..shift
   if igui.shift and (not (vslKeyboard in iselactive)) then include(iselactive,vslKeyboard);
   //..key
   if igui.down then
      begin
      //.onkey
      _key:=igui.key;
      if assigned(onkey) then onkey(self,_key);
      //.key
      case _key of
      vk_left,vk_up:itemindex:=frcmin(itemindex-1,0);//left,up
      vk_prior:itemindex:=frcmin(itemindex-frcmin(vcount-1,1),0);//page up
      vk_home:itemindex:=0;//home
      vk_right,vk_down:itemindex:=frcmax(itemindex+1,count-1);//right,down
      vk_next:itemindex:=frcmax(itemindex+frcmin(vcount-1,1),count-1);//page down
      vk_end:itemindex:=count-1;//end
      vk_return,vk_space:fireevent(fonitemhard,self);
      vk_delete:delete(e);
      else if iautofind and (igui.clas=recKey) and (_key>=32) then
         begin
         p:=findtext(char(_key));
         if (p>=0) then itemindex:=p;
         end;//end of if
      end;//end of case
      end;//end of if
   end;//end of if
//.finish
if igui.ismouse and (igui.act=aUp) then
   begin
   cf:=iclientfocused;
   iclientfocused:=false;
   exclude(iselactive,vslMouse);
   //onitemhard
   if cf and (igui.key=mLeft) then fireevent(fonitemhard,self);
   //showmenu
   if oShowmenu and wascf and igui.ismouse and (igui.act=aUp) and (igui.key=mRight) then showmenu;
   end;//end of if
//events 22SEP2007
if (not gui.down) then
   begin
   if (igui.clas=recKeyX) then
      case igui.key of
      vk_return:fireevent(onreturn,self);
      vk_escape:fireevent(onescape,self);
      end;//end of if
   end;//end of if
//.inherited
inherited;
except;end;
end;
//## getcanshowmenu ##
function tvirtualbaselist.getcanshowmenu:boolean;
begin
try;result:=(ipopmenu=nil) and oShowmenu;except;end;
end;
//## showmenu ##
procedure tvirtualbaselist.showmenu;
var
   e:string;
   ok:boolean;
begin
try
//defaults
ok:=true;
e:=gecTaskFailed;
//check
if not canshowmenu then exit;
//process
//.get
ipopmenu:=tpopmenu.create(nil);
ipopmenu.menu:=@smTEXT;
//.set
menus.itemenabled[ipopmenu.menu,smcCut]:=cancuttoclipboard;
menus.itemenabled[ipopmenu.menu,smcCopyAll]:=cancopyall;
menus.itemenabled[ipopmenu.menu,smcCopy]:=cancopytoclipboard;
menus.itemenabled[ipopmenu.menu,smcPaste]:=canpastefromclipboard;
menus.itemenabled[ipopmenu.menu,smcDelete]:=candelete;
menus.itemenabled[ipopmenu.menu,smcSelectAll]:=canselectall;
menus.itemenabled[ipopmenu.menu,smcUpper]:=canupper;
menus.itemenabled[ipopmenu.menu,smcLower]:=canlower;
menus.itemenabled[ipopmenu.menu,smcEdit]:=canedit;
//.action
case ipopmenu.popcursor(igui) of
smcCut:ok:=cuttoclipboard(e);
smcCopy:ok:=copytoclipboard(e);
smcCopyAll:ok:=copyall(e);
smcPaste:ok:=pastefromclipboard(e);
smcDelete:ok:=delete(e);
smcSelectall:ok:=selectall(e);
smcUpper:ok:=upper;
smcLower:ok:=lower;
smcEdit:ok:=edit;
end;//end of case
except;end;
try
freeobj(@ipopmenu);
if not ok then showerror60(translate(e));
except;end;
end;
//## _onshortcut ##
function tvirtualbaselist._onshortcut(_shortcut:string):boolean;
var
   ok:boolean;
   e:string;
begin
try
//defaults
result:=false;
ok:=true;
//process
if (_shortcut='CTRL+T') and cancuttoclipboard then//cut
   begin
   result:=true;
   ok:=cuttoclipboard(e);
   end
else if (_shortcut='CTRL+C') and cancopytoclipboard then//copy
   begin
   result:=true;
   ok:=copytoclipboard(e);
   end
else if (_shortcut='CTRL+A') and cancopyall then//copy all
   begin
   result:=true;
   ok:=copyall(e);
   end
else if (_shortcut='CTRL+P') and canpastefromclipboard then//paste
   begin
   result:=true;
   ok:=pastefromclipboard(e);
   end
else if (_shortcut='CTRL+D') and candelete then//delete
   begin
   result:=true;
   ok:=delete(e);
   end
else if (_shortcut='CTRL+S') and canselectall then//select all
   begin
   result:=true;
   ok:=selectall(e);
   end
else if (_shortcut='CTRL+U') and canupper then//upper case
   begin
   result:=true;
   upper;
   end
else if (_shortcut='CTRL+L') and canlower then//lower case
   begin
   result:=true;
   lower;
   end
else if (_shortcut='CTRL+M') and canshowmenu then//menu
   begin
   result:=true;
   showmenu;
   end
else if (_shortcut='CTRL+E') and canedit then//edit
   begin
   result:=true;
   edit;
   end;//end of if
//.error
if result and (not ok) then showerror60(translate(e));
except;end;
end;
//## getselA ##
procedure tvirtualbaselist.getselA(var x:string);
var//Before selection
   ss,sc,minp,maxp,xlen,p:integer;
begin
try
//setup
x:='';
xlen:=0;
ss:=selstart;
sc:=selcount;
//process
//.decide
if (sc=0) then
   begin
   minp:=0;
   maxp:=count-1;
   end
else
   begin
   minp:=0;
   maxp:=ss-1;
   end;//end of if
//.get
for p:=minp to maxp do pushb(xlen,x,items[p]+rcode);
pushb(xlen,x,'');
except;end;
end;
//## getselB ##
procedure tvirtualbaselist.getselB(var x:string);
var//Actual selection
   ss,sc,minp,maxp,xlen,p:integer;
begin
try
//setup
x:='';
xlen:=0;
ss:=selstart;
sc:=selcount;
//process
//.decide
if (sc=0) then exit
else
   begin
   minp:=ss;
   maxp:=minp+sc-1;
   end;//end of if
//.get
for p:=minp to maxp do pushb(xlen,x,items[p]+rcode);
pushb(xlen,x,'');
except;end;
end;
//## getselC ##
procedure tvirtualbaselist.getselC(var x:string);
var//After selection
   ss,sc,minp,maxp,xlen,p:integer;
begin
try
//setup
x:='';
xlen:=0;
ss:=selstart;
sc:=selcount;
//process
//.decide
if (sc=0) then exit
else
   begin
   minp:=ss+sc;
   maxp:=count-1;
   end;//end of if
//.get
for p:=minp to maxp do pushb(xlen,x,items[p]+rcode);
pushb(xlen,x,'');
except;end;
end;
//## delselB ##
procedure tvirtualbaselist.delselB(var i:integer);
var//Actual selection
   ss,sc,p,minp,maxp:integer;
begin
try
//setup
ss:=selstart;
sc:=selcount;
minp:=ss;
maxp:=ss+sc-1;
i:=itemindex;
//process
if (maxp>=minp) then
   begin
   //.set
   for p:=maxp downto minp do
   begin
   deleteitem(p);
   if (i>=1) and (p<=i) then dec(i);
   end;//end of loop
   end;//end of if
except;end;
end;
//## canselectall ##
function tvirtualbaselist.canselectall:boolean;
begin
try;result:=(vefSelectAll in ief) and multiselect and (selcount<>count);except;end;
end;
//## selectall ##
function tvirtualbaselist.selectall(var e:string):boolean;
var
   c:integer;
begin
try
//defaults
result:=false;
e:=gecTaskFailed;
//process
if canselectall then
   begin
   //.set
   c:=count-1;
   setparamsb(0,c,c,count,itemheight,true);
   //successful
   result:=true;
   end;//end of if
except;end;
end;
//## cancuttoclipboard ##
function tvirtualbaselist.cancuttoclipboard:boolean;
begin
try;result:=(vefCut in ief) and (selcount>=1) and (not ireadonly);except;end;
end;
//## cuttoclipboard ##
function tvirtualbaselist.cuttoclipboard(var e:string):boolean;
var
   i:integer;
   a,b,c:string;
begin
try
//defaults
result:=false;
e:=gecTaskFailed;
//process
if cancopytoclipboard then
   begin
   //.lock
   lock;
   //.get
   getsela(a);
   getselb(b);
   getselc(c);
   //.set
   clipboard.astext:=b;
   //.text
   delselB(i);
   text:=a+c;
   //.unlock
   itemindex:=i;
   unlock;
   //successful
   result:=true;
   end;//end of if
except;end;
end;
//## deleteitem ##
procedure tvirtualbaselist.deleteitem(x:integer);
begin
try
if assigned(fondelitem) then fondelitem(self,x);
count:=frcmin(count-1,0);
except;end;
end;
//## candelete ##
function tvirtualbaselist.candelete:boolean;
begin
try;result:=(vefDelete in ief) and (not ireadonly) and (selcount>=1);except;end;
end;
//## delete ##
function tvirtualbaselist.delete(var e:string):boolean;//delete selection
var
   i:integer;
   a,c:string;
begin
try
//defaults
result:=false;
e:=gecTaskFailed;
//process
if candelete then
   begin
   //.lock
   lock;
   //.get
   getsela(a);
   getselc(c);
   //.text
   delselB(i);
   text:=a+c;
   //.unlock
   itemindex:=i;
   unlock;
   //successful
   result:=true;
   end;//end of if
except;end;
end;
//## cancopytoclipboard ##
function tvirtualbaselist.cancopytoclipboard:boolean;
begin
try;result:=(vefCopy in ief) and (selcount>=1);except;end;
end;
//## copytoclipboard ##
function tvirtualbaselist.copytoclipboard(var e:string):boolean;
var
   b:string;
begin
try
//defaults
result:=false;
e:=gecTaskFailed;
//process
if cancopytoclipboard then
   begin
   //.get
   getselb(b);
   //.set
   clipboard.astext:=b;
   //successful
   result:=true;
   end;//end of if
except;end;
end;
//## cancopyall ##
function tvirtualbaselist.cancopyall:boolean;
begin
try;result:=(vefCopyAll in ief) and (count>=1);except;end;
end;
//## copyall ##
function tvirtualbaselist.copyall(var e:string):boolean;
var
   b:string;
begin
try
//defaults
result:=false;
e:=gecTaskFailed;
//process
if cancopyall then
   begin
   //.get
   clipboard.astext:=text;
   //successful
   result:=true;
   end;//end of if
except;end;
end;
//## canpastefromclipboard ##
function tvirtualbaselist.canpastefromclipboard:boolean;
begin
try;result:=(vefPaste in ief) and (not ireadonly) and clipboard.hasformat(cf_text);except;end;
end;
//## pastefromclipboard ##
function tvirtualbaselist.pastefromclipboard(var e:string):boolean;
var
   i,xlen:integer;
   x,a,b,c:string;
begin
try
//defaults
result:=false;
e:=gecTaskFailed;
//process
if canpastefromclipboard then
   begin
   //.lock
   lock;
   //.get
   getsela(a);
   getselb(b);
   getselc(c);
   //..force return code
   x:=clipboard.astext;
   xlen:=length(x);
   if (xlen>=1) and (x[xlen]<>#10) then x:=x+rcode;
   //.set
   case selcount of
   0:text:=a+b+c+x;//add
   1:text:=a+b+x+c;//insert+add
   else//insert+replace
      begin
      delselB(i);
      text:=a+x+c;//insert
      itemindex:=i;
      end;//end of begin
   end;//end of case
   //.unlock
   unlock;
   //successful
   result:=true;
   end;//end of if
except;end;
end;
//## canupper ##
function tvirtualbaselist.canupper:boolean;
begin
try;result:=(vefUpper in ief) and (not ireadonly) and (selcount>=1);except;end;
end;
//## upper ##
function tvirtualbaselist.upper:boolean;
var
   a,b,c:string;
begin
try
//defaults
result:=false;
//process
if canupper then
   begin
   //.get
   getsela(a);
   getselb(b);
   getselc(c);
   //.set
   text:=a+uppercase(b)+c;
   //successful
   result:=true;
   end;//end of if
except;end;
end;
//## canlower ##
function tvirtualbaselist.canlower:boolean;
begin
try;result:=(vefLower in ief) and (not ireadonly) and (selcount>=1);except;end;
end;
//## lower ##
function tvirtualbaselist.lower:boolean;
var
   a,b,c:string;
begin
try
//defaults
result:=false;
//process
if canupper then
   begin
   //.get
   getsela(a);
   getselb(b);
   getselc(c);
   //.set
   text:=a+lowercase(b)+c;
   //successful
   result:=true;
   end;//end of if
except;end;
end;
//## canedit ##
function tvirtualbaselist.canedit:boolean;
begin
try;result:=(vefEdit in ief) and (not ireadonly);except;end;
end;
//## edit ##
function tvirtualbaselist.edit:boolean;
var
   tmp:string;
begin
try
//defaults
result:=false;
//process
if canedit then
   begin
   tmp:=text;
   if showtext(tmp,false,oShowtextlarge) then text:=tmp;
   result:=true;
   end;//end of if
except;end;
end;
//## _onstate ##
procedure tvirtualbaselist._onstate(sender:tobject);
begin
try
case igui.shift of
true:if not (vslKeyboard in iselactive) then include(iselactive,vslKeyboard);
false:if (vslKeyboard in iselactive) then exclude(iselactive,vslKeyboard);
end;//end of case
except;end;
end;
//## partialinit ##
procedure tvirtualbaselist.partialinit;
var
   p:integer;
   tmp:string;
begin
try
//defaults
tmp:='';
//process
//.topindex
tmp:=from32bit(topindex);
//.selection states
for p:=vstart to vfinish do tmp:=tmp+bn(selected[p]);
//.set
ipartialinfo:=tmp;
except;end;
end;
//## partialpaint ##
procedure tvirtualbaselist.partialpaint;
begin
try;ipartialpaint:=true;paint;ipartialpaint:=false;except;end;
end;
//## _onpaint ##
procedure tvirtualbaselist._onpaint(sender:tobject;canvas:tcanvas);
label//Note: Partial information is not to be used when "buffer=true", since using a buffer automatically clears client paint area, thus a full repaint is required each and every time
   skipone;
var
   a:tbitmap;
   r:trect;
   s:tvirtualdrawstate;
   i,ptop,plen,ss,sf,tc,bc,ly,y,minp,maxp,p:integer;
   ispartial,isselected:boolean;
begin
try
//defaults
a:=nil;
//setup
if (bufferbmp=nil) and bufferrows then a:=tbitmap.create;
ispartial:=false;
minp:=vstart;
maxp:=vfinish;
if enabled or (not fDisable) then tc:=info^.font else tc:=canvas.font.color;
bc:=canvas.brush.color;
ly:=0;
ss:=selpos;
p:=selcount;
if (p=0) then sf:=-1 else sf:=ss+p-1;
//.partial - only to be used when "buffer=false"
if ipartialpaint and (bufferbmp=nil) then
   begin
   ptop:=to32bit(copy(ipartialinfo,1,4));
   plen:=length(ipartialinfo);
   ispartial:=(ptop=topindex);//top index must line up exact
   end;//end of if
//process
for p:=minp to maxp do
begin
//.get
isselected:=selected[p];
y:=(p-minp)*ipaintih;
//.check
if ispartial then
   begin
   i:=p-minp+1+4;//"1 based" + "skip paste ptop"
   if (i>=1) and (i<=plen) and ((ipartialinfo[i]='1')=isselected) then goto skipone;
   end;//end of if
//.set
s:=[];
if isselected then include(s,vdsSelected);
//.reset
canvas.font.color:=tc;
canvas.brush.color:=bc;
canvas.brush.style:=bsSolid;
//.get
if (a=nil) then
   begin
   r:=rect(0,y,clientwidth,y+ipaintih);
   //.set
   _ondrawitem(self,canvas,p,r,s);
   end
else
   begin
   if (a.width<>clientwidth) then a.width:=clientwidth;
   if (a.height<>ipaintih) then a.height:=ipaintih;
   r:=rect(0,0,clientwidth,ipaintih);
   //.a
   a.canvas.font.assign(canvas.font);
   a.canvas.brush.assign(canvas.brush);
   a.canvas.pen.assign(canvas.pen);
   //.set
   _ondrawitem(self,a.canvas,p,r,s);
   //.paint
   canvas.draw(0,y,a);
   end;//end of if
skipone:
ly:=y+ipaintih;
end;//end of loop
//.remainder cls
//cls
canvas.brush.color:=bc;
canvas.brush.style:=bsSolid;
canvas.fillrect(rect(0,ly,clientwidth,clientheight));
except;end;
try;freeobj(@a);except;end;
end;
//## sbwidth ##
function tvirtualbaselist.sbwidth:integer;
begin
try;if isb.visible then result:=isb.width else result:=0;except;end;
end;
//## areawidth ##
function tvirtualbaselist.areawidth:integer;
begin
try;result:=clientwidth-sbwidth;except;end;
end;
//## itemAsrect ##
function tvirtualbaselist.itemAsrect(p:integer;var r:trect):boolean;
begin
try
//defaults
result:=false;
r:=rect(0,0,0,0);
//process
if (p>=0) and (p<count) then
   begin
   r:=rect(0,p*ipaintih,clientwidth-isb.left,(p+1)*ipaintih);
   result:=true;
   end;//end of if
except;end;
end;
//## itemAsrect ##
function tvirtualbaselist.itematpos(x,y:integer;existing:boolean):integer;
begin
try
//defaults
result:=-1;
//range
y:=frcmin(y,0);
//process
result:=vstart+(y div ipaintih);
if ((result<0) or (result>=count)) then
   begin
   if existing then result:=frcrange(result,0,count-1)
   else result:=-1;
   end;//end of if
except;end;
end;
//## _onimage ##
procedure tvirtualbaselist._onimage(sender:tobject;index:integer;var image:tvirtualbitmap);
begin
try;if (iimage<>nil) and (index>=0) and (index<count) then image:=iimage;except;end;
end;
//## _ondrawitem ##
procedure tvirtualbaselist._ondrawitem(control:tvirtualcontrol;canvas:tcanvas;index:integer;area:trect;state:tvirtualdrawstate);
var
   iEVENT:tvirtualimageevent;
begin
try
//process
//.image
iEVENT:=fonimage;
if (iimage<>nil) and (not assigned(iEVENT)) then iEVENT:=_onimage;
//.init
if assigned(ondrawiteminit) then ondrawiteminit(self,canvas,index,area,state,fontext,iEVENT);
//.set
if assigned(fondrawitem) then fondrawitem(self,canvas,index,area,state,fontext,iEVENT)
else draws.drawitem(self,canvas,index,area,state,fontext,iEVENT);
except;end;
end;
//## settep ##
procedure tvirtualbaselist.settep(x:string);
var
   e:string;
begin
try
//.set
itep:=x;
//.sync
if (x='') then freeobj(@iimage)
else
   begin
   if (iimage=nil) then iimage:=tvirtualbitmap.create;
   iimage.settep(x,e);
   end;//end of if
except;end;
end;
//## lock ##
procedure tvirtualbaselist.lock;
begin
try
//self
inherited lock;
//isb
isb.lock;
except;end;
end;
//## unlock ##
procedure tvirtualbaselist.unlock;
begin
try
//isb
isb.unlock;//won't paint because parent is still locked
//self
inherited unlock;
//repaint isb
isb.paint;
except;end;
end;

//## tvirtuallist ##############################################################
//## create ##
constructor tvirtuallist.create(_gui:tvirtualform);
begin
//self
inherited create(_gui);
//controls
iitems:=tstringlist.create;
ief:=[vefCut,vefCopy,vefCopyAll,vefPaste,vefDelete,vefSelectAll,vefUpper,vefLower,vefEdit];
//events
iitems.onchange:=_onchange;
end;
//## destroy ##
destructor tvirtuallist.destroy;
begin
try
//init
destroyinit;
//controls
freeobj(@iitems);
//self
inherited;
except;end;
end;
//## deleteitem ##
procedure tvirtuallist.deleteitem(x:integer);
begin
try;if (x>=0) and (x<iitems.count) then iitems.delete(x);except;end;
end;
//## readwrite ##
procedure tvirtuallist.readwrite(mode:tvirtualstoragemode);
var
   tmp:integer;
begin
try
case mode of
vsmReadfromcontrols:if (isysptr>vsNil) then vs.i[isysptr]:=itemindex;
vsmWritetocontrols:if (isysptr>vsNil) then
   begin
   tmp:=vs.i[isysptr];
   if (tmp<>itemindex) then itemindex:=tmp;
   end;//end of if
end;//end of case
//self
inherited;
except;end;
end;
//## gettext ##
function tvirtuallist.gettext:string;
begin
try;result:=iitems.text;except;end;
end;
//## settext ##
procedure tvirtuallist.settext(x:string);
begin
try
//set
lock;
iitems.text:=x;
unlock;
//self
inherited;
except;end;
end;
//## getitem ##
function tvirtuallist.getitem(x:integer):string;
begin
try;if (x>=0) and (x<iitems.count) then result:=iitems[x] else result:='';except;end;
end;
//## setitem ##
procedure tvirtuallist.setitem(x:integer;y:string);
begin
try;if (x>=0) and (x<iitems.count) then iitems[x]:=y;except;end;
end;
//## _onchange ##
procedure tvirtuallist._onchange(sender:tobject);
begin
try;setparamsb(selpos,itemindex,topindex,iitems.count,itemheight,true);except;end;
end;

//## tvirtualdroplist ##########################################################
//## create ##
constructor tvirtualdroplist.create(_gui:tvirtualform);
begin
//self
inherited create(_gui);
//vars
bordersize:=0;
oDropwhenfull:=true;
ilastdropindex:=-1;
//controls
//.ipoplist
ipoplist:=nil;
//.ibutton
ibutton:=new('button','',simDropDown,'',valRight,nil) as tvirtualbutton;
ibutton.oHeight:=vhsClient;
ibutton.style:=[];
ibutton.imagealign:=valTop;
ibutton.padwidth:=0;
ibutton.aDownrelaxed:=false;//cursor must be within client area
//.iedit
iedit:=new('edit','','','',valRight,nil) as tvirtualedit;
iedit.style:=[];
iedit.oVariableWidth:=true;
//.iitems
iitems:=tstringlist.create;
//.self
style:=[vlsFocus,vlsHover];
self.groupfocus:=true;
ibutton.groupfocus:=groupfocus;
iedit.groupfocus:=groupfocus;
//defaults
ivaluestyle:=vvsNone;
idropcount:=10;
cursor:=vcText;
fBackground:=false;
fUnderline:=false;
fUpdnpaint:=false;
end;
//## destroy ##
destructor tvirtualdroplist.destroy;
begin
try
//init
destroyinit;
//dropclose
dropclose;
//controls
freeobj(@iitems);
freeobj(@ipoplist);
freeobj(@iedit);
freeobj(@ibutton);
//self
inherited;
except;end;
end;
//## setoheight ##
procedure tvirtualdroplist.setoheight(x:tvirtualheightstyle);
begin
try
inherited setoheight(x);
if (iedit<>nil) then iedit.oheight:=oheight;
if (ibutton<>nil) then ibutton.oheight:=oheight;
except;end;
end;
//## readwrite ##
procedure tvirtualdroplist.readwrite(mode:tvirtualstoragemode);
var
   tmp:string;
begin
try
case mode of
vsmReadfromcontrols:if (isysptr>vsNil) then
   begin
   tmp:=value;
   case ivaluestyle of
   vvsCommaNumber:general.remchar(tmp,',');
   end;//end of case
   vs.s[isysptr]:=tmp;
   end;//end of if
vsmWritetocontrols:if (isysptr>vsNil) then
   begin
   tmp:=vs.s[isysptr];
   case ivaluestyle of
   vvsCommaNumber:tmp:=general.curcomma(strCur(tmp));
   end;//end of case
   if (tmp<>value) then value:=tmp;
   end;//end of if
vsmUpdatecontrols:;
end;//end of case
except;end;
end;
//## candrop ##
function tvirtualdroplist.candrop:boolean;
begin
try;result:=(ipoplist=nil);except;end;
end;
//## dropclose ##
procedure tvirtualdroplist.dropclose;
begin
try;if not candrop then ipoplist.showclose(mrCancel);except;end;
end;
//## drop ##
function tvirtualdroplist.drop:boolean;
begin
try
//defaults
result:=false;
//check
if not candrop then exit;
//process
//.get
ipoplist:=tpoplist.create(nil);
//.fill
ipoplist.text:=text;
ipoplist.valueindex:=ilastdropindex;
ipoplist.value:=value;
ipoplist.dropcount:=idropcount;
ipoplist.oNumbered:=oNumbered;
ipoplist.tabs:=tabs;
ipoplist.tep:=tep;
//.pop
result:=ipoplist.popwh(igui,screenx,screeny+height,height,width,0);
if result then
   begin
   value:=ipoplist.value;
   ilastdropindex:=ipoplist.valueindex;
   end;//end of if
except;end;
try;freeobj(@ipoplist);except;end;
end;
//## setdropcount ##
procedure tvirtualdroplist.setdropcount(x:integer);
begin
try;idropcount:=frcmin(x,1);except;end;
end;
//## gettext ##
function tvirtualdroplist.gettext:string;
begin
try;result:=iitems.text;except;end;
end;
//## settext ##
procedure tvirtualdroplist.settext(x:string);
begin
try
//set
iitems.text:=x;
//event
doonchange;
except;end;
end;
//## getvalue ##
function tvirtualdroplist.getvalue:string;
begin
try
result:=iedit.text;
if (oFilter=vfEncodedUrl) then net_encode_url(result);
except;end;
end;
//## setvalue ##
procedure tvirtualdroplist.setvalue(x:string);
begin
try
//set
if (oFilter=vfEncodedUrl) then net_encode_url(x);
iedit.text:=x;
//event
doonchange;
except;end;
end;
//## _onshortcut ##
function tvirtualdroplist._onshortcut(_shortcut:string):boolean;
begin
try
//defaults
result:=false;
//process
result:=iedit._onshortcut(_shortcut);
if not result then result:=ibutton._onshortcut(_shortcut);
except;end;
end;
//## _onnotify ##
procedure tvirtualdroplist._onnotify(sender:tobject);
var
   wasempty:boolean;
begin
try
//BUTTON
//.start
if igui.ismouse and (igui.act=aDown) then ibuttonfocused:=ibutton.inclient;
//.re-route
if ibuttonfocused then
   begin
   ibutton._onnotify(ibutton);
   //.drop
   if igui.ismouse and (igui.act=aUp) and (igui.key=mLeft) then drop;
   end;//end of if
//EDIT
//.re-route
if (not ibuttonfocused) then
   begin
   wasempty:=(iedit.text='');
   iedit._onnotify(iedit);
   //drop - special key   //Don't respond to "vk_return" if host form has "mkReturn=TRUE" else conflict will occur - 30SEP2007
   if igui.iskeyboard and (not igui.mkReturn) and (igui.key=vk_return) and (igui.act=aUp) then
      begin
      if oDropwhenfull or wasempty then drop;
      end;//end of if
   end;//end of if
//FINISH
if igui.ismouse and (igui.act=aUp) then ibuttonfocused:=false;
except;end;
end;

//## tvirtualdropliststatic ####################################################
//## create ##
constructor tvirtualdropliststatic.create(_gui:tvirtualform);
begin
//self
inherited create(_gui);
//controls
//.ipoplist
ipoplist:=nil;
//.iitems
iitems:=tstringlist.create;
//.self
style:=[vlsFocus,vlsHover];
//defaults
ivalue:=0;
idropcount:=10;
bordersize:=1;
cursor:=vcLink;
oNumbered:=true;
end;
//## destroy ##
destructor tvirtualdropliststatic.destroy;
begin
try
//init
destroyinit;
//dropclose
dropclose;
//controls
freeobj(@iitems);
freeobj(@ipoplist);
//self
inherited;
except;end;
end;
//## doonchange ##
procedure tvirtualdropliststatic.doonchange;
begin
try
inherited;
//call "onclick" if "onchange" is not set
if not assigned(fonchange) then fireevent(fonclick,self)
except;end;
end;
//## settitle ##
procedure tvirtualdropliststatic.settitle(x:string);
begin
try;if general.setstring(x,ititle) then synccaption;except;end;
end;
//## __onitemindex ##
procedure tvirtualdropliststatic.__onitemindex(sender:tobject);
begin
try;syncvalue;except;end;
end;
//## syncvalue ##
procedure tvirtualdropliststatic.syncvalue;
begin
try;if (ipoplist<>nil) then value:=ipoplist.valueindex;except;end;
end;
//## synccaption ##
procedure tvirtualdropliststatic.synccaption;
var
   z:string;
begin
try
z:=ititle+general.insstr(general.thousands(value+1)+'. ',oNumbered);
if (iitems.count>=1) and (ivalue<iitems.count) then z:=z+iitems.strings[ivalue];
if (z<>caption) then caption:=z;
except;end;
end;
//## readwrite ##
procedure tvirtualdropliststatic.readwrite(mode:tvirtualstoragemode);
var
   tmp:integer;
begin
try
case mode of
vsmReadfromcontrols:if (isysptr>vsNil) then vs.i[isysptr]:=value;
vsmWritetocontrols:if (isysptr>vsNil) then
   begin
   tmp:=vs.i[isysptr];
   if (tmp<>value) then value:=tmp;
   //incase "oNumbered" changes
   synccaption;
   end;//end of if
vsmUpdatecontrols:;
end;//end of case
except;end;
end;
//## candrop ##
function tvirtualdropliststatic.candrop:boolean;
begin
try;result:=(ipoplist=nil);except;end;
end;
//## dropclose ##
procedure tvirtualdropliststatic.dropclose;
begin
try;if not candrop then ipoplist.showclose(mrCancel);except;end;
end;
//## drop ##
function tvirtualdropliststatic.drop:boolean;
var
   oldvalue:integer;
begin
try
//defaults
result:=false;
//check
if not candrop then exit;
//process
//.get
oldvalue:=value;
ipoplist:=tpoplist.create(nil);
//.fill
ipoplist.title:=ititle;
ipoplist.text:=text;
ipoplist.value:=iitems.strings[value];
ipoplist.dropcount:=idropcount;
ipoplist.oNumbered:=oNumbered;
ipoplist.tabs:=tabs;
ipoplist.onitemindex:=__onitemindex;
//.pop
result:=ipoplist.popwh(igui,screenx,screeny+height,height,width,0);
case result of
true:syncvalue;
false:value:=oldvalue;
end;//end of case
except;end;
try;freeobj(@ipoplist);except;end;
end;
//## setdropcount ##
procedure tvirtualdropliststatic.setdropcount(x:integer);
begin
try;idropcount:=frcmin(x,1);except;end;
end;
//## gettext ##
function tvirtualdropliststatic.gettext:string;
begin
try;result:=iitems.text;except;end;
end;
//## settext ##
procedure tvirtualdropliststatic.settext(x:string);
begin
try
//set
iitems.text:=x;
value:=value;
synccaption;
//event
doonchange;
except;end;
end;
//## getcount ##
function tvirtualdropliststatic.getcount:integer;
begin
try;result:=iitems.count;except;end;
end;
//## getvalue ##
function tvirtualdropliststatic.getvalue:integer;
begin
try;result:=frcrange(ivalue,0,iitems.count-1);except;end;
end;
//## setvalue ##
procedure tvirtualdropliststatic.setvalue(x:integer);
begin
try
//range
x:=frcrange(x,0,iitems.count-1);
//set
if (x<>ivalue) then
   begin
   ivalue:=x;
   synccaption;
   //event
   doonchange;
   end;//end of if
except;end;
end;
//## _onnotify ##
procedure tvirtualdropliststatic._onnotify(sender:tobject);
begin
try
//drop
if (igui.ismouse and (igui.act=aUp) and (igui.key=mLeft)) then drop
else if igui.iskeyboard and (igui.act=aUp) then
   begin
   case igui.key of
   vk_return:drop;
   vk_up,vk_left:value:=value-1;
   vk_down,vk_right:value:=value+1;
   vk_prior:value:=value-dropcount;
   vk_next:value:=value+dropcount;
   vk_home:value:=0;
   vk_end:value:=iitems.count-1;
   end;//end of case
   end;//end of if
except;end;
end;

//## tvirtualbasetext ##########################################################
//## create ##
constructor tvirtualbasetext.create(_gui:tvirtualform);
begin
//self
inherited create(_gui);
oHeight:=vhsClient;
//help
internalhelp:=rthtranslate('Right click for menu. Or, click to focus, hold down "Ctrl" key and press "M" key (CTRL+M)');//16DEC2007
//defaults
ief:=[vefCut,vefCopy,vefPaste,vefDelete,vefUpper,vefLower];
iitemindexlimit:=-1;
iitemindex:=-1;
icanedit:=true;
ispace:=2;//horizontal padding only - not to be used for vertical
cursor:=vcText;
fhighlight:=true;
fBackground:=false;
fUnderline:=false;
fFontcolor:=false;
oShowmenu:=true;
itime:=ms64;
timer:=250;
end;
//## destroy ##
destructor tvirtualbasetext.destroy;
begin
try
//init
destroyinit;
//controls
freeobj(@ipopmenu);
//self
inherited;
except;end;
end;
//## astext ##
function tvirtualbasetext.astext:string;//must always terminate with a "rcode" - 12FEB2008
begin
try;result:=misc.enforceEOLex(text,false);except;end;
end;
//## getmouseitem ##
function tvirtualbasetext.getmouseitem(topindex:integer;existing:boolean):integer;
var
   p:integer;
begin
try
//defaults
result:=-1;
//process
//.get
p:=topindex+(y div viFontHeight);
if existing then result:=frcrange(p,0,iitemindexlimit-1)
else if (p>=0) and (p<iitemindexlimit) then result:=p;
except;end;
end;
//## autoitemindex ##
function tvirtualbasetext.autoitemindex(topindex:integer;existing:boolean):integer;
begin
try
//get
result:=getmouseitem(topindex,existing);
//decide
if (result=itemindex) and (itemindex>=0) then result:=-1;
except;end;
end;
//## setitemindex ##
procedure tvirtualbasetext.setitemindex(x:integer);
begin
try
//range
if (x<-1) or (x>=iitemindexlimit) then x:=-1;
//set
if general.setint(x,iitemindex) then
   begin
   paint;
   doonchange;
   end;//end of if
except;end;
end;
//## _filter ##
function tvirtualbasetext._filter(x:string):string;
begin
try
//defaults
result:=x;
//process
if assigned(onfilter) then onfilter(self,result);
except;end;
end;
//## readwrite ##
procedure tvirtualbasetext.readwrite(mode:tvirtualstoragemode);
var
   tmp:string;
   ok:boolean;
begin
try
case mode of
vsmReadfromcontrols:if (isysptr>vsNil) then vs.s[isysptr]:=_filter(text);
vsmWritetocontrols:if (isysptr>vsNil) then
   begin
   tmp:=_filter(vs.s[isysptr]);
   if (tmp<>text) then text:=tmp;
   end;//end of if
vsmUpdatecontrols:begin
   ok:=false;
   if general.setint(info^.fontmap.id,ifontid) then
      begin
      ok:=true;
      dimensionsmodified:=true;
      end;//end of if
   if (iscrollsize<>viScrollSize) then
      begin
      ok:=true;
      dimensionsmodified:=true;
      iscrollsize:=viScrollSize;
      end;//end of if
   //.align control again - since one or more vital settings have changed
   if ok then doalign;
   end;//end of begin
end;//end of case
except;end;
end;
//## _onshortcut ##
function tvirtualbasetext._onshortcut(_shortcut:string):boolean;
var
   ok:boolean;
   e:string;
begin
try
//defaults
result:=false;
ok:=true;
//process
if (_shortcut='CTRL+T') and cancuttoclipboard then//cut
   begin
   result:=true;
   ok:=cuttoclipboard(e);
   end
else if (_shortcut='CTRL+C') and cancopytoclipboard then//copy
   begin
   result:=true;
   ok:=copytoclipboard(e);
   end
else if (_shortcut='CTRL+P') and canpastefromclipboard then//paste
   begin
   result:=true;
   ok:=pastefromclipboard(e);
   end
else if (_shortcut='CTRL+D') and candelete then//delete
   begin
   result:=true;
   ok:=delete(e);
   end
else if (_shortcut='CTRL+U') and canupper then//upper case
   begin
   result:=true;
   upper;
   end
else if (_shortcut='CTRL+L') and canlower then//lower case
   begin
   result:=true;
   lower;
   end
else if (_shortcut='CTRL+M') and canshowmenu then//menu
   begin
   result:=true;
   showmenu;
   end;//end of if
//.error
if result and (not ok) then showerror60(translate(e));
except;end;
end;
//## _onnotify ##
procedure tvirtualbasetext._onnotify(sender:tobject);
begin
try
//process
if igui.iskeyboard and down then
   begin
   //.standard
   if (igui.clas=recKey) and (not ireadonly) then addchar(char(igui.key))
   //.special
   else if (igui.clas=recKeyX) and (not ireadonly) then
      begin
      case igui.key of
      vk_left:moveleft;
      vk_up:moveup;
      vk_right:moveright;
      vk_down:movedown;
      vk_home:movehome;
      vk_end:moveend;
      vk_back:deleteleft;
      vk_delete:deleteright;
      end;//end of case
      end;//end of if
   end
else if igui.iskeyboard and (not down) then
   begin
   if (igui.clas=recKeyX) and (not ireadonly) then
      case igui.key of
      vk_return:fireevent(onreturn,self);
      vk_escape:fireevent(onescape,self);
      end;//end of if
   end
//.show when mouse is "aUP"
else if igui.ismouse and (igui.act=aUp) and (igui.key=mRight) then showmenu;
//self
inherited;
except;end;
end;
//## setmaxlen ##
procedure tvirtualbasetext.setmaxlen(x:integer);
begin
try
//range
x:=frcmin(x,0);
//set
if general.setint(x,imaxlen) and (count>limit) then text:=copy(text,1,limit);
except;end;
end;
//## getmaxlen ##
function tvirtualbasetext.getmaxlen:integer;
begin
try;result:=frcmin(imaxlen,0);except;end;
end;
//## limit ##
function tvirtualbasetext.limit:integer;
begin
try
//get
result:=maxlen;
//set
if (result=0) then result:=maxint;
except;end;
end;
//## addchar ##
procedure tvirtualbasetext.addchar(x:char);
begin
try;if icanedit then text:=copy(text+x,1,limit);except;end;
end;
//## moveleft ##
procedure tvirtualbasetext.moveleft;
begin
//nil
end;
//## moveright ##
procedure tvirtualbasetext.moveright;
begin
//nil
end;
//## moveup ##
procedure tvirtualbasetext.moveup;
begin
//nil
end;
//## movedown ##
procedure tvirtualbasetext.movedown;
begin
//nil
end;
//## movehome ##
procedure tvirtualbasetext.movehome;
begin
//nil
end;
//## moveend ##
procedure tvirtualbasetext.moveend;
begin
//nil
end;
//## deleteleft ##
procedure tvirtualbasetext.deleteleft;
begin
try;if icanedit then text:=copy(text,1,count-1);except;end;
end;
//## deleteright ##
procedure tvirtualbasetext.deleteright;
begin
try;if icanedit then clear;except;end;
end;
//## getcanshowmenu ##
function tvirtualbasetext.getcanshowmenu:boolean;
begin
try;result:=(ipopmenu=nil) and oShowmenu;except;end;
end;
//## showmenu ##
procedure tvirtualbasetext.showmenu;
var
   e:string;
   ok:boolean;
begin
try
//defaults
ok:=true;
e:=gecTaskFailed;
//check
if not canshowmenu then exit;
//process
//.get
ipopmenu:=tpopmenu.create(nil);
ipopmenu.menu:=@smTEXT;
//.set
menus.itemenabled[ipopmenu.menu,smcCut]:=cancuttoclipboard;
menus.itemenabled[ipopmenu.menu,smcCopy]:=cancopytoclipboard;
menus.itemenabled[ipopmenu.menu,smcCopyAll]:=cancopyall;
menus.itemenabled[ipopmenu.menu,smcPaste]:=canpastefromclipboard;
menus.itemenabled[ipopmenu.menu,smcDelete]:=candelete;
menus.itemenabled[ipopmenu.menu,smcSelectAll]:=false;
menus.itemenabled[ipopmenu.menu,smcUpper]:=canupper;
menus.itemenabled[ipopmenu.menu,smcLower]:=canlower;
menus.itemenabled[ipopmenu.menu,smcEdit]:=canedit;
//.action
case ipopmenu.popcursor(igui) of
smcCut:ok:=cuttoclipboard(e);
smcCopy:ok:=copytoclipboard(e);
smcCopyAll:ok:=copyall(e);
smcPaste:ok:=pastefromclipboard(e);
smcDelete:ok:=delete(e);
smcUpper:ok:=upper;
smcLower:ok:=lower;
smcEdit:ok:=edit;
end;//end of case
except;end;
try
freeobj(@ipopmenu);
if not ok then showerror60(translate(e));
except;end;
end;
//## _onpaint ##
procedure tvirtualbasetext._onpaint(sender:tobject;canvas:tcanvas);
var
   tmp:string;
   ox:integer;
begin
try
//cls
canvas.fillrect(clientrect);
canvas.brush.style:=bsClear;
//get
if (mask=#0) then tmp:=text
else tmp:=general.nullstr(count,mask);
//cursor
if (timer<>0) then
   begin
   _paintsingleline(sender,canvas,tmp);
   end;//end of if
except;end;
end;
//## _paintsingleline ##
procedure tvirtualbasetext._paintsingleline(sender:tobject;canvas:tcanvas;x:string);
var
   oy,ox,cx:integer;
   a:trect;
begin
try
//get
ox:=0;
cx:=ispace+info^.fontmap.textwidth(x);
if ((cx+5)>clientwidth) then ox:=-(cx+5-clientwidth);
oy:=(clientheight-info^.fontmap.maxH) div 2;
//text
a:=clientrect;
inc(a.left,ispace);
dec(a.right,ispace);
canvas.textrect(a,ispace+ox,oy,x);
//cursor
if focused and (iblink or ((ms64-itime)<500)) then
   begin
   if oLargeCursor then
      begin
      canvas.brush.color:=canvas.font.color;
      canvas.fillrect(rect(ox+cx,oy,ox+cx+2,clientheight-oy));
      end
   else
      begin
      canvas.pen.color:=canvas.font.color;
      canvas.moveto(ox+cx,oy);
      canvas.lineto(ox+cx,clientheight-oy);
      end;//end of if
   end;//end of if
except;end;
end;
//## timereset ##
procedure tvirtualbasetext.timereset;
begin
try;itime:=ms64;except;end;
end;
//## _ontimer ##
procedure tvirtualbasetext._ontimer(sender:tobject);
begin
try
//check
if igui.destroying then exit;
//other
if focused and ((ms64-itime)>=500) then
   begin
   iblink:=not iblink;
   paint;
   itime:=ms64;
   end;//end of if
except;end;
end;
//## getcount ##
function tvirtualbasetext.getcount:integer;
begin
try;result:=length(text);except;end;
end;
//## settext ##
procedure tvirtualbasetext.settext(x:string);
begin
//nil
end;
//## gettext ##
function tvirtualbasetext.gettext:string;
begin
result:='';//nil
end;
//## setmask ##
procedure tvirtualbasetext.setmask(x:char);
begin
//nil
end;
//## getmask ##
function tvirtualbasetext.getmask:char;
begin
result:=#0;//nil
end;
//## cancopytoclipboard ##
function tvirtualbasetext.cancopytoclipboard:boolean;
begin
try;result:=(vefCopy in ief) and (count>=1);except;end;
end;
//## copytoclipboard ##
function tvirtualbasetext.copytoclipboard(var e:string):boolean;
begin
try
//defaults
result:=false;
e:=gecTaskFailed;
//process
if cancopytoclipboard then
   begin
   case (itemindex>=0) and (itemindex<iitemindexlimit) of
   true:clipboard.astext:=getseltext;
   false:clipboard.astext:=text;
   end;//end of case
   result:=true;
   end;//end of if
except;end;
end;
//## cancopyall ##
function tvirtualbasetext.cancopyall:boolean;
begin
try;result:=(vefCopyAll in ief) and (count>=1);except;end;
end;
//## copyall ##
function tvirtualbasetext.copyall(var e:string):boolean;
begin
try
//defaults
result:=false;
e:=gecTaskFailed;
//process
if cancopyall then
   begin
   clipboard.astext:=text;
   result:=true;
   end;//end of if
except;end;
end;
//## getseltext ##
function tvirtualbasetext.getseltext:string;
begin
try;if fhighlight then result:='' else result:=text;except;end;
end;
//## cancuttoclipboard ##
function tvirtualbasetext.cancuttoclipboard:boolean;
begin
try;result:=(vefCut in ief) and (count>=1) and (not ireadonly);except;end;
end;
//## cuttoclipboard ##
function tvirtualbasetext.cuttoclipboard(var e:string):boolean;
begin
try
//defaults
result:=false;
e:=gecTaskFailed;
//process
if cancuttoclipboard then
   begin
   clipboard.astext:=text;
   text:='';
   result:=true;
   end;//end of if
except;end;
end;
//## canpastefromclipboard ##
function tvirtualbasetext.canpastefromclipboard:boolean;
begin
try;result:=(vefPaste in ief) and (not ireadonly) and clipboard.hasformat(cf_text);except;end;
end;
//## pastefromclipboard ##
function tvirtualbasetext.pastefromclipboard(var e:string):boolean;
begin
try
//defaults
result:=false;
e:=gecTaskFailed;
//process
if canpastefromclipboard then
   begin
   text:=copy(clipboard.astext,1,limit);
   result:=true;
   end;//end of if
except;end;
end;
//## candelete ##
function tvirtualbasetext.candelete:boolean;
begin
try;result:=(vefDelete in ief) and (not ireadonly) and (count>=1);except;end;
end;
//## delete ##
function tvirtualbasetext.delete(var e:string):boolean;
begin
try
//defaults
result:=false;
e:=gecTaskFailed;
//process
if candelete then
   begin
   text:='';
   result:=true;
   end;//end of if
except;end;
end;
//## canclear ##
function tvirtualbasetext.canclear:boolean;
begin
try;result:=(count>=1);except;end;
end;
//## clear ##
function tvirtualbasetext.clear:boolean;
begin
try
//defaults
result:=false;
//process
if canclear then
   begin
   text:='';
   result:=true;
   end;//end of if
except;end;
end;
//## canupper ##
function tvirtualbasetext.canupper:boolean;
begin
try;result:=(vefUpper in ief) and (not ireadonly) and (count>=1);except;end;
end;
//## upper ##
function tvirtualbasetext.upper:boolean;
begin
try
//defaults
result:=false;
//process
if canupper then
   begin
   text:=uppercase(text);
   result:=true;
   end;//end of if
except;end;
end;
//## canlower ##
function tvirtualbasetext.canlower:boolean;
begin
try;result:=(vefLower in ief) and (not ireadonly) and (count>=1);except;end;
end;
//## lower ##
function tvirtualbasetext.lower:boolean;
begin
try
//defaults
result:=false;
//process
if canlower then
   begin
   text:=lowercase(text);
   result:=true;
   end;//end of if
except;end;
end;
//## canedit ##
function tvirtualbasetext.canedit:boolean;
begin
try;result:=false;except;end;
end;
//## edit ##
function tvirtualbasetext.edit:boolean;
var
   tmp:string;
begin
try
//defaults
result:=false;
//process
if canedit then
   begin
   tmp:=text;
   if showtext(tmp,wordwrap,showtextlarge) then text:=tmp;
   result:=true;
   end;//end of if
except;end;
end;
//## getwordwrap ##
function tvirtualbasetext.getwordwrap:boolean;
begin
try;result:=false;except;end;
end;

//## tvirtualpassword ##########################################################
//## create ##
constructor tvirtualpassword.create(_gui:tvirtualform);
begin
//self
inherited create(_gui);
//defaults
ef:=[vefPaste,vefDelete,vefUpper,vefLower];
setparams('#',itext,false);
end;
//## setmask ##
procedure tvirtualpassword.setmask(x:char);
begin
try;setparams(x,itext,true);except;end;
end;
//## getmask ##
function tvirtualpassword.getmask:char;
begin
try;result:=imask;except;end;
end;
//## settext ##
procedure tvirtualpassword.settext(x:string);
begin
try
x:=general.firstNBL(x);
setparams(imask,x,true);
except;end;
end;
//## gettext ##
function tvirtualpassword.gettext:string;
begin
try;result:=itext;except;end;
end;
//## setparams ##
function tvirtualpassword.setparams(_mask:char;var _text:string;_notify:boolean):boolean;
var
   _count:integer;
begin
try
//defaults
result:=false;
//range
_text:=copy(_text,1,limit);
_count:=length(_text);
//check
if (_count=count) and
   (_mask=imask) and
   (_text=itext) then exit;
//process
//.set
imask:=_mask;
itext:=_text;
//.notify
if _notify then
   begin
   //.reset itime
   timereset;
   //.paint
   paint;
   //.event
   doonchange;
   end;//end of if
//changed
result:=true;
except;end;
end;

//## tvirtualedit ##############################################################
//## create ##
constructor tvirtualedit.create(_gui:tvirtualform);
begin
//self
inherited create(_gui);
//defaults
setparams(itext,false);
end;
//## settext ##
procedure tvirtualedit.settext(x:string);
begin
try
x:=general.firstNBL(x);
setparams(x,true);
except;end;
end;
//## gettext ##
function tvirtualedit.gettext:string;
begin
try;result:=itext;except;end;
end;
//## setparams ##
function tvirtualedit.setparams(var _text:string;_notify:boolean):boolean;
var
   _count:integer;
begin
try
//defaults
result:=false;
//range
_text:=copy(_text,1,limit);
_count:=length(_text);
//check
if (_count=count) and
   (_text=itext) then exit;
//process
//.set
itext:=_text;
//.notify
if _notify then
   begin
   //.reset itime
   timereset;
   //.paint
   paint;
   //.event
   doonchange;
   end;//end of if
//changed
result:=true;
except;end;
end;

//## tvirtualtext ##############################################################
//## create ##
constructor tvirtualtext.create(_gui:tvirtualform);
begin
//self
inherited create(_gui);
oHeight:=vhsHeight;
cursor:=vcArrow;
//controls
//.iitems
iitems:=tstringlist.create;
//.iv
iv:=new('scrollbar','','','',valNone,nil) as tvirtualscrollbar;
iv.internalhelp:=rthtranslate('Scroll text vertically');
iv.vertical:=true;
iv.style:=[];
//.ih
ih:=new('scrollbar','','','',valNone,nil) as tvirtualscrollbar;
ih.internalhelp:=rthtranslate('Scroll text horizontally');
ih.style:=[];
//.self
self.groupfocus:=true;
iv.groupfocus:=groupfocus;
ih.groupfocus:=groupfocus;
//defaults
ief:=[vefCut,vefCopy,vefCopyAll,vefPaste,vefDelete,vefUpper,vefLower,vefEdit];
oVariableheight:=true;
icanedit:=false;//no keyboard modification support (del, backspace or addchar)
ihunit:=1;
ispace:=2;//horizontal padding only - not to be used for vertical
timer:=0;
iitems.text:='#';
setparams(-1,'',false);
height:=200;
//events
iv.onpos:=_onpos;
ih.onpos:=_onpos;
end;
//## destroy ##
destructor tvirtualtext.destroy;
begin
try
//init
destroyinit;
//controls
freeobj(@iv);
freeobj(@ih);
freeobj(@iitems);
//self
inherited;
except;end;
end;
//## find ##
function tvirtualtext.find(x:string;_highlight:boolean):integer;
var
   tmp:string;
   pos,minp,p:integer;
begin
try
//defaults
result:=-1;//not found
//check
if (count=0) or (length(x)=0) then exit;
//process
//.get
if (iitemindex=-1) then minp:=0 else minp:=iitemindex+1;
if (minp>=count) then minp:=0;
//.find #1
for p:=minp to (count-1) do
begin
tmp:=iitems.strings[p];
pos:=1;
if general.findtext(pos,tmp,x) then
   begin
   result:=p;
   break;
   end;//end of if
end;//end of loop
//.find #2
if (result=-1) then
   begin
   for p:=0 to (minp-1) do
   begin
   tmp:=iitems.strings[p];
   pos:=1;
   if general.findtext(pos,tmp,x) then
      begin
      result:=p;
      break;
      end;//end of if
   end;//end of loop
   end;//end of if
//highlight
if _highlight and (result>=0) then
   begin
   if not ((result>=vstart) and (result<=vfinish)) then vpos:=result;
   itemindex:=result;
   end;//end of if
except;end;
end;
//## getseltext ##
function tvirtualtext.getseltext:string;
begin
try;if fhighlight and (itemindex>=0) and (itemindex<count) then result:=iitems.strings[itemindex] else result:=(inherited getseltext);except;end;
end;
//## paint ##
procedure tvirtualtext.paint;
begin
try
//self
inherited;
//other
iv.paint;
ih.paint;
except;end;
end;
//## canedit ##
function tvirtualtext.canedit:boolean;
begin
try;result:=(vefEdit in ief) and (not ireadonly);except;end;
end;
//## _onpos ##
procedure tvirtualtext._onpos(sender:tobject);
begin
try
if (ilockpos=0) then
   begin
   //paint
   paint;
   //event
   fireevent(fonpos,self);
   end;//end of if
except;end;
end;
//## settext ##
procedure tvirtualtext.settext(x:string);
begin
try;setparams(itemindex,x,true);except;end;
end;
//## gettext ##
function tvirtualtext.gettext:string;
begin
try;result:=iitems.text;except;end;
end;
//## maxwidth ##
function tvirtualtext.maxwidth:integer;
var
   tmp,p:integer;
begin
try
//defaults
result:=0;
//process
for p:=0 to (iitems.count-1) do
begin
tmp:=info^.fontmap.textwidthc(iitems.strings[p]);
if (tmp>result) then result:=tmp;
end;//end of loop
except;end;
end;
//## maxheight ##
function tvirtualtext.maxheight:integer;
begin
try;result:=iitems.count*viFontHeight;except;end;
end;
//## vclientheight ##
function tvirtualtext.vclientheight:integer;
begin
try;result:=frcmin(clientheight-viScrollSize,0);except;end;
end;
//## vclientwidth ##
function tvirtualtext.vclientwidth:integer;
begin
try;result:=frcmin(clientwidth-viScrollSize,0);except;end;
end;
//## vcount ##
function tvirtualtext.vcount:integer;
begin
try;result:=frcmin(vclientheight div viFontHeight,1);except;end;
end;
//## vstart ##
function tvirtualtext.vstart:integer;
begin
try;result:=iv.pos;except;end;
end;
//## vfinish ##
function tvirtualtext.vfinish:integer;
var
   s,c:integer;
begin
try
s:=vstart;
c:=vcount;
result:=frcrange(s+c-1,s,frcmin(s+c-1,0));
except;end;
end;
//## calc ##
procedure tvirtualtext.calc;
var
   y,z:integer;
begin
try
//CALC
//.ih
y:=frcmin(maxwidth-vclientwidth+ispace*2,0);
ihunit:=(info^.fontmap.maxW div 2);
z:=(y div ihunit);
if ((z*ihunit)<>y) then inc(z,1);
ih.setparams(0,ih.pos,z,false);
//.iv
z:=frcmin(count-vcount,0);
iv.setparams(0,iv.pos,z,false);
except;end;
end;
//## setparams ##
function tvirtualtext.setparams(_itemindex:integer;_text:string;_notify:boolean):boolean;
var
   _modified:boolean;
   _count,z,w,h:integer;
begin
try
//defaults
result:=false;
_modified:=false;
//range
_text:=copy(_text,1,limit);
_count:=length(_text);
//process
//.set
if (_count<>count) or (_text<>text) then
   begin
   iitems.text:=_text;
   iitemindexlimit:=iitems.count;
   calc;
   _modified:=true;
   end;//end of if
//.itemindex
if (_itemindex<-1) or (_itemindex>=iitemindexlimit) then _itemindex:=-1;
if (_itemindex<>itemindex) then
   begin
   iitemindex:=_itemindex;
   _modified:=true;
   end;//end of if
if not _modified then exit;
//.notify
if _notify then
   begin
   //.paint
   paint;
   //.event
   doonchange;
   end;//end of if
//changed
result:=true;
except;end;
end;
//## getcount ##
function tvirtualtext.getcount:integer;
begin
try;result:=iitems.count;except;end;
end;
//## canalign ##
function tvirtualtext.canalign:boolean;
begin
try;result:=(inherited canalign) and (ih<>nil);except;end;
end;
//## doalign ##
procedure tvirtualtext.doalign;
begin
try
//check
if not canalign then exit;
//process
//.iv
iv.setboundsb(clientwidth-viScrollSize,0,viScrollSize,clientheight-viScrollSize);
iv.stepby:=1;
iv.small:=1;
iv.large:=frcmin(vCount-1,1);
//.ih
ih.setboundsb(0,clientheight-viScrollSize,clientwidth-viScrollSize,viScrollSize);
ih.stepby:=info^.fontmap.minW;
ih.small:=ihunit;
//.calc
calc;
except;end;
end;
//## _onpaint ##
procedure tvirtualtext._onpaint(sender:tobject;canvas:tcanvas);
var
   a:tsize;
   tmp:string;
   r:trect;
   i,hfc,hbgc,fc,bgc,p,c,dx,dy,cw,minp,maxp:integer;
begin
try
//setup
minp:=vstart;
maxp:=vfinish;
cw:=vclientwidth;
c:=count;
dx:=-(ih.pos*ihunit)+ispace;
dy:=0;
//.colors
fc:=canvas.font.color;
bgc:=canvas.brush.color;
hfc:=general.aorb(fc,info.fonthighlight,fhighlight);
hbgc:=general.aorb(bgc,info.highlight,fhighlight);
i:=itemindex;
if not enabled then i:=-1;
//process
for p:=minp to maxp do
begin
//.get
dy:=(p-minp)*viFontHeight;
r:=rect(0,dy,cw,dy+viFontHeight);
//.highlight - single line
if (i>=0) then
   begin
   if (i=p) then
      begin
      canvas.font.color:=hfc;
      canvas.brush.color:=hbgc;
      end
   else if (p=(i+1)) then
      begin
      canvas.font.color:=fc;
      canvas.brush.color:=bgc;
      end;//end of if
   end;//end of if
//.text/cls
if (p<c) then canvas.textrect(r,dx,dy,iitems.strings[p])
else canvas.fillrect(r);
end;//end of loop
if (maxp>=minp) then inc(dy,viFontHeight);
//.unused areas
//.vertical
canvas.fillrect(rect(clientwidth-viScrollSize,0,clientwidth,dy));
//.horizontal - full width
canvas.fillrect(rect(0,dy,clientwidth,clientheight));
except;end;
end;
//## setvpos ##
procedure tvirtualtext.setvpos(x:integer);
begin
try;setpos(hpos,x,true);except;end;
end;
//## sethpos ##
procedure tvirtualtext.sethpos(x:integer);
begin
try;setpos(x,vpos,true);except;end;
end;
//## getvpos ##
function tvirtualtext.getvpos:integer;
begin
try;result:=iv.pos;except;end;
end;
//## gethpos ##
function tvirtualtext.gethpos:integer;
begin
try;result:=ih.pos;except;end;
end;
//## setpos ##
function tvirtualtext.setpos(_hpos,_vpos:integer;_notify:boolean):boolean;
begin
try
//defaults
result:=false;
//range
_hpos:=frcrange(_hpos,0,ih.max);
_vpos:=frcrange(_vpos,0,iv.max);
//check
if (_hpos=ih.pos) and
   (_vpos=iv.pos) then exit;
//process
//.set
inc(ilockpos);
ih.pos:=_hpos;
iv.pos:=_vpos;
dec(ilockpos);
//.notify
if _notify then _onpos(self);
//successful
result:=true;
except;end;
end;
//## _onrepeat ##
procedure tvirtualtext._onrepeat(sender:tobject);
begin
try
if ivclient then iv._onrepeat(self)
else if ihclient then ih._onrepeat(self);
except;end;
end;
//## _onwheelv ##
procedure tvirtualtext._onwheelv(sender:tobject);
var
   tmp:integer;
begin
try
//self
inherited;
//process
//.get
tmp:=round(igui.wheelv);
//.reset
igui.wheelv:=igui.wheelv-tmp;
//.set
if (tmp<>0) then iv.pos:=iv.pos-(tmp*iv.small);
except;end;
end;
//## _onnotify ##
procedure tvirtualtext._onnotify(sender:tobject);
var
   wasclient:boolean;
begin
try
if igui.iskeyboard then
   begin
   case igui.key of
   vk_up,vk_down,vk_home,vk_end,vk_prior,vk_next:iv._onnotify(self);
   vk_left,vk_right:ih._onnotify(self);
   end;//end of case
   end
else if igui.ismouse then
   begin
   //.switch
   if (igui.act=aDown) then
      begin
      ivclient:=iv.inclient;
      ihclient:=ih.inclient;
      end;//end of if
   //.re-route
   if ivclient then
      begin
      cursor:=iv.cursor;
      iv._onnotify(self);
      end
   else if ihclient then
      begin
      cursor:=ih.cursor;
      ih._onnotify(self);
      end
   else cursor:=vcArrow;
   //.release
   if (igui.act=aUp) then
      begin
      wasclient:=(not ivclient) and (not ihclient);
      ivclient:=false;
      ihclient:=false;
      //.show when mouse is "aUP"
      if wasclient then
         begin
         case igui.key of
         mLeft:if canedit then edit else itemindex:=autoitemindex(iv.pos,false);
         mRight:showmenu;
         end;//end of case
         end;//end of if
      end;//end of if
   end;//end of if
except;end;
end;

//## tvirtualtextwrap ##########################################################
//## create ##
constructor tvirtualtextwrap.create(_gui:tvirtualform);
begin
//self
inherited create(_gui);
oHeight:=vhsHeight;
cursor:=vcArrow;
//controls
//.iitems
iitems:=tstringlist.create;
iwrap:=tstringlist.create;
//.iv
iv:=new('scrollbar','','','',valNone,nil) as tvirtualscrollbar;
iv.internalhelp:=rthtranslate('Scroll text vertically');
iv.vertical:=true;
iv.style:=[];
//.self
self.groupfocus:=true;
iv.groupfocus:=groupfocus;
//defaults
ief:=[vefCut,vefCopy,vefCopyAll,vefPaste,vefDelete,vefUpper,vefLower,vefEdit];
iwrapchanged:=false;
oVariableheight:=true;
icanedit:=false;//no keyboard modification support (del, backspace or addchar)
ispace:=2;//horizontal padding only - not to be used for vertical
timer:=0;
iitems.text:='#';
setparams(-1,'',false);
height:=200;
//events
iv.onpos:=_onpos;
end;
//## destroy ##
destructor tvirtualtextwrap.destroy;
begin
try
//init
destroyinit;
//controls
freeobj(@iv);
freeobj(@iitems);
freeobj(@iwrap);
//self
inherited;
except;end;
end;
//## find ##
function tvirtualtextwrap.find(x:string;_highlight:boolean):integer;
var
   tmp:string;
   pos,minp,p:integer;
begin
try
//defaults
result:=-1;//not found
//check
if (iwrap.count=0) or (length(x)=0) then exit;
//process
//.get
if (iitemindex=-1) then minp:=0 else minp:=iitemindex+1;
if (minp>=count) then minp:=0;
//.find #1
for p:=minp to (iwrap.count-1) do
begin
tmp:=iwrap.strings[p];
pos:=1;
if general.findtext(pos,tmp,x) then
   begin
   result:=p;
   break;
   end;//end of if
end;//end of loop
//.find #2
if (result=-1) then
   begin
   for p:=0 to (minp-1) do
   begin
   tmp:=iwrap.strings[p];
   pos:=1;
   if general.findtext(pos,tmp,x) then
      begin
      result:=p;
      break;
      end;//end of if
   end;//end of loop
   end;//end of if
//highlight
if _highlight and (result>=0) then
   begin
   if not ((result>=vstart) and (result<=vfinish)) then vpos:=result;
   itemindex:=result;
   end;//end of if
except;end;
end;
//## getseltext ##
function tvirtualtextwrap.getseltext:string;
begin
try;if fhighlight and (itemindex>=0) and (itemindex<iitemindexlimit) then result:=iwrap.strings[itemindex] else result:=(inherited getseltext);except;end;
end;
//## paint ##
procedure tvirtualtextwrap.paint;
begin
try
//self
inherited;
//other
iv.paint;
except;end;
end;
//## getwordwrap ##
function tvirtualtextwrap.getwordwrap:boolean;
begin
try;result:=true;except;end;
end;
//## maxheight ##
function tvirtualtextwrap.maxheight:integer;
begin
try;result:=iwrap.count*viFontHeight;except;end;
end;
//## canedit ##
function tvirtualtextwrap.canedit:boolean;
begin
try;result:=(vefEdit in ief) and (not ireadonly);except;end;
end;
//## _onpos ##
procedure tvirtualtextwrap._onpos(sender:tobject);
begin
try
if (ilockpos=0) then
   begin
   //paint
   paint;
   //event
   fireevent(fonpos,self);
   end;//end of if
except;end;
end;
//## settext ##
procedure tvirtualtextwrap.settext(x:string);
begin
try;setparams(itemindex,x,true);except;end;
end;
//## gettext ##
function tvirtualtextwrap.gettext:string;
begin
try;result:=iitems.text;except;end;
end;
//## vclientwidth ##
function tvirtualtextwrap.vclientwidth:integer;
begin
try;result:=frcmin(clientwidth-viScrollSize,0);except;end;
end;
//## vcount ##
function tvirtualtextwrap.vcount:integer;
begin
try;result:=frcmin(clientheight div viFontHeight,1);except;end;
end;
//## vstart ##
function tvirtualtextwrap.vstart:integer;
begin
try;result:=iv.pos;except;end;
end;
//## vfinish ##
function tvirtualtextwrap.vfinish:integer;
var
   s,c:integer;
begin
try
s:=vstart;
c:=vcount;
result:=frcrange(s+c-1,s,frcmin(s+c-1,0));
except;end;
end;
//## nextwrap ##
function tvirtualtextwrap.nextwrap(var x:string;xlen,s,_maxwidth:integer):integer;
var
   v:byte;
   cw,w,p,lastspace:integer;
begin
try
//defaults
result:=0;
if (xlen=0) then exit;
if (s<1) then s:=1
else if (s>xlen) then exit;
lastspace:=0;
w:=0;
//process
for p:=s to xlen do
begin
//.get
v:=byte(x[p]);
cw:=info^.fontmap.w^[v];
//.check - atleast one or more characters
if ((w+cw)>_maxwidth) then
   begin
   if (lastspace<>0) then result:=frcmin(lastspace-s+1,1)
   else result:=frcmin(p-s,1);
   break;
   end;//end of if
//.lastspace
if (v=32) then lastspace:=p;
//.inc
inc(w,cw);
inc(result);
end;//end of if
except;end;
end;
//## dowordwrap ##
procedure tvirtualtextwrap.dowordwrap;
label
   skipend;
var
   tmp:string;
   xlen,s,tc,c,cw,p:integer;
begin
try
//reset
iwrap.clear;
//init
cw:=vclientwidth-(2*ispace);
//process
for p:=0 to (iitems.count-1) do
begin
//.get
tmp:=iitems.strings[p];
xlen:=length(tmp);
s:=1;
//.filter
general.swapchars(tmp,#9,#32);
//.set
while (s<=xlen) do
begin
//.find
c:=nextwrap(tmp,xlen,s,cw);
//.add
tc:=c;
if (tc<>0) and (tmp[s+tc-1]=#32) then dec(tc);
if (tc>=1) then iwrap.add(copy(tmp,s,tc));
//.inc
inc(s,c);
//.check
if (c=0) then goto skipend;
end;//end of while
//.blank line - hard return
if (xlen=0) then iwrap.add('');
end;//end of loop
skipend:
except;end;
try;iitemindexlimit:=iwrap.count;except;end;
end;
//## calc ##
procedure tvirtualtextwrap.calc;
var
   z:integer;
begin
try
//.wordwrap
if iwrapchanged or dimensionsmodified then
   begin
   iwrapchanged:=false;
   dowordwrap;
   end;//end of if
//.iv
z:=frcmin(iwrap.count-vcount,0);
iv.setparams(0,iv.pos,z,false);
except;end;
end;
//## setparams ##
function tvirtualtextwrap.setparams(_itemindex:integer;_text:string;_notify:boolean):boolean;
var
   _modified:boolean;
   _count,z,w,h:integer;
begin
try
//defaults
result:=false;
_modified:=false;
//range
_text:=copy(_text,1,limit);
_count:=length(_text);
//process
//.set
if (_count<>count) or (_text<>text) then
   begin
   _modified:=true;
   iitems.text:=_text;
   iwrapchanged:=true;
   calc;
   end;//end of if
//.itemindex
if (_itemindex<-1) or (_itemindex>=iitemindexlimit) then _itemindex:=-1;
if (_itemindex<>itemindex) then
   begin
   iitemindex:=_itemindex;
   _modified:=true;
   end;//end of if
if not _modified then exit;
//.notify
if _notify then
   begin
   //.paint
   paint;
   //.event
   doonchange;
   end;//end of if
//changed
result:=true;
except;end;
end;
//## getcount ##
function tvirtualtextwrap.getcount:integer;
begin
try;result:=iitems.count;except;end;
end;
//## canalign ##
function tvirtualtextwrap.canalign:boolean;
begin
try;result:=(inherited canalign) and (iv<>nil);except;end;
end;
//## doalign ##
procedure tvirtualtextwrap.doalign;
begin
try
//check
if not canalign then exit;
//process
//.iv
iv.setboundsb(clientwidth-viScrollSize,0,viScrollSize,clientheight);
iv.stepby:=1;
iv.small:=1;
iv.large:=frcmin(vCount-1,1);
//.changed
if (ilastwidth<>width) or dimensionsmodified then
   begin
   iwrapchanged:=true;
   ilastwidth:=width;
   end;//end of if
//.calc
calc;
except;end;
end;
//## _onpaint ##
procedure tvirtualtextwrap._onpaint(sender:tobject;canvas:tcanvas);
var
   a:tsize;
   tmp:string;
   r:trect;
   i,hfc,hbgc,fc,bgc,p,c,dx,dy,cw,minp,maxp:integer;
begin
try
//setup
minp:=vstart;
maxp:=vfinish;
cw:=vclientwidth;
c:=iwrap.count;
dx:=ispace;
dy:=0;
//.colors
fc:=canvas.font.color;
bgc:=canvas.brush.color;
hfc:=general.aorb(fc,info.fonthighlight,fhighlight);
hbgc:=general.aorb(bgc,info.highlight,fhighlight);
i:=itemindex;
if not enabled then i:=-1;
//process
for p:=minp to maxp do
begin
//.get
dy:=(p-minp)*viFontHeight;
r:=rect(0,dy,cw,dy+viFontHeight);
//.highlight - single line
if (i>=0) then
   begin
   if (i=p) then
      begin
      canvas.font.color:=hfc;
      canvas.brush.color:=hbgc;
      end
   else if (p=(i+1)) then
      begin
      canvas.font.color:=fc;
      canvas.brush.color:=bgc;
      end;//end of if
   end;//end of if
//.text/cls
if (p<c) then canvas.textrect(r,dx,dy,iwrap.strings[p])
else canvas.fillrect(r);
end;//end of loop
if (maxp>=minp) then inc(dy,viFontHeight);
//.unused areas
//.vertical
canvas.fillrect(rect(clientwidth-viScrollSize,0,clientwidth,clientheight));
//.horizontal - width upto vertical scrollbar
canvas.fillrect(rect(0,dy,clientwidth-viScrollSize,clientheight));
except;end;
end;
//## setvpos ##
procedure tvirtualtextwrap.setvpos(x:integer);
begin
try;setpos(0,x,true);except;end;
end;
//## getvpos ##
function tvirtualtextwrap.getvpos:integer;
begin
try;result:=iv.pos;except;end;
end;
//## setpos ##
function tvirtualtextwrap.setpos(_hpos,_vpos:integer;_notify:boolean):boolean;
begin
try
//defaults
result:=false;
//range
_vpos:=frcrange(_vpos,0,iv.max);
//check
if (_vpos=iv.pos) then exit;
//process
//.set
inc(ilockpos);
iv.pos:=_vpos;
dec(ilockpos);
//.notify
if _notify then _onpos(self);
//successful
result:=true;
except;end;
end;
//## _onrepeat ##
procedure tvirtualtextwrap._onrepeat(sender:tobject);
begin
try;if ivclient then iv._onrepeat(self);except;end;
end;
//## _onwheelv ##
procedure tvirtualtextwrap._onwheelv(sender:tobject);
var
   tmp:integer;
begin
try
//self
inherited;
//process
//.get
tmp:=round(igui.wheelv);
//.reset
igui.wheelv:=igui.wheelv-tmp;
//.set
if (tmp<>0) then iv.pos:=iv.pos-(tmp*iv.small);
except;end;
end;
//## _onnotify ##
procedure tvirtualtextwrap._onnotify(sender:tobject);
var
   wasclient:boolean;
begin
try
if igui.iskeyboard then
   begin
   case igui.key of
   vk_left,vk_right,vk_up,vk_down,vk_home,vk_end,vk_prior,vk_next:iv._onnotify(self);
   end;//end of case
   end
else if igui.ismouse then
   begin
   //.switch
   if (igui.act=aDown) then
      begin
      ivclient:=iv.inclient;
      end;//end of if
   //.re-route
   if ivclient then
      begin
      cursor:=iv.cursor;
      iv._onnotify(self);
      end
   else cursor:=vcArrow;
   //.release
   if (igui.act=aUp) then
      begin
      wasclient:=(not ivclient);
      ivclient:=false;
      //.show when mouse is "aUP"
      if wasclient then
         begin
         case igui.key of
         mLeft:if canedit then edit else itemindex:=autoitemindex(iv.pos,false);
         mRight:showmenu;
         end;//end of case
         end;//end of if
      end;//end of if
   end;//end of if
except;end;
end;

//## tvirtualpages #############################################################
//## create ##
constructor tvirtualpages.create(_gui:tvirtualform);
begin
//self
inherited create(_gui);
//vars
oseptop:=true;
osepbot:=true;
ilimit:=high(ipages)+1;
fillchar(ipages,sizeof(ipages),0);
ipage:=-1;//no page
bordersize:=0;
//controls
//.tabs
itabs:=new('grid','','','',valNone,nil) as tvirtualgrid;
itabs.space:=0;
itabs.bordersize:=0;
//defaults
style:=[];
cursor:=vcArrow;
oVariableheight:=true;
//special - fill "_gui.pages" with self if empty
if (_gui<>nil) and (_gui.pages=nil) then _gui.pages:=self;
end;
//## destroy ##
destructor tvirtualpages.destroy;
begin
try
//init
destroyinit;
//children
destroychildren;
//self
inherited;
except;end;
end;
//## _ontimer ##
procedure tvirtualpages._ontimer(sender:tobject);
var//Dedicated timer for "scroll"
   a:tvirtualcontrol;
   c,i,maxp,p:integer;
   good,ok,mr:boolean;
begin
try
//check
if (scroll=0) then exit;
//defaults
maxp:=high(ipages);
mr:=(iscroll>=0);
i:=frcmin(page,0);
good:=false;
//focus check
ok:=false;
a:=gui.focuscontrol;
if (a<>nil) then for p:=0 to maxp do if (ipages[p]<>nil) and (ipages[p].button=a) then
   begin
   ok:=true;
   break;
   end;//end of if
if not ok then
   begin
   scroll:=0;
   exit;
   end;//end of if
//get
for p:=0 to maxp do
begin
//.inc
if mr then inc(i) else dec(i);
//.range
if (i<0) then i:=maxp
else if (i>maxp) then i:=0;
//.decide
if (ipages[i]<>nil) and (ipages[i] as tvirtualpage).button.visible and (ipages[i] as tvirtualpage).button.enabled then
   begin
   //.set
   if assigned(onscroll) then ok:=onscroll(self,i) else ok:=true;
   if ok then
      begin
      good:=true;
      iscrollbusy:=true;
      page:=i;
      iscrollbusy:=false;
      break;
      end;//end of if
   end;//end of if
end;//end of loop
//stop - no valid pages to scroll so turn scroll off
if (not good) and (scroll<>0) then scroll:=0;
except;end;
end;
//## setscroll ##
procedure tvirtualpages.setscroll(x:integer);
begin
try
if general.setint(x,iscroll) then
   begin
   //focus page button
   iscrollbusy:=true;
   if (page<0) then page:=0
   else gui.focuscontrol:=ipages[page].button;
   iscrollbusy:=false;
   //timer
   if (x<0) then x:=-x;
   timer:=x;
   //event
   fireevent(onscrollstate,self);
   end;//end of if
except;end;
end;
//## aslinks ##
procedure tvirtualpages.aslinks;
begin
try;aslinksex(false);except;end;
end;
//## aslinksex ##
procedure tvirtualpages.aslinksex(_right:boolean);
begin
try
if iaslinks then exit else iaslinks:=true;
itabs.ovalRightReverse:=_right;
itabs.normal:=false;
itabs.bordersize:=1;
except;end;
end;
//## setpageinit ##
procedure tvirtualpages.setpageinit(x:integer);
begin//Note: always updates page even if already displaying
try;setpageb(x,false);except;end;
end;
//## setpage ##
procedure tvirtualpages.setpage(x:integer);
begin
try;setpageb(x,true);except;end;
end;
//## setpageb ##
procedure tvirtualpages.setpageb(x:integer;_check:boolean);
var
   oldpage:integer;
begin
try
//check
if destroying then exit;
//scroll stop
if (not iscrollbusy) and (scroll<>0) then scroll:=0;
//range
x:=frcrange(x,-1,high(ipages));
//check
if valid(x) and (not inuse(x)) then x:=-1;
//set
oldpage:=ipage;
if general.setint(x,ipage) or (not _check) then
   begin
   //.old
   if inuse(oldpage) then
      begin
      ipages[oldpage].visible:=false;
      (itabs.controls.items[oldpage] as tvirtualbutton).mark:=false;
      end;//end of if
   //.new
   if inuse(x) then
      begin
      //.page
      doalign;
      //..align page again, since viScrollSize/etc may have changed since before
      ipages[x].doalign;
      //..show page - don't paint yet
      ipages[x].visible:=true;
      //..realign all controls on parent, above and paint
      ipages[x].realign(true);
      //.tab
      (itabs.controls.items[x] as tvirtualbutton).mark:=true;
      end;//endof if
   end;//end of if
//.focus control
if inuse(x) and itabs.canpaint then igui.focuscontrol:=itabs.controls.items[x];
//.group
if (group<>0) then gui.groupnotify(self,group,_ongroup);
//.event
fireevent(onpage,self);
except;end;
end;
//## _ongroup ##
procedure tvirtualpages._ongroup(sender:tobject;control:tvirtualcontrol;group:integer);
begin
try
if (control<>nil) and (control is tvirtualpages) and ((control as tvirtualpages).page<>page) then
   begin
   (control as tvirtualpages).page:=page;
   end;//end of if
except;end;
end;
//## vsep ##
function tvirtualpages.vsep:integer;
begin
try
//defaults
result:=0;
//process
if (itabs.parent=self) and itabs.visible then
   begin
   result:=itabs.top+itabs.height;
   if osepbot then inc(result);
   end;//end of if
except;end;
end;
//## doalign ##
procedure tvirtualpages.doalign;
var
   y,tmp,z:integer;
begin
try
//check
if not canalign then exit;
//.tabs
if oseptop and (vsep<>0) then y:=1 else y:=0;
if (itabs.parent=self) and itabs.visible then
   begin
   itabs.setboundsb(0,y,clientwidth,itabs.height);
   tmp:=itabs.getalignheight;
   itabs.setboundsex(0,y,clientwidth,tmp,true);
   end;//end of if
z:=vsep;
//.page - must always update, since "fontsize" requires a "doalign" for sub-controls to update
if valid(ipage) and ipages[ipage].visible then ipages[ipage].setboundsex(0,z,clientwidth,clientheight-z,true);
except;end;
end;
//## valid ##
function tvirtualpages.valid(x:integer):boolean;
begin
try;result:=(x>=0) and (x<=high(ipages));except;end;
end;
//## inuse ##
function tvirtualpages.inuse(x:integer):boolean;
begin
try;result:=valid(x) and (ipages[x]<>nil);except;end;
end;
//## getpages ##
function tvirtualpages.getpages(x:integer):tvirtualcontrol;
begin
try;if inuse(x) then result:=ipages[x] else result:=nil;except;end;
end;
//## getcount ##
function tvirtualpages.getcount:integer;
var
   p:integer;
begin
try
//defaults
result:=0;
//process
for p:=0 to high(ipages) do if (ipages[p]<>nil) then inc(result);
except;end;
end;
//## newindex ##
function tvirtualpages.newindex:integer;
var
   p:integer;
begin
try
//defaults
result:=-1;
//process
for p:=0 to high(ipages) do if (ipages[p]=nil) then
   begin
   result:=p;
   break;
   end;//end of if
except;end;
end;
//## newpagevsplit ##
function tvirtualpages.newpagevsplit(_cap,_tep,_help:string;_capbar,_scrollTOP,_scrollBOT:boolean):tvirtualpagevsplit;
var
   tmp:integer;
begin
try
//get
result:=newpageb(_cap,_tep,_help,vpsVSplit,nil,tmp) as tvirtualpagevsplit;
result.createinit(_scrollTOP,_scrollBOT);
//set
if _capbar then result.pages[0].new('titlesmall',general.remcharb(_cap,'&'),'',result.help,valTop,nil);
except;end;
end;
//## newpagescroll ##
function tvirtualpages.newpagescroll(_cap:string;_tep,_help:string;_capbar:boolean):tvirtualpagescroll;
begin
try;result:=newpagescrollex(_cap,_tep,_help,_capbar,false);except;end;
end;
//## newpagescrollex ##
function tvirtualpages.newpagescrollex(_cap:string;_tep,_help:string;_capbar,_fillbar:boolean):tvirtualpagescroll;
var
   tmp:integer;
begin
try
//get
result:=newpageb(_cap,_tep,_help,vpsScrolling,nil,tmp) as tvirtualpagescroll;
//set
if _capbar then result.client.new('titlesmall',general.remcharb(_cap,'&'),'',result.help,valTop,nil);
if _fillbar then result.fillbar;
except;end;
end;
//## newpagestatic ##
function tvirtualpages.newpagestatic(_cap:string;_tep,_help:string;_capbar:boolean):tvirtualpage;
var
   tmp:integer;
begin
try
//get
result:=newpageb(_cap,_tep,_help,vpsNormal,nil,tmp) as tvirtualpage;
//set
if _capbar then result.client.new('titlesmall',general.remcharb(_cap,'&'),'',result.help,valTop,nil);
except;end;
end;
//## newpagestaticex ##
function tvirtualpages.newpagestaticex(_cap:string;_tep,_help:string;_capbar,_fillbar:boolean):tvirtualpage;
var
   z:tvirtualpagevsplit;
   tmp:integer;
begin
try
//defaults
result:=nil;
//get
z:=newpageb(_cap,_tep,_help,vpsVSplit,nil,tmp) as tvirtualpagevsplit;
z.createinit(false,false);
result:=z.pages[0];
//set
if _capbar then result.new('titlesmall',general.remcharb(_cap,'&'),'',result.help,valTop,nil);
if _fillbar then z.fillbar;
except;end;
end;
//## newpage ##
function tvirtualpages.newpage(_caption,_tep,_help:string;_style:tvirtualpagestyle;var _page:integer):tvirtualpage;
begin
try;result:=newpageb(_caption,_tep,_help,_style,nil,_page);except;end;
end;
//## newpageb ##
function tvirtualpages.newpageb(_caption,_tep,_help:string;_style:tvirtualpagestyle;_existingpage:tvirtualpage;var _page:integer):tvirtualpage;
label
   skipend;
var
   a:char;
   b:tvirtualbutton;
   tmp:string;
   p:integer;
   _right:boolean;
begin
try
//defaults
result:=nil;
_page:=-1;
//check
if destroying then exit;
//process
//.get
p:=newindex;
if (p=-1) then goto skipend;
//.tab
_right:=itabs.ovalRightReverse;
b:=itabs.new('button',_caption,_tep,_help,valLeft,__onclick) as tvirtualbutton;
with b do
begin
//large auto-height buttons which "compact"
if haveimage and (not iaslinks) then imagealign:=valTop;
tag:=p;
alignsep:=2;
onnotify:=__onnotify;
buffer:=true;
padwidth:=general.aorb(6,0,iaslinks);
//..aslink
if iaslinks then
   begin
   normal:=false;
   aslinkb(_right);
   end;//end of if
end;//end of with
//..get accelerator symbol
a:=menus.extractAKEY(_caption);
if (a<>#0) then b.shortcut:='ALT+'+char(a);
//.page
if (_existingpage=nil) then
   begin
   case _style of
   vpsScrolling:tmp:='pagescroll';
   vpsVSplit:tmp:='pagevsplit';
   vpsPages:tmp:='pages';
   else
    tmp:='page';//vpsNormal
   end;//end of case
   result:=new(tmp,'','',_help,valNone,nil) as tvirtualpage;
   end
else
   begin
   result:=_existingpage;
   with result do
   begin
   parent:=self;
   enabled:=true;
   hold:=false;
   end;//end of with
   end;//end of if
with result do
begin
button:=b;
tag:=p;
visible:=false;
bordersize:=0;
oPaintonvisible:=false;
if (_style=vpsNormal) or (_style=vpsVSplit) or (_style=vpsPages) then oVariableheight:=true;
end;//end of with
ipages[p]:=result;
_page:=p;
skipend:
//check
if (page=-1) and (count>=1) then page:=0;
except;end;
end;
//## __onclick ##
procedure tvirtualpages.__onclick(sender:tobject);
begin
try
//check
if destroying then exit;
//process
if (sender<>nil) and (sender is tvirtualbutton) then
   begin
   scroll:=0;
   page:=(sender as tvirtualcontrol).tag;
   end;//end of if
except;end;
end;
//## moveleft ##
procedure tvirtualpages.moveleft;
var
   i,p:integer;
begin
try
//scan
i:=page-1;
for p:=0 to (count-1) do
begin
//range
if (i>=count) then i:=0
else if (i<0) then i:=count-1;
//decide
if (ipages[i] as tvirtualpage).button.visible and (ipages[i] as tvirtualpage).button.enabled then break;
//dec
dec(i);
end;//end of loop
//set
page:=i;
except;end;
end;
//## moveright ##
procedure tvirtualpages.moveright;
var
   i,p:integer;
begin
try
//scan
i:=page+1;
for p:=0 to (count-1) do
begin
//range
if (i>=count) then i:=0
else if (i<0) then i:=count-1;
//decide
if (ipages[i] as tvirtualpage).button.visible and (ipages[i] as tvirtualpage).button.enabled then break;
//inc
inc(i);
end;//end of loop
//set
page:=i;
except;end;
end;
//## __onclick ##
procedure tvirtualpages.__onnotify(sender:tobject);
begin
try
//check
if destroying then exit;
//process
if igui.iskeyboard and (igui.act=aUp)then
   begin
   case igui.key of
   vk_left,vk_up:moveleft;
   vk_right,vk_down:moveright;
   vk_home:page:=0;
   vk_end:page:=count-1;
   end;//end of case
   end;//end of if
except;end;
end;

//## tvirtualuserschemes #######################################################
//## create ##
constructor tvirtualschemes.create(_gui:tvirtualform);
begin
//self
inherited create(_gui);
createinit(false,false);
//help
help:=rthtranslate('Load/save all Program options, settings, appearances in single "Scheme" file');
//controls
bordersize:=0;
ischemeext:='SCHEME';
//controls
with pages[0] do
begin
//.title
with new('titlegrid',ntranslate('schemes'),'','',valTop,nil) as tvirtualgrid do
begin
idefaultappearance:=newlink(ntranslate('default appearance'),tepDefaults20,rthtranslate('Restore default appearance settings'),__onclick);
iloadappearance:=newlink(ntranslate('load appearance'),tepOpen20,rthtranslate('Implement selected Scheme appearance settings'), __onclick);
ipaste:=newlink(ntranslate('paste'),tepPaste20,rthtranslate('Paste Scheme (plain text) from Clipboard. A query Window will display - click "Yes" to paste entire Scheme, "No" to paste appearance settings only (border, fonts, cursors, colors), or "Cancel"'),__onclick);
icopy:=newlink(ntranslate('copy'),tepCopy20,rthtranslate('Copy all options, settings, appearance to Clipboard as plain text Scheme'),__onclick);
igroup:=newlink(ntranslate('group'),tepFind20,rthtranslate('Toggle between all Schemes (default)/Program specific'),__onclick) as tvirtuallink;
end;//end of with
//.list
ilist:=new('list','','',rthtranslate('Available Schemes'),valTop,nil) as tvirtuallist;
ilist.oNumbered:=true;
ilist.ondblclick:=__onclick;
end;//end of page0

with pages[1] do
begin
oHeight:=vhsControls;
iload:=new('button',ntranslate('load'),tepOpen20,rthtranslate('Implement selected Scheme, to replace current options/settings/appearance'),valLeft,__onclick);
iloadfrom:=new('button',ntranslate('load from...'),tepOpen20,rthtranslate('Load Scheme from disk, to replace current options/settings/appearance'),valLeft,__onclick);
isaveas:=new('button',ntranslate('save as...'),tepSaveAs20,rthtranslate('Prompt and save current Scheme to disk'),valLeft,__onclick);
isave:=new('button',ntranslate('save'),tepSaveAs20,rthtranslate('Save current Scheme to disk'),valLeft,__onclick);
isave.alignsep:=isave.alignsep*2;
irefresh:=new('button',ntranslate('refresh'),tepRefresh20,rthtranslate('Update Schemes'' list'),valLeft,__onclick);
ifolder:=new('button',ntranslate('folder'),tepFolder20,rthtranslate('Display Schemes'' Folder. Delete, copy, manage Schemes'),valLeft,__onclick);
ifolder.alignsep:=ifolder.alignsep*2;
idefaults:=new('button',ntranslate('defaults'),tepDefaults20,rthtranslate('Restore Program defaults'),valLeft,__onclick);
end;//end of page1
//timer
timer:=1000;
//defaults
setbounds(0,0,100,250);
listrefresh;
end;
//## _ontimer ##
procedure tvirtualschemes._ontimer(sender:tobject);
begin
try
//check
if igui.destroying or (not showing) then exit;
//process
iload.enabled:=canschemeload;
iloadappearance.enabled:=iload.enabled;
isave.enabled:=canschemesave;
isaveas.enabled:=canschemesaveas;
ipaste.enabled:=canpastefrom;
except;end;
end;
//## __onclick ##
procedure tvirtualschemes.__onclick(sender:tobject);
var
   e:string;
begin
try
if (sender=iloadappearance) or (sender=ilist) then
   begin
   if (sender=ilist) then
      begin
      (iloadappearance as tvirtualbutton).mark:=true;
      application.processmessages;
      end;//end of if
   (if not schemeload(e,false) then showerror60(translate(e)) );
   if (sender=ilist) then
      begin
      (iloadappearance as tvirtualbutton).mark:=false;
      application.processmessages;
      sleep(100);
      end;//end of if
   end
else if (sender=iloadfrom) then
   begin
   //get
   if misc.opendlgb('scheme',ntranslate('schemes')+' (*.scheme)|*.scheme',ifilename,1,ifilename) then
      begin
      if not vs.loadfromfile(ifilename,e,false,true) then showerror60(translate(e));
      end;//end of if
   end
else if (sender=iload) then (if not schemeload(e,true) then showerror60(translate(e)) )
else if (sender=isave) then (if not schemesave(schemeselected,e) then showerror60(translate(e)) )
else if (sender=isaveas) then (if not schemesaveas(e) then showerror60(translate(e)) )
else if (sender=irefresh) then listrefresh
else if (sender=ifolder) then run(bvfportable(bvfSchemes),'')
else if (sender=idefaultappearance) then vs.defaultsb(true,false)//appearance
else if (sender=idefaults) then vs.defaults(true)
else if (sender=icopy) then copyto
else if (sender=ipaste) then pastefrom
else if (sender=igroup) then
     begin
     igroup.mark:=not igroup.mark;
     case igroup.mark of
     true:ipretext:=programnamehard+'__';
     false:ipretext:='';
     end;//end of case
     listrefresh;
     end;//end of if
except;end;
end;
//## copyto ##
procedure tvirtualschemes.copyto;
begin
try;vs.copyto;except;end;
end;
//## canpastefrom ##
function tvirtualschemes.canpastefrom:boolean;
begin
try;result:=vs.canpastefrom;except;end;
end;
//## pastefrom ##
procedure tvirtualschemes.pastefrom;
begin
try;vs.pastefrom;except;end;
end;
//## schemefilename ##
function tvirtualschemes.schemefilename(x:string):string;
begin
try;result:=bvfportable(bvfSchemes)+x+'.'+ischemeext;except;end;
end;
//## schemeselected ##
function tvirtualschemes.schemeselected:string;
begin
try
//defaults
result:='';
//process;
if (ilist.itemindex>=0) then result:=schemefilename(ipretext+ilist.items[ilist.itemindex]);
except;end;
end;
//## canschemeload ##
function tvirtualschemes.canschemeload:boolean;
begin
try;result:=(ilist.itemindex>=0) and fileexists(schemeselected);except;end;
end;
//## schemeload ##
function tvirtualschemes.schemeload(var e:string;full:boolean):boolean;
begin
try
//defaults
result:=false;
e:=gecUnexpectedError;
//process
if canschemeload then result:=vs.loadfromfile(schemeselected,e,false,full);
except;end;
end;
//## canschemesave ##
function tvirtualschemes.canschemesave:boolean;
begin
try;result:=programreadwrite and (ilist.itemindex>=0) and fileexists(schemeselected);except;end;
end;
//## schemesave ##
function tvirtualschemes.schemesave(x:string;var e:string):boolean;
var
   _exists:boolean;
begin
try
//defaults
result:=false;
e:=gecUnexpectedError;
//process
if (x<>'') then
   begin
   //.prompt
   _exists:=fileexists(x);
   if _exists and (not showquery(translate('Replace Scheme')+':'+rcode+nopretext(general.remlastext(extractfilename(x)))+'?',-60)) then
      begin
      result:=true;
      exit;
      end;//end of if
   //.set
   result:=vs.savetofile(x,e);
   //.refresh
   if not _exists then listrefreshex(x);
   end;//end of if
except;end;
end;
//## canschemesaveas ##
function tvirtualschemes.canschemesaveas:boolean;
begin
try;result:=programreadwrite;except;end;
end;
//## schemesaveas ##
function tvirtualschemes.schemesaveas(var e:string):boolean;
var
   x:string;
begin
try
//defaults
result:=false;
e:=gecUnexpectedError;
//process
//.prompt
x:='';
if not showedit(x,translate('Save As'),translate('Scheme')+#32+translate('Name'),translate('&Save'),-60) then
   begin
   result:=true;
   exit;
   end;//end of if
//.filter
x:=general.safeprogramname(x);//12JAN2008
//.set
result:=schemesave(schemefilename(ipretext+x),e);
except;end;
end;
//## listrefresh ##
procedure tvirtualschemes.listrefresh;
begin
try;listrefreshex('');except;end;
end;
//## listrefreshex ##
procedure tvirtualschemes.listrefreshex(n:string);
var
   a:tstringlist;
   p:integer;
   tmp:string;
begin
try
//defaults
a:=nil;
//process
//.get
if (n='') and (ilist.itemindex>=0) then n:=ilist.items[ilist.itemindex];
a:=tstringlist.create;
a.text:=general.files(bvfportable(bvfSchemes)+ipretext+'*.'+ischemeext,false);
//.filter
for p:=0 to (a.count-1) do
begin
tmp:=a.strings[p];
tmp:=nopretext(general.remlastext(tmp));
a.strings[p]:=tmp;
end;//end of loop
//.sort
a.sort;
//.set
ilist.text:=a.text;
//focus
if (copy(n,2,1)=':') then n:=nopretext(general.remlastext(extractfilename(n)));//convert "filename" to "clean name"
p:=ilist.findvalue(n);
ilist.itemindex:=p;
except;end;
try;freeObj(@a);except;end;
end;
//## nopretext ##
function tvirtualschemes.nopretext(x:string):string;
var
   xlen:integer;
begin
try
//defaults
result:=x;
//get
xlen:=length(ipretext);
if (xlen>=1) then result:=copy(result,xlen+1,length(result));
except;end;
end;

//yyyyyyyyyyyyyyyyyyyyyyyyyyy//7777777777777777777
//## tvirtualfilelist ##########################################################
//## create ##
constructor tvirtualfilelist.create(_gui:tvirtualform;_title,_itemlabel:string);
begin
//self
inherited create(_gui);
height:=300;
oVariableHeight:=true;
bordersize:=0;
//vars
iitemlabel:=_itemlabel;
//controls
//.title
with new('titlegrid',_title,'','',valTop,nil) as tvirtualgrid do
begin
//yyyyyyyyyyyyyyyyyyy "rthtranslate('')" has not been filled in on these links yet.
isaveas:=newlink(ntranslate('save as'),tepSaveAs20,'',__onclick);
isave:=newlink(ntranslate('save'),tepSaveAs20,'',__onclick);
iload:=newlink(ntranslate('load'),tepOpen20,'',__onclick);
ifolder:=newlink(ntranslate('folder'),tepFolder20,'',__onclick);
irefresh:=newlink(ntranslate('refresh'),tepRefresh20,'',__onclick);
end;//end of with
//.list
ilist:=new('list','','','',valTop,nil) as tvirtuallist;
ilist.oNumbered:=true;
ilist.oVariableHeight:=true;
//events
ilist.onitemindex:=__onclick;
//defaults
ipath:='\';
ilist.itemindex:=0;
refreshlist;
updatebuttons;
timer:=1000;
end;
//## readwrite ##
procedure tvirtualfilelist.readwrite(mode:tvirtualstoragemode);
begin
try
case mode of
vsmReadfromcontrols:if (isysptr>vsNil) then vs.s[isysptr]:=nameonly;
vsmWritetocontrols:if (isysptr>vsNil) then nameonly:=vs.s[isysptr];
vsmUpdatecontrols:;
end;//end of case
except;end;
end;
//## doonchange ##
procedure tvirtualfilelist.doonchange;
begin
try
inherited;
//call "onclick" if "onchange" is not set
if not assigned(fonchange) then fireevent(fonclick,self)
except;end;
end;
//## getshowsave ##
function tvirtualfilelist.getshowsave:boolean;
begin
try;result:=isave.visible;except;end;
end;
//## setshowsave ##
procedure tvirtualfilelist.setshowsave(x:boolean);
begin
try
if (x<>showsave) then
   begin
   isave.visible:=x;
   isaveas.visible:=x;
   realign(true);
   end;//end of if
except;end;
end;
//## getshowload ##
function tvirtualfilelist.getshowload:boolean;
begin
try;result:=iload.visible;except;end;
end;
//## setshowload ##
procedure tvirtualfilelist.setshowload(x:boolean);
begin
try
if (x<>showload) then
   begin
   iload.visible:=x;
   realign(true);
   end;//end of if
except;end;
end;
//## setitemindex ##
procedure tvirtualfilelist.setitemindex(x:integer);
begin
try;ilist.itemindex:=frcrange(x,0,ilist.count-1);except;end;
end;
//## getitemindex ##
function tvirtualfilelist.getitemindex:integer;
begin
try;result:=frcmin(ilist.itemindex,0);except;end;
end;
//## getitem ##
function tvirtualfilelist.getitem(x:integer):string;
begin
try;result:=ilist.items[x];except;end;
end;
//## setfilename ##
procedure tvirtualfilelist.setfilename(x:string);
begin
try
//range
x:=general.remlastext(extractfilename(x));
//set
if (comparetext(x,filename)<>0) then itemindex:=frcmin(ilist.findvalue(x),0);
except;end;
end;
//## getfilename ##
function tvirtualfilelist.getfilename:string;
begin
try
//defaults
result:='';
//get
if canpath and (ilist.itemindex>0) then result:=path+ilist.items[ilist.itemindex]+'.'+iext;
except;end;
end;
//## setnameonly ##
procedure tvirtualfilelist.setnameonly(x:string);
begin
try;filename:=x;except;end;
end;
//## getnameonly ##
function tvirtualfilelist.getnameonly:string;
begin
try;result:=extractfilename(filename);except;end;
end;
//## settep ##
procedure tvirtualfilelist.settep(x:string);
begin
try;ilist.tep:=x;except;end;
end;
//## gettep ##
function tvirtualfilelist.gettep:string;
begin
try;result:=ilist.tep;except;end;
end;
//## _ontimer ##
procedure tvirtualfilelist._ontimer(sender:tobject);
begin
try
updatebuttons;
except;end;
end;
//## getpath ##
function tvirtualfilelist.getpath:string;
begin
try
//defaults
result:=asfolder(ipath);
//set
if (result<>'\') then forcedirectories(ipath);
except;end;
end;
//## canpath ##
function tvirtualfilelist.canpath:boolean;
begin
try;result:=(ipath<>'\');except;end;
end;
//## setpath ##
procedure tvirtualfilelist.setpath(x:string);
begin
try;setparams(x,iext);except;end;
end;
//## setext ##
procedure tvirtualfilelist.setext(x:string);
begin
try;setparams(ipath,x);except;end;
end;
//## setparams ##
procedure tvirtualfilelist.setparams(_path,_ext:string);
begin
try
//range
_path:=asfolder(_path);
//set
if general.setstring(_path,ipath) or general.setstring(_ext,iext) then
   begin
   ipath:=_path;
   iext:=_ext;
   refreshlist;
   end;//end of if
except;end;
end;
//## refreshlist ##
procedure tvirtualfilelist.refreshlist;
begin
try;refreshlistex(nameonly);except;end;
end;
//## refreshlistex ##
procedure tvirtualfilelist.refreshlistex(n:string);
var
   a:tstringlist;
   _path,z,v,tmp:string;
   len,p:integer;
begin
try
//defaults
len:=0;
tmp:='';
a:=nil;
_path:=path;
if (n<>'') then n:=general.remlastext(extractfilename(n));
//get
z:=general.files(_path+'*.'+iext,false);
p:=1;
while general.nextline(p,z,v) do pushb(len,tmp,general.asname(general.remlastext(extractfilename(v)))+rcode);
//.finalise
pushb(len,tmp,'');
a:=tstringlist.create;
a.text:=tmp;
a.sort;
//.set
ilist.text:=
'('+ntranslate('none')+')'+rcode+
a.text;
//.reset
p:=0;
if (n<>'') then p:=frcmin(ilist.findvalue(n),0);
ilist.itemindex:=p;
except;end;
try
freeobj(@a);
doonchange;
except;end;
end;
//## __onclick ##
procedure tvirtualfilelist.__onclick(sender:tobject);
begin
try
//standard
if (sender=irefresh) then refreshlist
else if (sender=ifolder) then run(path,'')
else if (sender=iload) then
   begin
   if canload then load;
   end
else if (sender=isave) then
   begin
   if cansave then save(true);
   end
else if (sender=isaveas) then
   begin
   if cansaveas then saveas;
   end
else if (sender=ilist) then
   begin
   doonchange;
   end;//end of if
except;end;
end;
//## updatebuttons ##
procedure tvirtualfilelist.updatebuttons;
var
   iok:boolean;
   extra:string;
begin
try
ifolder.enabled:=canpath;
iload.enabled:=canload;
isave.enabled:=cansave;
isaveas.enabled:=cansaveas;
except;end;
end;
//## getdata ##
function tvirtualfilelist.getdata:string;
var
   e,f:string;
begin
try
//defaults
result:='';
//get
f:=filename;
if fileexists(f) then
   begin
   if not io.fromfile(f,result,e) then result:='';
   end;//end of if
except;end;
end;
//## setdata ##
procedure tvirtualfilelist.setdata(x:string);
var
   e:string;
begin
try;if canpath then io.tofile(filename,x,e);except;end;
end;
//## canload ##
function tvirtualfilelist.canload:boolean;
begin
try;result:=assigned(onload);except;end;
end;
//## load ##
procedure tvirtualfilelist.load;
label
   skipend;
var
   f,z,e:string;
begin
try
//check
e:=gecUnexpectedError;
if not canload then goto skipend;
//get
f:=filename;
if (f='') then z:=''//first item "(none)"
else if not io.fromfile(f,z,e) then goto skipend;
//event
if assigned(onload) and (not onload(self,f,z,e)) then goto skipend;
fireevent(onchange,self);
//successful
e:='';
skipend:
except;end;
try;general.iferror(e);except;end;
end;
//## cansave ##
function tvirtualfilelist.cansave:boolean;
begin
try;result:=assigned(onsave) and canpath and (filename<>'');except;end;
end;
//## save ##
procedure tvirtualfilelist.save(_prompt:boolean);
label
   skipend;
var
   f,z,e:string;
begin
try
//check
e:=gecUnexpectedError;
if not cansave then goto skipend;
//event
f:=filename;
z:='';
if assigned(onsave) and (not onsave(self,f,z,e)) then goto skipend;
//prompt
if _prompt and fileexists(f) then
   begin
   if (not showquery(ntranslate('replace')+general.insstr(#32+iitemlabel,iitemlabel<>'')+':'+rcode+general.remlastext(extractfilename(f))+'?',-60)) then
      begin
      e:='';
      goto skipend;
      end;//end of if
   end;//end of if
//get
if not io.tofile(f,z,e) then goto skipend;
//event
fireevent(onchange,self);
//successful
e:='';
skipend:
except;end;
try;general.iferror(e);except;end;
end;
//## cansaveas ##
function tvirtualfilelist.cansaveas:boolean;
begin
try;result:=assigned(onsave) and canpath;except;end;
end;
//## saveas ##
procedure tvirtualfilelist.saveas;
label
   skipend,redo;
var
   f,z,e:string;
begin
try
//check
e:=gecUnexpectedError;
if not cansaveas then goto skipend;
//prompt
redo:
f:='';
if not showedit(f,ntranslate('save as'),general.aorbstr(iitemlabel+#32+ntranslate('name'),ntranslate('file name'),iitemlabel=''),ntranslate('&save'),-60) then
   begin
   e:='';
   goto skipend;
   end;//end of if
f:=general.remlastext(general.safefilename(f,false));
if not general.textgood(f) then
   begin
   showerror(gecBadFilename);
   goto redo;
   end;//end of if
f:=path+f+'.'+iext;
//yyyyyyyyyyyyyyyyyyyyyyyyyyy THIS CONTROL IS NOT YET FINISHED!!!!!!!!!!!!!!!!! - 11JUN2007
//event
z:='';
if assigned(onsave) and (not onsave(self,f,z,e)) then goto skipend;
//get
if not io.tofile(f,z,e) then goto skipend;
//refresh
refreshlistex(f);
fireevent(onchange,self);
//successful
e:='';
skipend:
except;end;
try;general.iferror(e);except;end;
end;

//## tvirtualanimationviewer ###################################################
//## create ##
constructor tvirtualanimationviewer.create(_gui:tvirtualform;_title:string);
var
   tmp:string;
begin
//self
inherited create(_gui);
height:=200;
bordersize:=0;
//vars
namelenlimit:=maxint;//restrict length of names that can be used
ipath:='';
//translation
tsFiles:=ntranslate('files');
tsPath:=ntranslate('folder');
//controls
//.title
ititle:=new('titlegrid',general.udv(_title,ntranslate('images')),'','',valTop,nil) as tvirtualgrid;
with ititle do
begin
ianimations:=newlink(ntranslate('animations'),tepWebPage20,rthtranslate('Load Animations Support Folder'),__onclick);
ipictures:=newlink(ntranslate('pictures'),tepWebPage20,rthtranslate('Load Pictures Support Folder'),__onclick);
icursors:=newlink(ntranslate('cursors'),tepWebPage20,rthtranslate('Load Cursors Support Folder'),__onclick);
irefresh:=newlink(ntranslate('refresh'),tepRefresh20,rthtranslate('Update list'),__onclick);
ifolder:=newlink(ntranslate('folder'),tepFolder20,rthtranslate('View current Folder'),__onclick);
end;//end of with
//.path link
ipathlink:=newlink('#',tepFolder20,rthtranslate('Change current Folder'),__onclick);
ipathlink.align:=valTop;
ipathlink.visible:=false;//hide by default
//.ibase
ibase:=new('pagehsplit','','','',valTop,nil) as tvirtualpagevsplit;
ibase.createinit(false,false);
ibase.percentage:=50;
//PAGE0 - IMAGE
with ibase.pages[0] do
begin
tmp:=rthtranslate('View of current animation/image');
new('label',ntranslate('preview'),'',tmp,valTop,nil);
iimage:=new('button','','',tmp,valTop,__onclick) as tvirtualbutton;
iimage.style:=[];
iimage.fBackground:=false;
iimage.cursor:=vcArrow;
iimage.buffer:=true;
iimage.oVariableheight:=true;
iimage.oAllowBlack:=true;
iimage.dtransparent:=false;
end;//end of with

//PAGE1 - FILES
with ibase.pages[1] do
begin
//.files
ifiles:=new('labellink',tsFiles,'',rthtranslate('Name of current animation/image. Click to scroll name into view.'),valTop,__onclick) as tvirtuallink;
//.list
ilist:=new('list','','',rthtranslate('List of available animations/images'),valTop,nil) as tvirtuallist;
ilist.oNumbered:=true;
ilist.onitemindex:=__onclick;
ilist.onclick:=__onstop;
end;//end of with

//defaults
ilist.itemindex:=0;
refreshlist;
updatebuttons;
//timer
timer:=1000;
end;
//## getoshowsf ##
function tvirtualanimationviewer.getoshowsf:boolean;
begin
try;result:=ianimations.visible;except;end;
end;
//## setoshowsf ##
procedure tvirtualanimationviewer.setoshowsf(x:boolean);
begin
try
//check
if (x=oshowsf) then exit;
//set
ianimations.visible:=x;
ipictures.visible:=x;
icursors.visible:=x;
except;end;
end;
//## setorestrictsf ##
procedure tvirtualanimationviewer.setorestrictsf(x:boolean);
begin
try
//check
if (x=iorestrictsf) then exit;
//set
iorestrictsf:=x;
//filter
pathfile:=pathfile;
except;end;
end;
//## getitemindex ##
function tvirtualanimationviewer.getitemindex:integer;
begin
try;result:=ilist.itemindex;except;end;
end;
//## __onstop ##
procedure tvirtualanimationviewer.__onstop(sender:tobject);
begin
try;fireevent(onstopnext,self);except;end;
end;
//## cannext ##
function tvirtualanimationviewer.cannext:boolean;
begin
try;result:=(ilist.count>=2);except;end;
end;
//## next ##
procedure tvirtualanimationviewer.next(_up:boolean);
var
   p:integer;
begin
try
//check
if not cannext then exit;
//get
case _up of
true:begin
   p:=ilist.itemindex-1;
   if (p<0) then p:=ilist.count-1;
   end;//end of begin
false:begin
   p:=ilist.itemindex+1;
   if (p>=ilist.count) then p:=0;
   end;//end of begin
end;//end of case
//set
ilist.itemindex:=p;
except;end;
end;
//## setoShowfilename ##
procedure tvirtualanimationviewer.setoShowfilename(x:boolean);
begin
try;if general.setbol(x,ioShowfilename) then syncstatus;except;end;
end;
//## setbgcolor ##
procedure tvirtualanimationviewer.setbgcolor(x:integer);
begin
try
ibase.pages[0].oBgcolor:=x;
iimage.oBgcolor:=x;
except;end;
end;
//## getbgcolor ##
function tvirtualanimationviewer.getbgcolor:integer;
begin
try;result:=ibase.pages[0].oBgcolor;except;end;
end;
//## getframeimage ##
function tvirtualanimationviewer.getframeimage:boolean;
begin
try;result:=iimage.oFrameimage;except;end;
end;
//## setframeimage ##
procedure tvirtualanimationviewer.setframeimage(x:boolean);
begin
try;iimage.oFrameimage:=x;except;end;
end;
//## getimage ##
function tvirtualanimationviewer.getimage:tvirtualbitmapanimated;
begin
try;result:=iimage.image;except;end;
end;
//## _ontimer ##
procedure tvirtualanimationviewer._ontimer(sender:tobject);
begin
try
updatebuttons;
except;end;
end;
//## __onclick ##
procedure tvirtualanimationviewer.__onclick(sender:tobject);
var
   tmp:string;
begin
try
//standard
if (sender=ipathlink) then
   begin
   tmp:=asfolder(path);
   if misc.folderdlg('',tmp) then
      begin
      path:=tmp;
      //vs
      if (isysptr>vsNil) then vs.apply;
      end;//end of if
   end
else if (sender=ianimations) then path:=bvfportable(bvfAnimations)
else if (sender=ipictures) then path:=bvfportable(bvfPictures)
else if (sender=icursors) then path:=bvfportable(bvfCursors)
else if (sender=ifiles) then ilist.topindex:=ilist.itemindex
else if (sender=irefresh) then refreshlist
else if (sender=ifolder) then
   begin
   if (path<>'') then run(path,'');
   end
else if (sender=ilist) then load;
except;end;
end;
//## readwrite ##
procedure tvirtualanimationviewer.readwrite(mode:tvirtualstoragemode);
begin
try
case mode of
vsmReadfromcontrols:if (isysptr>vsNil) then vs.s[isysptr]:=pathfile;
vsmWritetocontrols:if (isysptr>vsNil) then pathfile:=vs.s[isysptr];
vsmUpdatecontrols:;
end;//end of case
except;end;
end;
//## getpathfile ##
function tvirtualanimationviewer.getpathfile:string;
begin
try;result:=path+filename;except;end;
end;
//## setpathfile ##
procedure tvirtualanimationviewer.setpathfile(x:string);
begin
try
path:=extractfilepath(x);
filename:=extractfilename(x);
except;end;
end;
//## getpath ##
function tvirtualanimationviewer.getpath:string;
begin
try
//defaults
result:=ipath;
//get
if (result<>'') and (not directoryexists(ipath)) then forcedirectories(ipath);
except;end;
end;
//## setpath ##
procedure tvirtualanimationviewer.setpath(x:string);
var
   ok:boolean;
begin
try
//range
x:=asfolder(x);
ok:=true;
//filter
if ioRestrictSF and
   (comparetext(x,bvfportable(bvfAnimations))<>0) and
   (comparetext(x,bvfportable(bvfPictures))<>0) and
   (comparetext(x,bvfportable(bvfCursors))<>0) then
      begin
      x:=bvfportable(bvfAnimations);
      ok:=false;
      end;//end of if
//check
if ok and (comparetext(x,ipath)=0) and (ilastmask=mask) then exit;
//set
if (x<>'') and (not directoryexists(x)) then forcedirectories(x);
ipath:=x;
refreshlist;
except;end;
end;
//## getfilename ##
function tvirtualanimationviewer.getfilename:string;
begin
try
//defaults
result:='';
//get
if (ilist.itemindex>=1) then result:=ilist.items[ilist.itemindex];
except;end;
end;
//## setfilename ##
procedure tvirtualanimationviewer.setfilename(x:string);
begin
try;reload(x,false);except;end;
end;
//## acceptable ##
function tvirtualanimationviewer.acceptable(n:string):boolean;
begin
try
//defaults
result:=true;
//get
if assigned(onacceptable) then result:=onacceptable(self,n);
except;end;
end;
//## refreshlist ##
procedure tvirtualanimationviewer.refreshlist;
var
   a:tstringlist;
   _filename,z,v,tmp:string;
   len,p:integer;
begin
try
//defaults
len:=0;
tmp:='';
a:=nil;
_filename:=filename;
ilastmask:=mask;
//process
//.files (animations & pictures)
z:=general.files(ipath+cmAllFiles,false);
p:=1;
while general.nextline(p,z,v) do if (length(v)<=namelenlimit) and ccs.supportformatstr(v) and
   acceptable(v) and ((mask='') or general.inf(v,mask)) then pushb(len,tmp,v+rcode);
//.finalise
pushb(len,tmp,'');
a:=tstringlist.create;
a.text:=tmp;
a.sort;
//.set
ilist.text:=
'('+ntranslate('none')+')'+rcode+
a.text;
//.reset
if not ilist.locked then filename:=_filename;
//.sync
syncstatus;
except;end;
try;freeobj(@a);except;end;
end;
//## syncstatus ##
procedure tvirtualanimationviewer.syncstatus;
var
   f:string;
   p:integer;
begin
try
//get
f:=filename;
p:=ilist.itemindex+1;
//set
ifiles.caption:=tsFiles+general.insstr(' - '+general.thousands(p)+'. '+f,oShowfilename and (f<>''));
ipathlink.caption:=tsPath+': '+path;//03OCT2007
except;end;
end;
//## load ##
procedure tvirtualanimationviewer.load;
var
   z,e:string;
begin
try
//get
io.fromfile(path+filename,z,e);
//set
if (isysptr>vsNil) then vs.s[isysptr]:=path+filename;
iimage.animation:=z;
syncstatus;
//updatebuttons
updatebuttons;
//event
fireevent(onload,self);
except;end;
end;
//## reload ##
procedure tvirtualanimationviewer.reload(x:string;_update:boolean);
var
   p:integer;
   mustload:boolean;
begin
try
//range
if (x<>'') then x:=extractfilename(x);
if (comparetext(filename,x)=0) and (not _update) then exit;
//lock
if _update then
   begin
   ilist.lock;
   refreshlist;
   end;//end of if
//get
if (x='') then p:=0 else p:=ilist.findvalue(x);
//set
p:=frcmin(p,0);
mustload:=(ilist.itemindex<>0) and (ilist.itemindex=p);//if same index (rare fluke but does happen, then listbox will not "__onclick" so we must "load")
ilist.itemindex:=p;
ilist.topindex:=p;
if mustload then load;
except;end;
try;if _update then ilist.unlock;except;end;
end;
//## updatebuttons ##
procedure tvirtualanimationviewer.updatebuttons;
begin
try
ifolder.enabled:=(ipath<>'');
irefresh.enabled:=(ipath<>'');
except;end;
end;

//## tvirtualviewerhelp ########################################################
//## create ##
constructor tvirtualviewerhelp.create(_gui:tvirtualform);
begin
//self
inherited create(_gui);
//vars
textenhance:=true;
//links
ihtml:=cpanel.newlink(ntranslate('html'),tepWebPage14,rthtranslate('View html Help in default web browser'),__onclick2);
ihtml.hint:=ntranslate('html')+#32+translate('version of help');
itxt:=cpanel.newlink(ntranslate('text'),tepWebPage14,rthtranslate('View Plain Text Help in default text editor/viewer (*.txt)'),__onclick2);
itxt.hint:=ntranslate('text')+#32+translate('version of help');
ivisit.alignsep:=10;
//defaults
text:=misc.helpise(programhelp,false);
end;
//## __onclick ##
procedure tvirtualviewerhelp.__onclick2(sender:tobject);
begin
try
if (sender=ihtml) then pg.showhelp(false)
else if (sender=itxt) then pg.showhelp(true);
except;end;
end;

//## tvirtualviewertext ########################################################
//## create ##
constructor tvirtualviewertext.create(_gui:tvirtualform);
var
   tmp:string;
begin
//self
inherited create(_gui);
align:=valTop;
bordersize:=0;
//pages
createinit(false,false);
horizontal:=true;
percentage:=33;
//vars
iitemindex:=0;
//controls
iitems:=tdynamicstring.create;
//.topics
tmp:=rthtranslate('Highlight Topic to view');
pages[0].new('titlesmall',ntranslate('topics'),'',tmp,valTop,nil);
ilist:=pages[0].new('list','','',tmp,valTop,nil) as tvirtuallist;
ilist.tep:=tepBullet;
//.content
icpanel:=pages[1].new('titlesmall',ntranslate('content'),'',rthtranslate('Topic content view'),valTop,nil) as tvirtualtitle;
with icpanel do
begin
icopy:=newlink(ntranslate('copy'),tepCopy14,rthtranslate('Copy complete Topic to Clipboard as plain text'),__onclick);
ivisit:=newlink(ntranslate('visit'),tepVisit14,rthtranslate('Visit website or write an email'),__onclick);
end;//end of with
itext:=pages[1].new('textwrap','','',icpanel.help,valTop,nil) as tvirtualtextwrap;
itext.readonly:=true;
//.events
ilist.onitemindex:=_onitemindex;
//defaults
updatebuttons;
timer:=1000;
end;
//## destroy ##
destructor tvirtualviewertext.destroy;
begin
try
//self
inherited;
//controls
freeobj(@iitems);
except;end;
end;
//## _ontimer ##
procedure tvirtualviewertext._ontimer(sender:tobject);
begin
try
if (not gui.paintallowed) or (not showing) then exit;
updatebuttons;
except;end;
end;
//## updatebuttons ##
procedure tvirtualviewertext.updatebuttons;
begin
try
ivisit.enabled:=canvisit;
ivisit.hint:=geturl;
icopy.enabled:=(itext.count>=1);
except;end;
end;
//## geturl ##
function tvirtualviewertext.geturl:string;
var//Accepts: http://, https://, ftp:// and mailto:
   c,i,p:integer;
   v,z:string;
   ok:boolean;
begin
try
//defaults
result:='';
//process
//.get
p:=itext.itemindex;
if (p>=0) and (p<itext._wrap.count) then
   begin
   //.scan
   ok:=false;
   z:=itext._wrap.strings[p];
   for i:=1 to length(z) do if (comparetext(copy(z,i,7),'http://')=0) or (comparetext(copy(z,i,8),'https://')=0) or (comparetext(copy(z,i,6),'ftp://')=0) or (comparetext(copy(z,i,7),'mailto:')=0) then
      begin
      z:=copy(z,i,length(z));
      ok:=true;
      break;
      end;//end of if
   if not ok then exit;
   //.set
   inc(p);
   if (p<itext._wrap.count) then
      begin
      c:=0;
      repeat
      v:=itext._wrap.strings[p];
      if (v='') then
         begin
         z:=z+#32;//insert space (terminator for urls)
         break;
         end
      else z:=z+v;
      //.inc
      inc(c);
      inc(p);
      until (p>=itext._wrap.count) or (c>=20);//max of 20 lines to be appended
      end;//end of if
   //.find end (first space);
   for i:=1 to length(z) do if (z[i]=#32) then
      begin
      z:=copy(z,1,i);
      break;
      end;//end of if
   //return result
   result:=z;
   end;//end of if
except;end;
end;
//## canvisit ##
function tvirtualviewertext.canvisit:boolean;
begin
try;result:=(geturl<>'');except;end;
end;
//## visit ##
procedure tvirtualviewertext.visit;
begin
try;if canvisit then run(geturl,'');except;end;
end;
//## __onclick ##
procedure tvirtualviewertext.__onclick(sender:tobject);
begin
try
if (sender=ivisit) then visit
else if (sender=icopy) then clipboard.astext:=itext.text;
except;end;
end;
//## _onitemindex ##
procedure tvirtualviewertext._onitemindex(sender:tobject);
begin
try;itemindex:=ilist.itemindex;except;end;
end;
//## clear ##
procedure tvirtualviewertext.clear;
begin
try
iitems.clear;
ilist.items.clear;
itext.clear;
except;end;
end;
//## getcount ##
function tvirtualviewertext.getcount:integer;
begin
try;result:=iitems.count;except;end;
end;
//## setitemindex ##
procedure tvirtualviewertext.setitemindex(x:integer);
begin
try
//check
if ibusy then exit else ibusy:=true;
//range
x:=frcrange(x,0,count-1);
//set
ilist.itemindex:=x;
itext.vpos:=0;
itext.text:=iitems.value[x];
except;end;
try;ibusy:=false;except;end;
end;
//## settext ##
procedure tvirtualviewertext.settext(x:string);
var
   c,vlen,p:integer;
   v,z,n,ntmp:string;
   once,ok:boolean;
begin
try
//defaults
clear;
//process
//.get
n:='';
ntmp:='';
v:='';
vlen:=0;
p:=1;
c:=0;
once:=true;
while general.nextline(p,x,z) do
begin
if not once then
   begin
   ok:=true;
   //.detect end of topic
   if (z='') then
      begin
      inc(c);
      if (c>=2) then
         begin
         //.finalise
         pushb(vlen,v,'');
         if (length(v)<>0) and (length(ntmp)<>0) then
            begin
            iitems.value[iitems.count]:=v;
            n:=n+ntmp+rcode;
            end;//end of if
         //.reset
         v:='';
         vlen:=0;
         ntmp:='';
         c:=0;
         ok:=false;
         end;//end of if
      end;//end of if
   //.add to current topic's content
   if ok then
      begin
      if (z<>'') then c:=0;
      if (vlen=0) and (ntmp='') then
         begin
         ntmp:=z;
         if textenhance then z:=uppercase(z)+rcode;
         end;//end of if
      pushb(vlen,v,z+rcode);
      end;//end of if
   end;//end of if
//.skip over "title of program and 1st blank line"
if once and (z='') then once:=false;
end;//end of loop
//.finalise
pushb(vlen,v,'');
if (length(v)<>0) and (length(ntmp)<>0) then
   begin
   iitems.value[iitems.count]:=v;
   n:=n+ntmp+rcode;
   end;//end of if
//.set
ilist.text:=n;
itemindex:=0;
except;end;
end;
//## gettext ##
function tvirtualviewertext.gettext:string;
var
   len,p:integer;
begin
try
//defaults
result:='';
len:=0;
//process
//.get
for p:=0 to (iitems.count-1) do pushb(len,result,iitems.value[p]+rcode+rcode);
//.finalise
pushb(len,result,'');
except;end;
end;

//## tvirtualsysinfo ###########################################################
//## create ##
constructor tvirtualsysinfo.create(_gui:tvirtualform);
const
   sp=5;
var
   pagetmp:tvirtualpage;
   p2,p,pageID:integer;
   _help  :array[0..vsiMax] of string;
   _tabs  :array[0..vsiMax] of string;
   _ptype :array[0..vsiMax] of tvirtualpagestyle;
   tmp:array[0..6] of string;
   title:tvirtualtitle;
   g:tvirtualgrid;
   tmph,hlist,hack,h1,_label,_foldername,_realtimehelp,uhelp1,uhelp2,ulc,ulcpurchase:string;
begin
//self
inherited create(_gui);
bordersize:=0;
oVariableHeight:=true;
//vars
networkmonitorCat:=programcategoryHARD;//use program category by default
nmRESET;
for p:=0 to high(icfpath) do
begin
icfpath[p]:='';
icflink[p]:=nil;
end;//end of loop
//.filesize
ifilesize:=filesize(application.exename);
iclENG:=(uppercase(multilingual.caption)='ENGLISH');
ulc:=ntranslate(ecap('64M2@2-9I74G',false));//ntranslate('unlock / modify license') - spider bait
ulcpurchase:=ntranslate(ecap('23??B/1(=M;@R',false));//ntranslate('purchase license') - spider bait
uhelp1:=rthtranslate('Unlock Program from License Information within Clipboard');
uhelp2:=rthtranslate('Visit online product order page to license');
//.caps
for p:=0 to high(idelay) do idelay[p]:=5000;
icaps[vsiTools]:=ntranslate('tools');
icaps[vsiFolders]:=ntranslate('folders');
icaps[vsiProgram]:=tsProgram;
icaps[vsiSystem]:=tsSystem;
icaps[vsiRemote]:=ntranslate('remote');
icaps[vsiTranslation]:=ntranslate('translation');
icaps[vsiEULA]:=ntranslate('license');
icaps[vsiHelp]:=ntranslate('help');
icaps[vsiConnections]:=ntranslate('connections');
icaps[vsiTraffic]:=ntranslate('traffic');
icaps[vsiCodes]:=tsCodes;
//.help
_help[vsiTools]:=rthtranslate('Program specific tools');
_help[vsiFolders]:=rthtranslate('Blaiz Enterprises'' Program/host common Folders');
_help[vsiProgram]:=rthtranslate('Program specific information');
_help[vsiSystem]:=rthtranslate('System specific status/information');
_help[vsiRemote]:=rthtranslate('Remote management settings');
_help[vsiTranslation]:=rthtranslate('Custom/Primary Translation options. Create custom Program specific translation and/or use predefined translation (primary)');
_help[vsiEULA]:=rthtranslate('Program End User License Agreement "EULA"');
_help[vsiHelp]:=rthtranslate('Built-in, easy to use, Help viewer');
_help[vsiCodes]:=rthtranslate('View server/client status codes');
_help[vsiConnections]:=rthtranslate('Realtime server connections (connected clients) overview');
_help[vsiTraffic]:=rthtranslate('Realtime 24 hour client history/status overview');
//.tabs
_tabs[vsiTools]:=tabsLL;
_tabs[vsiFolders]:='';
_tabs[vsiProgram]:=tabsLL;
_tabs[vsiSystem]:=tabsLL;
_tabs[vsiRemote]:='';
_tabs[vsiTranslation]:=tabsLL;
_tabs[vsiEULA]:='';
_tabs[vsiHelp]:='';
_tabs[vsiCodes]:=tabsLL;
_tabs[vsiConnections]:='TABS:S10,L0,R100,R200,R300,L360,L460,L510';
_tabs[vsiTraffic]:='TABS:S10,L0,R100,R230,R400,R560,L630';
//.static
istatic[vsiTools]:=true;
istatic[vsiFolders]:=false;
istatic[vsiProgram]:=false;
istatic[vsiSystem]:=false;
istatic[vsiRemote]:=false;
istatic[vsiTranslation]:=false;
istatic[vsiEULA]:=true;
istatic[vsiHelp]:=true;
istatic[vsiCodes]:=true;
istatic[vsiConnections]:=false;
istatic[vsiTraffic]:=false;
//._pstype
_ptype[vsiTools]:=vpsScrolling;
_ptype[vsiFolders]:=vpsScrolling;
_ptype[vsiProgram]:=vpsNormal;
_ptype[vsiSystem]:=vpsNormal;
_ptype[vsiRemote]:=vpsVSplit;
_ptype[vsiTranslation]:=vpsNormal;
_ptype[vsiEULA]:=vpsNormal;
_ptype[vsiHelp]:=vpsNormal;
_ptype[vsiCodes]:=vpsNormal;
_ptype[vsiConnections]:=vpsNormal;
_ptype[vsiTraffic]:=vpsNormal;
//.delay
idelay[vsiConnections]:=1000;//once per second
idelay[vsiTranslation]:=2000;
idelay[vsiRemote]:=2000;
//controls
//.pages
ipages:=tvirtualpages.create(gui);
ipages.setup(self);
ipages.oseptop:=false;
ipages.aslinks;
//.sub-pages
for p:=0 to high(iobjs) do
begin
pagetmp:=ipages.newpage(icaps[p],general.aorbstr(tepWebPage20,tepHelp20,p=vsiHelp),_help[p],_ptype[p],pageID) as tvirtualpage;
with pagetmp do
begin
//..title
if (p<>vsiTools) and (p<>vsiRemote) and (p<>vsiTranslation) and (p<>vsiFolders) and (p<>vsiHelp) then title:=(new('titlesmall',icaps[p],'',_help[p],valTop,nil) as tvirtualtitle) else title:=nil;
//..content
case p of
vsiProgram,vsiSystem,vsiCodes,vsiConnections,vsiTraffic:begin
   case p of
   vsiConnections:begin
      title.caption:=tsType+#9+tsSent+#9+tsRecv+#9+tsIdle+#9+tsResource+#9+tsID+#9+tsUrl;
      title.tabs:=_tabs[p];
      end;//end of begin
   vsiTraffic:begin
      title.caption:=tsIP+#9+tsErrors+'/'+tsHits+#9+tsBandwidth+#9+tsTime+#9+tsState;
      title.tabs:=_tabs[p];
      end;//end of begin
   end;//end of case
   iobjs[p]:=new('list','','',_help[p],valTop,nil) as tvirtuallist;
   with iobjs[p] as tvirtuallist do
   begin
   tabs:=_tabs[p];
   tag:=p;
   readonly:=true;
   oShowmenu:=true;
   multiselect:=true;
   end;//end of with
   end;//end of begin
vsiRemote:begin
   with (pagetmp as tvirtualpagevsplit) do
   begin
   createinit(true,false);
   horizontal:=false;
   fillbar;
    with pages[0].client do
    begin
    with new('titlegrid',ntranslate('network monitor'),'',rthtranslate('Network Monitor settings'),valTop,nil) as tvirtualgrid do
    begin
    inmwebsite:=newlink(ntranslate('website'),tepWeb20,rthtranslate('Visit Network Monitor Server online product page for more information and download'),__onclick);
    inmview:=newlink(ntranslate('web panel'),tepHome20,rthtranslate('View your Network Monitor''s Web Panel'),__onclick);
    end;//end of with
    newb('tick',translate('Enable network monitoring'),'',rthtranslate('Bullet: Send program health and status information to your local (intranet) Network Monitor Server'),valTop,nil,vsUseNM,sgsBoolean,'','');//use system default
    newb('droplist',translate('Local (intranet) IP address of Network Monitor'),';127.0.0.1;10.0.0.1;10.0.0.2;10.0.0.3;10.1.1.1;10.1.1.2;10.1.1.3',rthtranslate('Specify a local (intranet) IP address of your Network Monitor Server'),valTop,nil,vsNMIP,sgsString,'','');//use system default
    end;//end of with
   end;//end of with
   end;//end of begin
vsiTranslation:begin
   //hide this tab when program is "Select Language"
   if (comparetext(programnameHARD,'select language')=0) and (pagetmp.button<>nil) then pagetmp.button.visible:=false;
   //init
   h1:=rthtranslate('"Realtime Help" translations implement immediately. "GUI/Error" translations require Program restart');
   hlist:=rthtranslate('Translation overview/statistics');
   hack:=rthtranslate('Author translation accreditation/information');
   isuptransid:=-1;
   tmph:=rthtranslate('Program specific, user customisable translation');
   //CUSTOM
   with client.pagetabs.newpagevsplit(ntranslate('custom translation'),tepWebPage20,tmph,false,false,false) as tvirtualpagevsplit do
   begin
   percentage:=75;
   isuptransbutton:=button;
   isuptransbutton.oAllowBlack:=true;//allow image to retain black pixels
   with pages[0].client do
   begin
    with new('titlegrid',ntranslate('custom translation'),'',tmph,valTop,nil) as tvirtualgrid do
    begin
    icleartransup:=newlink(ntranslate('clear'),tepClear20,rthtranslate('Restore "Custom Translation" defaults')+rcode+h1,__onclick);
    ipastetransup:=newlink(ntranslate('paste'),tepPaste20,rthtranslate('Paste Custom Translation from Clipboard')+rcode+h1,__onclick);
    icopytransup:=newlink(ntranslate('copy'),tepCopy20,rthtranslate('Copy Custom Translation to Clipboard'),__onclick);
    end;//end of with
    itranslist2:=new('list','','',hlist,valTop,nil) as tvirtuallist;
    with itranslist2 do
    begin
    tabs:=_tabs[p];
    tag:=p;
    readonly:=true;
    oShowmenu:=true;
    multiselect:=true;
    oHeight:=vhsHeight;
    height:=270;
    end;//end of with
   end;//end of with

   with pages[1].client do
   begin
    itranstextwrap2:=new('textwrap',ntranslate('acknowledgement'),'',hack,valTop,nil) as tvirtualtextwrap;
    with itranstextwrap2 do
    begin
    readonly:=true;
    oShowmenu:=true;
    oVariableheight:=true;
    end;//end of with
   end;//end of with
   end;//end of with

   //PRIMARY
   tmph:=rthtranslate('Predefined "Select Language" translation - used by all Blaiz Enterprises'' programs');
   with client.pagetabs.newpagevsplit(ntranslate('primary translation'),general.udv(multilingual.tep,tepEnglish),tmph,false,false,false) as tvirtualpagevsplit do
   begin
   percentage:=75;
   button.oAllowBlack:=true;//allow image to retain black pixels
   with pages[0].client do
   begin
    with new('titlegrid',ntranslate('primary translation'),'',tmph,valTop,nil) as tvirtualgrid do
    begin
    iSLinfo:=newlink(ntranslate('more information'),tepWebPage20,rthtranslate('View "Select Language" website in default browser - http://www.blaizenterprises.com/sl.html'),__onclick);
    iSLtrans:=newlink(ntranslate('change language'),tepSL20,rthtranslate('View "Select Language" Program. Highlight desired language and close SL. Restart current Program to implement changes'),__onclick);
    iSLtrans.enabled:=false;//disabled by default
    end;//end of with
    itranslist1:=new('list','','',hlist,valTop,nil) as tvirtuallist;
    with itranslist1 do
    begin
    tabs:=_tabs[p];
    tag:=p;
    readonly:=true;
    oShowmenu:=true;
    multiselect:=true;
    oHeight:=vhsHeight;
    height:=270;
    end;//end of with
   end;//end of with

   with pages[1].client do
   begin
    itranstextwrap1:=new('textwrap',ntranslate('acknowledgement'),'',hack,valTop,nil) as tvirtualtextwrap;
    with itranstextwrap1 do
    begin
    readonly:=true;
    oShowmenu:=true;
    oVariableheight:=true;
    end;//end of with
   end;//end of with
   end;//end of with
   end;//end of begin
vsiEULA:begin

   iobjs[p]:=new('textwrap','','',_help[p],valTop,nil) as tvirtualtextwrap;
   with iobjs[p] as tvirtualtextwrap do
   begin
   tabs:=_tabs[p];
   tag:=p;
   readonly:=true;
   oShowmenu:=true;
   end;//end of with

   end;//end of begin
vsiHelp:if pg.canhelp then with tvirtualviewerhelp.create(gui) do setup(pagetmp);
vsiTools:begin//tools
   with (pagetmp as tvirtualpagescroll).client do
   begin
{
   //.RAWGRUNT
   with new('titlesmall','RawGrunt.com - '+ntranslate('Blaiz Enterprises'),'',rthtranslate('Blaiz Enterprises'' RawGrunt Internet Search Engine - http://www.rawgrunt.com'),valTop,nil) as tvirtualtitle do
   begin
   iaddurl:=newlink(ntranslate('Add Url'),tepPlusSign14,rthtranslate('View RawGrunt''s free "Add Url" submission page'), __onclick);
   isearch:=newlink(ntranslate('Search'),tepSearch14,rthtranslate('View RawGrunt''s "Search" page'),__onclick);
   end;//end of with
   new('label',translate('Internet Search'),'','',valTop,nil);
   with new('webedit',ecap('0?.4#?AFC6``fWq',false),tepRawGruntSearch20,'',valTop,nil) as tvirtualwebedit do
   begin
   edit.help:=rthtranslate('Type search query and click "Send" or "Enter" key');
   send.help:=rthtranslate('Perform Search');
   end;//end of with
}
   //.HELP
   new('titlesmall',ntranslate('help'),'',rthtranslate('Program Help and information'),valTop,nil);//12aug2025: removed vertical sep/gap
   g:=new('grid','','','',valTop,nil) as tvirtualgrid;
   with g do
   begin
   alignmargin:=5;
   bordersize:=0;
   if pg.canhelp then
      begin
      ihelphtml:=new('button',ntranslate('help'),tepHelp20,rthtranslate('View html Help in default web browser'),valleft,__onclick);
      ihelptext:=new('button',ntranslate('plain text help'),tepHelp20,rthtranslate('View Plain Text Help in default text editor/viewer (*.txt)'),valleft,__onclick);
      end;//end of if
   iabout:=new('button',ntranslate('about'),tepInfo20,rthtranslate('View About Window'),valleft,__onclick);
   if programshowunlock then
      begin
      ipurchase:=new('button',ulcpurchase,tepWebPage20,uhelp2,valleft,__onclick);
      iunlock:=new('button',ulc,tepUnlock20,uhelp1,valleft,__onclick);
      end;//end of if
   end;//end of with
   //.INTERNET
   new('titlesmall',ntranslate('internet'),'',rthtranslate('Blaiz Enterprises/Program specific websites'),valTop,nil).valignsep:=sp;
   g:=new('grid','','','',valTop,nil) as tvirtualgrid;
   with g do
   begin
   alignmargin:=5;
   bordersize:=0;
   ihomepage:=new('button',ntranslate(ProgramnameHARD)+#32+ntranslate('homepage'),tepWebPage20,rthtranslate('Visit Program website'),valleft,__onclick);
//   ifreesoftware:=new('button',ntranslate('free software homepage'),tepWebPage20,rthtranslate('Visit Free Software website'),valleft,__onclick);
   iblaiznet:=new('button',ntranslate('visit blaiz enterprises'),tepBlaiznet20,rthtranslate('Visit Blaiz Enterprises'' Portal http://www.blaizenterprises.com'),valleft,__onclick);
//   icontact:=new('button',ntranslate('contact us'),tepWebPage20,rthtranslate('View Blaiz Enterprises'' Contact page'),valleft,__onclick);
   end;//end of with
   //.WINDOW
   new('titlesmall',ntranslate('window'),'',rthtranslate('Window options'),valTop,nil).valignsep:=sp;
   g:=new('grid','','','',valTop,nil) as tvirtualgrid;
   with g do
   begin
   alignmargin:=5;
   bordersize:=0;
   icenter:=new('button',ntranslate('center'),tepCenter20,rthtranslate('Center Window in work area'),valleft,__onclick);
   ienlarge:=new('button',ntranslate('enlarge'),tepEnlarge20,rthtranslate('Increase Window width/height'),valleft,__onclick);
   ishrink:=new('button',ntranslate('shrink'),tepShrink20,rthtranslate('Decrease Window width/height'),valleft,__onclick);
   isizetooriginal:=new('button',ntranslate('original'),tepSizeTo20,rthtranslate('Restore original Window width/height'),valleft,__onclick);
   isizeto800x600:=new('button','800x600',tepSizeTo20,rthtranslate('Size Window to 800x600'),valleft,__onclick);
   isizeto640x480:=new('button','640x480',tepSizeTo20,rthtranslate('Size Window to 640x480'),valleft,__onclick);
   isizeto580x560:=new('button','580x560',tepSizeTo20,rthtranslate('Size Window to 580x560'),valleft,__onclick);
   isizeto400x400:=new('button','400x400',tepSizeTo20,rthtranslate('Size Window to 400x400'),valleft,__onclick);
   end;//end of with
   //.PROGRAM
   new('titlesmall',ntranslate('program'),'',rthtranslate('Program options'),valTop,nil).valignsep:=sp;
   g:=new('grid','','','',valTop,nil) as tvirtualgrid;
   with g do
   begin
   alignmargin:=5;
   bordersize:=0;
   if not programonecopy then inewinstance:=new('button',ntranslate('new instance'),tepNew20,rthtranslate('Run another copy of Program'),valleft,__onclick);
   iclose:=new('button',ntranslate('close'),tepClose20,rthtranslate('Shutdown Program'),valleft,__onclick);
   //..clone
   if pg.canclone then
      begin
      iclone:=new('button',ntranslate('clone...'),tepClone20,rthtranslate('Create duplicate Program copy (clone). Clone has same options/settings/appearance until further identity personalisation'),valleft,__onclick);
      iclone.enabled:=programreadwrite;//12JAN2008
      end;//end ofif
   //..delete
{
   if pg.candelete then
      begin
      //.space
      if (iclone<>nil) then iclone.alignsep:=10
      else if (iclose<>nil) then iclose.alignsep:=10;
      //.get
      idelete:=new('button',ntranslate('delete program')+'...',tepWarning20,
       rthtranslate(
        'Permanently delete Program and directly associated files from host computer (Start button) or storage device (Portable mode).'+
        ' Note: Blaiz Enterprises'' Delete Program "blaizdel.exe" (~18K), tasked with removal of selected Program, is written to Windows Temp Folder to be removed by operating system'
        )
       ,valleft,__onclick);
      idelete.enabled:=programreadwrite;//12JAN2008
      end;//end of if
}
   end;//end of with
   end;//end of with
   end;//end of begin
vsiFolders:begin//folders - 12aug2025
   iobjs[p]:=(pagetmp as tvirtualpagescroll);
   iobjs[p].tag:=p;
   with (pagetmp as tvirtualpagescroll) do//.client do
   begin
   //init
   //.system
   tmp[0]:=rthtranslate('View Folder - Blaiz Enterprises'' infrastructure Folder. Storage/coordination/maintenance of all Programs');
   //.category
   tmp[1]:=rthtranslate('View Folder - Program specific category Folder. Similar Programs are grouped in shared Folders e.g. "Image Tools" for graphics tools');
   //.files
   tmp[2]:=rthtranslate('View Folder - Categorised data Folders. Share animation, picture, music files etc between Programs.');
   //.logs
   tmp[3]:=rthtranslate('View Folder - Central logs storage');
   //.settings
   tmp[4]:=rthtranslate('View Folder - Central settings storage');
   //.temp
   tmp[5]:=rthtranslate('View Folder - Temporary file storage');
   //.file clipboard
   tmp[6]:=rthtranslate('View Folder - File based Clipboard');
   //program
   new('titlesmall',ntranslate('program system folders'),'',rthtranslate('Common Program Folders'),valTop,nil);
   newcflink(client,ntranslate('system'),tmp[0],bvfportableex('',false));
   newcflink(client,ntranslate('category'),tmp[1],exeCategory);
   newcflink(client,ntranslate('files'),tmp[2],bvfportableex(bvfFiles,false));
   newcflink(client,ntranslate('logs'),tmp[3],bvfportableex(bvfLogs,false));
   newcflink(client,ntranslate('settings'),tmp[4],bvfportableex(bvfSettings,false));
   newcflink(client,ntranslate('clipboard'),tmp[6],bvfportableex(bvfClipboard,false));
   newcflink(client,ntranslate('temp'),tmp[5],bvfportableex(bvfTemp,false));
   new('titlesmall',ntranslate('program support folders'),'',rthtranslate('Common Program Support Folders'),valTop,nil).valignsep:=2;
   //.support folders
   for p2:=0 to (misc.supportcount-1) do if misc.supportinfo(p2,_label,_foldername,_realtimehelp) then newcflink(client,_label,_realtimehelp,bvfportableex(_foldername,false));
   //.options
   new('titlesmall',ntranslate('options'),'',rthtranslate('Support Folder options'),valTop,nil).valignsep:=2;
   iextractsupportfiles:=newtlink(client,ntranslate('extract support files'),tepSaveAs20,rthtranslate('Unpack support files (schemes, cursors etc) to Support Folders. Automatically performed during Program''s initial run'));
   end;//with
   end;//begin
end;//case
end;//with
end;//loop

//.links
with ipages.tabs do
begin
icopy:=newlink(ntranslate('copy'),tepCopy20,rthtranslate('Copy panel information to Clipboard as plain text'),__onclick);
icopy.align:=valLeft;
end;//end of with

//special
//.help
if not pg.canhelp then
   with ipages.pages[vsiHelp] as tvirtualpage do
   begin
   visible:=false;
   button.visible:=false;
   end;//end of with
//.network codes
if not programnetworkenabled then
   begin
   //.network
   with ipages.pages[vsiConnections] as tvirtualpage do
   begin
   visible:=false;
   button.visible:=false;
   end;//end of with
   //.network hits
   with ipages.pages[vsiTraffic] as tvirtualpage do
   begin
   visible:=false;
   button.visible:=false;
   end;//end of with
   end;//end of if
//.network codes
if (not programnetworkenabled) or (not programnetworkcodes) then
   begin
   with ipages.pages[vsiCodes] as tvirtualpage do
   begin
   visible:=false;
   button.visible:=false;
   end;//end of with
   end;//end of if
//events
ipages.onpage:=_onpage;
//timer
timer:=idelay[vsiSystem];
//defaults
buildall(true);
end;
//## destroy ##
destructor tvirtualsysinfo.destroy;
begin
try
//init
destroyinit;
destroychildren;
//controls
freeobj(@inmserver);
//self
inherited;
except;end;
end;
//## readwrite ##
procedure tvirtualsysinfo.readwrite(mode:tvirtualstoragemode);
var
   z:integer;
begin
try
case mode of
vsmReadfromcontrols:;
vsmWritetocontrols:;
vsmUpdatecontrols:begin
   //network monitor - use only "private IP address"
   z:=0;
   if vs.b[vsUseNM] then
      begin
      z:=_intip(vs.s[vsNMIP]);
      if not misc.ipprivate(z) then z:=0;
      end;//end of if
   inmip:=z;
   //.server
   case (z<>0) of
   true:if (inmserver=nil) then
      begin
      inmserver:=tudpbasic.create;
      with (inmserver as tudpbasic) do
      begin
      limits:=100;//set all 4 limits at once
      throttle:=5000;//dialup throttle
      ports:=portrange(18010,19999);//ports 18,000...18,009 are reserved for Network Monitor itself
      end;//end of with
      end;//end of if
   false:freeobj(@inmserver)
   end;//end of case
   end;//end of begin
end;//end of case
except;end;
end;
//## newcflink ##
procedure tvirtualsysinfo.newcflink(_parent:tvirtualcontrol;_label,_help,_path:string);
var
   p:integer;
begin
try
//check
if (icfcount>high(icfpath)) or (_parent=nil) or (_path='') then exit;
//init
_path:=asfolder(_path);
p:=icfcount;
inc(icfcount);
//get
icflink[p]:=_parent.newlink(_label,tepFolder16,_help,__oncf);
icflink[p].align:=valTop;
icflink[p].tag:=p;
icfpath[p]:=_path;
except;end;
end;
//## newtlink ##
function tvirtualsysinfo.newtlink(_parent:tvirtualcontrol;_label,_tep,_help:string):tvirtuallink;
begin
try
//defaults
result:=nil;
if (_parent=nil) then exit;
//check
result:=_parent.newlink(_label,_tep,_help,__onclick);
result.align:=valTop;
except;end;
end;
//## setcaption ##
procedure tvirtualsysinfo.setcaption(x:string);
begin
try;ipages.tabs.caption:=x;except;end;
end;
//## getcaption ##
function tvirtualsysinfo.getcaption:string;
begin
try;result:=ipages.tabs.caption;except;end;
end;
//## updatebuttons ##
procedure tvirtualsysinfo.updatebuttons;
begin
try
icopy.enabled:=(page>=0) and (iobjs[page]<>nil) and (iobjs[page].tag<>vsiFolders);
inmview.enabled:=(inmip<>0);
except;end;
end;
//## nmRESET ##
procedure tvirtualsysinfo.nmRESET;//20FEB2008
begin             //4min+random range of 0..1min (so 4min to 5min randomly)
try;inmtime:=ms64+240000+random(60000);except;end;
end;
//## nmSEND ##
procedure tvirtualsysinfo.nmSEND;//21FEB2008
var
   z503:string;
begin
try
//check
if (inmip=0) or (inmserver=nil) then exit;
//get
z503:=
'NM/1.0'+rcode+//Network Monitor header - required
'style: alive'+rcode+//inform Network Monitor packet is an "alive" packet
'name: '+programnameHARD+rcode+
'ver: '+programversion+rcode+
'cat: '+networkmonitorCat+rcode+//09MAR2008
'boot: '+dates.shortdatetimeb(systemboottime,true,true)+rcode+
'uptime: '+dates.uptime(ms64-systemboot,true,#32)+rcode+
'portable: '+bn(programportablepath<>'')+rcode+
'cloned: '+bn(programclonename<>'')+rcode+
'licensed: 0'+rcode+//0=no, 1=yes, nil=N/A
'hits: '+floattostr(networkmonitorHits)+rcode+
'bandwidth: '+floattostr(networkmonitorBandwidth)+rcode+
'view: '+networkmonitorView+rcode+
'admin: '+networkmonitorAdmin+rcode+
'comment: '+networkmonitorComment+rcode;
//set
if (inmip<>0) and (inmserver<>nil) and (inmserver is tudpbasic) then (inmserver as tudpbasic).rsend(inmip,18000,0,z503);
except;end;
end;
//## _ontimer ##
procedure tvirtualsysinfo._ontimer(sender:tobject);
begin
try
//build all
buildall(false);
//network monitor
if (inmtime<=ms64) then
   begin
   nmSEND;
   nmRESET;
   end;//end of if
except;end;
end;
//## _onpage ##
procedure tvirtualsysinfo._onpage(sender:tobject);
begin
try
timer:=idelay[frcmin(page,0)];
updatebuttons;
except;end;
end;
//## getpage ##
function tvirtualsysinfo.getpage:integer;
begin
try;result:=ipages.page;except;end;
end;
//## setpage ##
procedure tvirtualsysinfo.setpage(x:integer);
begin
try;ipages.page:=x;except;end;
end;
//## gettext ##
function tvirtualsysinfo.gettext(p:integer):string;
begin
try
//defaults
result:='';
//get
if (p>=0) and (p<=high(iobjs)) and (iobjs[p]<>nil) then
   begin
   if (iobjs[p] is tvirtuallist) then result:=(iobjs[p] as tvirtuallist).text
   else if (iobjs[p] is tvirtualbasetext) then result:=(iobjs[p] as tvirtualbasetext).text;
   end;//end of if
except;end;
end;
//## settext ##
procedure tvirtualsysinfo.settext(p:integer;y:string);
begin
try
//get
if (p>=0) and (p<=high(iobjs)) and (iobjs[p]<>nil) then
   begin
   if (iobjs[p] is tvirtuallist) then (iobjs[p] as tvirtuallist).text:=y
   else if (iobjs[p] is tvirtualbasetext) then (iobjs[p] as tvirtualbasetext).text:=y;
   end;//end of if
except;end;
end;
//## __oncf ##
procedure tvirtualsysinfo.__oncf(sender:tobject);
var
   p:integer;
   f:string;
begin
try
//check
if (sender=nil) or (not (sender is tvirtualcontrol)) then exit;
//get
p:=(sender as tvirtualcontrol).tag;
if (p<0) or (p>=icfcount) then exit;
//set
f:=icfpath[p];
if (f<>'') and directoryexists(f) then run(f,'');
except;end;
end;
//## __onclick ##
procedure tvirtualsysinfo.__onclick(sender:tobject);
var
   w,h,c:integer;
   tmp,e:string;
begin
try
//check
if (sender=nil) or (not (sender is tvirtualcontrol)) then exit;
//actions
//.network monitor
if (sender=inmview) then
   begin
   if (inmip<>0) then run('http://'+_strip(inmip)+':18000','');
   end
else if (sender=inmwebsite) then run('http://www.blaizenterprises.com/nms.html','')
//.copy
else if (sender=icopy) and (page>=0) then clipboard.astext:=childrenastext//12FEB2007
//.transup
else if (sender=iSLtrans) then
   begin
   if bvfFindtoolex('select language',tmp,false) then bvfRuntoolex('select language','',false);
   end
else if (sender=iSLinfo) then run('http://www.blaizenterprises.com/SL.HTM','')
else if (sender=icopytransup) then clipboard.astext:=st.text
else if (sender=icleartransup) then
   begin
   //prompt
   if showquery60(ntranslate('clear custom translation')+'?') then
      begin
      //reset
      multilingual.clearlast;
      //get
      st.flush;
      //set
      vs.s[vsSuptrans]:='';
      vs.writetocontrols;
      end;//end of if
   end
else if (sender=ipastetransup) then
   begin
   //prompt
   if clipboard.hasformat(cf_text) and showquery60(ntranslate('replace custom translation')+'?') then
      begin
      //reset
      multilingual.clearlast;
      //get
      st.text:=clipboard.astext;//auto. apply internally
      //set
      vs.s[vsSuptrans]:=st.text;
      vs.writetocontrols;
      end;//end of if
   end
//.tools
else if (sender=isearch) then rawgruntsite
else if (sender=iaddurl) then rawgruntaddurl
else if (sender=iabout) then splash.about
//else if (sender=ipurchase) or (sender=ipurchaseLINK) then run(ecap('(G984=,"+5+KAb^a',false)+uppercase(webname)+'.HTM#buy','')//Example: "http://www.blaiz.net/AV.HTM#buy"
else if (sender=ihelphtml) then pg.showhelp(false)
else if (sender=ihelptext) then pg.showhelp(true)
else if (sender=iextractsupportfiles) then pg.usprompt(true)
else if (sender=ihomepage) then programsite
else if (sender=ifreesoftware) then freesite
else if (sender=iblaiznet) then blaizsite
else if (sender=icenter) then gui.center
else if (sender=icontact) then blaizcontact
else if (sender=inewinstance) then run(application.exename,'')
else if (sender=iclose) then
   begin
   if (sysstate=ssOK) and appprompt then siClose;
   end
else if (sender=iclone) then pg.clone
else if (sender=idelete) then pg.delete
else if (sender=ishrink) then gui.enlarge(-50,-50)
else if (sender=ienlarge) then gui.enlarge(50,50)
else if (sender=isizetooriginal) then gui.sizeto(mainformwidth,mainformheight)
else if (sender=isizeto800x600) then gui.sizeto(800,600)
else if (sender=isizeto640x480) then gui.sizeto(640,480)
else if (sender=isizeto580x560) then gui.sizeto(580,560)
else if (sender=isizeto400x400) then gui.sizeto(400,400);
except;showerror60(ntranslate(gecTaskFailed));end;
end;
//## buildall ##
procedure tvirtualsysinfo.buildall(init:boolean);
var
   p:integer;
   tmp:string;
begin
try
//fill
for p:=0 to high(iobjs) do if init or (not istatic[p]) then
   begin
   tmp:=buildtext(iobjs[p],p);
   if (iobjs[p]<>nil) then text[p]:=tmp;
   end;//end of if
//updatebuttons
updatebuttons;
except;end;
end;
//## buildtext ##
function tvirtualsysinfo.buildtext(x:tvirtualcontrol;xtag:integer):string;
const
   sep=rcode;
   ma='-- ';
   mb=' --';
var
   z,tmp,lt:string;
   len,p:integer;
begin
try
//defaults
result:='';
//check
if (x<>nil) then xtag:=x.tag;
//process
case xtag of
vsiTranslation:begin
   result:='';
   //primary
   itranslist1.text:=multilingual.stats(true,#9,rcode);
   itranstextwrap1.text:=multilingual.details;
   iSLtrans.enabled:=programreadwrite and bvfFindtoolex('select language',tmp,false);//local/portable copy only - if portable, then don't use host version as it will not have any impact on us as we are portable
   //custom
   itranslist2.text:=st.stats(true,#9,rcode);
   itranstextwrap2.text:=st.details;
   //info
   if (isuptransid<>st.id) then
      begin
      isuptransid:=st.id;
      if (isuptransbutton<>nil) then
         begin
         isuptransbutton.animation:=general.udv(st.tep,tepEnglish);
         if ipages.showing then ipages.realign(true);
         end;//end of if
      end;//end of if
   end;//end of begin
vsiProgram:begin//program
   result:=result+
   //.program
   ma+tsProgram+mb+#9+sep+
   tsName                  +#9+programnameHARD+sep+
   tsVersion               +#9+'v'+programversion+sep+
   general.insstr(tsDescription           +#9+programdescription+sep,programdescription<>'')+
   tsCategory              +#9+programcategoryHARD+sep+
   tsCustomLanguage        +#9+ntranslate(st.language)+sep+
   tsPrimaryLanguage       +#9+ntranslate(multilingual.caption)+sep+
   tsBuiltinHelp           +#9+misc.yest(programhelp<>'')+sep+
   tsSize                  +#9+general.thousands(ifilesize)+#32+lowercase(tsbytes)+sep+
//   tsSecurity              +#9+tsAntitamperDetection+sep+
   general.insstr(tsEncryption+#9+programencryption+sep,programencryption<>'')+
   tsPublisher             +#9+'http://www.blaizenterprises.com'+sep+
   //.instance
   sep+
   ma+tsInstance+mb+#9+sep+
   tsName                  +#9+extractfilename(application.exename)+sep+
   general.insstr(tsCloned+#9+misc.yest(programclonename<>'')+sep,programrename)+
   tsPortable              +#9+misc.yest(programportablepath<>'')+sep+
   tsSystemFolder          +#9+bvfportable('')+sep+
   tsDiskAccess            +#9+general.aorbstr(tsReadOnly,tsReadWrite,programreadwrite)+sep+
   //.license
   sep+
   ma+tsLicense+mb+#9+sep+
   tsClassification        +#9+programclassification+sep+
   tsLicense               +#9+'MIT License'+sep+
   //.infrastructure
   sep+
   ma+tsInfrastructure+' - V.U.N.'+mb+#9+sep+
   systemversions;
   end;//end of begin
vsiSystem:begin//system
   result:=result+
   //.time
   ma+tsSystem+mb+#9+sep+
   tsBoot+#32+tsTime+#9+dates.shortdatetimeb(systemboottime,true,true)+sep+
   tsUp+#32+tsTime+#9+dates.uptime(ms64-systemboot,true,#32)+sep+
   tsIdle+#32+tsTime+#9+dates.uptime(systemidletime,true,#32)+sep+
   tsThreads+#9+general.thousands(threadcount+1)+sep+
   tsVirtual+#32+tsThreads+#9+general.thousands(programactive)+'/'+general.thousands(programcount)+sep+
   tsVirtual+#32+tsInstructionsExecuted+#9+general.curcomma(programinstructioncount)+sep+
   tsVirtual+#32+tsImages+#9+general.curcomma(virtualimages)+sep+
   tsVirtual+#32+tsAnimations+#9+general.curcomma(virtualanimations)+sep+
   tsVirtual+#32+tsClicks+#9+general.curcomma(virtualclicks)+sep+
   tsVirtual+#32+tsKeyStrokes+#9+general.curcomma(virtualkeystrokes)+sep+
   tsFileRemaps+#9+general.curcomma(systemfileremaps)+sep+
   //.timer
   sep+
   ma+tsTimer+mb+#9+sep+
   tsTickCount+' 64-'+tslcbit+#9+general.curcomma(ms64)+sep+
   tsTickCount+' 32-'+tslcbit+#9+general.curcomma(ms32)+sep+
   tsActive+#9+general.thousands(timerloadactive)+sep+
   tsLoad+#9+general.thousands(timerload)+sep+
   //.controls
   sep+
   ma+tsVirtual+#32+tsControls+mb+#9+sep+
   tsActive+#9+general.thousands(viControlsActive)+sep+
   tsCreated+#9+general.thousands(viControlsCreated)+sep+
   tsDestroyed+#9+general.thousands(viControlsDestroyed)+sep+
   //.system controls
   sep+
   ma+tsSystem+#32+tsControls+mb+#9+sep+
   tsActive+#9+general.thousands(sysinfo.active)+sep+
   tsCreated+#9+general.thousands(sysinfo.create)+sep+
   tsDestroyed+#9+general.thousands(sysinfo.destroy)+sep;
   //.network
   if programnetworkenabled then
      begin
      //.init
      lt:='0';
      if (lm<>nil) then lt:=general.thousands(lm.maxthread);
      //.append
      result:=result+
      sep+
      ma+tsNetwork+mb+#9+sep+
      tsLookup+#32+tsThreads+#9+lt+sep+
      tsLookup+#9+general.curcomma(networklookup)+sep+
      tsMappings+#9+general.thousands(mip.count)+sep+
      tsOut+#9+general.curcomma(networkhitsout)+sep+
      tsIn+#9+general.curcomma(networkhitsin)+sep;
      end;//end of if
   //.misc
   if (piggyform<>nil) then
      begin
      result:=result+
      sep+
      ma+tsMiscellaneous+mb+#9+sep+
      tsDimensions+#9+general.thousands(piggyform.width)+'x'+general.thousands(piggyform.height)+sep;
      end;//end of if
   end;//end of begin
vsiEULA:result:=result+programEULA;
vsiHelp:begin//Help
   result:=result+general.udv(misc.helpise(programhelp,false),tsNoHelp);
   end;//end of begin
vsiCodes:result:=result+general.networkcodes(#9,rcode);
vsiConnections:result:=result+nw.stats(false,#9,rcode);
vsiTraffic:result:=result+secip.stats(false,#9,rcode);
vsiFolders:begin
   //folders
   for p:=0 to (icfCount-1) do if (icflink[p]<>nil) then icflink[p].enabled:=(icfpath[p]<>'') and directoryexists(asfolder(icfpath[p]));
   //options
   iextractsupportfiles.enabled:=pg.canus;
   end;//end of begin
end;//end of case
except;end;
end;

//## tvirtualalertaudio ########################################################
//## create ##
constructor tvirtualalertaudio.create(_gui:tvirtualform;_sysptr:integer;_vars:string);
var
   z,tmp,tsPlay,tsPlayOnce,tsBeep:string;
   _normal:boolean;
   len,p:integer;
begin
//Note: Sample "_vars" input:
//_vars:=';index: sound31'
//self
inherited create(_gui,_sysptr,_vars);
oHeight:=vhsControls;
oAllowvariableheights:=false;
bordersize:=1;
_normal:=true;
//vars - Note: "_sysptr" used in temp filenames for multiple controls within same instance of program to play simultaneously
iwavefile:=bvfportable(bvfTemp)+programname+'-'+programcategoryHARD+'-'+inttostr(_sysptr)+'-alert.wav';
imidifile:=bvfportable(bvfTemp)+programname+'-'+programcategoryHARD+'-'+inttostr(_sysptr)+'-alert.mid';
tsBeep:=ntranslate('beep');
tsPlay:=ntranslate('play');
tsPlayOnce:=ntranslate('play once');
help:=rthtranslate('Multimedia audio player');
//.translation
tsSound:=ntranslate('sound');
//controls
ilabel:=tdynamicstring.create;
iname:=tdynamicnamelist.create;
idata:=tdynamicstring.create;
//.imm
imm:=tmm.create;
(imm as tmm).onnotify:=__onclick;
//.fill
add(ntranslate('none'),'none','');//none is assumed as item "0"
add(ntranslate('custom'),'custom','');//custom is assumed as item "1"
//..beeps
add(tsBeep+#32+'1','beep1','PCS1#1,50,60');
add(tsBeep+#32+'2','beep2','PCS1#2,50,60');
add(tsBeep+#32+'3','beep3','PCS1#3,50,50');
add(tsBeep+#32+'4','beep4','PCS1#1,50,50');
add(tsBeep+#32+'5','beep5','PCS1#1,100,60|2,200,60');
add(tsBeep+#32+'6','beep6','PCS1#10,50,50');
//..system sounds
add(tsSystem+#32+ntranslate('asterisk')     ,'system1','SSD1#asterisk');
add(tsSystem+#32+ntranslate('exclamation')  ,'system2','SSD1#exclamation');
add(tsSystem+#32+ntranslate('critical stop'),'system3','SSD1#criticalstop');
add(tsSystem+#32+ntranslate('question')     ,'system4','SSD1#question');
add(tsSystem+#32+ntranslate('default sound'),'system5','SSD1#defaultsound');
//..midi sounds
add(tsSound+#32+'1','sound1','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAGwDAAgCQXWSDYIBdAFjAAACQXQAogF0AAP8vAA==');
add(tsSound+#32+'2','sound2','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAGwDAAgCQSmSDYIBKAGTAAACQSgAogEoAAP8vAA==');
add(tsSound+#32+'3','sound3','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAMgDAAgCQTWR4gE0AAJBTZHiAUwAAkE1keIBNAACQU2R4gFMAMcAAAJBNACiATQAA/y8A');
add(tsSound+#32+'4','sound4','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAIgDAAgCQSGQdgEgAPJBIZB+ASAAnwAAAkEgAKIBIAAD/LwA=');
add(tsSound+#32+'5','sound5','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAIgDAAgCQTWQdgE0APJBIZB+ASAAkwAAAkE4AKIBOAAD/LwA=');
add(tsSound+#32+'6','sound6','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAIgDAAgCQTWQdgE0APJBUZB+AVAAgwAAAkFIAKIBSAAD/LwA=');
add(tsSound+#32+'7','sound7','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAANgDAAgCQT2SBcIBPAACQT2SBcIBPAACQT2SBcIBPAACQT2SBcIBPAEHAAACQTwAogE8AAP8vAA==');
add(tsSound+#32+'8','sound8','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAKwDAAgCQTGR4gEwAAJBMZHiATAAAkExkg2CATAAswAAAkEwAKIBMAAD/LwA=');
add(tsSound+#32+'9','sound9','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAQgDAAwCQTWR4gE0AAJBIZHiASAAAkEhkeIBIAACQSGR4gEgAAJBNZHiATQAAkFFkeIBRADLAAACQTQAogE0AAP8vAA==');
add(tsSound+#32+'10','sound10','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAQgDAAwCQTWR4gE0AAJBIZHiASAAAkEhkeIBIAACQSGR4gEgAAJBNZHiATQAAkFFkeIBRAGfAAACQSwAogEsAAP8vAA==');
add(tsSound+#32+'11','sound11','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAIgDDWwCTR2R4g0cAAJNIZHiDSABcwAAAkEgAKIBIAAD/LwA=');
add(tsSound+#32+'12','sound12','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAIgDDZACTR2R4g0cAAJNIZHiDSABDwAAAkEgAKIBIAAD/LwA=');
add(tsSound+#32+'13','sound13','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAIgDDbwCTR2R4g0cAAJNIZHiDSABawAAAkEgAKIBIAAD/LwA=');
add(tsSound+#32+'14','sound14','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAIgDDcQCTR2R4g0cAAJNIZHiDSABbwAAAkEgAKIBIAAD/LwA=');
add(tsSound+#32+'15','sound15','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAGgDDcQCTR2R4g0cAXcAAAJBHACiARwAA/y8A');
add(tsSound+#32+'16','sound16','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAGgDDcwCTR2R4g0cASMAAAJBHACiARwAA/y8A');
add(tsSound+#32+'17','sound17','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAGgDDFACTR2R4g0cANsAAAJBIACiASAAA/y8A');
add(tsSound+#32+'18','sound18','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAMgDAAwCQR2QOgEcALpBIZA6ASAAukEpkDoBKAC6QTWQOgE0AQcAAAJBLACiASwAA/y8A');
add(tsSound+#32+'19','sound19','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAOwDAAwCQR2QOgEcALpBIZA6ASAAukEpkDoBKAC6QTWQOgE0ALpBHZIFwgEcATsAAAJBHACiARwAA/y8A');
add(tsSound+#32+'20','sound20','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAOwDAAwCQR2QOgEcALpBIZA6ASAAukEpkDoBKAC6QTWQOgE0ALpBUZIITgFQATcAAAJBUAFOAVAAA/y8A');
add(tsSound+#32+'21','sound21','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAGwDADgCQT2SDYIBPADDAAACQTwAogE8AAP8vAA==');
add(tsSound+#32+'22','sound22','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAGwDADgCQSmSDYIBKADXAAACQSgAogEoAAP8vAA==');
add(tsSound+#32+'23','sound23','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAOgDADgCQR2R4gEcAAJBKZHiASgAAkEdkeIBHAACQSGR4gEgAAJBIZHiASAA9wAAAkEgAKIBIAAD/LwA=');
add(tsSound+#32+'24','sound24','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAOgDADgCQR2R4gEcAAJBNZHiATQAAkEdkeIBHAACQTWR4gE0AAJBKZHiASgBJwAAAkE4AKIBOAAD/LwA=');
add(tsSound+#32+'25','sound25','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAMgDADgCQR2R4gEcAAJBNZHiATQAAkEdkeIBHAACQTWR4gE0APsAAAJBNACiATQAA/y8A');
add(tsSound+#32+'26','sound26','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAIgDAEQCQR2R4gEcAAJBDZHiAQwArwAAAkEcAKIBHAAD/LwA=');
add(tsSound+#32+'27','sound27','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAIgDAEQCQWGR4gFgAAJBRZHiAUQAgwAAAkFgAKIBYAAD/LwA=');
add(tsSound+#32+'28','sound28','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAIgDAFgCQWGR4gFgAAJBRZHiAUQAuwAAAkFgAKIBYAAD/LwA=');
add(tsSound+#32+'29','sound29','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAQgDAFgCQSGQdgEgAAJBIZB+ASAAAkEhkHYBIAACQSGQfgEgAAJBIZB2ASAAAkEhkH4BIABzAAACQSAAogEgAAP8vAA==');
add(tsSound+#32+'30','sound30','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAASgDAFgCQSGQdgEgAAJBKZB+ASgAAkEhkHYBIAACQR2QfgEcAAJBIZB2ASAAAkEpkH4BKAACQR2QdgEcAHcAAAJBKACiASgAA/y8A');
add(tsSound+#32+'31','sound31','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAASgDAFgCQSGQdgEgAAJBNZB+ATQAAkEhkHYBIAACQQ2QfgEMAAJBIZB2ASAAAkE1kH4BNAACQR2QdgEcAJsAAAJBLACiASwAA/y8A');
add(tsSound+#32+'32','sound32','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAMgDAFgCQSGQdgEgAAJBNZB+ATQAAkEhkHYBIAACQQ2QfgEMAHMAAAJBIACiASAAA/y8A');
add(tsSound+#32+'33','sound33','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAUwDAFgCQSGQdgEgAAJBNZB+ATQAAkEhkHYBIAACQQ2QfgEMAAJBHZINggEcAAJBMZB2ATAAAkE1kH4BNAACQQWQdgEEAGMAAAJBIACiASAAA/y8A');
add(tsSound+#32+'34','sound34','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAASgDAFgCQSGQdgEgAAJBNZB+ATQAAkEhkHYBIAACQQ2QfgEMAeJBMZB2ATAAAkE1kH4BNAACQQWQdgEEAHsAAAJBJACiASQAA/y8A');
add(tsSound+#32+'35','sound35','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAANgDAFgCQQ2SBcIBDAACQR2SBcIBHAACQSmSBcIBKAACQTWSBcIBNACLAAACQTQAogE0AAP8vAA==');
add(tsSound+#32+'36','sound36','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAKwDAFgCQR2R4gEcAAJBKZIFwgEoAAJBHZHiARwAqwAAAkEcAKIBHAAD/LwA=');
add(tsSound+#32+'37','sound37','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAKwDACACQR2R4gEcAAJBHZHiARwAAkEpkgXCASgAswAAAkEoAKIBKAAD/LwA=');
add(tsSound+#32+'38','sound38','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAGwDADgCQR2QOgEcAgTrAAACQRwAogEcAAP8vAA==');
add(tsSound+#32+'39','sound39','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAIwDADgCQR2QOgEcALpBIZA6ASACBS8AAAJBJACiASQAA/y8A');
add(tsSound+#32+'40','sound40','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAIgDARQCQR2Q8gEcAAJBMZDyATAAqwAAAkEwAKIBMAAD/LwA=');
add(tsSound+#32+'41','sound41','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAIgDARQCQR2Q8gEcAAJBFZDyARQAmwAAAkEgAKIBIAAD/LwA=');
add(tsSound+#32+'42','sound42','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAGgDARQCQR2Q8gEcAK8AAAJBHACiARwAA/y8A');
add(tsSound+#32+'43','sound43','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAGgDARQCQT2Q8gE8ASsAAAJBPACiATwAA/y8A');
add(tsSound+#32+'44','sound44','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAGgDARQCQVmQ8gFYAOsAAAJBWACiAVgAA/y8A');
add(tsSound+#32+'45','sound45','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAGgDARQCQN2Q8gDcAR8AAAJA4ACiAOAAA/y8A');
add(tsSound+#32+'46','sound46','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAGgDAPACQUWQ8gFEAOcAAAJBRACiAUQAA/y8A');
add(tsSound+#32+'47','sound47','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAMg7APACQSGQPgEgAH5BKZA6ASgAPkExkD4BMABCQTWQOgE0AKcAAAJBNACiATQAA/y8A');
add(tsSound+#32+'48','sound48','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAUg7APACQSGQPgEgAH5BKZA6ASgAPkExkD4BMABCQTWQOgE0AD5BFZA+ARQAQkEdkDoBHAA+QSGQPgEgAEJBKZA6ASgAvwAAAkE4AKIBOAAD/LwA=');
add(tsSound+#32+'49','sound49','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAYg7APACQSGQPgEgAH5BKZA6ASgAPkExkD4BMABCQTWQOgE0AD5BFZA+ARQAQkEdkDoBHAA+QSGQPgEgAEJBKZA6ASgAPkE1kD4BNABCQTWQOgE0AOMAAAJBNACiATQAA/y8A');
add(tsSound+#32+'50','sound50','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAYg7APACQSGQPgEgAH5BKZA6ASgAPkExkD4BMABCQTWQOgE0AD5BFZA+ARQAQkE1kDoBNAA+QSGQPgEgAEJBFZA6ARQAPkEFkD4BBABCQQWQOgEEANMAAAJBLACiASwAA/y8A');
add(tsSound+#32+'51','sound51','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAcg7APACQSGQPgEgAH5BKZA6ASgAPkExkD4BMABCQTWQOgE0AD5BFZA+ARQAQkE1kDoBNAA+QSGQPgEgAEJBFZA6ARQAPkEFkD4BBABCQTWQdgE0AAJBNZB+ATQAAkE1kHYBNAC7AAACQTQAogE0AAP8vAA==');
add(tsSound+#32+'52','sound52','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAeg7APACQSGQPgEgAH5BKZA6ASgAPkExkD4BMABCQTWQdgE0AAJBNZB+ATQAAkE1kHYBNAACQTGQfgEwAAJBKZB2ASgAAkEpkH4BKAACQTGQdgEwAAJBMZB+ATAAAkE1kHYBNAACQSGQfgEgALsAAAJBNACiATQAA/y8A');
add(tsSound+#32+'53','sound53','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAgw7APACQSGQPgEgAH5BKZA6ASgAPkExkD4BMABCQTWQdgE0AAJBNZB+ATQAAkE1kHYBNAACQTGQfgEwAAJBKZB2ASgAAkEpkH4BKAACQTGQdgEwAAJBMZB+ATAAAkE1kHYBNAACQSGQfgEgAPJBNZIFwgE0ANsAAAJBNACiATQAA/y8A');
add(tsSound+#32+'54','sound54','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAGgDAPACQU2R4gFMAMcAAAJBTACiAUwAA/y8A');
add(tsSound+#32+'55','sound55','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAGgDAPACQR2R4gEcAXMAAAJBHACiARwAA/y8A');
add(tsSound+#32+'56','sound56','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAGgDAOACQSmR4gEoAKMAAAJBKACiASgAA/y8A');
add(tsSound+#32+'57','sound57','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAGgDAMwCQSmR4gEoATsAAAJBKACiASgAA/y8A');
add(tsSound+#32+'58','sound58','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAIgDAMwCQSmR4gEoAAJBHZHiARwBLwAAAkEsAKIBLAAD/LwA=');
add(tsSound+#32+'59','sound59','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAKgDAMwCQSmR4gEoAAJBHZHiARwAAkE9keIBPAELAAACQTwAogE8AAP8vAA==');
add(tsSound+#32+'60','sound60','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAOgDAMwCQSmR4gEoAAJBHZHiARwAAkE9keIBPAACQT2R4gE8AAJBPZHiATwBdwAAAkE8AKIBPAAD/LwA=');
add(tsSound+#32+'61','sound61','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAIgDALwCQSmR4gEoAAJBHZHiARwBLwAAAkEsAKIBLAAD/LwA=');
add(tsSound+#32+'62','sound62','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAIgDALgCQSmR4gEoAAJBHZHiARwA9wAAAkEsAKIBLAAD/LwA=');
add(tsSound+#32+'63','sound63','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAOgDALgCQSmR4gEoAAJBHZHiARwAAkE1keIBNAACQU2R4gFMAAJBTZHiAUwBewAAAkFQAKIBUAAD/LwA=');
add(tsSound+#32+'64','sound64','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAQgDALgCQR2R4gEcAAJBKZHiASgAAkENkeIBDAACQSmR4gEoAAJBKZHiASgAAkEdkeIBHADXAAACQSwAogEsAAP8vAA==');
add(tsSound+#32+'65','sound65','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAKgDALgCQR2R4gEcAAJBKZHiASgAAkENkeIBDAEnAAACQSQAogEkAAP8vAA==');
add(tsSound+#32+'66','sound66','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAKgDALgCQR2R4gEcAAJBKZHiASgAAkExkeIBMAD/AAACQTQAogE0AAP8vAA==');
add(tsSound+#32+'67','sound67','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAKgDALgCQR2R4gEcAAJBKZHiASgAAkENkeIBDAEbAAACQSgAogEoAAP8vAA==');
add(tsSound+#32+'68','sound68','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAKgDALgCQQ2R4gEMAAJBAZHiAQAAAkENkeIBDAGDAAACQRAAogEQAAP8vAA==');
add(tsSound+#32+'69','sound69','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAKgDALgCQQ2R4gEMAAJBNZHiATQAAkENkeIBDAE3AAACQTAAogEwAAP8vAA==');
add(tsSound+#32+'70','sound70','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAIgDALgCQQGR4gEAAAJBNZHiATQBdwAAAkEsAKIBLAAD/LwA=');
add(tsSound+#32+'71','sound71','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAIgDALgCQQGR4gEAAAJBDZHiAQwBewAAAkEQAKIBEAAD/LwA=');
add(tsSound+#32+'72','sound72','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAIwDALgCQQGR4gEAAAJBAZHiAQACBHsAAAJBAACiAQAAA/y8A');
add(tsSound+#32+'73','sound73','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAIwDALgCQR2R4gEcAAJBHZHiARwCBBcAAAJBHACiARwAA/y8A');
add(tsSound+#32+'74','sound74','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAIgDALgCQTGR4gEwAAJBMZHiATAB8wAAAkEwAKIBMAAD/LwA=');
add(tsSound+#32+'75','sound75','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAIgDAJwCQTGR4gEwAAJBMZHiATAAYwAAAkEwAKIBMAAD/LwA=');
add(tsSound+#32+'76','sound76','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAKgDAJwCQTGR4gEwAAJBHZB2ARwBbkEhkHYBIAFTAAACQSwAogEsAAP8vAA==');
add(tsSound+#32+'77','sound77','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAKgDAJwCQTGR4gEwAAJBHZB2ARwBbkEdkHYBHAFPAAACQSwAogEsAAP8vAA==');
add(tsSound+#32+'78','sound78','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAKgDAJwCQTGR4gEwAAJBHZB2ARwBbkENkHYBDAErAAACQTQAogE0AAP8vAA==');
add(tsSound+#32+'79','sound79','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAMgDAJwCQTGR4gEwAAJBHZB2ARwBbkENkHYBDAFuQSmQdgEoASMAAAJBLACiASwAA/y8A');
add(tsSound+#32+'80','sound80','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAMgDAJwCQR2R4gEcAAJBKZB2ASgBbkE1kHYBNAFuQSmQdgEoAQcAAAJBKACiASgAA/y8A');
add(tsSound+#32+'81','sound81','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAMgDAJwCQR2R4gEcAAJBHZB2ARwBbkE1kHYBNAFuQR2QdgEcAU8AAAJBNACiATQAA/y8A');
add(tsSound+#32+'82','sound82','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAGgDDBgCTR2R4g0cALcAAAJBHACiARwAA/y8A');
add(tsSound+#32+'83','sound83','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAIgDDBgCTR2R4g0cAAJNHZHiDRwBVwAAAkEcAKIBHAAD/LwA=');
add(tsSound+#32+'84','sound84','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAKgDDBgCTR2R4g0cAAJNHZHiDRwAAk0dkeINHAEvAAACQRwAogEcAAP8vAA==');
add(tsSound+#32+'85','sound85','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAARADDBgCTR2R4g0cAAJNHZHiDRwAAk0dkg2CDRwAMk0dkeINHAACTR2R4g0cAAJNHZINgg0cAVsAAAJBHACiARwAA/y8A');
add(tsSound+#32+'86','sound86','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAMgDDAACTSGQOg0gAD5NFZA+DRQAQk0hkDoNIAA+TRWQPg0UALcAAAJBIACiASAAA/y8A');
add(tsSound+#32+'87','sound87','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAUgDDAACTSGQOg0gAD5NFZA+DRQAQk0hkDoNIAA+TRWQPg0UAEJNIZA6DSAAPk0VkD4NFABCTSGQOg0gAD5NFZA+DRQA2wAAAkEgAKIBIAAD/LwA=');
add(tsSound+#32+'88','sound88','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAagDDAACTSGQOg0gAD5NFZA+DRQAQk0hkDoNIAA+TRWQPg0UAEJNIZA6DSAAPk0VkD4NFABCTSGQOg0gAD5NFZA+DRQAQk0xkDoNMAA+TTGQPg0wAEJNMZA6DTAArwAAAkEsAKIBLAAD/LwA=');
add(tsSound+#32+'89','sound89','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAUgDDAACTTGQOg0wAD5NBZA+DQQAQk0xkDoNMAA+TQWQPg0EAEJNBZA6DQQAPk0hkD4NIABCTSGQOg0gAD5NFZA+DRQBnwAAAkEgAKIBIAAD/LwA=');
add(tsSound+#32+'90','sound90','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAOgDDAACTTGQOg0wAD5NBZA+DQQAQk0xkDoNMAA+TSmQPg0oAEJNKZA6DSgA0wAAAkEsAKIBLAAD/LwA=');
add(tsSound+#32+'91','sound91','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAMgDDAACTTGQOg0wAapNHZA6DRwBqk01kDoNNAGqTR2QOg0cARMAAAJBJACiASQAA/y8A');
add(tsSound+#32+'92','sound92','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAIgDDAACTTGQOg0wAapNHZA6DRwBdwAAAkE0AKIBNAAD/LwA=');
add(tsSound+#32+'93','sound93','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAGgDDEwCTR2R4g0cAZMAAAJBIACiASAAA/y8A');
add(tsSound+#32+'94','sound94','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAGgDDEwCTTWR4g00ATsAAAJBNACiATQAA/y8A');
add(tsSound+#32+'95','sound95','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAGgDDEwCTTGR4g0wATMAAAJBMACiATAAA/y8A');
add(tsSound+#32+'96','sound96','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAGgDDEwCTQGR4g0AASMAAAJBBACiAQQAA/y8A');
add(tsSound+#32+'97','sound97','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAOgDDEwCTQGR4g0AAAJNFZHiDRQAAk0hkeINIAACTQWR4g0EAAJNIZHiDSABawAAAkEYAKIBGAAD/LwA=');
add(tsSound+#32+'98','sound98','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAMgDDEwCTR2R4g0cAAJNKZHiDSgAAk0NkeINDAACTR2R4g0cAZMAAAJBIACiASAAA/y8A');
add(tsSound+#32+'99','sound99','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAIgDDHQCTR2R4g0cAAJNIZHiDSABRwAAAkEYAKIBGAAD/LwA=');
add(tsSound+#32+'100','sound100','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAIgDDLACTR2R4g0cAAJNIZHiDSABKwAAAkEcAKIBHAAD/LwA=');
add(tsSound+#32+'101','sound101','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAIgDDOACTR2R4g0cAAJNIZHiDSABGwAAAkEcAKIBHAAD/LwA=');
add(tsSound+#32+'102','sound102','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAIgDDRgCTR2R4g0cAAJNIZHiDSAA/wAAAkEgAKIBIAAD/LwA=');
add(tsSound+#32+'103','sound103','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAIgDDRwCTR2R4g0cAAJNIZHiDSABkwAAAkEgAKIBIAAD/LwA=');
add(tsSound+#32+'104','sound104','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAIgDDSACTR2R4g0cAAJNIZHiDSABOwAAAkEgAKIBIAAD/LwA=');
add(tsSound+#32+'105','sound105','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAIgDDTQCTR2R4g0cAAJNIZHiDSABQwAAAkEgAKIBIAAD/LwA=');
add(tsSound+#32+'106','sound106','TVRoZAAAAAYAAQACAHhNVHJrAAAAGQD/WAQEAhgIAP9ZAgAAAP9RAwknwAD/LwBNVHJrAAAAIgDDVgCTR2R4g0cAAJNIZHiDSABLwAAAkEgAKIBIAAD/LwA=');
//.list
icustom:=newllink(ntranslate('custom'),tepFolder20,rthtranslate('Select custom sound file. An "Open" window will display, select sound and click "Open" button'),__onclick);
istop:=newllink(ntranslate('stop'),tepStop20,rthtranslate('Halt current audio playback'),__onclick);
iplay:=newllink(ntranslate('play'),tepPlay20a,rthtranslate('Initiate audio playback'),__onclick);
iplay.buffer:=true;
inext:=newllink(ntranslate('next'),tepRightSkip20,rthtranslate('Play next sound'),__onclick);
inext.alignsep:=5;
//repeat list
tmp:='';
len:=0;
pushb(len,tmp,#1+ntranslate('play forever'));
pushb(len,tmp,#1+tsPlayOnce);
for p:=2 to 100 do pushb(len,tmp,#1+tsPlay+#32+inttostr(p)+'x');
pushb(len,tmp,'');
//.value
z:=vars.s['repeat'];
if (z='*') then p:=1//use system default of "play once"
else p:=frcrange(strint(z),0,100);
//.list
irepeatlist:=newb('dropliststatic','',tmp,rthtranslate('Play options'),valLeft,nil,sysptr+2,sgsInteger,inttostr(p),'') as tvirtualdropliststatic;
with irepeatlist do
begin
oNumbered:=false;
oWidth:=vwsWidth;
width:=160;
oHeight:=vhsFont;
bordersize:=0;
end;//end of with
//droplist
p:=frcmin(iname.findfast(0,vars.s['index']),0);//find by name
idroplist:=newb('dropliststatic','',getlabels(#1,true),rthtranslate('View list of sounds'),valLeft,nil,sysptr+0,sgsInteger,inttostr(p),'') as tvirtualdropliststatic;
with idroplist do
begin
oNumbered:=false;
tabs:='TABS:S5,L0,L280';
oVariablewidth:=true;
oHeight:=vhsFont;
bordersize:=0;
end;//end of with
//.filename
newb('hidden','','','',valNone,nil,sysptr+1,sgsString,'','');
//events
idroplist.onchange:=_onitemindex;
//timer
timer:=1000;
//finished
createfinished;
end;
//## destroy ##
destructor tvirtualalertaudio.destroy;
begin
try
//init
destroyinit;
//wavefile
__onclick(imm);
//controls
freeobj(@imm);
freeobj(@ilabel);
freeobj(@iname);
freeobj(@idata);
//self
inherited
except;end;
end;
//## getplayNOW ##
function tvirtualalertaudio.getplayNOW:boolean;
begin
try
//defaults
result:=true;
//get
if (icountnew=0) then result:=false
else if (icount=0) and (not (imm as tmm).canstop) then result:=false;
except;end;
end;
//## getplay ##
function tvirtualalertaudio.getplay:boolean;
begin
try;result:=(icount<>0) or (imm as tmm).canstop;except;end;
end;
//## setplay ##
procedure tvirtualalertaudio.setplay(x:boolean);
var
   tmp:integer;
begin
try
//get
case x of
false:tmp:=0;
true:begin
   //get
   tmp:=frcrange(irepeatlist.value,0,irepeatlist.count-1);
   //decide
   if (tmp=0) then tmp:=-1;//forever
   end;//end of loop
end;//end of case
//set
icountnew:=frcrange(tmp,-1,maxint);
icountmodified:=true;
updatebuttons;
except;end;
end;
//## __fillfromdisk ##
procedure tvirtualalertaudio.__fillfromdisk;
var//Used at code time to automatically read and fill sound files and their labels
   a:tstringlist;
   count,zlen,p:integer;
   _path,tmp,e,z:string;
begin
try
//defaults
a:=nil;
a:=tstringlist.create;
zlen:=0;
z:='';
count:=1;
//get
_path:='c:\123blaiz\bc\';
a.text:=general.filesex(_path+'*.mid',false,true);
//set
for p:=0 to (a.count-1) do if io.fromfile(_path+a.strings[p],tmp,e) and ass.supportformat(ass.findformatb(tmp)) then
   begin
   //convert
   tmp:=io.tob64b(tmp,0);
   //set
   pushb(zlen,z,'add(tsSound+#32+'+#39+inttostr(count)+#39+','+
   #39+'sound'+inttostr(count)+#39+','+
   #39+tmp+#39+');'+rcode);
   //inc
   inc(count);
   end;//end of if
//finalise
pushb(zlen,z,'');
//return result
clipboard.astext:=z;
showinfo60('Ready.');
except;end;
try
freeobj(@a);
siHalt;
except;end;
end;
//## _onitemindex ##
procedure tvirtualalertaudio._onitemindex(sender:tobject);
begin
try
if ilocked then exit;
__onclick(istop);
__onclick(iplay);
except;end;
end;
//## getlabels ##
function tvirtualalertaudio.getlabels(sep:string;showtype:boolean):string;
var
   p:integer;
   z:string;
begin
try
//defaults
result:='';
//get
for p:=0 to (ilabel.count-1) do
   begin
   //get
   z:='';
   if showtype then
      begin
      ass.extlabel(ass.findformatb(idata.items[p]^),z);
      z:=#9+general.udv(z,'-');
      end;//end of if
   //set
   result:=result+sep+ilabel.items[p]^+z;
   end;//end of if
except;end;
end;
//## add ##
procedure tvirtualalertaudio.add(_label,_name,rawORb64:string);
var
   p:integer;
   format:string;
   binary:boolean;
begin
try
//decide
if (rawORb64<>'') and (not ass.findformat(rawORb64,format,binary)) then
   begin
   rawORb64:=io.fromb64b(rawORb64);
   if not ass.findformat(rawORb64,format,binary) then exit;
   end;//end of if
//set
p:=iname.add(_name);
if (p>=0) then
   begin
   ilabel.value[p]:=_label;
   idata.value[p]:=rawORb64;
   end;//end of if
except;end;
end;
//## readwrite ##
procedure tvirtualalertaudio.readwrite(mode:tvirtualstoragemode);
var
   mustresync:boolean;
   _filename:string;
begin
try
case mode of
vsmReadfromcontrols:ilocked:=true;
vsmWritetocontrols:ilocked:=true;
vsmUpdatecontrols:begin
   //defaults
   mustresync:=false;
   _filename:=ifilename;
   //set
   ilocked:=false;
   ifilename:=vs.s[sysptr+1];
   //resync
   if play and (idroplist.value=0) then mustresync:=true
   else if (comparetext(_filename,ifilename)<>0) then mustresync:=true;
   if mustresync and (imm as tmm).playing then play:=true;
   end;//end of begin
end;//end of case
except;end;
end;
//## __onclick ##
procedure tvirtualalertaudio.__onclick(sender:tobject);
var
   fall,f,tmp:string;
   p:integer;
begin
try
//standard
if (sender=inext) then
   begin
   //stop
   play:=false;
   //inc
   p:=idroplist.value+1;
   if (p>=idroplist.count) then p:=0;
   idroplist.value:=p;
   //play
   play:=true;
   end
else if (sender=iplay) then play:=true
else if (sender=istop) then play:=false
else if (sender=imm) then
   begin
   //.remove temp "wavefile" - called when imm.stops
   if fileexists(iwavefile) then
      begin
      (imm as tmm).stop;
      remfilems(iwavefile,1000);
      end;//end of if
   //.remove temp "midifile" - called when imm.stops
   if fileexists(imidifile) then
      begin
      (imm as tmm).stop;
      remfilems(imidifile,1000);
      end;//end of if
   //.dec
   if (icount>=1) then dec(icount);
   end
else if (sender=icustom) then
   begin
   //.get
   f:='';
   fall:='';
   //..wave
   f:=f+ntranslate('wave')+' (*.wav,*.snd,*.au,*.aif,*.aifc,*.aiff)|*.wav;*.snd;*.au;*.aif;*.aifc;*.aiff|';
   fall:=fall+'*.wav;*.snd;*.au;*.aif;*.aifc;*.aiff';
   //..mp3
   f:=f+uppercase(translate('MP3'))+' (*.mp3)|*.mp3|';
   fall:=fall+'*.mp3;';
   //..wma
   f:=f+ntranslate('windows media audio')+' (*.wma)|*.wma|';
   fall:=fall+'*.wma;';
   //..midi
   f:=f+ntranslate('midi')+' (*.mid,*.midi,*.rmi)|*.mid;*.midi;*.rmi|';
   fall:=fall+'*.mid;*.midi;*.rmi;';
   //..finalise
   f:=ntranslate('all audio formats')+'|'+fall+'|'+f;
   //.set
   if misc.opendlgb('',f,ifilename,0,tmp) then
      begin
      vs.i[sysptr+0]:=1;//custom
      vs.s[sysptr+1]:=tmp;
      vs.writetocontrols;
      end;//end of if
   end;//end of if
except;end;
end;
//## updatebuttons ##
procedure tvirtualalertaudio.updatebuttons;
begin
try
iplay.enabled:=(idroplist.value>=1);
istop.enabled:=playNOW;
iplay.image.run:=iplay.enabled and istop.enabled;
except;end;
end;
//## _ontimer ##
procedure tvirtualalertaudio._ontimer(sender:tobject);
var
   _ssd,_pcs,tmp,ext,e,z,f:string;
   binary,b:boolean;
   p:integer;
begin
try
//stop - was playing but now "item0" selected or "no sound"
if (idroplist.value=0) and play then//18DEC2007
   begin
   icountnew:=0;
   icountmodified:=true;
   end;//end of if
//sync
if icountmodified then
   begin
   (imm as tmm).stop;
   icount:=icountnew;
   icountmodified:=false;
   end;//end of if
//check
if (icount=0) or (imm as tmm).playing then
   begin
   //.buttons
   updatebuttons;
   //.quit
   exit;
   end;//end of if
//process
//.beep
b:=false;
f:='';
z:='';
ext:='';
binary:=false;
_pcs:='';
_ssd:='';
//.get
p:=frcrange(idroplist.value,0,idroplist.count-1);
case p of
0:;//none
1:begin//custom - autofind file if not in expected location (specified drive or current drive)
   f:=misc.mapfile(ifilename);
   b:=(f='');
   end;//end of begin
else
   begin
   //init
   b:=true;//beep if sound fails
   //get
   z:='';
   if (length(idata.items[p]^)>=1) and ass.findformat(idata.items[p]^,ext,binary) then
      begin
      //get
      tmp:='';
      if (ext='PCS') then _pcs:=idata.items[p]^
      else if (ext='SSD') then _ssd:=idata.items[p]^
      else
         begin
         if (ext='MID') or (ext='RMI') then tmp:=imidifile
         else if (ext='WAV') then tmp:=iwavefile;
         //set
         if (tmp<>'') and io.toFILE(tmp,idata.items[p]^,e) then
            begin
            f:=tmp;
            b:=false;
            end;//end of if
         end;//end of if
      end;//end of if
   end;//end of begin
end;//end of case
//.audio file
if (f<>'') then
   begin
   //.play
   b:=not (imm as tmm).play(f,e);
   end;//end of if
//.pcs audio file (pc speaker)
if (_pcs<>'') then ass.playpcs(_pcs);
//.ssd audio file (pc speaker)
if (_ssd<>'') then ass.playssd(_ssd);
//.beep if error with audio file
if b then
   begin
   general.shortbeepb(2,50,60);
   f:='';
   end;//end of if
except;end;
try
//.dec
if (icount>=1) and (f='') then dec(icount);
//.buttons
updatebuttons;
except;end;
end;

//## tvirtualcontacts ##########################################################
//## create ##
constructor tvirtualcontacts.create(_gui:tvirtualform;_title:string);//yyyyyyyyyyyyyyyyyyyyyyy is this required any more???????????????????????
const
   tab='TABS:S5,L0,L200';
begin
//self
inherited create(_gui);
height:=300;
oVariableheight:=true;
//controls
//.title
with new('title',general.udv(_title,ntranslate('contacts')),'','',valTop,nil) as tvirtualtitle do
begin
irefresh:=newlink(ntranslate('refresh'),tepRefresh20,'',__onclick);
ifolder:=newlink(ntranslate('folder'),tepFolder20,'',__onclick);
ifolder.alignsep:=10;
iconnect:=newlink(ntranslate('connect'),tepConnect20,'',__onclick);
iconnect.alignsep:=10;
icopy:=newlink(ntranslate('copy'),tepCopy20,'',__onclick);
iedit:=newlink(ntranslate('edit'),tepEdit20,'',__onclick);
inew:=newlink(ntranslate('new'),tepNew20,'',__onclick);
end;//end of with

//.ibase
ibase:=new('pagehsplit','','','',valTop,nil) as tvirtualpagevsplit;
ibase.createinit(false,false);
ibase.pageheight:=-220;
//PAGE0
with ibase.pages[0] do
begin
ifiles:=new('list',ntranslate('contacts'),'','',valTop,nil) as tvirtuallist;
ifiles.oNumbered:=true;
ifiles.onitemindex:=__onclick;
ifiles.tep:='T2H00C00)3000us)))))~'+'GLLLL0fgggQaMfggQfPgggMQbgggbggggQfLLLbMgggggbMLbgQfgggg6fgggQ0LLLL1#';
end;//end of with
//PAGE1
with ibase.pages[1] do
begin
new('label',ntranslate('address')+#9+ntranslate('name'),tab,'',valTop,nil);
ifile:=new('list','',tab,'',valTop,nil) as tvirtuallist;
ifile.tep:='T3C00C00)300MBu0))F0ZCo8))))~'+'0899100HIIA08QJQJ1HZSZSAHZRZRAHQJQJAHIIIIAHIQJIAHJIIQA8QIIJ10HRRA0089910#';
ifile.oNumbered:=true;
end;//end of with
//defaults
ifiles.itemindex:=-1;
refreshlist;
updatebuttons;
end;
//## __onclick ##
procedure tvirtualcontacts.__onclick(sender:tobject);
var
   x:string;
begin
try
//standard
if (sender=irefresh) then refreshlist
else if (sender=ifolder) then run(bvfportable(bvfContacts),'')
else if (sender=ifiles) then load
else if (sender=icopy) then clipboard.astext:=idata
else if (sender=iconnect) then fireevent(onconnect,self)
else if (sender=iedit) then
   begin
   if (ifiles.itemindex>=0) then
      begin
      x:=idata;
      if showtextb(ntranslate('edit')+' - '+ifiles.items[ifiles.itemindex],
         translate('One domain/IP address and name label (optional) set per line')+rcode+
         translate('Example 1: 127.0.0.1=A Friend')+rcode+
         translate('Example 2: 127.0.0.1'),x,false,false) then
         begin
         idata:=x;
         savedata(ifiles.itemindex);
         end;//end of if
      end;//end of if
   end
else if (sender=inew) then newcontact;
except;end;
end;
//## newcontact ##
procedure tvirtualcontacts.newcontact;
label
   redo;
var
   e,xfile,xname:string;
   p:integer;
begin
try
//process
//.get
redo:
xname:='';
xfile:='';
if not showedit60(xname,ntranslate('new contact'),translate('Type a name for new contact'),ntranslate('&create')) then exit;
//.range
xname:=general.safeprogramname(xname);
xfile:=bvfportable(bvfContacts)+xname+'.txt';
if (xname='') or fileexists(xfile) then
   begin
   showerror60(translate('Name already exists, use another.'));
   goto redo;
   end;//end of if
//.file
io.tofileb(xfile,'',e);
//.update list
refreshlist;
//.find
p:=ifiles.findtext(extractfilename(xfile));
if (p>=0) then
   begin
   ifiles.itemindex:=p;
   //.edit
   __onclick(iedit);
   end;//end of if
except;end;
end;
//## refreshlist ##
procedure tvirtualcontacts.refreshlist;
var
   a:tstringlist;
   o:integer;
begin
try
//defaults
a:=nil;
o:=ifiles.itemindex;
//process
//.files (contacts *.TXT)
a:=tstringlist.create;
a.text:=general.files(bvfportable(bvfContacts)+'*.TXT',false);
//.sort
a.sort;
//.set
ifiles.text:=a.text;
//.reset
ifiles.itemindex:=o;
load;
except;end;
try;freeobj(@a);except;end;
end;
//## savedata ##
procedure tvirtualcontacts.savedata(p:integer);
var
   e:string;
begin
try
//defaults
e:=gecTaskFailed;
//process
if (p>=0) and (p<ifiles.count) and io.tofile(bvfportable(bvfContacts)+ifiles.items[p],idata,e) then
   begin
   //successful
   e:='';
   //.load
   load;
   end;//end of if
except;end;
try;if (e<>'') then showerror60(translate(e));except;end;
end;
//## getdata ##
function tvirtualcontacts.getdata(p:integer):string;
var
   e:string;
begin
try
//defaults
result:='';
//process
if (p>=0) and (p<ifiles.count) then io.fromfile(bvfportable(bvfContacts)+ifiles.items[p],result,e);
except;end;
end;
//## load ##
procedure tvirtualcontacts.load;
begin
try;setdata(getdata(ifiles.itemindex));except;end;
end;
//## setdata ##
procedure tvirtualcontacts.setdata(x:string);
var
   i,len,p:integer;
   v,_ips,tmp,e:string;
begin
try
//process
//.get
tmp:=x;
//.set
idata:=x;
//.list
general.swapchars(tmp,'=',#9);
ifile.text:=tmp;
//.iips
_ips:='';
len:=0;
p:=1;
while general.nextline(p,x,v) do if (v<>'') then
   begin
   for i:=1 to length(v) do if (v[i]='=') then
      begin
      v:=copy(v,1,i-1);
      break;
      end;//end of if
   pushb(len,_ips,v+rcode);
   end;//end of if
//..finalise
pushb(len,_ips,'');
iips:=_ips;
//updatebuttons
updatebuttons;
except;end;
end;
//## updatebuttons ##
procedure tvirtualcontacts.updatebuttons;
begin
try
iedit.enabled:=(ifiles.itemindex>=0);
icopy.enabled:=(idata<>'');
iconnect.enabled:=assigned(onconnect) and general.textgood(idata);
except;end;
end;

//## tvirtualpath ##############################################################
//## create ##
constructor tvirtualpath.create(_gui:tvirtualform);
begin
//self
inherited create(_gui);
//vars
tsNopath:=ntranslate('< no folder specified >');
//help
internalhelp:=rthtranslate('Specify custom Folder. A "Browse for Folder" window will display, select Folder and click "OK" button');
//defaults
cursor:=vcLink;
animation:=tepFolder20;
end;
//## getcaption ##
function tvirtualpath.getcaption:string;
begin
try;result:=general.udv(ipath,tsNopath);except;end;
end;
//## readwrite ##
procedure tvirtualpath.readwrite(mode:tvirtualstoragemode);
var
   tmp:string;
begin
try
case mode of
vsmReadfromcontrols:if (isysptr>vsNil) then vs.s[isysptr]:=path;
vsmWritetocontrols:if (isysptr>vsNil) then
   begin
   tmp:=vs.s[isysptr];
   if (tmp<>path) then path:=tmp;
   end;//end of if
vsmUpdatecontrols:;
end;//end of case
except;end;
end;
//## setpath ##
procedure tvirtualpath.setpath(x:string);
begin
try;if general.setstring(x,ipath) then paint;except;end;
end;
//## click ##
procedure tvirtualpath.click;
var
   tmp:string;
begin
try
//dialog
tmp:=asfolder(path);
if misc.folderdlg('',tmp) then path:=tmp;
//self
inherited;
except;end;
end;

//## tvirtualfile ##############################################################
//## create ##
constructor tvirtualfile.create(_gui:tvirtualform);
begin
//self
inherited create(_gui);
//vars
tsNofile:=ntranslate('< no file name specified >');
//help
internalhelp:=rthtranslate('Specify custom file name - an "Open" window will display, select file name and click "Open" button');
//defaults
cursor:=vcLink;
animation:=tepWebPage20;
end;
//## getcaption ##
function tvirtualfile.getcaption:string;
begin
try;result:=general.udv(ifilename,tsNofile);except;end;
end;
//## readwrite ##
procedure tvirtualfile.readwrite(mode:tvirtualstoragemode);
var
   tmp:string;
begin
try
case mode of
vsmReadfromcontrols:if (isysptr>vsNil) then vs.s[isysptr]:=filename;
vsmWritetocontrols:if (isysptr>vsNil) then
   begin
   tmp:=vs.s[isysptr];
   if (tmp<>filename) then filename:=tmp;
   end;//end of if
vsmUpdatecontrols:;
end;//end of case
except;end;
end;
//## setfilename ##
procedure tvirtualfile.setfilename(x:string);
begin
try;if general.setstring(x,ifilename) then paint;except;end;
end;
//## click ##
procedure tvirtualfile.click;
var
   _filters,tmp:string;
begin
try
//init
_filters:=general.udv(filters,ntranslate('all files')+' (*.*)|*.*');
//prompt
tmp:=ifilename;
if misc.opendlgb('',_filters,tmp,1,tmp) then filename:=tmp;
//self
inherited;
except;end;
end;

//## tvirtualtile ##############################################################
//## create ##
constructor tvirtualtile.create(_gui:tvirtualform;_caption:string);
begin
//self
inherited create(_gui);
bordersize:=0;
//vars
itimer2:=mtNilTimer;
//controls
iimg:=tvirtualbitmap.create;
with new('titlegrid',_caption,'','',valTop,nil) as tvirtualgrid do
begin
iclear:=newlink(ntranslate('clear'),tepClear20,rthtranslate('Restore defaults - no image'),__onclick);
icopy:=newlink(ntranslate('copy'),tepCopy20,rthtranslate('Copy image to Clipboard'),__onclick);
ipaste:=newlink(ntranslate('paste'),tepPaste20,rthtranslate('Paste image from Clipboard'),__onclick);
iopen:=newlink(ntranslate('open'),tepOpen20,rthtranslate('Specify custom image - an "Open Image" window will display, select image and click "Open" button'),__onclick);
end;//end of with
iview:=new('control','','',rthtranslate('Preview'),valTop,nil) as tvirtualcontrol;
iview.oVariableheight:=true;
iview.buffer:=true;
iview.bordersize:=1;
iview.style:=[];
height:=250;
//EVENTS
iview.onpaint:=__onpaint;

//defaults
cursor:=vcLink;
itimer2:=mt.new(_ontimer2,1000,true);
end;
//## destroy ##
destructor tvirtualtile.destroy;
begin
try
//init
destroyinit;
mt.del(itimer2);
//children
destroychildren;
//controls
freeobj(@iimg);
//self
inherited;
except;end;
end;
//## _ontimer2 ##
procedure tvirtualtile._ontimer2(sender:tobject);
begin
try
updatebuttons;
if imustpaint then
   begin
   imustpaint:=false;
   iview.paint;
   end;//end of if
except;end;
end;
//## updatebuttons ##
procedure tvirtualtile.updatebuttons;
var
   ok2,ok:boolean;
begin
try
//get
ok:=(not ibusy);
//set
icopy.enabled:=ok and (not iimg.empty);
ipaste.enabled:=ok and clipboard.hasformat(cf_bitmap);
iopen.enabled:=ok;
//breath
application.processmessages;
except;end;
end;
//## __onclick ##
procedure tvirtualtile.__onclick(sender:tobject);
label
   skipend;
var
   a:tbitmapenhanced;
   e:string;
   _update:boolean;
begin
try
//check
if ibusy or (not forma.showing) then exit;
//defaults
a:=nil;
e:='';
ibusy:=true;
_update:=false;
updatebuttons;
//paste
if (sender=ipaste) then
   begin
   e:=gecTaskFailed;
   if clipboard.hasformat(cf_bitmap) then
      begin
      e:=gecOutOfMemory;
      a:=ccs.newbmpeh(1,1);
      a.assign(clipboard);
      _update:=true;
      if not iimg.copyfrom(a,e) then goto skipend;
      end;//end of if
   //successful
   e:='';
   end
else if (sender=iopen) then
   begin
   a:=ccs.newbmpeh(1,1);
   if misc.openimagedlg(a,ifilenametext,ifilenametext) then
      begin
      _update:=true;
      if not iimg.copyfrom(a,e) then goto skipend;
      end
   else goto skipend;
   //successful
   e:='';
   end
//copy
else if (sender=icopy) then
   begin
   //get
   e:=gecOutOfMemory;
   iimg.lock;
   iimg.pullall(false,false);
   e:=gecTaskFailed;
   clipboard.assign(iimg.buffer);
   iimg.unlock;
   //successful
   e:='';
   end
//clear
else if (sender=iclear) then
   begin
   //get
   e:=gecOutOfMemory;
   //.prompt
   if showquery60(ntranslate('clear')+'?') then
      begin
      iimg.text:='';
      _update:=true;
      end;//end of if
   //successful
   e:='';
   end;//end of if
skipend:
except;end;
try;freeobj(@a);except;end;
try
iimg.unlock;
ibusy:=false;
if _update then
   begin
   vs.apply;
   modified:=true;
   end;//end of if
updatebuttons;
general.iferror(e);
except;end;
end;
//## __onpaint ##
procedure tvirtualtile.__onpaint(sender:tobject;canvas:tcanvas);
var
   bs,dx,dy,dw,dh:integer;
begin
try
//check
if (sender<>iview) then exit;
//get
canvas.fillrect(iview.clientrect);
bs:=2;
//set
if not iimg.empty then
   begin
   ccs.scaledown(iview.clientwidth-(2*bs),iview.clientheight-(2*bs),iimg.width,iimg.height,dw,dh);
   dx:=(iview.clientwidth-dw) div 2;
   dy:=(iview.clientheight-dh) div 2;
   iimg.lock;
   iimg.pullall(false,false);
   canvas.stretchdraw(rect(dx,dy,dx+dw,dy+dh),iimg.buffer);
   iimg.unlock;
   end;//end of if
//border
if (bs<>0) then ccs.drectb(canvas,rect(dx-bs,dy-bs,dx+dw+bs,dy+dh+bs),clBlack,clNone,false,bs);
except;end;
try;iimg.unlock;except;end;
end;
//## readwrite ##
procedure tvirtualtile.readwrite(mode:tvirtualstoragemode);
var
   tmp:string;
begin
try
case mode of
vsmReadfromcontrols:if (isysptr>vsNil) then vs.s[isysptr]:=iimg.text;
vsmWritetocontrols:if (isysptr>vsNil) then
   begin
   tmp:=vs.s[isysptr];
   if (tmp<>iimg.text) then
      begin
      iimg.text:=tmp;
      imustpaint:=true;
      modified:=true;
      end;//end of if
   end;//end of if
vsmUpdatecontrols:;
end;//end of case
except;end;
end;
//## tile ##
function tvirtualtile.tile(dr:trect;d:tbitmap;deg:integer;var e:string):boolean;
begin
try
//defaults
result:=false;
e:=gecOutOfMemory;
//get
if iimg.empty then
   begin
   result:=true;
   exit;
   end
else
   begin
   iimg.lock;
   iimg.pullall(false,false);
   result:=ccs.tile(dr,d,iimg.buffer,deg,e);
   end;//end of if
except;end;
try;iimg.unlock;except;end;
end;


//## draws ##
function draws:tdraws;
begin
siAutoCreate(@fdraws,tdraws,@result);
end;
//## menus ##
function menus:tmenus;
begin
siAutoCreate(@fmenus,tmenus,@result);
end;
//## mns ##
function mns:tmenus;
begin
result:=menus;
end;
//## appstart ##
procedure appstart;
begin
try
//check
if appstarted then exit else appstarted:=true;
//adjust application's hidden form
{
showwindow(application.handle,sw_hide);
SetWindowLong(Application.Handle, GWL_EXSTYLE,GetWindowLong(Application.Handle, GWL_EXSTYLE) and not WS_EX_APPWINDOW or WS_EX_TOOLWINDOW);
ShowWindow(Application.Handle, SW_SHOW);
{}//yyyyyyyyyyyyyyyyyyyyyy this is NOT OLD CODE, but CODE THAT IS YET TO BE IMPLEMENTED WITH LINUX??? 13SEP2007
//remote event
__appstart;
except;end;
end;
//## appsync ##
procedure appsync;
begin
try
//update controls that rely on virtual information settings
if (fwec<>nil) then wec.update;
if (fpg<>nil) then fpg.visyncnow;
except;end;
end;
//## appprompt ##
function appprompt:boolean;
var
   old:boolean;
begin
try
//defaults
result:=true;
//check
if appprompted then exit;
//USER CODE
//.lock dialogs to MODAL
old:=viShowSoft;
viShowSoft:=false;
//.prompt
result:=(not programshutdownprompt) or _appPrompt;
//.unlock dialog if NOT closing
if not result then viShowSoft:=old;
except;end;
try;if result then appprompted:=true;except;end;
end;
//## general ##
function general:tgeneral;
begin
siAutoCreate(@fgeneral,tgeneral,@result);
end;
//## html ##
function html:thtml;
begin
siAutoCreate(@fhtml,thtml,@result);
end;
//## misc ##
function misc:tmisc;
begin
siAutoCreate(@fmisc,tmisc,@result);
end;
//## script ##
function script:tscript;
begin
siAutoCreate(@fscript,tscript,@result);
end;
//## wec ##
function wec:twec;
begin
siAutoCreate(@fwec,twec,@result);
end;
//## newnv ##
function newnv:tnv;
begin
try;result:=nil;result:=tnv.create;except;end;
end;
//## io ##
function io:tio;
begin
siAutoCreate(@fio,tio,@result);
end;
//## vs ##
function vs:tvirtualstorage;
begin
siAutoCreate(@fvs,tvirtualstorage,@result);
end;
//## newio ##
function newio:tio;
begin
try;result:=nil;result:=tio.create;except;end;
end;
//## newioE ##
function newioE(_onchange:tnotifyevent):tio;
begin
try;result:=newio;result.onchange:=_onchange;except;end;
end;
//## newstringlist ##
function newstringlist(x:string):tstringlist;
begin
try
result:=nil;
result:=tstringlist.create;
if (x<>'') then result.text:=x;
except;end;
end;
//## newdualmask ##
function newdualmask(_include,_exclude:string):tdualmask;
begin
try
result:=nil;
result:=tdualmask.create;
result.init(_include,_exclude);
except;end;
end;
//## multilingual ##
function multilingual:tmultilingual;
begin
siAutoCreate(@fmultilingual,tmultilingual,@result);
end;
//## tsuptrans ##
function st:tsuptrans;
begin
siAutoCreate(@fst,tsuptrans,@result);
end;
//## splash ##
function splash:tsplash;
begin
siAutoCreate(@fsplash,tsplash,@result);
end;
//## pg ##
function pg:tpg;
begin
siAutoCreate(@fpg,tpg,@result);
end;
//## db ##
function db:tdebug;
begin
siAutoCreate(@fdb,tdebug,@result);
end;
//## dates ##
function dates:tdates;
begin
siAutoCreate(@fdates,tdates,@result);
end;
//## ht ##
function ht:thtmltemplate;
begin
siAutoCreate(@fht,thtmltemplate,@result);
end;
//## testing ##
function testing:ttesting;
begin
siAutoCreate(@ftesting,ttesting,@result);
end;
//## sysarrays ##
procedure sysarrays;
var
   p:integer;
begin
try
//int32
for p:=0 to high(p4INT32) do p4INT32[p]:=p*p*p*p;
//cur256
for p:=0 to high(p4CUR256) do
begin
p4CUR256[p]:=p*p;
p4CUR256[p]:=p4CUR256[p]*p4CUR256[p];
end;//end of loop
except;showerror60(ntranslate('arithmetic overload'));end;//translate('Arithmetic Overload');
end;


initialization
  //start
  siInit;
  //translated strings
  tsX:=lowercase(translate('x'));
  tsY:=lowercase(translate('y'));
  tsW:=lowercase(translate('w'));
  tsH:=lowercase(translate('h'));
  tsBytes:=ntranslate('bytes');
  tsB:='b';//single byte
  tsKB:=uppercase(translate('kb'));
  tsMB:=uppercase(translate('mb'));
  tsGB:=uppercase(translate('gb'));
  tsConnections:=ntranslate('connections');
  tsOffline:=ntranslate('offline');
  tsOnline:=ntranslate('online');
  tsHits:=ntranslate('hits');
  tsErrors:=ntranslate('errors');
  tsBandwidth:=ntranslate('bandwidth');
  tsYes:=ntranslate('yes');
  tsNo:=ntranslate('no');
  tsProgram:=ntranslate('program');
  tsName:=ntranslate('name');
  tsVersion:=ntranslate('version');
  tsDescription:=ntranslate('description');
  tsCategory:=ntranslate('category');
  tsCustomLanguage:=ntranslate('custom language');
  tsPrimaryLanguage:=ntranslate('primary language');
  tsBuiltinHelp:=ntranslate('built-in help');
  tsSize:=ntranslate('size');
  tsSecurity:=ntranslate('security');
  tsPublisher:=ntranslate('publisher');
  tsCloned:=ntranslate('cloned');
  tsInstance:=ntranslate('instance');
  tsInfrastructure:=ntranslate('infrastructure');
  tsAntitamperDetection:=ntranslate('anti-tamper detection');
  tsEncryption:=ntranslate('encryption');
  //.dates.uptime - short labels
  tslcMTH:=lowercase(translate('mth'));//month
  tslcDY :=lowercase(translate('dy'));//day
  tslcH  :=lowercase(translate('h'));//hour
  tslcM  :=lowercase(translate('m'));//minute
  tslcS  :=lowercase(translate('s'));//second
  tslcMS :=lowercase(translate('ms'));//milli-second
  //.system information
  //..program
  tsPortable:=ntranslate('portable');
  tsSystemFolder:=ntranslate('system folder');
  tsDiskAccess:=ntranslate('disk access');
  tsReadOnly:=ntranslate('read only');
  tsReadWrite:=ntranslate('read / write');
  //..system
  tsFileRemaps:=ntranslate('file remaps');
  tsVirtual:=ntranslate('virtual');
  tsImages:=ntranslate('images');
  tsAnimations:=ntranslate('animations');
  tsClicks:=ntranslate('clicks');
  tsKeyStrokes:=ntranslate('key strokes');
  tsDimensions:=ntranslate('dimensions');
  //..help
  tsNoHelp:=translate('No help present');
  //..time
  tsTime:=ntranslate('time');
  tsBoot:=ntranslate('boot');
  tsUp:=ntranslate('up');
  tslcbit:=lowercase(translate('bit'));
  //..timer
  tsTimer:=ntranslate('timer');
  tsTickCount:=ntranslate('tick count');
  tsLoad:=ntranslate('load');
  //..network
  tsID:=uppercase(translate('id'));
  tsNetwork:=ntranslate('network');
  tsCodes:=ntranslate('codes');
  tsLookup:=ntranslate('lookup');
  tsMappings:=ntranslate('mappings');
  tsThreads:=ntranslate('threads');
  tsInstructionsExecuted:=ntranslate('instructions executed');
  tsIn:=ntranslate('in');
  tsOut:=ntranslate('out');
  tsRequests:=ntranslate('requests');
  //..network codes
  tsCode:=ntranslate('code');
  tsServer:=ntranslate('server');
  tsUDP:=uppercase(translate('UDP'));
  tsServerThread:=ntranslate('server thread');
  tsClient:=ntranslate('client');
  tsOrientated:=ntranslate('orientated');
  //..controls
  tsControls:=ntranslate('controls');
  tsSystem:=ntranslate('system');
  tsActive:=ntranslate('active');
  tsCreated:=ntranslate('created');
  tsDestroyed:=ntranslate('destroyed');
  //..translation
  tsCustom:=ntranslate('custom');
  tsCount:=ntranslate('count');
  tsSuccessful:=ntranslate('successful');
  tsNotFound:=ntranslate('not found');
  //.license
  tsLicense:=ntranslate('license');
  tsClassification:=ntranslate('classification');
  //..miscellaneous
  tsMiscellaneous:=ntranslate('miscellaneous');
  tsAddress:=ntranslate('address');
  tsTotal:=ntranslate('total');
  tsInformation:=ntranslate('information');
  tsCoverage:=ntranslate('coverage');
  tsLanguage:=ntranslate('language');
  tsPrimary:=ntranslate('primary');
  tsError:=ntranslate('error');
  tsGUI:=translate('GUI');
  tsRealtimeHelp:=ntranslate('realtime help');
  tsUnused:=ntranslate('unused');
  tsoriginalinstance:=ntranslate('original instance');
  tsUnlock:=ntranslate('unlock');
  //other
  tsIP:=translate('IP');
  tsClientIPlc:=lowercase(ntranslate('client-ip'));
  tsProxyIPlc:=lowercase(translate('proxy-ip'));
  tsTransactiontimelc:=lowercase(translate('transaction-time'));
  tsClientHostlc:=lowercase(translate('client-host'));
  tsRate:=ntranslate('rate');
  tsQueue:=ntranslate('queue');
  tsStatistics:=ntranslate('statistics');
  tsStatus:=ntranslate('status');
  tsAlive:=ntranslate('alive');
  tsUserAddress:=ntranslate('user address');
  //nav
  tsHome:=ntranslate('home');
  tsLocal:=ntranslate('local');
  tsBookmarks:=ntranslate('bookmarks');
  tsSettings:=ntranslate('settings');
  tsInternet:=ntranslate('internet');
  //system versions
  systemversions:=
  ntranslate('Visual Engine')   +#9+translate('Displays and coordinates controls')+rcode
                                +#9+'v3.00.15925'+rcode+
  ntranslate('User Management') +#9+translate('Organises colors, cursors, options and settings')+rcode
                                +#9+'v3.00.10210'+rcode+
  systemversions;

finalization
  //system
  siCloseAll;

end.

